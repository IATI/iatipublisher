/******/ (() => {
  // webpackBootstrap
  /******/ var __webpack_modules__ = {
    /***/ './node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js':
      /*!***************************************************************************!*\
  !*** ./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js ***!
  \***************************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ generateCodeFrame: () =>
            /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_0__.generateCodeFrame,
          /* harmony export */ BASE_TRANSITION: () =>
            /* binding */ BASE_TRANSITION,
          /* harmony export */ CAMELIZE: () => /* binding */ CAMELIZE,
          /* harmony export */ CAPITALIZE: () => /* binding */ CAPITALIZE,
          /* harmony export */ CREATE_BLOCK: () => /* binding */ CREATE_BLOCK,
          /* harmony export */ CREATE_COMMENT: () =>
            /* binding */ CREATE_COMMENT,
          /* harmony export */ CREATE_ELEMENT_BLOCK: () =>
            /* binding */ CREATE_ELEMENT_BLOCK,
          /* harmony export */ CREATE_ELEMENT_VNODE: () =>
            /* binding */ CREATE_ELEMENT_VNODE,
          /* harmony export */ CREATE_SLOTS: () => /* binding */ CREATE_SLOTS,
          /* harmony export */ CREATE_STATIC: () => /* binding */ CREATE_STATIC,
          /* harmony export */ CREATE_TEXT: () => /* binding */ CREATE_TEXT,
          /* harmony export */ CREATE_VNODE: () => /* binding */ CREATE_VNODE,
          /* harmony export */ FRAGMENT: () => /* binding */ FRAGMENT,
          /* harmony export */ GUARD_REACTIVE_PROPS: () =>
            /* binding */ GUARD_REACTIVE_PROPS,
          /* harmony export */ IS_MEMO_SAME: () => /* binding */ IS_MEMO_SAME,
          /* harmony export */ IS_REF: () => /* binding */ IS_REF,
          /* harmony export */ KEEP_ALIVE: () => /* binding */ KEEP_ALIVE,
          /* harmony export */ MERGE_PROPS: () => /* binding */ MERGE_PROPS,
          /* harmony export */ NORMALIZE_CLASS: () =>
            /* binding */ NORMALIZE_CLASS,
          /* harmony export */ NORMALIZE_PROPS: () =>
            /* binding */ NORMALIZE_PROPS,
          /* harmony export */ NORMALIZE_STYLE: () =>
            /* binding */ NORMALIZE_STYLE,
          /* harmony export */ OPEN_BLOCK: () => /* binding */ OPEN_BLOCK,
          /* harmony export */ POP_SCOPE_ID: () => /* binding */ POP_SCOPE_ID,
          /* harmony export */ PUSH_SCOPE_ID: () => /* binding */ PUSH_SCOPE_ID,
          /* harmony export */ RENDER_LIST: () => /* binding */ RENDER_LIST,
          /* harmony export */ RENDER_SLOT: () => /* binding */ RENDER_SLOT,
          /* harmony export */ RESOLVE_COMPONENT: () =>
            /* binding */ RESOLVE_COMPONENT,
          /* harmony export */ RESOLVE_DIRECTIVE: () =>
            /* binding */ RESOLVE_DIRECTIVE,
          /* harmony export */ RESOLVE_DYNAMIC_COMPONENT: () =>
            /* binding */ RESOLVE_DYNAMIC_COMPONENT,
          /* harmony export */ RESOLVE_FILTER: () =>
            /* binding */ RESOLVE_FILTER,
          /* harmony export */ SET_BLOCK_TRACKING: () =>
            /* binding */ SET_BLOCK_TRACKING,
          /* harmony export */ SUSPENSE: () => /* binding */ SUSPENSE,
          /* harmony export */ TELEPORT: () => /* binding */ TELEPORT,
          /* harmony export */ TO_DISPLAY_STRING: () =>
            /* binding */ TO_DISPLAY_STRING,
          /* harmony export */ TO_HANDLERS: () => /* binding */ TO_HANDLERS,
          /* harmony export */ TO_HANDLER_KEY: () =>
            /* binding */ TO_HANDLER_KEY,
          /* harmony export */ UNREF: () => /* binding */ UNREF,
          /* harmony export */ WITH_CTX: () => /* binding */ WITH_CTX,
          /* harmony export */ WITH_DIRECTIVES: () =>
            /* binding */ WITH_DIRECTIVES,
          /* harmony export */ WITH_MEMO: () => /* binding */ WITH_MEMO,
          /* harmony export */ advancePositionWithClone: () =>
            /* binding */ advancePositionWithClone,
          /* harmony export */ advancePositionWithMutation: () =>
            /* binding */ advancePositionWithMutation,
          /* harmony export */ assert: () => /* binding */ assert,
          /* harmony export */ baseCompile: () => /* binding */ baseCompile,
          /* harmony export */ baseParse: () => /* binding */ baseParse,
          /* harmony export */ buildDirectiveArgs: () =>
            /* binding */ buildDirectiveArgs,
          /* harmony export */ buildProps: () => /* binding */ buildProps,
          /* harmony export */ buildSlots: () => /* binding */ buildSlots,
          /* harmony export */ checkCompatEnabled: () =>
            /* binding */ checkCompatEnabled,
          /* harmony export */ createArrayExpression: () =>
            /* binding */ createArrayExpression,
          /* harmony export */ createAssignmentExpression: () =>
            /* binding */ createAssignmentExpression,
          /* harmony export */ createBlockStatement: () =>
            /* binding */ createBlockStatement,
          /* harmony export */ createCacheExpression: () =>
            /* binding */ createCacheExpression,
          /* harmony export */ createCallExpression: () =>
            /* binding */ createCallExpression,
          /* harmony export */ createCompilerError: () =>
            /* binding */ createCompilerError,
          /* harmony export */ createCompoundExpression: () =>
            /* binding */ createCompoundExpression,
          /* harmony export */ createConditionalExpression: () =>
            /* binding */ createConditionalExpression,
          /* harmony export */ createForLoopParams: () =>
            /* binding */ createForLoopParams,
          /* harmony export */ createFunctionExpression: () =>
            /* binding */ createFunctionExpression,
          /* harmony export */ createIfStatement: () =>
            /* binding */ createIfStatement,
          /* harmony export */ createInterpolation: () =>
            /* binding */ createInterpolation,
          /* harmony export */ createObjectExpression: () =>
            /* binding */ createObjectExpression,
          /* harmony export */ createObjectProperty: () =>
            /* binding */ createObjectProperty,
          /* harmony export */ createReturnStatement: () =>
            /* binding */ createReturnStatement,
          /* harmony export */ createRoot: () => /* binding */ createRoot,
          /* harmony export */ createSequenceExpression: () =>
            /* binding */ createSequenceExpression,
          /* harmony export */ createSimpleExpression: () =>
            /* binding */ createSimpleExpression,
          /* harmony export */ createStructuralDirectiveTransform: () =>
            /* binding */ createStructuralDirectiveTransform,
          /* harmony export */ createTemplateLiteral: () =>
            /* binding */ createTemplateLiteral,
          /* harmony export */ createTransformContext: () =>
            /* binding */ createTransformContext,
          /* harmony export */ createVNodeCall: () =>
            /* binding */ createVNodeCall,
          /* harmony export */ extractIdentifiers: () =>
            /* binding */ extractIdentifiers,
          /* harmony export */ findDir: () => /* binding */ findDir,
          /* harmony export */ findProp: () => /* binding */ findProp,
          /* harmony export */ generate: () => /* binding */ generate,
          /* harmony export */ getBaseTransformPreset: () =>
            /* binding */ getBaseTransformPreset,
          /* harmony export */ getInnerRange: () => /* binding */ getInnerRange,
          /* harmony export */ getMemoedVNodeCall: () =>
            /* binding */ getMemoedVNodeCall,
          /* harmony export */ getVNodeBlockHelper: () =>
            /* binding */ getVNodeBlockHelper,
          /* harmony export */ getVNodeHelper: () =>
            /* binding */ getVNodeHelper,
          /* harmony export */ hasDynamicKeyVBind: () =>
            /* binding */ hasDynamicKeyVBind,
          /* harmony export */ hasScopeRef: () => /* binding */ hasScopeRef,
          /* harmony export */ helperNameMap: () => /* binding */ helperNameMap,
          /* harmony export */ injectProp: () => /* binding */ injectProp,
          /* harmony export */ isBuiltInType: () => /* binding */ isBuiltInType,
          /* harmony export */ isCoreComponent: () =>
            /* binding */ isCoreComponent,
          /* harmony export */ isFunctionType: () =>
            /* binding */ isFunctionType,
          /* harmony export */ isInDestructureAssignment: () =>
            /* binding */ isInDestructureAssignment,
          /* harmony export */ isMemberExpression: () =>
            /* binding */ isMemberExpression,
          /* harmony export */ isMemberExpressionBrowser: () =>
            /* binding */ isMemberExpressionBrowser,
          /* harmony export */ isMemberExpressionNode: () =>
            /* binding */ isMemberExpressionNode,
          /* harmony export */ isReferencedIdentifier: () =>
            /* binding */ isReferencedIdentifier,
          /* harmony export */ isSimpleIdentifier: () =>
            /* binding */ isSimpleIdentifier,
          /* harmony export */ isSlotOutlet: () => /* binding */ isSlotOutlet,
          /* harmony export */ isStaticArgOf: () => /* binding */ isStaticArgOf,
          /* harmony export */ isStaticExp: () => /* binding */ isStaticExp,
          /* harmony export */ isStaticProperty: () =>
            /* binding */ isStaticProperty,
          /* harmony export */ isStaticPropertyKey: () =>
            /* binding */ isStaticPropertyKey,
          /* harmony export */ isTemplateNode: () =>
            /* binding */ isTemplateNode,
          /* harmony export */ isText: () => /* binding */ isText,
          /* harmony export */ isVSlot: () => /* binding */ isVSlot,
          /* harmony export */ locStub: () => /* binding */ locStub,
          /* harmony export */ makeBlock: () => /* binding */ makeBlock,
          /* harmony export */ noopDirectiveTransform: () =>
            /* binding */ noopDirectiveTransform,
          /* harmony export */ processExpression: () =>
            /* binding */ processExpression,
          /* harmony export */ processFor: () => /* binding */ processFor,
          /* harmony export */ processIf: () => /* binding */ processIf,
          /* harmony export */ processSlotOutlet: () =>
            /* binding */ processSlotOutlet,
          /* harmony export */ registerRuntimeHelpers: () =>
            /* binding */ registerRuntimeHelpers,
          /* harmony export */ resolveComponentType: () =>
            /* binding */ resolveComponentType,
          /* harmony export */ toValidAssetId: () =>
            /* binding */ toValidAssetId,
          /* harmony export */ trackSlotScopes: () =>
            /* binding */ trackSlotScopes,
          /* harmony export */ trackVForSlotScopes: () =>
            /* binding */ trackVForSlotScopes,
          /* harmony export */ transform: () => /* binding */ transform,
          /* harmony export */ transformBind: () => /* binding */ transformBind,
          /* harmony export */ transformElement: () =>
            /* binding */ transformElement,
          /* harmony export */ transformExpression: () =>
            /* binding */ transformExpression,
          /* harmony export */ transformModel: () =>
            /* binding */ transformModel,
          /* harmony export */ transformOn: () => /* binding */ transformOn,
          /* harmony export */ traverseNode: () => /* binding */ traverseNode,
          /* harmony export */ walkBlockDeclarations: () =>
            /* binding */ walkBlockDeclarations,
          /* harmony export */ walkFunctionParams: () =>
            /* binding */ walkFunctionParams,
          /* harmony export */ walkIdentifiers: () =>
            /* binding */ walkIdentifiers,
          /* harmony export */ warnDeprecation: () =>
            /* binding */ warnDeprecation,
          /* harmony export */
        });
        /* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! @vue/shared */ './node_modules/@vue/shared/dist/shared.esm-bundler.js'
          );

        function defaultOnError(error) {
          throw error;
        }
        function defaultOnWarn(msg) {
          true && console.warn(`[Vue warn] ${msg.message}`);
        }
        function createCompilerError(code, loc, messages, additionalMessage) {
          const msg = true
            ? (messages || errorMessages)[code] + (additionalMessage || ``)
            : 0;
          const error = new SyntaxError(String(msg));
          error.code = code;
          error.loc = loc;
          return error;
        }
        const errorMessages = {
          // parse errors
          [0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */]: 'Illegal comment.',
          [1 /* CDATA_IN_HTML_CONTENT */]:
            'CDATA section is allowed only in XML context.',
          [2 /* DUPLICATE_ATTRIBUTE */]: 'Duplicate attribute.',
          [3 /* END_TAG_WITH_ATTRIBUTES */]: 'End tag cannot have attributes.',
          [4 /* END_TAG_WITH_TRAILING_SOLIDUS */]: "Illegal '/' in tags.",
          [5 /* EOF_BEFORE_TAG_NAME */]: 'Unexpected EOF in tag.',
          [6 /* EOF_IN_CDATA */]: 'Unexpected EOF in CDATA section.',
          [7 /* EOF_IN_COMMENT */]: 'Unexpected EOF in comment.',
          [8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */]:
            'Unexpected EOF in script.',
          [9 /* EOF_IN_TAG */]: 'Unexpected EOF in tag.',
          [10 /* INCORRECTLY_CLOSED_COMMENT */]: 'Incorrectly closed comment.',
          [11 /* INCORRECTLY_OPENED_COMMENT */]: 'Incorrectly opened comment.',
          [12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */]:
            "Illegal tag name. Use '&lt;' to print '<'.",
          [13 /* MISSING_ATTRIBUTE_VALUE */]: 'Attribute value was expected.',
          [14 /* MISSING_END_TAG_NAME */]: 'End tag name was expected.',
          [15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */]:
            'Whitespace was expected.',
          [16 /* NESTED_COMMENT */]: "Unexpected '<!--' in comment.",
          [17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */]:
            'Attribute name cannot contain U+0022 ("), U+0027 (\'), and U+003C (<).',
          [18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */]:
            'Unquoted attribute value cannot contain U+0022 ("), U+0027 (\'), U+003C (<), U+003D (=), and U+0060 (`).',
          [19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */]:
            "Attribute name cannot start with '='.",
          [21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */]:
            "'<?' is allowed only in XML context.",
          [20 /* UNEXPECTED_NULL_CHARACTER */]: `Unexpected null character.`,
          [22 /* UNEXPECTED_SOLIDUS_IN_TAG */]: "Illegal '/' in tags.",
          // Vue-specific parse errors
          [23 /* X_INVALID_END_TAG */]: 'Invalid end tag.',
          [24 /* X_MISSING_END_TAG */]: 'Element is missing end tag.',
          [25 /* X_MISSING_INTERPOLATION_END */]:
            'Interpolation end sign was not found.',
          [27 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */]:
            'End bracket for dynamic directive argument was not found. ' +
            'Note that dynamic directive argument cannot contain spaces.',
          [26 /* X_MISSING_DIRECTIVE_NAME */]:
            'Legal directive name was expected.',
          // transform errors
          [28 /* X_V_IF_NO_EXPRESSION */]: `v-if/v-else-if is missing expression.`,
          [29 /* X_V_IF_SAME_KEY */]: `v-if/else branches must use unique keys.`,
          [30 /* X_V_ELSE_NO_ADJACENT_IF */]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
          [31 /* X_V_FOR_NO_EXPRESSION */]: `v-for is missing expression.`,
          [32 /* X_V_FOR_MALFORMED_EXPRESSION */]: `v-for has invalid expression.`,
          [33 /* X_V_FOR_TEMPLATE_KEY_PLACEMENT */]: `<template v-for> key should be placed on the <template> tag.`,
          [34 /* X_V_BIND_NO_EXPRESSION */]: `v-bind is missing expression.`,
          [35 /* X_V_ON_NO_EXPRESSION */]: `v-on is missing expression.`,
          [36 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */]: `Unexpected custom directive on <slot> outlet.`,
          [37 /* X_V_SLOT_MIXED_SLOT_USAGE */]:
            `Mixed v-slot usage on both the component and nested <template>.` +
            `When there are multiple named slots, all slots should use <template> ` +
            `syntax to avoid scope ambiguity.`,
          [38 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */]: `Duplicate slot names found. `,
          [39 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */]:
            `Extraneous children found when component already has explicitly named ` +
            `default slot. These children will be ignored.`,
          [40 /* X_V_SLOT_MISPLACED */]: `v-slot can only be used on components or <template> tags.`,
          [41 /* X_V_MODEL_NO_EXPRESSION */]: `v-model is missing expression.`,
          [42 /* X_V_MODEL_MALFORMED_EXPRESSION */]: `v-model value must be a valid JavaScript member expression.`,
          [43 /* X_V_MODEL_ON_SCOPE_VARIABLE */]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
          [44 /* X_INVALID_EXPRESSION */]: `Error parsing JavaScript expression: `,
          [45 /* X_KEEP_ALIVE_INVALID_CHILDREN */]: `<KeepAlive> expects exactly one child component.`,
          // generic errors
          [46 /* X_PREFIX_ID_NOT_SUPPORTED */]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
          [47 /* X_MODULE_MODE_NOT_SUPPORTED */]: `ES module mode is not supported in this build of compiler.`,
          [48 /* X_CACHE_HANDLER_NOT_SUPPORTED */]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
          [49 /* X_SCOPE_ID_NOT_SUPPORTED */]: `"scopeId" option is only supported in module mode.`,
          // just to fulfill types
          [50 /* __EXTEND_POINT__ */]: ``,
        };

        const FRAGMENT = Symbol(true ? `Fragment` : 0);
        const TELEPORT = Symbol(true ? `Teleport` : 0);
        const SUSPENSE = Symbol(true ? `Suspense` : 0);
        const KEEP_ALIVE = Symbol(true ? `KeepAlive` : 0);
        const BASE_TRANSITION = Symbol(true ? `BaseTransition` : 0);
        const OPEN_BLOCK = Symbol(true ? `openBlock` : 0);
        const CREATE_BLOCK = Symbol(true ? `createBlock` : 0);
        const CREATE_ELEMENT_BLOCK = Symbol(true ? `createElementBlock` : 0);
        const CREATE_VNODE = Symbol(true ? `createVNode` : 0);
        const CREATE_ELEMENT_VNODE = Symbol(true ? `createElementVNode` : 0);
        const CREATE_COMMENT = Symbol(true ? `createCommentVNode` : 0);
        const CREATE_TEXT = Symbol(true ? `createTextVNode` : 0);
        const CREATE_STATIC = Symbol(true ? `createStaticVNode` : 0);
        const RESOLVE_COMPONENT = Symbol(true ? `resolveComponent` : 0);
        const RESOLVE_DYNAMIC_COMPONENT = Symbol(
          true ? `resolveDynamicComponent` : 0
        );
        const RESOLVE_DIRECTIVE = Symbol(true ? `resolveDirective` : 0);
        const RESOLVE_FILTER = Symbol(true ? `resolveFilter` : 0);
        const WITH_DIRECTIVES = Symbol(true ? `withDirectives` : 0);
        const RENDER_LIST = Symbol(true ? `renderList` : 0);
        const RENDER_SLOT = Symbol(true ? `renderSlot` : 0);
        const CREATE_SLOTS = Symbol(true ? `createSlots` : 0);
        const TO_DISPLAY_STRING = Symbol(true ? `toDisplayString` : 0);
        const MERGE_PROPS = Symbol(true ? `mergeProps` : 0);
        const NORMALIZE_CLASS = Symbol(true ? `normalizeClass` : 0);
        const NORMALIZE_STYLE = Symbol(true ? `normalizeStyle` : 0);
        const NORMALIZE_PROPS = Symbol(true ? `normalizeProps` : 0);
        const GUARD_REACTIVE_PROPS = Symbol(true ? `guardReactiveProps` : 0);
        const TO_HANDLERS = Symbol(true ? `toHandlers` : 0);
        const CAMELIZE = Symbol(true ? `camelize` : 0);
        const CAPITALIZE = Symbol(true ? `capitalize` : 0);
        const TO_HANDLER_KEY = Symbol(true ? `toHandlerKey` : 0);
        const SET_BLOCK_TRACKING = Symbol(true ? `setBlockTracking` : 0);
        const PUSH_SCOPE_ID = Symbol(true ? `pushScopeId` : 0);
        const POP_SCOPE_ID = Symbol(true ? `popScopeId` : 0);
        const WITH_CTX = Symbol(true ? `withCtx` : 0);
        const UNREF = Symbol(true ? `unref` : 0);
        const IS_REF = Symbol(true ? `isRef` : 0);
        const WITH_MEMO = Symbol(true ? `withMemo` : 0);
        const IS_MEMO_SAME = Symbol(true ? `isMemoSame` : 0);
        // Name mapping for runtime helpers that need to be imported from 'vue' in
        // generated code. Make sure these are correctly exported in the runtime!
        // Using `any` here because TS doesn't allow symbols as index type.
        const helperNameMap = {
          [FRAGMENT]: `Fragment`,
          [TELEPORT]: `Teleport`,
          [SUSPENSE]: `Suspense`,
          [KEEP_ALIVE]: `KeepAlive`,
          [BASE_TRANSITION]: `BaseTransition`,
          [OPEN_BLOCK]: `openBlock`,
          [CREATE_BLOCK]: `createBlock`,
          [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
          [CREATE_VNODE]: `createVNode`,
          [CREATE_ELEMENT_VNODE]: `createElementVNode`,
          [CREATE_COMMENT]: `createCommentVNode`,
          [CREATE_TEXT]: `createTextVNode`,
          [CREATE_STATIC]: `createStaticVNode`,
          [RESOLVE_COMPONENT]: `resolveComponent`,
          [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
          [RESOLVE_DIRECTIVE]: `resolveDirective`,
          [RESOLVE_FILTER]: `resolveFilter`,
          [WITH_DIRECTIVES]: `withDirectives`,
          [RENDER_LIST]: `renderList`,
          [RENDER_SLOT]: `renderSlot`,
          [CREATE_SLOTS]: `createSlots`,
          [TO_DISPLAY_STRING]: `toDisplayString`,
          [MERGE_PROPS]: `mergeProps`,
          [NORMALIZE_CLASS]: `normalizeClass`,
          [NORMALIZE_STYLE]: `normalizeStyle`,
          [NORMALIZE_PROPS]: `normalizeProps`,
          [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
          [TO_HANDLERS]: `toHandlers`,
          [CAMELIZE]: `camelize`,
          [CAPITALIZE]: `capitalize`,
          [TO_HANDLER_KEY]: `toHandlerKey`,
          [SET_BLOCK_TRACKING]: `setBlockTracking`,
          [PUSH_SCOPE_ID]: `pushScopeId`,
          [POP_SCOPE_ID]: `popScopeId`,
          [WITH_CTX]: `withCtx`,
          [UNREF]: `unref`,
          [IS_REF]: `isRef`,
          [WITH_MEMO]: `withMemo`,
          [IS_MEMO_SAME]: `isMemoSame`,
        };
        function registerRuntimeHelpers(helpers) {
          Object.getOwnPropertySymbols(helpers).forEach((s) => {
            helperNameMap[s] = helpers[s];
          });
        }

        // AST Utilities ---------------------------------------------------------------
        // Some expressions, e.g. sequence and conditional expressions, are never
        // associated with template nodes, so their source locations are just a stub.
        // Container types like CompoundExpression also don't need a real location.
        const locStub = {
          source: '',
          start: { line: 1, column: 1, offset: 0 },
          end: { line: 1, column: 1, offset: 0 },
        };
        function createRoot(children, loc = locStub) {
          return {
            type: 0 /* ROOT */,
            children,
            helpers: [],
            components: [],
            directives: [],
            hoists: [],
            imports: [],
            cached: 0,
            temps: 0,
            codegenNode: undefined,
            loc,
          };
        }
        function createVNodeCall(
          context,
          tag,
          props,
          children,
          patchFlag,
          dynamicProps,
          directives,
          isBlock = false,
          disableTracking = false,
          isComponent = false,
          loc = locStub
        ) {
          if (context) {
            if (isBlock) {
              context.helper(OPEN_BLOCK);
              context.helper(getVNodeBlockHelper(context.inSSR, isComponent));
            } else {
              context.helper(getVNodeHelper(context.inSSR, isComponent));
            }
            if (directives) {
              context.helper(WITH_DIRECTIVES);
            }
          }
          return {
            type: 13 /* VNODE_CALL */,
            tag,
            props,
            children,
            patchFlag,
            dynamicProps,
            directives,
            isBlock,
            disableTracking,
            isComponent,
            loc,
          };
        }
        function createArrayExpression(elements, loc = locStub) {
          return {
            type: 17 /* JS_ARRAY_EXPRESSION */,
            loc,
            elements,
          };
        }
        function createObjectExpression(properties, loc = locStub) {
          return {
            type: 15 /* JS_OBJECT_EXPRESSION */,
            loc,
            properties,
          };
        }
        function createObjectProperty(key, value) {
          return {
            type: 16 /* JS_PROPERTY */,
            loc: locStub,
            key: (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(key)
              ? createSimpleExpression(key, true)
              : key,
            value,
          };
        }
        function createSimpleExpression(
          content,
          isStatic = false,
          loc = locStub,
          constType = 0 /* NOT_CONSTANT */
        ) {
          return {
            type: 4 /* SIMPLE_EXPRESSION */,
            loc,
            content,
            isStatic,
            constType: isStatic ? 3 /* CAN_STRINGIFY */ : constType,
          };
        }
        function createInterpolation(content, loc) {
          return {
            type: 5 /* INTERPOLATION */,
            loc,
            content: (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(
              content
            )
              ? createSimpleExpression(content, false, loc)
              : content,
          };
        }
        function createCompoundExpression(children, loc = locStub) {
          return {
            type: 8 /* COMPOUND_EXPRESSION */,
            loc,
            children,
          };
        }
        function createCallExpression(callee, args = [], loc = locStub) {
          return {
            type: 14 /* JS_CALL_EXPRESSION */,
            loc,
            callee,
            arguments: args,
          };
        }
        function createFunctionExpression(
          params,
          returns = undefined,
          newline = false,
          isSlot = false,
          loc = locStub
        ) {
          return {
            type: 18 /* JS_FUNCTION_EXPRESSION */,
            params,
            returns,
            newline,
            isSlot,
            loc,
          };
        }
        function createConditionalExpression(
          test,
          consequent,
          alternate,
          newline = true
        ) {
          return {
            type: 19 /* JS_CONDITIONAL_EXPRESSION */,
            test,
            consequent,
            alternate,
            newline,
            loc: locStub,
          };
        }
        function createCacheExpression(index, value, isVNode = false) {
          return {
            type: 20 /* JS_CACHE_EXPRESSION */,
            index,
            value,
            isVNode,
            loc: locStub,
          };
        }
        function createBlockStatement(body) {
          return {
            type: 21 /* JS_BLOCK_STATEMENT */,
            body,
            loc: locStub,
          };
        }
        function createTemplateLiteral(elements) {
          return {
            type: 22 /* JS_TEMPLATE_LITERAL */,
            elements,
            loc: locStub,
          };
        }
        function createIfStatement(test, consequent, alternate) {
          return {
            type: 23 /* JS_IF_STATEMENT */,
            test,
            consequent,
            alternate,
            loc: locStub,
          };
        }
        function createAssignmentExpression(left, right) {
          return {
            type: 24 /* JS_ASSIGNMENT_EXPRESSION */,
            left,
            right,
            loc: locStub,
          };
        }
        function createSequenceExpression(expressions) {
          return {
            type: 25 /* JS_SEQUENCE_EXPRESSION */,
            expressions,
            loc: locStub,
          };
        }
        function createReturnStatement(returns) {
          return {
            type: 26 /* JS_RETURN_STATEMENT */,
            returns,
            loc: locStub,
          };
        }

        const isStaticExp = (p) =>
          p.type === 4 /* SIMPLE_EXPRESSION */ && p.isStatic;
        const isBuiltInType = (tag, expected) =>
          tag === expected ||
          tag ===
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.hyphenate)(expected);
        function isCoreComponent(tag) {
          if (isBuiltInType(tag, 'Teleport')) {
            return TELEPORT;
          } else if (isBuiltInType(tag, 'Suspense')) {
            return SUSPENSE;
          } else if (isBuiltInType(tag, 'KeepAlive')) {
            return KEEP_ALIVE;
          } else if (isBuiltInType(tag, 'BaseTransition')) {
            return BASE_TRANSITION;
          }
        }
        const nonIdentifierRE = /^\d|[^\$\w]/;
        const isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
        const validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
        const validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
        const whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
        /**
         * Simple lexer to check if an expression is a member expression. This is
         * lax and only checks validity at the root level (i.e. does not validate exps
         * inside square brackets), but it's ok since these are only used on template
         * expressions and false positives are invalid expressions in the first place.
         */
        const isMemberExpressionBrowser = (path) => {
          // remove whitespaces around . or [ first
          path = path.trim().replace(whitespaceRE, (s) => s.trim());
          let state = 0; /* inMemberExp */
          let stateStack = [];
          let currentOpenBracketCount = 0;
          let currentOpenParensCount = 0;
          let currentStringType = null;
          for (let i = 0; i < path.length; i++) {
            const char = path.charAt(i);
            switch (state) {
              case 0 /* inMemberExp */:
                if (char === '[') {
                  stateStack.push(state);
                  state = 1 /* inBrackets */;
                  currentOpenBracketCount++;
                } else if (char === '(') {
                  stateStack.push(state);
                  state = 2 /* inParens */;
                  currentOpenParensCount++;
                } else if (
                  !(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(
                    char
                  )
                ) {
                  return false;
                }
                break;
              case 1 /* inBrackets */:
                if (char === `'` || char === `"` || char === '`') {
                  stateStack.push(state);
                  state = 3 /* inString */;
                  currentStringType = char;
                } else if (char === `[`) {
                  currentOpenBracketCount++;
                } else if (char === `]`) {
                  if (!--currentOpenBracketCount) {
                    state = stateStack.pop();
                  }
                }
                break;
              case 2 /* inParens */:
                if (char === `'` || char === `"` || char === '`') {
                  stateStack.push(state);
                  state = 3 /* inString */;
                  currentStringType = char;
                } else if (char === `(`) {
                  currentOpenParensCount++;
                } else if (char === `)`) {
                  // if the exp ends as a call then it should not be considered valid
                  if (i === path.length - 1) {
                    return false;
                  }
                  if (!--currentOpenParensCount) {
                    state = stateStack.pop();
                  }
                }
                break;
              case 3 /* inString */:
                if (char === currentStringType) {
                  state = stateStack.pop();
                  currentStringType = null;
                }
                break;
            }
          }
          return !currentOpenBracketCount && !currentOpenParensCount;
        };
        const isMemberExpressionNode =
          _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP;
        const isMemberExpression = isMemberExpressionBrowser;
        function getInnerRange(loc, offset, length) {
          const source = loc.source.slice(offset, offset + length);
          const newLoc = {
            source,
            start: advancePositionWithClone(loc.start, loc.source, offset),
            end: loc.end,
          };
          if (length != null) {
            newLoc.end = advancePositionWithClone(
              loc.start,
              loc.source,
              offset + length
            );
          }
          return newLoc;
        }
        function advancePositionWithClone(
          pos,
          source,
          numberOfCharacters = source.length
        ) {
          return advancePositionWithMutation(
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, pos),
            source,
            numberOfCharacters
          );
        }
        // advance by mutation without cloning (for performance reasons), since this
        // gets called a lot in the parser
        function advancePositionWithMutation(
          pos,
          source,
          numberOfCharacters = source.length
        ) {
          let linesCount = 0;
          let lastNewLinePos = -1;
          for (let i = 0; i < numberOfCharacters; i++) {
            if (source.charCodeAt(i) === 10 /* newline char code */) {
              linesCount++;
              lastNewLinePos = i;
            }
          }
          pos.offset += numberOfCharacters;
          pos.line += linesCount;
          pos.column =
            lastNewLinePos === -1
              ? pos.column + numberOfCharacters
              : numberOfCharacters - lastNewLinePos;
          return pos;
        }
        function assert(condition, msg) {
          /* istanbul ignore if */
          if (!condition) {
            throw new Error(msg || `unexpected compiler condition`);
          }
        }
        function findDir(node, name, allowEmpty = false) {
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (
              p.type === 7 /* DIRECTIVE */ &&
              (allowEmpty || p.exp) &&
              ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(name)
                ? p.name === name
                : name.test(p.name))
            ) {
              return p;
            }
          }
        }
        function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 6 /* ATTRIBUTE */) {
              if (dynamicOnly) continue;
              if (p.name === name && (p.value || allowEmpty)) {
                return p;
              }
            } else if (
              p.name === 'bind' &&
              (p.exp || allowEmpty) &&
              isStaticArgOf(p.arg, name)
            ) {
              return p;
            }
          }
        }
        function isStaticArgOf(arg, name) {
          return !!(arg && isStaticExp(arg) && arg.content === name);
        }
        function hasDynamicKeyVBind(node) {
          return node.props.some(
            (p) =>
              p.type === 7 /* DIRECTIVE */ &&
              p.name === 'bind' &&
              (!p.arg || // v-bind="obj"
                p.arg.type !== 4 /* SIMPLE_EXPRESSION */ || // v-bind:[_ctx.foo]
                !p.arg.isStatic) // v-bind:[foo]
          );
        }
        function isText(node) {
          return (
            node.type === 5 /* INTERPOLATION */ || node.type === 2 /* TEXT */
          );
        }
        function isVSlot(p) {
          return p.type === 7 /* DIRECTIVE */ && p.name === 'slot';
        }
        function isTemplateNode(node) {
          return (
            node.type === 1 /* ELEMENT */ && node.tagType === 3 /* TEMPLATE */
          );
        }
        function isSlotOutlet(node) {
          return node.type === 1 /* ELEMENT */ && node.tagType === 2 /* SLOT */;
        }
        function getVNodeHelper(ssr, isComponent) {
          return ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
        }
        function getVNodeBlockHelper(ssr, isComponent) {
          return ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
        }
        const propsHelperSet = new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
        function getUnnormalizedProps(props, callPath = []) {
          if (
            props &&
            !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(props) &&
            props.type === 14 /* JS_CALL_EXPRESSION */
          ) {
            const callee = props.callee;
            if (
              !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(callee) &&
              propsHelperSet.has(callee)
            ) {
              return getUnnormalizedProps(
                props.arguments[0],
                callPath.concat(props)
              );
            }
          }
          return [props, callPath];
        }
        function injectProp(node, prop, context) {
          let propsWithInjection;
          /**
           * 1. mergeProps(...)
           * 2. toHandlers(...)
           * 3. normalizeProps(...)
           * 4. normalizeProps(guardReactiveProps(...))
           *
           * we need to get the real props before normalization
           */
          let props =
            node.type === 13 /* VNODE_CALL */ ? node.props : node.arguments[2];
          let callPath = [];
          let parentCall;
          if (
            props &&
            !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(props) &&
            props.type === 14 /* JS_CALL_EXPRESSION */
          ) {
            const ret = getUnnormalizedProps(props);
            props = ret[0];
            callPath = ret[1];
            parentCall = callPath[callPath.length - 1];
          }
          if (
            props == null ||
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(props)
          ) {
            propsWithInjection = createObjectExpression([prop]);
          } else if (props.type === 14 /* JS_CALL_EXPRESSION */) {
            // merged props... add ours
            // only inject key to object literal if it's the first argument so that
            // if doesn't override user provided keys
            const first = props.arguments[0];
            if (
              !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(first) &&
              first.type === 15 /* JS_OBJECT_EXPRESSION */
            ) {
              first.properties.unshift(prop);
            } else {
              if (props.callee === TO_HANDLERS) {
                // #2366
                propsWithInjection = createCallExpression(
                  context.helper(MERGE_PROPS),
                  [createObjectExpression([prop]), props]
                );
              } else {
                props.arguments.unshift(createObjectExpression([prop]));
              }
            }
            !propsWithInjection && (propsWithInjection = props);
          } else if (props.type === 15 /* JS_OBJECT_EXPRESSION */) {
            let alreadyExists = false;
            // check existing key to avoid overriding user provided keys
            if (prop.key.type === 4 /* SIMPLE_EXPRESSION */) {
              const propKeyName = prop.key.content;
              alreadyExists = props.properties.some(
                (p) =>
                  p.key.type === 4 /* SIMPLE_EXPRESSION */ &&
                  p.key.content === propKeyName
              );
            }
            if (!alreadyExists) {
              props.properties.unshift(prop);
            }
            propsWithInjection = props;
          } else {
            // single v-bind with expression, return a merged replacement
            propsWithInjection = createCallExpression(
              context.helper(MERGE_PROPS),
              [createObjectExpression([prop]), props]
            );
            // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(props))`,
            // it will be rewritten as `normalizeProps(mergeProps({ key: 0 }, props))`,
            // the `guardReactiveProps` will no longer be needed
            if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
              parentCall = callPath[callPath.length - 2];
            }
          }
          if (node.type === 13 /* VNODE_CALL */) {
            if (parentCall) {
              parentCall.arguments[0] = propsWithInjection;
            } else {
              node.props = propsWithInjection;
            }
          } else {
            if (parentCall) {
              parentCall.arguments[0] = propsWithInjection;
            } else {
              node.arguments[2] = propsWithInjection;
            }
          }
        }
        function toValidAssetId(name, type) {
          // see issue#4422, we need adding identifier on validAssetId if variable `name` has specific character
          return `_${type}_${name.replace(
            /[^\w]/g,
            (searchValue, replaceValue) => {
              return searchValue === '-'
                ? '_'
                : name.charCodeAt(replaceValue).toString();
            }
          )}`;
        }
        // Check if a node contains expressions that reference current context scope ids
        function hasScopeRef(node, ids) {
          if (!node || Object.keys(ids).length === 0) {
            return false;
          }
          switch (node.type) {
            case 1 /* ELEMENT */:
              for (let i = 0; i < node.props.length; i++) {
                const p = node.props[i];
                if (
                  p.type === 7 /* DIRECTIVE */ &&
                  (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))
                ) {
                  return true;
                }
              }
              return node.children.some((c) => hasScopeRef(c, ids));
            case 11 /* FOR */:
              if (hasScopeRef(node.source, ids)) {
                return true;
              }
              return node.children.some((c) => hasScopeRef(c, ids));
            case 9 /* IF */:
              return node.branches.some((b) => hasScopeRef(b, ids));
            case 10 /* IF_BRANCH */:
              if (hasScopeRef(node.condition, ids)) {
                return true;
              }
              return node.children.some((c) => hasScopeRef(c, ids));
            case 4 /* SIMPLE_EXPRESSION */:
              return (
                !node.isStatic &&
                isSimpleIdentifier(node.content) &&
                !!ids[node.content]
              );
            case 8 /* COMPOUND_EXPRESSION */:
              return node.children.some(
                (c) =>
                  (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(c) &&
                  hasScopeRef(c, ids)
              );
            case 5 /* INTERPOLATION */:
            case 12 /* TEXT_CALL */:
              return hasScopeRef(node.content, ids);
            case 2 /* TEXT */:
            case 3 /* COMMENT */:
              return false;
            default:
              if (true);
              return false;
          }
        }
        function getMemoedVNodeCall(node) {
          if (
            node.type === 14 /* JS_CALL_EXPRESSION */ &&
            node.callee === WITH_MEMO
          ) {
            return node.arguments[1].returns;
          } else {
            return node;
          }
        }
        function makeBlock(node, { helper, removeHelper, inSSR }) {
          if (!node.isBlock) {
            node.isBlock = true;
            removeHelper(getVNodeHelper(inSSR, node.isComponent));
            helper(OPEN_BLOCK);
            helper(getVNodeBlockHelper(inSSR, node.isComponent));
          }
        }

        const deprecationData = {
          ['COMPILER_IS_ON_ELEMENT' /* COMPILER_IS_ON_ELEMENT */]: {
            message:
              `Platform-native elements with "is" prop will no longer be ` +
              `treated as components in Vue 3 unless the "is" value is explicitly ` +
              `prefixed with "vue:".`,
            link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`,
          },
          ['COMPILER_V_BIND_SYNC' /* COMPILER_V_BIND_SYNC */]: {
            message: (key) =>
              `.sync modifier for v-bind has been removed. Use v-model with ` +
              `argument instead. \`v-bind:${key}.sync\` should be changed to ` +
              `\`v-model:${key}\`.`,
            link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`,
          },
          ['COMPILER_V_BIND_PROP' /* COMPILER_V_BIND_PROP */]: {
            message:
              `.prop modifier for v-bind has been removed and no longer necessary. ` +
              `Vue 3 will automatically set a binding as DOM property when appropriate.`,
          },
          ['COMPILER_V_BIND_OBJECT_ORDER' /* COMPILER_V_BIND_OBJECT_ORDER */]: {
            message:
              `v-bind="obj" usage is now order sensitive and behaves like JavaScript ` +
              `object spread: it will now overwrite an existing non-mergeable attribute ` +
              `that appears before v-bind in the case of conflict. ` +
              `To retain 2.x behavior, move v-bind to make it the first attribute. ` +
              `You can also suppress this warning if the usage is intended.`,
            link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`,
          },
          ['COMPILER_V_ON_NATIVE' /* COMPILER_V_ON_NATIVE */]: {
            message: `.native modifier for v-on has been removed as is no longer necessary.`,
            link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`,
          },
          ['COMPILER_V_IF_V_FOR_PRECEDENCE' /* COMPILER_V_IF_V_FOR_PRECEDENCE */]:
            {
              message:
                `v-if / v-for precedence when used on the same element has changed ` +
                `in Vue 3: v-if now takes higher precedence and will no longer have ` +
                `access to v-for scope variables. It is best to avoid the ambiguity ` +
                `with <template> tags or use a computed property that filters v-for ` +
                `data source.`,
              link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`,
            },
          ['COMPILER_NATIVE_TEMPLATE' /* COMPILER_NATIVE_TEMPLATE */]: {
            message:
              `<template> with no special directives will render as a native template ` +
              `element instead of its inner content in Vue 3.`,
          },
          ['COMPILER_INLINE_TEMPLATE' /* COMPILER_INLINE_TEMPLATE */]: {
            message: `"inline-template" has been removed in Vue 3.`,
            link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`,
          },
          ['COMPILER_FILTER' /* COMPILER_FILTERS */]: {
            message:
              `filters have been removed in Vue 3. ` +
              `The "|" symbol will be treated as native JavaScript bitwise OR operator. ` +
              `Use method calls or computed properties instead.`,
            link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`,
          },
        };
        function getCompatValue(key, context) {
          const config = context.options
            ? context.options.compatConfig
            : context.compatConfig;
          const value = config && config[key];
          if (key === 'MODE') {
            return value || 3; // compiler defaults to v3 behavior
          } else {
            return value;
          }
        }
        function isCompatEnabled(key, context) {
          const mode = getCompatValue('MODE', context);
          const value = getCompatValue(key, context);
          // in v3 mode, only enable if explicitly set to true
          // otherwise enable for any non-false value
          return mode === 3 ? value === true : value !== false;
        }
        function checkCompatEnabled(key, context, loc, ...args) {
          const enabled = isCompatEnabled(key, context);
          if (true && enabled) {
            warnDeprecation(key, context, loc, ...args);
          }
          return enabled;
        }
        function warnDeprecation(key, context, loc, ...args) {
          const val = getCompatValue(key, context);
          if (val === 'suppress-warning') {
            return;
          }
          const { message, link } = deprecationData[key];
          const msg = `(deprecation ${key}) ${
            typeof message === 'function' ? message(...args) : message
          }${link ? `\n  Details: ${link}` : ``}`;
          const err = new SyntaxError(msg);
          err.code = key;
          if (loc) err.loc = loc;
          context.onWarn(err);
        }

        // The default decoder only provides escapes for characters reserved as part of
        // the template syntax, and is only used if the custom renderer did not provide
        // a platform-specific decoder.
        const decodeRE = /&(gt|lt|amp|apos|quot);/g;
        const decodeMap = {
          gt: '>',
          lt: '<',
          amp: '&',
          apos: "'",
          quot: '"',
        };
        const defaultParserOptions = {
          delimiters: [`{{`, `}}`],
          getNamespace: () => 0 /* HTML */,
          getTextMode: () => 0 /* DATA */,
          isVoidTag: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
          isPreTag: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
          isCustomElement: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
          decodeEntities: (rawText) =>
            rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),
          onError: defaultOnError,
          onWarn: defaultOnWarn,
          comments: 'development' !== 'production',
        };
        function baseParse(content, options = {}) {
          const context = createParserContext(content, options);
          const start = getCursor(context);
          return createRoot(
            parseChildren(context, 0 /* DATA */, []),
            getSelection(context, start)
          );
        }
        function createParserContext(content, rawOptions) {
          const options = (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(
            {},
            defaultParserOptions
          );
          let key;
          for (key in rawOptions) {
            // @ts-ignore
            options[key] =
              rawOptions[key] === undefined
                ? defaultParserOptions[key]
                : rawOptions[key];
          }
          return {
            options,
            column: 1,
            line: 1,
            offset: 0,
            originalSource: content,
            source: content,
            inPre: false,
            inVPre: false,
            onWarn: options.onWarn,
          };
        }
        function parseChildren(context, mode, ancestors) {
          const parent = last(ancestors);
          const ns = parent ? parent.ns : 0; /* HTML */
          const nodes = [];
          while (!isEnd(context, mode, ancestors)) {
            const s = context.source;
            let node = undefined;
            if (mode === 0 /* DATA */ || mode === 1 /* RCDATA */) {
              if (
                !context.inVPre &&
                startsWith(s, context.options.delimiters[0])
              ) {
                // '{{'
                node = parseInterpolation(context, mode);
              } else if (mode === 0 /* DATA */ && s[0] === '<') {
                // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state
                if (s.length === 1) {
                  emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 1);
                } else if (s[1] === '!') {
                  // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state
                  if (startsWith(s, '<!--')) {
                    node = parseComment(context);
                  } else if (startsWith(s, '<!DOCTYPE')) {
                    // Ignore DOCTYPE by a limitation.
                    node = parseBogusComment(context);
                  } else if (startsWith(s, '<![CDATA[')) {
                    if (ns !== 0 /* HTML */) {
                      node = parseCDATA(context, ancestors);
                    } else {
                      emitError(context, 1 /* CDATA_IN_HTML_CONTENT */);
                      node = parseBogusComment(context);
                    }
                  } else {
                    emitError(context, 11 /* INCORRECTLY_OPENED_COMMENT */);
                    node = parseBogusComment(context);
                  }
                } else if (s[1] === '/') {
                  // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state
                  if (s.length === 2) {
                    emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 2);
                  } else if (s[2] === '>') {
                    emitError(context, 14 /* MISSING_END_TAG_NAME */, 2);
                    advanceBy(context, 3);
                    continue;
                  } else if (/[a-z]/i.test(s[2])) {
                    emitError(context, 23 /* X_INVALID_END_TAG */);
                    parseTag(context, 1 /* End */, parent);
                    continue;
                  } else {
                    emitError(
                      context,
                      12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */,
                      2
                    );
                    node = parseBogusComment(context);
                  }
                } else if (/[a-z]/i.test(s[1])) {
                  node = parseElement(context, ancestors);
                  // 2.x <template> with no directive compat
                  if (
                    isCompatEnabled(
                      'COMPILER_NATIVE_TEMPLATE' /* COMPILER_NATIVE_TEMPLATE */,
                      context
                    ) &&
                    node &&
                    node.tag === 'template' &&
                    !node.props.some(
                      (p) =>
                        p.type === 7 /* DIRECTIVE */ &&
                        isSpecialTemplateDirective(p.name)
                    )
                  ) {
                    true &&
                      warnDeprecation(
                        'COMPILER_NATIVE_TEMPLATE' /* COMPILER_NATIVE_TEMPLATE */,
                        context,
                        node.loc
                      );
                    node = node.children;
                  }
                } else if (s[1] === '?') {
                  emitError(
                    context,
                    21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */,
                    1
                  );
                  node = parseBogusComment(context);
                } else {
                  emitError(
                    context,
                    12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */,
                    1
                  );
                }
              }
            }
            if (!node) {
              node = parseText(context, mode);
            }
            if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node)) {
              for (let i = 0; i < node.length; i++) {
                pushNode(nodes, node[i]);
              }
            } else {
              pushNode(nodes, node);
            }
          }
          // Whitespace handling strategy like v2
          let removedWhitespace = false;
          if (mode !== 2 /* RAWTEXT */ && mode !== 1 /* RCDATA */) {
            const shouldCondense = context.options.whitespace !== 'preserve';
            for (let i = 0; i < nodes.length; i++) {
              const node = nodes[i];
              if (!context.inPre && node.type === 2 /* TEXT */) {
                if (!/[^\t\r\n\f ]/.test(node.content)) {
                  const prev = nodes[i - 1];
                  const next = nodes[i + 1];
                  // Remove if:
                  // - the whitespace is the first or last node, or:
                  // - (condense mode) the whitespace is adjacent to a comment, or:
                  // - (condense mode) the whitespace is between two elements AND contains newline
                  if (
                    !prev ||
                    !next ||
                    (shouldCondense &&
                      (prev.type === 3 /* COMMENT */ ||
                        next.type === 3 /* COMMENT */ ||
                        (prev.type === 1 /* ELEMENT */ &&
                          next.type === 1 /* ELEMENT */ &&
                          /[\r\n]/.test(node.content))))
                  ) {
                    removedWhitespace = true;
                    nodes[i] = null;
                  } else {
                    // Otherwise, the whitespace is condensed into a single space
                    node.content = ' ';
                  }
                } else if (shouldCondense) {
                  // in condense mode, consecutive whitespaces in text are condensed
                  // down to a single space.
                  node.content = node.content.replace(/[\t\r\n\f ]+/g, ' ');
                }
              }
              // Remove comment nodes if desired by configuration.
              else if (
                node.type === 3 /* COMMENT */ &&
                !context.options.comments
              ) {
                removedWhitespace = true;
                nodes[i] = null;
              }
            }
            if (
              context.inPre &&
              parent &&
              context.options.isPreTag(parent.tag)
            ) {
              // remove leading newline per html spec
              // https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element
              const first = nodes[0];
              if (first && first.type === 2 /* TEXT */) {
                first.content = first.content.replace(/^\r?\n/, '');
              }
            }
          }
          return removedWhitespace ? nodes.filter(Boolean) : nodes;
        }
        function pushNode(nodes, node) {
          if (node.type === 2 /* TEXT */) {
            const prev = last(nodes);
            // Merge if both this and the previous node are text and those are
            // consecutive. This happens for cases like "a < b".
            if (
              prev &&
              prev.type === 2 /* TEXT */ &&
              prev.loc.end.offset === node.loc.start.offset
            ) {
              prev.content += node.content;
              prev.loc.end = node.loc.end;
              prev.loc.source += node.loc.source;
              return;
            }
          }
          nodes.push(node);
        }
        function parseCDATA(context, ancestors) {
          advanceBy(context, 9);
          const nodes = parseChildren(context, 3 /* CDATA */, ancestors);
          if (context.source.length === 0) {
            emitError(context, 6 /* EOF_IN_CDATA */);
          } else {
            advanceBy(context, 3);
          }
          return nodes;
        }
        function parseComment(context) {
          const start = getCursor(context);
          let content;
          // Regular comment.
          const match = /--(\!)?>/.exec(context.source);
          if (!match) {
            content = context.source.slice(4);
            advanceBy(context, context.source.length);
            emitError(context, 7 /* EOF_IN_COMMENT */);
          } else {
            if (match.index <= 3) {
              emitError(context, 0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */);
            }
            if (match[1]) {
              emitError(context, 10 /* INCORRECTLY_CLOSED_COMMENT */);
            }
            content = context.source.slice(4, match.index);
            // Advancing with reporting nested comments.
            const s = context.source.slice(0, match.index);
            let prevIndex = 1,
              nestedIndex = 0;
            while ((nestedIndex = s.indexOf('<!--', prevIndex)) !== -1) {
              advanceBy(context, nestedIndex - prevIndex + 1);
              if (nestedIndex + 4 < s.length) {
                emitError(context, 16 /* NESTED_COMMENT */);
              }
              prevIndex = nestedIndex + 1;
            }
            advanceBy(context, match.index + match[0].length - prevIndex + 1);
          }
          return {
            type: 3 /* COMMENT */,
            content,
            loc: getSelection(context, start),
          };
        }
        function parseBogusComment(context) {
          const start = getCursor(context);
          const contentStart = context.source[1] === '?' ? 1 : 2;
          let content;
          const closeIndex = context.source.indexOf('>');
          if (closeIndex === -1) {
            content = context.source.slice(contentStart);
            advanceBy(context, context.source.length);
          } else {
            content = context.source.slice(contentStart, closeIndex);
            advanceBy(context, closeIndex + 1);
          }
          return {
            type: 3 /* COMMENT */,
            content,
            loc: getSelection(context, start),
          };
        }
        function parseElement(context, ancestors) {
          // Start tag.
          const wasInPre = context.inPre;
          const wasInVPre = context.inVPre;
          const parent = last(ancestors);
          const element = parseTag(context, 0 /* Start */, parent);
          const isPreBoundary = context.inPre && !wasInPre;
          const isVPreBoundary = context.inVPre && !wasInVPre;
          if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
            // #4030 self-closing <pre> tag
            if (isPreBoundary) {
              context.inPre = false;
            }
            if (isVPreBoundary) {
              context.inVPre = false;
            }
            return element;
          }
          // Children.
          ancestors.push(element);
          const mode = context.options.getTextMode(element, parent);
          const children = parseChildren(context, mode, ancestors);
          ancestors.pop();
          // 2.x inline-template compat
          {
            const inlineTemplateProp = element.props.find(
              (p) =>
                p.type === 6 /* ATTRIBUTE */ && p.name === 'inline-template'
            );
            if (
              inlineTemplateProp &&
              checkCompatEnabled(
                'COMPILER_INLINE_TEMPLATE' /* COMPILER_INLINE_TEMPLATE */,
                context,
                inlineTemplateProp.loc
              )
            ) {
              const loc = getSelection(context, element.loc.end);
              inlineTemplateProp.value = {
                type: 2 /* TEXT */,
                content: loc.source,
                loc,
              };
            }
          }
          element.children = children;
          // End tag.
          if (startsWithEndTagOpen(context.source, element.tag)) {
            parseTag(context, 1 /* End */, parent);
          } else {
            emitError(
              context,
              24 /* X_MISSING_END_TAG */,
              0,
              element.loc.start
            );
            if (
              context.source.length === 0 &&
              element.tag.toLowerCase() === 'script'
            ) {
              const first = children[0];
              if (first && startsWith(first.loc.source, '<!--')) {
                emitError(
                  context,
                  8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */
                );
              }
            }
          }
          element.loc = getSelection(context, element.loc.start);
          if (isPreBoundary) {
            context.inPre = false;
          }
          if (isVPreBoundary) {
            context.inVPre = false;
          }
          return element;
        }
        const isSpecialTemplateDirective = /*#__PURE__*/ (0,
        _vue_shared__WEBPACK_IMPORTED_MODULE_0__.makeMap)(
          `if,else,else-if,for,slot`
        );
        function parseTag(context, type, parent) {
          // Tag open.
          const start = getCursor(context);
          const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
          const tag = match[1];
          const ns = context.options.getNamespace(tag, parent);
          advanceBy(context, match[0].length);
          advanceSpaces(context);
          // save current state in case we need to re-parse attributes with v-pre
          const cursor = getCursor(context);
          const currentSource = context.source;
          // check <pre> tag
          if (context.options.isPreTag(tag)) {
            context.inPre = true;
          }
          // Attributes.
          let props = parseAttributes(context, type);
          // check v-pre
          if (
            type === 0 /* Start */ &&
            !context.inVPre &&
            props.some((p) => p.type === 7 /* DIRECTIVE */ && p.name === 'pre')
          ) {
            context.inVPre = true;
            // reset context
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(
              context,
              cursor
            );
            context.source = currentSource;
            // re-parse attrs and filter out v-pre itself
            props = parseAttributes(context, type).filter(
              (p) => p.name !== 'v-pre'
            );
          }
          // Tag close.
          let isSelfClosing = false;
          if (context.source.length === 0) {
            emitError(context, 9 /* EOF_IN_TAG */);
          } else {
            isSelfClosing = startsWith(context.source, '/>');
            if (type === 1 /* End */ && isSelfClosing) {
              emitError(context, 4 /* END_TAG_WITH_TRAILING_SOLIDUS */);
            }
            advanceBy(context, isSelfClosing ? 2 : 1);
          }
          if (type === 1 /* End */) {
            return;
          }
          // 2.x deprecation checks
          if (
            true &&
            isCompatEnabled(
              'COMPILER_V_IF_V_FOR_PRECEDENCE' /* COMPILER_V_IF_V_FOR_PRECEDENCE */,
              context
            )
          ) {
            let hasIf = false;
            let hasFor = false;
            for (let i = 0; i < props.length; i++) {
              const p = props[i];
              if (p.type === 7 /* DIRECTIVE */) {
                if (p.name === 'if') {
                  hasIf = true;
                } else if (p.name === 'for') {
                  hasFor = true;
                }
              }
              if (hasIf && hasFor) {
                warnDeprecation(
                  'COMPILER_V_IF_V_FOR_PRECEDENCE' /* COMPILER_V_IF_V_FOR_PRECEDENCE */,
                  context,
                  getSelection(context, start)
                );
                break;
              }
            }
          }
          let tagType = 0; /* ELEMENT */
          if (!context.inVPre) {
            if (tag === 'slot') {
              tagType = 2 /* SLOT */;
            } else if (tag === 'template') {
              if (
                props.some(
                  (p) =>
                    p.type === 7 /* DIRECTIVE */ &&
                    isSpecialTemplateDirective(p.name)
                )
              ) {
                tagType = 3 /* TEMPLATE */;
              }
            } else if (isComponent(tag, props, context)) {
              tagType = 1 /* COMPONENT */;
            }
          }
          return {
            type: 1 /* ELEMENT */,
            ns,
            tag,
            tagType,
            props,
            isSelfClosing,
            children: [],
            loc: getSelection(context, start),
            codegenNode: undefined, // to be created during transform phase
          };
        }
        function isComponent(tag, props, context) {
          const options = context.options;
          if (options.isCustomElement(tag)) {
            return false;
          }
          if (
            tag === 'component' ||
            /^[A-Z]/.test(tag) ||
            isCoreComponent(tag) ||
            (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||
            (options.isNativeTag && !options.isNativeTag(tag))
          ) {
            return true;
          }
          // at this point the tag should be a native tag, but check for potential "is"
          // casting
          for (let i = 0; i < props.length; i++) {
            const p = props[i];
            if (p.type === 6 /* ATTRIBUTE */) {
              if (p.name === 'is' && p.value) {
                if (p.value.content.startsWith('vue:')) {
                  return true;
                } else if (
                  checkCompatEnabled(
                    'COMPILER_IS_ON_ELEMENT' /* COMPILER_IS_ON_ELEMENT */,
                    context,
                    p.loc
                  )
                ) {
                  return true;
                }
              }
            } else {
              // directive
              // v-is (TODO Deprecate)
              if (p.name === 'is') {
                return true;
              } else if (
                // :is on plain element - only treat as component in compat mode
                p.name === 'bind' &&
                isStaticArgOf(p.arg, 'is') &&
                true &&
                checkCompatEnabled(
                  'COMPILER_IS_ON_ELEMENT' /* COMPILER_IS_ON_ELEMENT */,
                  context,
                  p.loc
                )
              ) {
                return true;
              }
            }
          }
        }
        function parseAttributes(context, type) {
          const props = [];
          const attributeNames = new Set();
          while (
            context.source.length > 0 &&
            !startsWith(context.source, '>') &&
            !startsWith(context.source, '/>')
          ) {
            if (startsWith(context.source, '/')) {
              emitError(context, 22 /* UNEXPECTED_SOLIDUS_IN_TAG */);
              advanceBy(context, 1);
              advanceSpaces(context);
              continue;
            }
            if (type === 1 /* End */) {
              emitError(context, 3 /* END_TAG_WITH_ATTRIBUTES */);
            }
            const attr = parseAttribute(context, attributeNames);
            // Trim whitespace between class
            // https://github.com/vuejs/core/issues/4251
            if (
              attr.type === 6 /* ATTRIBUTE */ &&
              attr.value &&
              attr.name === 'class'
            ) {
              attr.value.content = attr.value.content
                .replace(/\s+/g, ' ')
                .trim();
            }
            if (type === 0 /* Start */) {
              props.push(attr);
            }
            if (/^[^\t\r\n\f />]/.test(context.source)) {
              emitError(
                context,
                15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */
              );
            }
            advanceSpaces(context);
          }
          return props;
        }
        function parseAttribute(context, nameSet) {
          // Name.
          const start = getCursor(context);
          const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
          const name = match[0];
          if (nameSet.has(name)) {
            emitError(context, 2 /* DUPLICATE_ATTRIBUTE */);
          }
          nameSet.add(name);
          if (name[0] === '=') {
            emitError(
              context,
              19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */
            );
          }
          {
            const pattern = /["'<]/g;
            let m;
            while ((m = pattern.exec(name))) {
              emitError(
                context,
                17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */,
                m.index
              );
            }
          }
          advanceBy(context, name.length);
          // Value
          let value = undefined;
          if (/^[\t\r\n\f ]*=/.test(context.source)) {
            advanceSpaces(context);
            advanceBy(context, 1);
            advanceSpaces(context);
            value = parseAttributeValue(context);
            if (!value) {
              emitError(context, 13 /* MISSING_ATTRIBUTE_VALUE */);
            }
          }
          const loc = getSelection(context, start);
          if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name)) {
            const match =
              /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(
                name
              );
            let isPropShorthand = startsWith(name, '.');
            let dirName =
              match[1] ||
              (isPropShorthand || startsWith(name, ':')
                ? 'bind'
                : startsWith(name, '@')
                ? 'on'
                : 'slot');
            let arg;
            if (match[2]) {
              const isSlot = dirName === 'slot';
              const startOffset = name.lastIndexOf(match[2]);
              const loc = getSelection(
                context,
                getNewPosition(context, start, startOffset),
                getNewPosition(
                  context,
                  start,
                  startOffset +
                    match[2].length +
                    ((isSlot && match[3]) || '').length
                )
              );
              let content = match[2];
              let isStatic = true;
              if (content.startsWith('[')) {
                isStatic = false;
                if (!content.endsWith(']')) {
                  emitError(
                    context,
                    27 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */
                  );
                  content = content.slice(1);
                } else {
                  content = content.slice(1, content.length - 1);
                }
              } else if (isSlot) {
                // #1241 special case for v-slot: vuetify relies extensively on slot
                // names containing dots. v-slot doesn't have any modifiers and Vue 2.x
                // supports such usage so we are keeping it consistent with 2.x.
                content += match[3] || '';
              }
              arg = {
                type: 4 /* SIMPLE_EXPRESSION */,
                content,
                isStatic,
                constType: isStatic
                  ? 3 /* CAN_STRINGIFY */
                  : 0 /* NOT_CONSTANT */,
                loc,
              };
            }
            if (value && value.isQuoted) {
              const valueLoc = value.loc;
              valueLoc.start.offset++;
              valueLoc.start.column++;
              valueLoc.end = advancePositionWithClone(
                valueLoc.start,
                value.content
              );
              valueLoc.source = valueLoc.source.slice(1, -1);
            }
            const modifiers = match[3] ? match[3].slice(1).split('.') : [];
            if (isPropShorthand) modifiers.push('prop');
            // 2.x compat v-bind:foo.sync -> v-model:foo
            if (dirName === 'bind' && arg) {
              if (
                modifiers.includes('sync') &&
                checkCompatEnabled(
                  'COMPILER_V_BIND_SYNC' /* COMPILER_V_BIND_SYNC */,
                  context,
                  loc,
                  arg.loc.source
                )
              ) {
                dirName = 'model';
                modifiers.splice(modifiers.indexOf('sync'), 1);
              }
              if (true && modifiers.includes('prop')) {
                checkCompatEnabled(
                  'COMPILER_V_BIND_PROP' /* COMPILER_V_BIND_PROP */,
                  context,
                  loc
                );
              }
            }
            return {
              type: 7 /* DIRECTIVE */,
              name: dirName,
              exp: value && {
                type: 4 /* SIMPLE_EXPRESSION */,
                content: value.content,
                isStatic: false,
                // Treat as non-constant by default. This can be potentially set to
                // other values by `transformExpression` to make it eligible for hoisting.
                constType: 0 /* NOT_CONSTANT */,
                loc: value.loc,
              },
              arg,
              modifiers,
              loc,
            };
          }
          // missing directive name or illegal directive name
          if (!context.inVPre && startsWith(name, 'v-')) {
            emitError(context, 26 /* X_MISSING_DIRECTIVE_NAME */);
          }
          return {
            type: 6 /* ATTRIBUTE */,
            name,
            value: value && {
              type: 2 /* TEXT */,
              content: value.content,
              loc: value.loc,
            },
            loc,
          };
        }
        function parseAttributeValue(context) {
          const start = getCursor(context);
          let content;
          const quote = context.source[0];
          const isQuoted = quote === `"` || quote === `'`;
          if (isQuoted) {
            // Quoted value.
            advanceBy(context, 1);
            const endIndex = context.source.indexOf(quote);
            if (endIndex === -1) {
              content = parseTextData(
                context,
                context.source.length,
                4 /* ATTRIBUTE_VALUE */
              );
            } else {
              content = parseTextData(
                context,
                endIndex,
                4 /* ATTRIBUTE_VALUE */
              );
              advanceBy(context, 1);
            }
          } else {
            // Unquoted
            const match = /^[^\t\r\n\f >]+/.exec(context.source);
            if (!match) {
              return undefined;
            }
            const unexpectedChars = /["'<=`]/g;
            let m;
            while ((m = unexpectedChars.exec(match[0]))) {
              emitError(
                context,
                18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */,
                m.index
              );
            }
            content = parseTextData(
              context,
              match[0].length,
              4 /* ATTRIBUTE_VALUE */
            );
          }
          return { content, isQuoted, loc: getSelection(context, start) };
        }
        function parseInterpolation(context, mode) {
          const [open, close] = context.options.delimiters;
          const closeIndex = context.source.indexOf(close, open.length);
          if (closeIndex === -1) {
            emitError(context, 25 /* X_MISSING_INTERPOLATION_END */);
            return undefined;
          }
          const start = getCursor(context);
          advanceBy(context, open.length);
          const innerStart = getCursor(context);
          const innerEnd = getCursor(context);
          const rawContentLength = closeIndex - open.length;
          const rawContent = context.source.slice(0, rawContentLength);
          const preTrimContent = parseTextData(context, rawContentLength, mode);
          const content = preTrimContent.trim();
          const startOffset = preTrimContent.indexOf(content);
          if (startOffset > 0) {
            advancePositionWithMutation(innerStart, rawContent, startOffset);
          }
          const endOffset =
            rawContentLength -
            (preTrimContent.length - content.length - startOffset);
          advancePositionWithMutation(innerEnd, rawContent, endOffset);
          advanceBy(context, close.length);
          return {
            type: 5 /* INTERPOLATION */,
            content: {
              type: 4 /* SIMPLE_EXPRESSION */,
              isStatic: false,
              // Set `isConstant` to false by default and will decide in transformExpression
              constType: 0 /* NOT_CONSTANT */,
              content,
              loc: getSelection(context, innerStart, innerEnd),
            },
            loc: getSelection(context, start),
          };
        }
        function parseText(context, mode) {
          const endTokens =
            mode === 3 /* CDATA */
              ? [']]>']
              : ['<', context.options.delimiters[0]];
          let endIndex = context.source.length;
          for (let i = 0; i < endTokens.length; i++) {
            const index = context.source.indexOf(endTokens[i], 1);
            if (index !== -1 && endIndex > index) {
              endIndex = index;
            }
          }
          const start = getCursor(context);
          const content = parseTextData(context, endIndex, mode);
          return {
            type: 2 /* TEXT */,
            content,
            loc: getSelection(context, start),
          };
        }
        /**
         * Get text data with a given length from the current location.
         * This translates HTML entities in the text data.
         */
        function parseTextData(context, length, mode) {
          const rawText = context.source.slice(0, length);
          advanceBy(context, length);
          if (
            mode === 2 /* RAWTEXT */ ||
            mode === 3 /* CDATA */ ||
            !rawText.includes('&')
          ) {
            return rawText;
          } else {
            // DATA or RCDATA containing "&"". Entity decoding required.
            return context.options.decodeEntities(
              rawText,
              mode === 4 /* ATTRIBUTE_VALUE */
            );
          }
        }
        function getCursor(context) {
          const { column, line, offset } = context;
          return { column, line, offset };
        }
        function getSelection(context, start, end) {
          end = end || getCursor(context);
          return {
            start,
            end,
            source: context.originalSource.slice(start.offset, end.offset),
          };
        }
        function last(xs) {
          return xs[xs.length - 1];
        }
        function startsWith(source, searchString) {
          return source.startsWith(searchString);
        }
        function advanceBy(context, numberOfCharacters) {
          const { source } = context;
          advancePositionWithMutation(context, source, numberOfCharacters);
          context.source = source.slice(numberOfCharacters);
        }
        function advanceSpaces(context) {
          const match = /^[\t\r\n\f ]+/.exec(context.source);
          if (match) {
            advanceBy(context, match[0].length);
          }
        }
        function getNewPosition(context, start, numberOfCharacters) {
          return advancePositionWithClone(
            start,
            context.originalSource.slice(start.offset, numberOfCharacters),
            numberOfCharacters
          );
        }
        function emitError(context, code, offset, loc = getCursor(context)) {
          if (offset) {
            loc.offset += offset;
            loc.column += offset;
          }
          context.options.onError(
            createCompilerError(code, {
              start: loc,
              end: loc,
              source: '',
            })
          );
        }
        function isEnd(context, mode, ancestors) {
          const s = context.source;
          switch (mode) {
            case 0 /* DATA */:
              if (startsWith(s, '</')) {
                // TODO: probably bad performance
                for (let i = ancestors.length - 1; i >= 0; --i) {
                  if (startsWithEndTagOpen(s, ancestors[i].tag)) {
                    return true;
                  }
                }
              }
              break;
            case 1 /* RCDATA */:
            case 2 /* RAWTEXT */: {
              const parent = last(ancestors);
              if (parent && startsWithEndTagOpen(s, parent.tag)) {
                return true;
              }
              break;
            }
            case 3 /* CDATA */:
              if (startsWith(s, ']]>')) {
                return true;
              }
              break;
          }
          return !s;
        }
        function startsWithEndTagOpen(source, tag) {
          return (
            startsWith(source, '</') &&
            source.slice(2, 2 + tag.length).toLowerCase() ===
              tag.toLowerCase() &&
            /[\t\r\n\f />]/.test(source[2 + tag.length] || '>')
          );
        }

        function hoistStatic(root, context) {
          walk(
            root,
            context,
            // Root node is unfortunately non-hoistable due to potential parent
            // fallthrough attributes.
            isSingleElementRoot(root, root.children[0])
          );
        }
        function isSingleElementRoot(root, child) {
          const { children } = root;
          return (
            children.length === 1 &&
            child.type === 1 /* ELEMENT */ &&
            !isSlotOutlet(child)
          );
        }
        function walk(node, context, doNotHoistNode = false) {
          const { children } = node;
          const originalCount = children.length;
          let hoistedCount = 0;
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            // only plain elements & text calls are eligible for hoisting.
            if (
              child.type === 1 /* ELEMENT */ &&
              child.tagType === 0 /* ELEMENT */
            ) {
              const constantType = doNotHoistNode
                ? 0 /* NOT_CONSTANT */
                : getConstantType(child, context);
              if (constantType > 0 /* NOT_CONSTANT */) {
                if (constantType >= 2 /* CAN_HOIST */) {
                  child.codegenNode.patchFlag =
                    -1 /* HOISTED */ + (true ? ` /* HOISTED */` : 0);
                  child.codegenNode = context.hoist(child.codegenNode);
                  hoistedCount++;
                  continue;
                }
              } else {
                // node may contain dynamic children, but its props may be eligible for
                // hoisting.
                const codegenNode = child.codegenNode;
                if (codegenNode.type === 13 /* VNODE_CALL */) {
                  const flag = getPatchFlag(codegenNode);
                  if (
                    (!flag ||
                      flag === 512 /* NEED_PATCH */ ||
                      flag === 1) /* TEXT */ &&
                    getGeneratedPropsConstantType(child, context) >=
                      2 /* CAN_HOIST */
                  ) {
                    const props = getNodeProps(child);
                    if (props) {
                      codegenNode.props = context.hoist(props);
                    }
                  }
                  if (codegenNode.dynamicProps) {
                    codegenNode.dynamicProps = context.hoist(
                      codegenNode.dynamicProps
                    );
                  }
                }
              }
            } else if (
              child.type === 12 /* TEXT_CALL */ &&
              getConstantType(child.content, context) >= 2 /* CAN_HOIST */
            ) {
              child.codegenNode = context.hoist(child.codegenNode);
              hoistedCount++;
            }
            // walk further
            if (child.type === 1 /* ELEMENT */) {
              const isComponent = child.tagType === 1; /* COMPONENT */
              if (isComponent) {
                context.scopes.vSlot++;
              }
              walk(child, context);
              if (isComponent) {
                context.scopes.vSlot--;
              }
            } else if (child.type === 11 /* FOR */) {
              // Do not hoist v-for single child because it has to be a block
              walk(child, context, child.children.length === 1);
            } else if (child.type === 9 /* IF */) {
              for (let i = 0; i < child.branches.length; i++) {
                // Do not hoist v-if single child because it has to be a block
                walk(
                  child.branches[i],
                  context,
                  child.branches[i].children.length === 1
                );
              }
            }
          }
          if (hoistedCount && context.transformHoist) {
            context.transformHoist(children, context, node);
          }
          // all children were hoisted - the entire children array is hoistable.
          if (
            hoistedCount &&
            hoistedCount === originalCount &&
            node.type === 1 /* ELEMENT */ &&
            node.tagType === 0 /* ELEMENT */ &&
            node.codegenNode &&
            node.codegenNode.type === 13 /* VNODE_CALL */ &&
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(
              node.codegenNode.children
            )
          ) {
            node.codegenNode.children = context.hoist(
              createArrayExpression(node.codegenNode.children)
            );
          }
        }
        function getConstantType(node, context) {
          const { constantCache } = context;
          switch (node.type) {
            case 1 /* ELEMENT */:
              if (node.tagType !== 0 /* ELEMENT */) {
                return 0 /* NOT_CONSTANT */;
              }
              const cached = constantCache.get(node);
              if (cached !== undefined) {
                return cached;
              }
              const codegenNode = node.codegenNode;
              if (codegenNode.type !== 13 /* VNODE_CALL */) {
                return 0 /* NOT_CONSTANT */;
              }
              if (
                codegenNode.isBlock &&
                node.tag !== 'svg' &&
                node.tag !== 'foreignObject'
              ) {
                return 0 /* NOT_CONSTANT */;
              }
              const flag = getPatchFlag(codegenNode);
              if (!flag) {
                let returnType = 3; /* CAN_STRINGIFY */
                // Element itself has no patch flag. However we still need to check:
                // 1. Even for a node with no patch flag, it is possible for it to contain
                // non-hoistable expressions that refers to scope variables, e.g. compiler
                // injected keys or cached event handlers. Therefore we need to always
                // check the codegenNode's props to be sure.
                const generatedPropsType = getGeneratedPropsConstantType(
                  node,
                  context
                );
                if (generatedPropsType === 0 /* NOT_CONSTANT */) {
                  constantCache.set(node, 0 /* NOT_CONSTANT */);
                  return 0 /* NOT_CONSTANT */;
                }
                if (generatedPropsType < returnType) {
                  returnType = generatedPropsType;
                }
                // 2. its children.
                for (let i = 0; i < node.children.length; i++) {
                  const childType = getConstantType(node.children[i], context);
                  if (childType === 0 /* NOT_CONSTANT */) {
                    constantCache.set(node, 0 /* NOT_CONSTANT */);
                    return 0 /* NOT_CONSTANT */;
                  }
                  if (childType < returnType) {
                    returnType = childType;
                  }
                }
                // 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0
                // type, check if any of the props can cause the type to be lowered
                // we can skip can_patch because it's guaranteed by the absence of a
                // patchFlag.
                if (returnType > 1 /* CAN_SKIP_PATCH */) {
                  for (let i = 0; i < node.props.length; i++) {
                    const p = node.props[i];
                    if (
                      p.type === 7 /* DIRECTIVE */ &&
                      p.name === 'bind' &&
                      p.exp
                    ) {
                      const expType = getConstantType(p.exp, context);
                      if (expType === 0 /* NOT_CONSTANT */) {
                        constantCache.set(node, 0 /* NOT_CONSTANT */);
                        return 0 /* NOT_CONSTANT */;
                      }
                      if (expType < returnType) {
                        returnType = expType;
                      }
                    }
                  }
                }
                // only svg/foreignObject could be block here, however if they are
                // static then they don't need to be blocks since there will be no
                // nested updates.
                if (codegenNode.isBlock) {
                  context.removeHelper(OPEN_BLOCK);
                  context.removeHelper(
                    getVNodeBlockHelper(context.inSSR, codegenNode.isComponent)
                  );
                  codegenNode.isBlock = false;
                  context.helper(
                    getVNodeHelper(context.inSSR, codegenNode.isComponent)
                  );
                }
                constantCache.set(node, returnType);
                return returnType;
              } else {
                constantCache.set(node, 0 /* NOT_CONSTANT */);
                return 0 /* NOT_CONSTANT */;
              }
            case 2 /* TEXT */:
            case 3 /* COMMENT */:
              return 3 /* CAN_STRINGIFY */;
            case 9 /* IF */:
            case 11 /* FOR */:
            case 10 /* IF_BRANCH */:
              return 0 /* NOT_CONSTANT */;
            case 5 /* INTERPOLATION */:
            case 12 /* TEXT_CALL */:
              return getConstantType(node.content, context);
            case 4 /* SIMPLE_EXPRESSION */:
              return node.constType;
            case 8 /* COMPOUND_EXPRESSION */:
              let returnType = 3; /* CAN_STRINGIFY */
              for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                if (
                  (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(
                    child
                  ) ||
                  (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(child)
                ) {
                  continue;
                }
                const childType = getConstantType(child, context);
                if (childType === 0 /* NOT_CONSTANT */) {
                  return 0 /* NOT_CONSTANT */;
                } else if (childType < returnType) {
                  returnType = childType;
                }
              }
              return returnType;
            default:
              if (true);
              return 0 /* NOT_CONSTANT */;
          }
        }
        const allowHoistedHelperSet = new Set([
          NORMALIZE_CLASS,
          NORMALIZE_STYLE,
          NORMALIZE_PROPS,
          GUARD_REACTIVE_PROPS,
        ]);
        function getConstantTypeOfHelperCall(value, context) {
          if (
            value.type === 14 /* JS_CALL_EXPRESSION */ &&
            !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(
              value.callee
            ) &&
            allowHoistedHelperSet.has(value.callee)
          ) {
            const arg = value.arguments[0];
            if (arg.type === 4 /* SIMPLE_EXPRESSION */) {
              return getConstantType(arg, context);
            } else if (arg.type === 14 /* JS_CALL_EXPRESSION */) {
              // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(exp))`
              return getConstantTypeOfHelperCall(arg, context);
            }
          }
          return 0 /* NOT_CONSTANT */;
        }
        function getGeneratedPropsConstantType(node, context) {
          let returnType = 3; /* CAN_STRINGIFY */
          const props = getNodeProps(node);
          if (props && props.type === 15 /* JS_OBJECT_EXPRESSION */) {
            const { properties } = props;
            for (let i = 0; i < properties.length; i++) {
              const { key, value } = properties[i];
              const keyType = getConstantType(key, context);
              if (keyType === 0 /* NOT_CONSTANT */) {
                return keyType;
              }
              if (keyType < returnType) {
                returnType = keyType;
              }
              let valueType;
              if (value.type === 4 /* SIMPLE_EXPRESSION */) {
                valueType = getConstantType(value, context);
              } else if (value.type === 14 /* JS_CALL_EXPRESSION */) {
                // some helper calls can be hoisted,
                // such as the `normalizeProps` generated by the compiler for pre-normalize class,
                // in this case we need to respect the ConstantType of the helper's arguments
                valueType = getConstantTypeOfHelperCall(value, context);
              } else {
                valueType = 0 /* NOT_CONSTANT */;
              }
              if (valueType === 0 /* NOT_CONSTANT */) {
                return valueType;
              }
              if (valueType < returnType) {
                returnType = valueType;
              }
            }
          }
          return returnType;
        }
        function getNodeProps(node) {
          const codegenNode = node.codegenNode;
          if (codegenNode.type === 13 /* VNODE_CALL */) {
            return codegenNode.props;
          }
        }
        function getPatchFlag(node) {
          const flag = node.patchFlag;
          return flag ? parseInt(flag, 10) : undefined;
        }

        function createTransformContext(
          root,
          {
            filename = '',
            prefixIdentifiers = false,
            hoistStatic = false,
            cacheHandlers = false,
            nodeTransforms = [],
            directiveTransforms = {},
            transformHoist = null,
            isBuiltInComponent = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP,
            isCustomElement = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP,
            expressionPlugins = [],
            scopeId = null,
            slotted = true,
            ssr = false,
            inSSR = false,
            ssrCssVars = ``,
            bindingMetadata = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJ,
            inline = false,
            isTS = false,
            onError = defaultOnError,
            onWarn = defaultOnWarn,
            compatConfig,
          }
        ) {
          const nameMatch = filename
            .replace(/\?.*$/, '')
            .match(/([^/\\]+)\.\w+$/);
          const context = {
            // options
            selfName:
              nameMatch &&
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.capitalize)(
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(
                  nameMatch[1]
                )
              ),
            prefixIdentifiers,
            hoistStatic,
            cacheHandlers,
            nodeTransforms,
            directiveTransforms,
            transformHoist,
            isBuiltInComponent,
            isCustomElement,
            expressionPlugins,
            scopeId,
            slotted,
            ssr,
            inSSR,
            ssrCssVars,
            bindingMetadata,
            inline,
            isTS,
            onError,
            onWarn,
            compatConfig,
            // state
            root,
            helpers: new Map(),
            components: new Set(),
            directives: new Set(),
            hoists: [],
            imports: [],
            constantCache: new Map(),
            temps: 0,
            cached: 0,
            identifiers: Object.create(null),
            scopes: {
              vFor: 0,
              vSlot: 0,
              vPre: 0,
              vOnce: 0,
            },
            parent: null,
            currentNode: root,
            childIndex: 0,
            inVOnce: false,
            // methods
            helper(name) {
              const count = context.helpers.get(name) || 0;
              context.helpers.set(name, count + 1);
              return name;
            },
            removeHelper(name) {
              const count = context.helpers.get(name);
              if (count) {
                const currentCount = count - 1;
                if (!currentCount) {
                  context.helpers.delete(name);
                } else {
                  context.helpers.set(name, currentCount);
                }
              }
            },
            helperString(name) {
              return `_${helperNameMap[context.helper(name)]}`;
            },
            replaceNode(node) {
              /* istanbul ignore if */
              if (true) {
                if (!context.currentNode) {
                  throw new Error(`Node being replaced is already removed.`);
                }
                if (!context.parent) {
                  throw new Error(`Cannot replace root node.`);
                }
              }
              context.parent.children[context.childIndex] =
                context.currentNode = node;
            },
            removeNode(node) {
              if (true && !context.parent) {
                throw new Error(`Cannot remove root node.`);
              }
              const list = context.parent.children;
              const removalIndex = node
                ? list.indexOf(node)
                : context.currentNode
                ? context.childIndex
                : -1;
              /* istanbul ignore if */
              if (true && removalIndex < 0) {
                throw new Error(
                  `node being removed is not a child of current parent`
                );
              }
              if (!node || node === context.currentNode) {
                // current node removed
                context.currentNode = null;
                context.onNodeRemoved();
              } else {
                // sibling node removed
                if (context.childIndex > removalIndex) {
                  context.childIndex--;
                  context.onNodeRemoved();
                }
              }
              context.parent.children.splice(removalIndex, 1);
            },
            onNodeRemoved: () => {},
            addIdentifiers(exp) {},
            removeIdentifiers(exp) {},
            hoist(exp) {
              if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(exp))
                exp = createSimpleExpression(exp);
              context.hoists.push(exp);
              const identifier = createSimpleExpression(
                `_hoisted_${context.hoists.length}`,
                false,
                exp.loc,
                2 /* CAN_HOIST */
              );
              identifier.hoisted = exp;
              return identifier;
            },
            cache(exp, isVNode = false) {
              return createCacheExpression(context.cached++, exp, isVNode);
            },
          };
          {
            context.filters = new Set();
          }
          return context;
        }
        function transform(root, options) {
          const context = createTransformContext(root, options);
          traverseNode(root, context);
          if (options.hoistStatic) {
            hoistStatic(root, context);
          }
          if (!options.ssr) {
            createRootCodegen(root, context);
          }
          // finalize meta information
          root.helpers = [...context.helpers.keys()];
          root.components = [...context.components];
          root.directives = [...context.directives];
          root.imports = context.imports;
          root.hoists = context.hoists;
          root.temps = context.temps;
          root.cached = context.cached;
          {
            root.filters = [...context.filters];
          }
        }
        function createRootCodegen(root, context) {
          const { helper } = context;
          const { children } = root;
          if (children.length === 1) {
            const child = children[0];
            // if the single child is an element, turn it into a block.
            if (isSingleElementRoot(root, child) && child.codegenNode) {
              // single element root is never hoisted so codegenNode will never be
              // SimpleExpressionNode
              const codegenNode = child.codegenNode;
              if (codegenNode.type === 13 /* VNODE_CALL */) {
                makeBlock(codegenNode, context);
              }
              root.codegenNode = codegenNode;
            } else {
              // - single <slot/>, IfNode, ForNode: already blocks.
              // - single text node: always patched.
              // root codegen falls through via genNode()
              root.codegenNode = child;
            }
          } else if (children.length > 1) {
            // root has multiple nodes - return a fragment block.
            let patchFlag = 64; /* STABLE_FRAGMENT */
            let patchFlagText =
              _vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[64];
            // check if the fragment actually contains a single valid child with
            // the rest being comments
            if (
              true &&
              children.filter((c) => c.type !== 3 /* COMMENT */).length === 1
            ) {
              patchFlag |= 2048 /* DEV_ROOT_FRAGMENT */;
              patchFlagText += `, ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[2048]}`;
            }
            root.codegenNode = createVNodeCall(
              context,
              helper(FRAGMENT),
              undefined,
              root.children,
              patchFlag + (true ? ` /* ${patchFlagText} */` : 0),
              undefined,
              undefined,
              true,
              undefined,
              false /* isComponent */
            );
          } else;
        }
        function traverseChildren(parent, context) {
          let i = 0;
          const nodeRemoved = () => {
            i--;
          };
          for (; i < parent.children.length; i++) {
            const child = parent.children[i];
            if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child))
              continue;
            context.parent = parent;
            context.childIndex = i;
            context.onNodeRemoved = nodeRemoved;
            traverseNode(child, context);
          }
        }
        function traverseNode(node, context) {
          context.currentNode = node;
          // apply transform plugins
          const { nodeTransforms } = context;
          const exitFns = [];
          for (let i = 0; i < nodeTransforms.length; i++) {
            const onExit = nodeTransforms[i](node, context);
            if (onExit) {
              if (
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(onExit)
              ) {
                exitFns.push(...onExit);
              } else {
                exitFns.push(onExit);
              }
            }
            if (!context.currentNode) {
              // node was removed
              return;
            } else {
              // node may have been replaced
              node = context.currentNode;
            }
          }
          switch (node.type) {
            case 3 /* COMMENT */:
              if (!context.ssr) {
                // inject import for the Comment symbol, which is needed for creating
                // comment nodes with `createVNode`
                context.helper(CREATE_COMMENT);
              }
              break;
            case 5 /* INTERPOLATION */:
              // no need to traverse, but we need to inject toString helper
              if (!context.ssr) {
                context.helper(TO_DISPLAY_STRING);
              }
              break;
            // for container types, further traverse downwards
            case 9 /* IF */:
              for (let i = 0; i < node.branches.length; i++) {
                traverseNode(node.branches[i], context);
              }
              break;
            case 10 /* IF_BRANCH */:
            case 11 /* FOR */:
            case 1 /* ELEMENT */:
            case 0 /* ROOT */:
              traverseChildren(node, context);
              break;
          }
          // exit transforms
          context.currentNode = node;
          let i = exitFns.length;
          while (i--) {
            exitFns[i]();
          }
        }
        function createStructuralDirectiveTransform(name, fn) {
          const matches = (0,
          _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(name)
            ? (n) => n === name
            : (n) => name.test(n);
          return (node, context) => {
            if (node.type === 1 /* ELEMENT */) {
              const { props } = node;
              // structural directive transforms are not concerned with slots
              // as they are handled separately in vSlot.ts
              if (node.tagType === 3 /* TEMPLATE */ && props.some(isVSlot)) {
                return;
              }
              const exitFns = [];
              for (let i = 0; i < props.length; i++) {
                const prop = props[i];
                if (prop.type === 7 /* DIRECTIVE */ && matches(prop.name)) {
                  // structural directives are removed to avoid infinite recursion
                  // also we remove them *before* applying so that it can further
                  // traverse itself in case it moves the node around
                  props.splice(i, 1);
                  i--;
                  const onExit = fn(node, prop, context);
                  if (onExit) exitFns.push(onExit);
                }
              }
              return exitFns;
            }
          };
        }

        const PURE_ANNOTATION = `/*#__PURE__*/`;
        function createCodegenContext(
          ast,
          {
            mode = 'function',
            prefixIdentifiers = mode === 'module',
            sourceMap = false,
            filename = `template.vue.html`,
            scopeId = null,
            optimizeImports = false,
            runtimeGlobalName = `Vue`,
            runtimeModuleName = `vue`,
            ssrRuntimeModuleName = 'vue/server-renderer',
            ssr = false,
            isTS = false,
            inSSR = false,
          }
        ) {
          const context = {
            mode,
            prefixIdentifiers,
            sourceMap,
            filename,
            scopeId,
            optimizeImports,
            runtimeGlobalName,
            runtimeModuleName,
            ssrRuntimeModuleName,
            ssr,
            isTS,
            inSSR,
            source: ast.loc.source,
            code: ``,
            column: 1,
            line: 1,
            offset: 0,
            indentLevel: 0,
            pure: false,
            map: undefined,
            helper(key) {
              return `_${helperNameMap[key]}`;
            },
            push(code, node) {
              context.code += code;
            },
            indent() {
              newline(++context.indentLevel);
            },
            deindent(withoutNewLine = false) {
              if (withoutNewLine) {
                --context.indentLevel;
              } else {
                newline(--context.indentLevel);
              }
            },
            newline() {
              newline(context.indentLevel);
            },
          };
          function newline(n) {
            context.push('\n' + `  `.repeat(n));
          }
          return context;
        }
        function generate(ast, options = {}) {
          const context = createCodegenContext(ast, options);
          if (options.onContextCreated) options.onContextCreated(context);
          const {
            mode,
            push,
            prefixIdentifiers,
            indent,
            deindent,
            newline,
            scopeId,
            ssr,
          } = context;
          const hasHelpers = ast.helpers.length > 0;
          const useWithBlock = !prefixIdentifiers && mode !== 'module';
          // preambles
          // in setup() inline mode, the preamble is generated in a sub context
          // and returned separately.
          const preambleContext = context;
          {
            genFunctionPreamble(ast, preambleContext);
          }
          // enter render function
          const functionName = ssr ? `ssrRender` : `render`;
          const args = ssr
            ? ['_ctx', '_push', '_parent', '_attrs']
            : ['_ctx', '_cache'];
          const signature = args.join(', ');
          {
            push(`function ${functionName}(${signature}) {`);
          }
          indent();
          if (useWithBlock) {
            push(`with (_ctx) {`);
            indent();
            // function mode const declarations should be inside with block
            // also they should be renamed to avoid collision with user properties
            if (hasHelpers) {
              push(
                `const { ${ast.helpers
                  .map((s) => `${helperNameMap[s]}: _${helperNameMap[s]}`)
                  .join(', ')} } = _Vue`
              );
              push(`\n`);
              newline();
            }
          }
          // generate asset resolution statements
          if (ast.components.length) {
            genAssets(ast.components, 'component', context);
            if (ast.directives.length || ast.temps > 0) {
              newline();
            }
          }
          if (ast.directives.length) {
            genAssets(ast.directives, 'directive', context);
            if (ast.temps > 0) {
              newline();
            }
          }
          if (ast.filters && ast.filters.length) {
            newline();
            genAssets(ast.filters, 'filter', context);
            newline();
          }
          if (ast.temps > 0) {
            push(`let `);
            for (let i = 0; i < ast.temps; i++) {
              push(`${i > 0 ? `, ` : ``}_temp${i}`);
            }
          }
          if (ast.components.length || ast.directives.length || ast.temps) {
            push(`\n`);
            newline();
          }
          // generate the VNode tree expression
          if (!ssr) {
            push(`return `);
          }
          if (ast.codegenNode) {
            genNode(ast.codegenNode, context);
          } else {
            push(`null`);
          }
          if (useWithBlock) {
            deindent();
            push(`}`);
          }
          deindent();
          push(`}`);
          return {
            ast,
            code: context.code,
            preamble: ``,
            // SourceMapGenerator does have toJSON() method but it's not in the types
            map: context.map ? context.map.toJSON() : undefined,
          };
        }
        function genFunctionPreamble(ast, context) {
          const {
            ssr,
            prefixIdentifiers,
            push,
            newline,
            runtimeModuleName,
            runtimeGlobalName,
            ssrRuntimeModuleName,
          } = context;
          const VueBinding = runtimeGlobalName;
          const aliasHelper = (s) =>
            `${helperNameMap[s]}: _${helperNameMap[s]}`;
          // Generate const declaration for helpers
          // In prefix mode, we place the const declaration at top so it's done
          // only once; But if we not prefixing, we place the declaration inside the
          // with block so it doesn't incur the `in` check cost for every helper access.
          if (ast.helpers.length > 0) {
            {
              // "with" mode.
              // save Vue in a separate variable to avoid collision
              push(`const _Vue = ${VueBinding}\n`);
              // in "with" mode, helpers are declared inside the with block to avoid
              // has check cost, but hoists are lifted out of the function - we need
              // to provide the helper here.
              if (ast.hoists.length) {
                const staticHelpers = [
                  CREATE_VNODE,
                  CREATE_ELEMENT_VNODE,
                  CREATE_COMMENT,
                  CREATE_TEXT,
                  CREATE_STATIC,
                ]
                  .filter((helper) => ast.helpers.includes(helper))
                  .map(aliasHelper)
                  .join(', ');
                push(`const { ${staticHelpers} } = _Vue\n`);
              }
            }
          }
          genHoists(ast.hoists, context);
          newline();
          push(`return `);
        }
        function genAssets(assets, type, { helper, push, newline, isTS }) {
          const resolver = helper(
            type === 'filter'
              ? RESOLVE_FILTER
              : type === 'component'
              ? RESOLVE_COMPONENT
              : RESOLVE_DIRECTIVE
          );
          for (let i = 0; i < assets.length; i++) {
            let id = assets[i];
            // potential component implicit self-reference inferred from SFC filename
            const maybeSelfReference = id.endsWith('__self');
            if (maybeSelfReference) {
              id = id.slice(0, -6);
            }
            push(
              `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(
                id
              )}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`
            );
            if (i < assets.length - 1) {
              newline();
            }
          }
        }
        function genHoists(hoists, context) {
          if (!hoists.length) {
            return;
          }
          context.pure = true;
          const { push, newline, helper, scopeId, mode } = context;
          newline();
          for (let i = 0; i < hoists.length; i++) {
            const exp = hoists[i];
            if (exp) {
              push(`const _hoisted_${i + 1} = ${``}`);
              genNode(exp, context);
              newline();
            }
          }
          context.pure = false;
        }
        function isText$1(n) {
          return (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(n) ||
            n.type === 4 /* SIMPLE_EXPRESSION */ ||
            n.type === 2 /* TEXT */ ||
            n.type === 5 /* INTERPOLATION */ ||
            n.type === 8 /* COMPOUND_EXPRESSION */
          );
        }
        function genNodeListAsArray(nodes, context) {
          const multilines =
            nodes.length > 3 ||
            (true &&
              nodes.some(
                (n) =>
                  (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(n) ||
                  !isText$1(n)
              ));
          context.push(`[`);
          multilines && context.indent();
          genNodeList(nodes, context, multilines);
          multilines && context.deindent();
          context.push(`]`);
        }
        function genNodeList(nodes, context, multilines = false, comma = true) {
          const { push, newline } = context;
          for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node)) {
              push(node);
            } else if (
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node)
            ) {
              genNodeListAsArray(node, context);
            } else {
              genNode(node, context);
            }
            if (i < nodes.length - 1) {
              if (multilines) {
                comma && push(',');
                newline();
              } else {
                comma && push(', ');
              }
            }
          }
        }
        function genNode(node, context) {
          if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node)) {
            context.push(node);
            return;
          }
          if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(node)) {
            context.push(context.helper(node));
            return;
          }
          switch (node.type) {
            case 1 /* ELEMENT */:
            case 9 /* IF */:
            case 11 /* FOR */:
              true &&
                assert(
                  node.codegenNode != null,
                  `Codegen node is missing for element/if/for node. ` +
                    `Apply appropriate transforms first.`
                );
              genNode(node.codegenNode, context);
              break;
            case 2 /* TEXT */:
              genText(node, context);
              break;
            case 4 /* SIMPLE_EXPRESSION */:
              genExpression(node, context);
              break;
            case 5 /* INTERPOLATION */:
              genInterpolation(node, context);
              break;
            case 12 /* TEXT_CALL */:
              genNode(node.codegenNode, context);
              break;
            case 8 /* COMPOUND_EXPRESSION */:
              genCompoundExpression(node, context);
              break;
            case 3 /* COMMENT */:
              genComment(node, context);
              break;
            case 13 /* VNODE_CALL */:
              genVNodeCall(node, context);
              break;
            case 14 /* JS_CALL_EXPRESSION */:
              genCallExpression(node, context);
              break;
            case 15 /* JS_OBJECT_EXPRESSION */:
              genObjectExpression(node, context);
              break;
            case 17 /* JS_ARRAY_EXPRESSION */:
              genArrayExpression(node, context);
              break;
            case 18 /* JS_FUNCTION_EXPRESSION */:
              genFunctionExpression(node, context);
              break;
            case 19 /* JS_CONDITIONAL_EXPRESSION */:
              genConditionalExpression(node, context);
              break;
            case 20 /* JS_CACHE_EXPRESSION */:
              genCacheExpression(node, context);
              break;
            case 21 /* JS_BLOCK_STATEMENT */:
              genNodeList(node.body, context, true, false);
              break;
            // SSR only types
            case 22 /* JS_TEMPLATE_LITERAL */:
              break;
            case 23 /* JS_IF_STATEMENT */:
              break;
            case 24 /* JS_ASSIGNMENT_EXPRESSION */:
              break;
            case 25 /* JS_SEQUENCE_EXPRESSION */:
              break;
            case 26 /* JS_RETURN_STATEMENT */:
              break;
            /* istanbul ignore next */
            case 10 /* IF_BRANCH */:
              // noop
              break;
            default:
              if (true) {
                assert(false, `unhandled codegen node type: ${node.type}`);
                // make sure we exhaust all possible types
                const exhaustiveCheck = node;
                return exhaustiveCheck;
              }
          }
        }
        function genText(node, context) {
          context.push(JSON.stringify(node.content), node);
        }
        function genExpression(node, context) {
          const { content, isStatic } = node;
          context.push(isStatic ? JSON.stringify(content) : content, node);
        }
        function genInterpolation(node, context) {
          const { push, helper, pure } = context;
          if (pure) push(PURE_ANNOTATION);
          push(`${helper(TO_DISPLAY_STRING)}(`);
          genNode(node.content, context);
          push(`)`);
        }
        function genCompoundExpression(node, context) {
          for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child)) {
              context.push(child);
            } else {
              genNode(child, context);
            }
          }
        }
        function genExpressionAsPropertyKey(node, context) {
          const { push } = context;
          if (node.type === 8 /* COMPOUND_EXPRESSION */) {
            push(`[`);
            genCompoundExpression(node, context);
            push(`]`);
          } else if (node.isStatic) {
            // only quote keys if necessary
            const text = isSimpleIdentifier(node.content)
              ? node.content
              : JSON.stringify(node.content);
            push(text, node);
          } else {
            push(`[${node.content}]`, node);
          }
        }
        function genComment(node, context) {
          const { push, helper, pure } = context;
          if (pure) {
            push(PURE_ANNOTATION);
          }
          push(
            `${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`,
            node
          );
        }
        function genVNodeCall(node, context) {
          const { push, helper, pure } = context;
          const {
            tag,
            props,
            children,
            patchFlag,
            dynamicProps,
            directives,
            isBlock,
            disableTracking,
            isComponent,
          } = node;
          if (directives) {
            push(helper(WITH_DIRECTIVES) + `(`);
          }
          if (isBlock) {
            push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
          }
          if (pure) {
            push(PURE_ANNOTATION);
          }
          const callHelper = isBlock
            ? getVNodeBlockHelper(context.inSSR, isComponent)
            : getVNodeHelper(context.inSSR, isComponent);
          push(helper(callHelper) + `(`, node);
          genNodeList(
            genNullableArgs([tag, props, children, patchFlag, dynamicProps]),
            context
          );
          push(`)`);
          if (isBlock) {
            push(`)`);
          }
          if (directives) {
            push(`, `);
            genNode(directives, context);
            push(`)`);
          }
        }
        function genNullableArgs(args) {
          let i = args.length;
          while (i--) {
            if (args[i] != null) break;
          }
          return args.slice(0, i + 1).map((arg) => arg || `null`);
        }
        // JavaScript
        function genCallExpression(node, context) {
          const { push, helper, pure } = context;
          const callee = (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(
            node.callee
          )
            ? node.callee
            : helper(node.callee);
          if (pure) {
            push(PURE_ANNOTATION);
          }
          push(callee + `(`, node);
          genNodeList(node.arguments, context);
          push(`)`);
        }
        function genObjectExpression(node, context) {
          const { push, indent, deindent, newline } = context;
          const { properties } = node;
          if (!properties.length) {
            push(`{}`, node);
            return;
          }
          const multilines =
            properties.length > 1 ||
            (true &&
              properties.some(
                (p) => p.value.type !== 4 /* SIMPLE_EXPRESSION */
              ));
          push(multilines ? `{` : `{ `);
          multilines && indent();
          for (let i = 0; i < properties.length; i++) {
            const { key, value } = properties[i];
            // key
            genExpressionAsPropertyKey(key, context);
            push(`: `);
            // value
            genNode(value, context);
            if (i < properties.length - 1) {
              // will only reach this if it's multilines
              push(`,`);
              newline();
            }
          }
          multilines && deindent();
          push(multilines ? `}` : ` }`);
        }
        function genArrayExpression(node, context) {
          genNodeListAsArray(node.elements, context);
        }
        function genFunctionExpression(node, context) {
          const { push, indent, deindent } = context;
          const { params, returns, body, newline, isSlot } = node;
          if (isSlot) {
            // wrap slot functions with owner context
            push(`_${helperNameMap[WITH_CTX]}(`);
          }
          push(`(`, node);
          if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(params)) {
            genNodeList(params, context);
          } else if (params) {
            genNode(params, context);
          }
          push(`) => `);
          if (newline || body) {
            push(`{`);
            indent();
          }
          if (returns) {
            if (newline) {
              push(`return `);
            }
            if (
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(returns)
            ) {
              genNodeListAsArray(returns, context);
            } else {
              genNode(returns, context);
            }
          } else if (body) {
            genNode(body, context);
          }
          if (newline || body) {
            deindent();
            push(`}`);
          }
          if (isSlot) {
            if (node.isNonScopedSlot) {
              push(`, undefined, true`);
            }
            push(`)`);
          }
        }
        function genConditionalExpression(node, context) {
          const { test, consequent, alternate, newline: needNewline } = node;
          const { push, indent, deindent, newline } = context;
          if (test.type === 4 /* SIMPLE_EXPRESSION */) {
            const needsParens = !isSimpleIdentifier(test.content);
            needsParens && push(`(`);
            genExpression(test, context);
            needsParens && push(`)`);
          } else {
            push(`(`);
            genNode(test, context);
            push(`)`);
          }
          needNewline && indent();
          context.indentLevel++;
          needNewline || push(` `);
          push(`? `);
          genNode(consequent, context);
          context.indentLevel--;
          needNewline && newline();
          needNewline || push(` `);
          push(`: `);
          const isNested =
            alternate.type === 19; /* JS_CONDITIONAL_EXPRESSION */
          if (!isNested) {
            context.indentLevel++;
          }
          genNode(alternate, context);
          if (!isNested) {
            context.indentLevel--;
          }
          needNewline && deindent(true /* without newline */);
        }
        function genCacheExpression(node, context) {
          const { push, helper, indent, deindent, newline } = context;
          push(`_cache[${node.index}] || (`);
          if (node.isVNode) {
            indent();
            push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
            newline();
          }
          push(`_cache[${node.index}] = `);
          genNode(node.value, context);
          if (node.isVNode) {
            push(`,`);
            newline();
            push(`${helper(SET_BLOCK_TRACKING)}(1),`);
            newline();
            push(`_cache[${node.index}]`);
            deindent();
          }
          push(`)`);
        }

        function walkIdentifiers(
          root,
          onIdentifier,
          includeAll = false,
          parentStack = [],
          knownIds = Object.create(null)
        ) {
          {
            return;
          }
        }
        function isReferencedIdentifier(id, parent, parentStack) {
          {
            return false;
          }
        }
        function isInDestructureAssignment(parent, parentStack) {
          if (
            parent &&
            (parent.type === 'ObjectProperty' || parent.type === 'ArrayPattern')
          ) {
            let i = parentStack.length;
            while (i--) {
              const p = parentStack[i];
              if (p.type === 'AssignmentExpression') {
                return true;
              } else if (
                p.type !== 'ObjectProperty' &&
                !p.type.endsWith('Pattern')
              ) {
                break;
              }
            }
          }
          return false;
        }
        function walkFunctionParams(node, onIdent) {
          for (const p of node.params) {
            for (const id of extractIdentifiers(p)) {
              onIdent(id);
            }
          }
        }
        function walkBlockDeclarations(block, onIdent) {
          for (const stmt of block.body) {
            if (stmt.type === 'VariableDeclaration') {
              if (stmt.declare) continue;
              for (const decl of stmt.declarations) {
                for (const id of extractIdentifiers(decl.id)) {
                  onIdent(id);
                }
              }
            } else if (
              stmt.type === 'FunctionDeclaration' ||
              stmt.type === 'ClassDeclaration'
            ) {
              if (stmt.declare || !stmt.id) continue;
              onIdent(stmt.id);
            }
          }
        }
        function extractIdentifiers(param, nodes = []) {
          switch (param.type) {
            case 'Identifier':
              nodes.push(param);
              break;
            case 'MemberExpression':
              let object = param;
              while (object.type === 'MemberExpression') {
                object = object.object;
              }
              nodes.push(object);
              break;
            case 'ObjectPattern':
              for (const prop of param.properties) {
                if (prop.type === 'RestElement') {
                  extractIdentifiers(prop.argument, nodes);
                } else {
                  extractIdentifiers(prop.value, nodes);
                }
              }
              break;
            case 'ArrayPattern':
              param.elements.forEach((element) => {
                if (element) extractIdentifiers(element, nodes);
              });
              break;
            case 'RestElement':
              extractIdentifiers(param.argument, nodes);
              break;
            case 'AssignmentPattern':
              extractIdentifiers(param.left, nodes);
              break;
          }
          return nodes;
        }
        const isFunctionType = (node) => {
          return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
        };
        const isStaticProperty = (node) =>
          node &&
          (node.type === 'ObjectProperty' || node.type === 'ObjectMethod') &&
          !node.computed;
        const isStaticPropertyKey = (node, parent) =>
          isStaticProperty(parent) && parent.key === node;

        // these keywords should not appear inside expressions, but operators like
        // typeof, instanceof and in are allowed
        const prohibitedKeywordRE = new RegExp(
          '\\b' +
            (
              'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
              'super,throw,while,yield,delete,export,import,return,switch,default,' +
              'extends,finally,continue,debugger,function,arguments,typeof,void'
            )
              .split(',')
              .join('\\b|\\b') +
            '\\b'
        );
        // strip strings in expressions
        const stripStringRE =
          /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
        /**
         * Validate a non-prefixed expression.
         * This is only called when using the in-browser runtime compiler since it
         * doesn't prefix expressions.
         */
        function validateBrowserExpression(
          node,
          context,
          asParams = false,
          asRawStatements = false
        ) {
          const exp = node.content;
          // empty expressions are validated per-directive since some directives
          // do allow empty expressions.
          if (!exp.trim()) {
            return;
          }
          try {
            new Function(
              asRawStatements
                ? ` ${exp} `
                : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`
            );
          } catch (e) {
            let message = e.message;
            const keywordMatch = exp
              .replace(stripStringRE, '')
              .match(prohibitedKeywordRE);
            if (keywordMatch) {
              message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
            }
            context.onError(
              createCompilerError(
                44 /* X_INVALID_EXPRESSION */,
                node.loc,
                undefined,
                message
              )
            );
          }
        }

        const transformExpression = (node, context) => {
          if (node.type === 5 /* INTERPOLATION */) {
            node.content = processExpression(node.content, context);
          } else if (node.type === 1 /* ELEMENT */) {
            // handle directives on element
            for (let i = 0; i < node.props.length; i++) {
              const dir = node.props[i];
              // do not process for v-on & v-for since they are special handled
              if (dir.type === 7 /* DIRECTIVE */ && dir.name !== 'for') {
                const exp = dir.exp;
                const arg = dir.arg;
                // do not process exp if this is v-on:arg - we need special handling
                // for wrapping inline statements.
                if (
                  exp &&
                  exp.type === 4 /* SIMPLE_EXPRESSION */ &&
                  !(dir.name === 'on' && arg)
                ) {
                  dir.exp = processExpression(
                    exp,
                    context,
                    // slot args must be processed as function params
                    dir.name === 'slot'
                  );
                }
                if (
                  arg &&
                  arg.type === 4 /* SIMPLE_EXPRESSION */ &&
                  !arg.isStatic
                ) {
                  dir.arg = processExpression(arg, context);
                }
              }
            }
          }
        };
        // Important: since this function uses Node.js only dependencies, it should
        // always be used with a leading !true check so that it can be
        // tree-shaken from the browser build.
        function processExpression(
          node,
          context,
          // some expressions like v-slot props & v-for aliases should be parsed as
          // function params
          asParams = false,
          // v-on handler values may contain multiple statements
          asRawStatements = false,
          localVars = Object.create(context.identifiers)
        ) {
          {
            if (true) {
              // simple in-browser validation (same logic in 2.x)
              validateBrowserExpression(
                node,
                context,
                asParams,
                asRawStatements
              );
            }
            return node;
          }
        }

        const transformIf = createStructuralDirectiveTransform(
          /^(if|else|else-if)$/,
          (node, dir, context) => {
            return processIf(node, dir, context, (ifNode, branch, isRoot) => {
              // #1587: We need to dynamically increment the key based on the current
              // node's sibling nodes, since chained v-if/else branches are
              // rendered at the same depth
              const siblings = context.parent.children;
              let i = siblings.indexOf(ifNode);
              let key = 0;
              while (i-- >= 0) {
                const sibling = siblings[i];
                if (sibling && sibling.type === 9 /* IF */) {
                  key += sibling.branches.length;
                }
              }
              // Exit callback. Complete the codegenNode when all children have been
              // transformed.
              return () => {
                if (isRoot) {
                  ifNode.codegenNode = createCodegenNodeForBranch(
                    branch,
                    key,
                    context
                  );
                } else {
                  // attach this branch's codegen node to the v-if root.
                  const parentCondition = getParentCondition(
                    ifNode.codegenNode
                  );
                  parentCondition.alternate = createCodegenNodeForBranch(
                    branch,
                    key + ifNode.branches.length - 1,
                    context
                  );
                }
              };
            });
          }
        );
        // target-agnostic transform used for both Client and SSR
        function processIf(node, dir, context, processCodegen) {
          if (dir.name !== 'else' && (!dir.exp || !dir.exp.content.trim())) {
            const loc = dir.exp ? dir.exp.loc : node.loc;
            context.onError(
              createCompilerError(28 /* X_V_IF_NO_EXPRESSION */, dir.loc)
            );
            dir.exp = createSimpleExpression(`true`, false, loc);
          }
          if (true && dir.exp) {
            validateBrowserExpression(dir.exp, context);
          }
          if (dir.name === 'if') {
            const branch = createIfBranch(node, dir);
            const ifNode = {
              type: 9 /* IF */,
              loc: node.loc,
              branches: [branch],
            };
            context.replaceNode(ifNode);
            if (processCodegen) {
              return processCodegen(ifNode, branch, true);
            }
          } else {
            // locate the adjacent v-if
            const siblings = context.parent.children;
            const comments = [];
            let i = siblings.indexOf(node);
            while (i-- >= -1) {
              const sibling = siblings[i];
              if (true && sibling && sibling.type === 3 /* COMMENT */) {
                context.removeNode(sibling);
                comments.unshift(sibling);
                continue;
              }
              if (
                sibling &&
                sibling.type === 2 /* TEXT */ &&
                !sibling.content.trim().length
              ) {
                context.removeNode(sibling);
                continue;
              }
              if (sibling && sibling.type === 9 /* IF */) {
                // Check if v-else was followed by v-else-if
                if (
                  dir.name === 'else-if' &&
                  sibling.branches[sibling.branches.length - 1].condition ===
                    undefined
                ) {
                  context.onError(
                    createCompilerError(
                      30 /* X_V_ELSE_NO_ADJACENT_IF */,
                      node.loc
                    )
                  );
                }
                // move the node to the if node's branches
                context.removeNode();
                const branch = createIfBranch(node, dir);
                if (
                  true &&
                  comments.length &&
                  // #3619 ignore comments if the v-if is direct child of <transition>
                  !(
                    context.parent &&
                    context.parent.type === 1 /* ELEMENT */ &&
                    isBuiltInType(context.parent.tag, 'transition')
                  )
                ) {
                  branch.children = [...comments, ...branch.children];
                }
                // check if user is forcing same key on different branches
                if (true) {
                  const key = branch.userKey;
                  if (key) {
                    sibling.branches.forEach(({ userKey }) => {
                      if (isSameKey(userKey, key)) {
                        context.onError(
                          createCompilerError(
                            29 /* X_V_IF_SAME_KEY */,
                            branch.userKey.loc
                          )
                        );
                      }
                    });
                  }
                }
                sibling.branches.push(branch);
                const onExit =
                  processCodegen && processCodegen(sibling, branch, false);
                // since the branch was removed, it will not be traversed.
                // make sure to traverse here.
                traverseNode(branch, context);
                // call on exit
                if (onExit) onExit();
                // make sure to reset currentNode after traversal to indicate this
                // node has been removed.
                context.currentNode = null;
              } else {
                context.onError(
                  createCompilerError(
                    30 /* X_V_ELSE_NO_ADJACENT_IF */,
                    node.loc
                  )
                );
              }
              break;
            }
          }
        }
        function createIfBranch(node, dir) {
          return {
            type: 10 /* IF_BRANCH */,
            loc: node.loc,
            condition: dir.name === 'else' ? undefined : dir.exp,
            children:
              node.tagType === 3 /* TEMPLATE */ && !findDir(node, 'for')
                ? node.children
                : [node],
            userKey: findProp(node, `key`),
          };
        }
        function createCodegenNodeForBranch(branch, keyIndex, context) {
          if (branch.condition) {
            return createConditionalExpression(
              branch.condition,
              createChildrenCodegenNode(branch, keyIndex, context),
              // make sure to pass in asBlock: true so that the comment node call
              // closes the current block.
              createCallExpression(context.helper(CREATE_COMMENT), [
                true ? '"v-if"' : 0,
                'true',
              ])
            );
          } else {
            return createChildrenCodegenNode(branch, keyIndex, context);
          }
        }
        function createChildrenCodegenNode(branch, keyIndex, context) {
          const { helper } = context;
          const keyProperty = createObjectProperty(
            `key`,
            createSimpleExpression(
              `${keyIndex}`,
              false,
              locStub,
              2 /* CAN_HOIST */
            )
          );
          const { children } = branch;
          const firstChild = children[0];
          const needFragmentWrapper =
            children.length !== 1 || firstChild.type !== 1; /* ELEMENT */
          if (needFragmentWrapper) {
            if (children.length === 1 && firstChild.type === 11 /* FOR */) {
              // optimize away nested fragments when child is a ForNode
              const vnodeCall = firstChild.codegenNode;
              injectProp(vnodeCall, keyProperty, context);
              return vnodeCall;
            } else {
              let patchFlag = 64; /* STABLE_FRAGMENT */
              let patchFlagText =
                _vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[64];
              // check if the fragment actually contains a single valid child with
              // the rest being comments
              if (
                true &&
                children.filter((c) => c.type !== 3 /* COMMENT */).length === 1
              ) {
                patchFlag |= 2048 /* DEV_ROOT_FRAGMENT */;
                patchFlagText += `, ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[2048]}`;
              }
              return createVNodeCall(
                context,
                helper(FRAGMENT),
                createObjectExpression([keyProperty]),
                children,
                patchFlag + (true ? ` /* ${patchFlagText} */` : 0),
                undefined,
                undefined,
                true,
                false,
                false /* isComponent */,
                branch.loc
              );
            }
          } else {
            const ret = firstChild.codegenNode;
            const vnodeCall = getMemoedVNodeCall(ret);
            // Change createVNode to createBlock.
            if (vnodeCall.type === 13 /* VNODE_CALL */) {
              makeBlock(vnodeCall, context);
            }
            // inject branch key
            injectProp(vnodeCall, keyProperty, context);
            return ret;
          }
        }
        function isSameKey(a, b) {
          if (!a || a.type !== b.type) {
            return false;
          }
          if (a.type === 6 /* ATTRIBUTE */) {
            if (a.value.content !== b.value.content) {
              return false;
            }
          } else {
            // directive
            const exp = a.exp;
            const branchExp = b.exp;
            if (exp.type !== branchExp.type) {
              return false;
            }
            if (
              exp.type !== 4 /* SIMPLE_EXPRESSION */ ||
              exp.isStatic !== branchExp.isStatic ||
              exp.content !== branchExp.content
            ) {
              return false;
            }
          }
          return true;
        }
        function getParentCondition(node) {
          while (true) {
            if (node.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {
              if (node.alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {
                node = node.alternate;
              } else {
                return node;
              }
            } else if (node.type === 20 /* JS_CACHE_EXPRESSION */) {
              node = node.value;
            }
          }
        }

        const transformFor = createStructuralDirectiveTransform(
          'for',
          (node, dir, context) => {
            const { helper, removeHelper } = context;
            return processFor(node, dir, context, (forNode) => {
              // create the loop render function expression now, and add the
              // iterator on exit after all children have been traversed
              const renderExp = createCallExpression(helper(RENDER_LIST), [
                forNode.source,
              ]);
              const isTemplate = isTemplateNode(node);
              const memo = findDir(node, 'memo');
              const keyProp = findProp(node, `key`);
              const keyExp =
                keyProp &&
                (keyProp.type === 6 /* ATTRIBUTE */
                  ? createSimpleExpression(keyProp.value.content, true)
                  : keyProp.exp);
              const keyProperty = keyProp
                ? createObjectProperty(`key`, keyExp)
                : null;
              const isStableFragment =
                forNode.source.type === 4 /* SIMPLE_EXPRESSION */ &&
                forNode.source.constType > 0; /* NOT_CONSTANT */
              const fragmentFlag = isStableFragment
                ? 64 /* STABLE_FRAGMENT */
                : keyProp
                ? 128 /* KEYED_FRAGMENT */
                : 256; /* UNKEYED_FRAGMENT */
              forNode.codegenNode = createVNodeCall(
                context,
                helper(FRAGMENT),
                undefined,
                renderExp,
                fragmentFlag +
                  (true
                    ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[fragmentFlag]} */`
                    : 0),
                undefined,
                undefined,
                true /* isBlock */,
                !isStableFragment /* disableTracking */,
                false /* isComponent */,
                node.loc
              );
              return () => {
                // finish the codegen now that all children have been traversed
                let childBlock;
                const { children } = forNode;
                // check <template v-for> key placement
                if (true && isTemplate) {
                  node.children.some((c) => {
                    if (c.type === 1 /* ELEMENT */) {
                      const key = findProp(c, 'key');
                      if (key) {
                        context.onError(
                          createCompilerError(
                            33 /* X_V_FOR_TEMPLATE_KEY_PLACEMENT */,
                            key.loc
                          )
                        );
                        return true;
                      }
                    }
                  });
                }
                const needFragmentWrapper =
                  children.length !== 1 || children[0].type !== 1; /* ELEMENT */
                const slotOutlet = isSlotOutlet(node)
                  ? node
                  : isTemplate &&
                    node.children.length === 1 &&
                    isSlotOutlet(node.children[0])
                  ? node.children[0] // api-extractor somehow fails to infer this
                  : null;
                if (slotOutlet) {
                  // <slot v-for="..."> or <template v-for="..."><slot/></template>
                  childBlock = slotOutlet.codegenNode;
                  if (isTemplate && keyProperty) {
                    // <template v-for="..." :key="..."><slot/></template>
                    // we need to inject the key to the renderSlot() call.
                    // the props for renderSlot is passed as the 3rd argument.
                    injectProp(childBlock, keyProperty, context);
                  }
                } else if (needFragmentWrapper) {
                  // <template v-for="..."> with text or multi-elements
                  // should generate a fragment block for each loop
                  childBlock = createVNodeCall(
                    context,
                    helper(FRAGMENT),
                    keyProperty
                      ? createObjectExpression([keyProperty])
                      : undefined,
                    node.children,
                    64 /* STABLE_FRAGMENT */ +
                      (true
                        ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[64]} */`
                        : 0),
                    undefined,
                    undefined,
                    true,
                    undefined,
                    false /* isComponent */
                  );
                } else {
                  // Normal element v-for. Directly use the child's codegenNode
                  // but mark it as a block.
                  childBlock = children[0].codegenNode;
                  if (isTemplate && keyProperty) {
                    injectProp(childBlock, keyProperty, context);
                  }
                  if (childBlock.isBlock !== !isStableFragment) {
                    if (childBlock.isBlock) {
                      // switch from block to vnode
                      removeHelper(OPEN_BLOCK);
                      removeHelper(
                        getVNodeBlockHelper(
                          context.inSSR,
                          childBlock.isComponent
                        )
                      );
                    } else {
                      // switch from vnode to block
                      removeHelper(
                        getVNodeHelper(context.inSSR, childBlock.isComponent)
                      );
                    }
                  }
                  childBlock.isBlock = !isStableFragment;
                  if (childBlock.isBlock) {
                    helper(OPEN_BLOCK);
                    helper(
                      getVNodeBlockHelper(context.inSSR, childBlock.isComponent)
                    );
                  } else {
                    helper(
                      getVNodeHelper(context.inSSR, childBlock.isComponent)
                    );
                  }
                }
                if (memo) {
                  const loop = createFunctionExpression(
                    createForLoopParams(forNode.parseResult, [
                      createSimpleExpression(`_cached`),
                    ])
                  );
                  loop.body = createBlockStatement([
                    createCompoundExpression([
                      `const _memo = (`,
                      memo.exp,
                      `)`,
                    ]),
                    createCompoundExpression([
                      `if (_cached`,
                      ...(keyExp ? [` && _cached.key === `, keyExp] : []),
                      ` && ${context.helperString(
                        IS_MEMO_SAME
                      )}(_cached, _memo)) return _cached`,
                    ]),
                    createCompoundExpression([`const _item = `, childBlock]),
                    createSimpleExpression(`_item.memo = _memo`),
                    createSimpleExpression(`return _item`),
                  ]);
                  renderExp.arguments.push(
                    loop,
                    createSimpleExpression(`_cache`),
                    createSimpleExpression(String(context.cached++))
                  );
                } else {
                  renderExp.arguments.push(
                    createFunctionExpression(
                      createForLoopParams(forNode.parseResult),
                      childBlock,
                      true /* force newline */
                    )
                  );
                }
              };
            });
          }
        );
        // target-agnostic transform used for both Client and SSR
        function processFor(node, dir, context, processCodegen) {
          if (!dir.exp) {
            context.onError(
              createCompilerError(31 /* X_V_FOR_NO_EXPRESSION */, dir.loc)
            );
            return;
          }
          const parseResult = parseForExpression(
            // can only be simple expression because vFor transform is applied
            // before expression transform.
            dir.exp,
            context
          );
          if (!parseResult) {
            context.onError(
              createCompilerError(
                32 /* X_V_FOR_MALFORMED_EXPRESSION */,
                dir.loc
              )
            );
            return;
          }
          const { addIdentifiers, removeIdentifiers, scopes } = context;
          const { source, value, key, index } = parseResult;
          const forNode = {
            type: 11 /* FOR */,
            loc: dir.loc,
            source,
            valueAlias: value,
            keyAlias: key,
            objectIndexAlias: index,
            parseResult,
            children: isTemplateNode(node) ? node.children : [node],
          };
          context.replaceNode(forNode);
          // bookkeeping
          scopes.vFor++;
          const onExit = processCodegen && processCodegen(forNode);
          return () => {
            scopes.vFor--;
            if (onExit) onExit();
          };
        }
        const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
        // This regex doesn't cover the case if key or index aliases have destructuring,
        // but those do not make sense in the first place, so this works in practice.
        const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
        const stripParensRE = /^\(|\)$/g;
        function parseForExpression(input, context) {
          const loc = input.loc;
          const exp = input.content;
          const inMatch = exp.match(forAliasRE);
          if (!inMatch) return;
          const [, LHS, RHS] = inMatch;
          const result = {
            source: createAliasExpression(
              loc,
              RHS.trim(),
              exp.indexOf(RHS, LHS.length)
            ),
            value: undefined,
            key: undefined,
            index: undefined,
          };
          if (true) {
            validateBrowserExpression(result.source, context);
          }
          let valueContent = LHS.trim().replace(stripParensRE, '').trim();
          const trimmedOffset = LHS.indexOf(valueContent);
          const iteratorMatch = valueContent.match(forIteratorRE);
          if (iteratorMatch) {
            valueContent = valueContent.replace(forIteratorRE, '').trim();
            const keyContent = iteratorMatch[1].trim();
            let keyOffset;
            if (keyContent) {
              keyOffset = exp.indexOf(
                keyContent,
                trimmedOffset + valueContent.length
              );
              result.key = createAliasExpression(loc, keyContent, keyOffset);
              if (true) {
                validateBrowserExpression(result.key, context, true);
              }
            }
            if (iteratorMatch[2]) {
              const indexContent = iteratorMatch[2].trim();
              if (indexContent) {
                result.index = createAliasExpression(
                  loc,
                  indexContent,
                  exp.indexOf(
                    indexContent,
                    result.key
                      ? keyOffset + keyContent.length
                      : trimmedOffset + valueContent.length
                  )
                );
                if (true) {
                  validateBrowserExpression(result.index, context, true);
                }
              }
            }
          }
          if (valueContent) {
            result.value = createAliasExpression(
              loc,
              valueContent,
              trimmedOffset
            );
            if (true) {
              validateBrowserExpression(result.value, context, true);
            }
          }
          return result;
        }
        function createAliasExpression(range, content, offset) {
          return createSimpleExpression(
            content,
            false,
            getInnerRange(range, offset, content.length)
          );
        }
        function createForLoopParams({ value, key, index }, memoArgs = []) {
          return createParamsList([value, key, index, ...memoArgs]);
        }
        function createParamsList(args) {
          let i = args.length;
          while (i--) {
            if (args[i]) break;
          }
          return args
            .slice(0, i + 1)
            .map(
              (arg, i) =>
                arg || createSimpleExpression(`_`.repeat(i + 1), false)
            );
        }

        const defaultFallback = createSimpleExpression(`undefined`, false);
        // A NodeTransform that:
        // 1. Tracks scope identifiers for scoped slots so that they don't get prefixed
        //    by transformExpression. This is only applied in non-browser builds with
        //    { prefixIdentifiers: true }.
        // 2. Track v-slot depths so that we know a slot is inside another slot.
        //    Note the exit callback is executed before buildSlots() on the same node,
        //    so only nested slots see positive numbers.
        const trackSlotScopes = (node, context) => {
          if (
            node.type === 1 /* ELEMENT */ &&
            (node.tagType === 1 /* COMPONENT */ ||
              node.tagType === 3) /* TEMPLATE */
          ) {
            // We are only checking non-empty v-slot here
            // since we only care about slots that introduce scope variables.
            const vSlot = findDir(node, 'slot');
            if (vSlot) {
              vSlot.exp;
              context.scopes.vSlot++;
              return () => {
                context.scopes.vSlot--;
              };
            }
          }
        };
        // A NodeTransform that tracks scope identifiers for scoped slots with v-for.
        // This transform is only applied in non-browser builds with { prefixIdentifiers: true }
        const trackVForSlotScopes = (node, context) => {
          let vFor;
          if (
            isTemplateNode(node) &&
            node.props.some(isVSlot) &&
            (vFor = findDir(node, 'for'))
          ) {
            const result = (vFor.parseResult = parseForExpression(
              vFor.exp,
              context
            ));
            if (result) {
              const { value, key, index } = result;
              const { addIdentifiers, removeIdentifiers } = context;
              value && addIdentifiers(value);
              key && addIdentifiers(key);
              index && addIdentifiers(index);
              return () => {
                value && removeIdentifiers(value);
                key && removeIdentifiers(key);
                index && removeIdentifiers(index);
              };
            }
          }
        };
        const buildClientSlotFn = (props, children, loc) =>
          createFunctionExpression(
            props,
            children,
            false /* newline */,
            true /* isSlot */,
            children.length ? children[0].loc : loc
          );
        // Instead of being a DirectiveTransform, v-slot processing is called during
        // transformElement to build the slots object for a component.
        function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
          context.helper(WITH_CTX);
          const { children, loc } = node;
          const slotsProperties = [];
          const dynamicSlots = [];
          // If the slot is inside a v-for or another v-slot, force it to be dynamic
          // since it likely uses a scope variable.
          let hasDynamicSlots =
            context.scopes.vSlot > 0 || context.scopes.vFor > 0;
          // 1. Check for slot with slotProps on component itself.
          //    <Comp v-slot="{ prop }"/>
          const onComponentSlot = findDir(node, 'slot', true);
          if (onComponentSlot) {
            const { arg, exp } = onComponentSlot;
            if (arg && !isStaticExp(arg)) {
              hasDynamicSlots = true;
            }
            slotsProperties.push(
              createObjectProperty(
                arg || createSimpleExpression('default', true),
                buildSlotFn(exp, children, loc)
              )
            );
          }
          // 2. Iterate through children and check for template slots
          //    <template v-slot:foo="{ prop }">
          let hasTemplateSlots = false;
          let hasNamedDefaultSlot = false;
          const implicitDefaultChildren = [];
          const seenSlotNames = new Set();
          for (let i = 0; i < children.length; i++) {
            const slotElement = children[i];
            let slotDir;
            if (
              !isTemplateNode(slotElement) ||
              !(slotDir = findDir(slotElement, 'slot', true))
            ) {
              // not a <template v-slot>, skip.
              if (slotElement.type !== 3 /* COMMENT */) {
                implicitDefaultChildren.push(slotElement);
              }
              continue;
            }
            if (onComponentSlot) {
              // already has on-component slot - this is incorrect usage.
              context.onError(
                createCompilerError(
                  37 /* X_V_SLOT_MIXED_SLOT_USAGE */,
                  slotDir.loc
                )
              );
              break;
            }
            hasTemplateSlots = true;
            const { children: slotChildren, loc: slotLoc } = slotElement;
            const {
              arg: slotName = createSimpleExpression(`default`, true),
              exp: slotProps,
              loc: dirLoc,
            } = slotDir;
            // check if name is dynamic.
            let staticSlotName;
            if (isStaticExp(slotName)) {
              staticSlotName = slotName ? slotName.content : `default`;
            } else {
              hasDynamicSlots = true;
            }
            const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);
            // check if this slot is conditional (v-if/v-for)
            let vIf;
            let vElse;
            let vFor;
            if ((vIf = findDir(slotElement, 'if'))) {
              hasDynamicSlots = true;
              dynamicSlots.push(
                createConditionalExpression(
                  vIf.exp,
                  buildDynamicSlot(slotName, slotFunction),
                  defaultFallback
                )
              );
            } else if (
              (vElse = findDir(
                slotElement,
                /^else(-if)?$/,
                true /* allowEmpty */
              ))
            ) {
              // find adjacent v-if
              let j = i;
              let prev;
              while (j--) {
                prev = children[j];
                if (prev.type !== 3 /* COMMENT */) {
                  break;
                }
              }
              if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {
                // remove node
                children.splice(i, 1);
                i--;
                // attach this slot to previous conditional
                let conditional = dynamicSlots[dynamicSlots.length - 1];
                while (
                  conditional.alternate.type ===
                  19 /* JS_CONDITIONAL_EXPRESSION */
                ) {
                  conditional = conditional.alternate;
                }
                conditional.alternate = vElse.exp
                  ? createConditionalExpression(
                      vElse.exp,
                      buildDynamicSlot(slotName, slotFunction),
                      defaultFallback
                    )
                  : buildDynamicSlot(slotName, slotFunction);
              } else {
                context.onError(
                  createCompilerError(
                    30 /* X_V_ELSE_NO_ADJACENT_IF */,
                    vElse.loc
                  )
                );
              }
            } else if ((vFor = findDir(slotElement, 'for'))) {
              hasDynamicSlots = true;
              const parseResult =
                vFor.parseResult || parseForExpression(vFor.exp, context);
              if (parseResult) {
                // Render the dynamic slots as an array and add it to the createSlot()
                // args. The runtime knows how to handle it appropriately.
                dynamicSlots.push(
                  createCallExpression(context.helper(RENDER_LIST), [
                    parseResult.source,
                    createFunctionExpression(
                      createForLoopParams(parseResult),
                      buildDynamicSlot(slotName, slotFunction),
                      true /* force newline */
                    ),
                  ])
                );
              } else {
                context.onError(
                  createCompilerError(
                    32 /* X_V_FOR_MALFORMED_EXPRESSION */,
                    vFor.loc
                  )
                );
              }
            } else {
              // check duplicate static names
              if (staticSlotName) {
                if (seenSlotNames.has(staticSlotName)) {
                  context.onError(
                    createCompilerError(
                      38 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */,
                      dirLoc
                    )
                  );
                  continue;
                }
                seenSlotNames.add(staticSlotName);
                if (staticSlotName === 'default') {
                  hasNamedDefaultSlot = true;
                }
              }
              slotsProperties.push(
                createObjectProperty(slotName, slotFunction)
              );
            }
          }
          if (!onComponentSlot) {
            const buildDefaultSlotProperty = (props, children) => {
              const fn = buildSlotFn(props, children, loc);
              if (context.compatConfig) {
                fn.isNonScopedSlot = true;
              }
              return createObjectProperty(`default`, fn);
            };
            if (!hasTemplateSlots) {
              // implicit default slot (on component)
              slotsProperties.push(
                buildDefaultSlotProperty(undefined, children)
              );
            } else if (
              implicitDefaultChildren.length &&
              // #3766
              // with whitespace: 'preserve', whitespaces between slots will end up in
              // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
              implicitDefaultChildren.some((node) =>
                isNonWhitespaceContent(node)
              )
            ) {
              // implicit default slot (mixed with named slots)
              if (hasNamedDefaultSlot) {
                context.onError(
                  createCompilerError(
                    39 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */,
                    implicitDefaultChildren[0].loc
                  )
                );
              } else {
                slotsProperties.push(
                  buildDefaultSlotProperty(undefined, implicitDefaultChildren)
                );
              }
            }
          }
          const slotFlag = hasDynamicSlots
            ? 2 /* DYNAMIC */
            : hasForwardedSlots(node.children)
            ? 3 /* FORWARDED */
            : 1; /* STABLE */
          let slots = createObjectExpression(
            slotsProperties.concat(
              createObjectProperty(
                `_`,
                // 2 = compiled but dynamic = can skip normalization, but must run diff
                // 1 = compiled and static = can skip normalization AND diff as optimized
                createSimpleExpression(
                  slotFlag +
                    (true
                      ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.slotFlagsText[slotFlag]} */`
                      : 0),
                  false
                )
              )
            ),
            loc
          );
          if (dynamicSlots.length) {
            slots = createCallExpression(context.helper(CREATE_SLOTS), [
              slots,
              createArrayExpression(dynamicSlots),
            ]);
          }
          return {
            slots,
            hasDynamicSlots,
          };
        }
        function buildDynamicSlot(name, fn) {
          return createObjectExpression([
            createObjectProperty(`name`, name),
            createObjectProperty(`fn`, fn),
          ]);
        }
        function hasForwardedSlots(children) {
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            switch (child.type) {
              case 1 /* ELEMENT */:
                if (
                  child.tagType === 2 /* SLOT */ ||
                  hasForwardedSlots(child.children)
                ) {
                  return true;
                }
                break;
              case 9 /* IF */:
                if (hasForwardedSlots(child.branches)) return true;
                break;
              case 10 /* IF_BRANCH */:
              case 11 /* FOR */:
                if (hasForwardedSlots(child.children)) return true;
                break;
            }
          }
          return false;
        }
        function isNonWhitespaceContent(node) {
          if (node.type !== 2 /* TEXT */ && node.type !== 12 /* TEXT_CALL */)
            return true;
          return node.type === 2 /* TEXT */
            ? !!node.content.trim()
            : isNonWhitespaceContent(node.content);
        }

        // some directive transforms (e.g. v-model) may return a symbol for runtime
        // import, which should be used instead of a resolveDirective call.
        const directiveImportMap = new WeakMap();
        // generate a JavaScript AST for this element's codegen
        const transformElement = (node, context) => {
          // perform the work on exit, after all child expressions have been
          // processed and merged.
          return function postTransformElement() {
            node = context.currentNode;
            if (
              !(
                node.type === 1 /* ELEMENT */ &&
                (node.tagType === 0 /* ELEMENT */ ||
                  node.tagType === 1) /* COMPONENT */
              )
            ) {
              return;
            }
            const { tag, props } = node;
            const isComponent = node.tagType === 1; /* COMPONENT */
            // The goal of the transform is to create a codegenNode implementing the
            // VNodeCall interface.
            let vnodeTag = isComponent
              ? resolveComponentType(node, context)
              : `"${tag}"`;
            const isDynamicComponent =
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(
                vnodeTag
              ) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
            let vnodeProps;
            let vnodeChildren;
            let vnodePatchFlag;
            let patchFlag = 0;
            let vnodeDynamicProps;
            let dynamicPropNames;
            let vnodeDirectives;
            let shouldUseBlock =
              // dynamic component may resolve to plain elements
              isDynamicComponent ||
              vnodeTag === TELEPORT ||
              vnodeTag === SUSPENSE ||
              (!isComponent &&
                // <svg> and <foreignObject> must be forced into blocks so that block
                // updates inside get proper isSVG flag at runtime. (#639, #643)
                // This is technically web-specific, but splitting the logic out of core
                // leads to too much unnecessary complexity.
                (tag === 'svg' || tag === 'foreignObject'));
            // props
            if (props.length > 0) {
              const propsBuildResult = buildProps(node, context);
              vnodeProps = propsBuildResult.props;
              patchFlag = propsBuildResult.patchFlag;
              dynamicPropNames = propsBuildResult.dynamicPropNames;
              const directives = propsBuildResult.directives;
              vnodeDirectives =
                directives && directives.length
                  ? createArrayExpression(
                      directives.map((dir) => buildDirectiveArgs(dir, context))
                    )
                  : undefined;
              if (propsBuildResult.shouldUseBlock) {
                shouldUseBlock = true;
              }
            }
            // children
            if (node.children.length > 0) {
              if (vnodeTag === KEEP_ALIVE) {
                // Although a built-in component, we compile KeepAlive with raw children
                // instead of slot functions so that it can be used inside Transition
                // or other Transition-wrapping HOCs.
                // To ensure correct updates with block optimizations, we need to:
                // 1. Force keep-alive into a block. This avoids its children being
                //    collected by a parent block.
                shouldUseBlock = true;
                // 2. Force keep-alive to always be updated, since it uses raw children.
                patchFlag |= 1024 /* DYNAMIC_SLOTS */;
                if (true && node.children.length > 1) {
                  context.onError(
                    createCompilerError(
                      45 /* X_KEEP_ALIVE_INVALID_CHILDREN */,
                      {
                        start: node.children[0].loc.start,
                        end: node.children[node.children.length - 1].loc.end,
                        source: '',
                      }
                    )
                  );
                }
              }
              const shouldBuildAsSlots =
                isComponent &&
                // Teleport is not a real component and has dedicated runtime handling
                vnodeTag !== TELEPORT &&
                // explained above.
                vnodeTag !== KEEP_ALIVE;
              if (shouldBuildAsSlots) {
                const { slots, hasDynamicSlots } = buildSlots(node, context);
                vnodeChildren = slots;
                if (hasDynamicSlots) {
                  patchFlag |= 1024 /* DYNAMIC_SLOTS */;
                }
              } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
                const child = node.children[0];
                const type = child.type;
                // check for dynamic text children
                const hasDynamicTextChild =
                  type === 5 /* INTERPOLATION */ ||
                  type === 8; /* COMPOUND_EXPRESSION */
                if (
                  hasDynamicTextChild &&
                  getConstantType(child, context) === 0 /* NOT_CONSTANT */
                ) {
                  patchFlag |= 1 /* TEXT */;
                }
                // pass directly if the only child is a text node
                // (plain / interpolation / expression)
                if (hasDynamicTextChild || type === 2 /* TEXT */) {
                  vnodeChildren = child;
                } else {
                  vnodeChildren = node.children;
                }
              } else {
                vnodeChildren = node.children;
              }
            }
            // patchFlag & dynamicPropNames
            if (patchFlag !== 0) {
              if (true) {
                if (patchFlag < 0) {
                  // special flags (negative and mutually exclusive)
                  vnodePatchFlag =
                    patchFlag +
                    ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[patchFlag]} */`;
                } else {
                  // bitwise flags
                  const flagNames = Object.keys(
                    _vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames
                  )
                    .map(Number)
                    .filter((n) => n > 0 && patchFlag & n)
                    .map(
                      (n) =>
                        _vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[
                          n
                        ]
                    )
                    .join(`, `);
                  vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;
                }
              } else {
              }
              if (dynamicPropNames && dynamicPropNames.length) {
                vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
              }
            }
            node.codegenNode = createVNodeCall(
              context,
              vnodeTag,
              vnodeProps,
              vnodeChildren,
              vnodePatchFlag,
              vnodeDynamicProps,
              vnodeDirectives,
              !!shouldUseBlock,
              false /* disableTracking */,
              isComponent,
              node.loc
            );
          };
        };
        function resolveComponentType(node, context, ssr = false) {
          let { tag } = node;
          // 1. dynamic component
          const isExplicitDynamic = isComponentTag(tag);
          const isProp = findProp(node, 'is');
          if (isProp) {
            if (
              isExplicitDynamic ||
              isCompatEnabled(
                'COMPILER_IS_ON_ELEMENT' /* COMPILER_IS_ON_ELEMENT */,
                context
              )
            ) {
              const exp =
                isProp.type === 6 /* ATTRIBUTE */
                  ? isProp.value &&
                    createSimpleExpression(isProp.value.content, true)
                  : isProp.exp;
              if (exp) {
                return createCallExpression(
                  context.helper(RESOLVE_DYNAMIC_COMPONENT),
                  [exp]
                );
              }
            } else if (
              isProp.type === 6 /* ATTRIBUTE */ &&
              isProp.value.content.startsWith('vue:')
            ) {
              // <button is="vue:xxx">
              // if not <component>, only is value that starts with "vue:" will be
              // treated as component by the parse phase and reach here, unless it's
              // compat mode where all is values are considered components
              tag = isProp.value.content.slice(4);
            }
          }
          // 1.5 v-is (TODO: Deprecate)
          const isDir = !isExplicitDynamic && findDir(node, 'is');
          if (isDir && isDir.exp) {
            return createCallExpression(
              context.helper(RESOLVE_DYNAMIC_COMPONENT),
              [isDir.exp]
            );
          }
          // 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)
          const builtIn =
            isCoreComponent(tag) || context.isBuiltInComponent(tag);
          if (builtIn) {
            // built-ins are simply fallthroughs / have special handling during ssr
            // so we don't need to import their runtime equivalents
            if (!ssr) context.helper(builtIn);
            return builtIn;
          }
          // 5. user component (resolve)
          context.helper(RESOLVE_COMPONENT);
          context.components.add(tag);
          return toValidAssetId(tag, `component`);
        }
        function buildProps(node, context, props = node.props, ssr = false) {
          const { tag, loc: elementLoc, children } = node;
          const isComponent = node.tagType === 1; /* COMPONENT */
          let properties = [];
          const mergeArgs = [];
          const runtimeDirectives = [];
          const hasChildren = children.length > 0;
          let shouldUseBlock = false;
          // patchFlag analysis
          let patchFlag = 0;
          let hasRef = false;
          let hasClassBinding = false;
          let hasStyleBinding = false;
          let hasHydrationEventBinding = false;
          let hasDynamicKeys = false;
          let hasVnodeHook = false;
          const dynamicPropNames = [];
          const analyzePatchFlag = ({ key, value }) => {
            if (isStaticExp(key)) {
              const name = key.content;
              const isEventHandler = (0,
              _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isOn)(name);
              if (
                !isComponent &&
                isEventHandler &&
                // omit the flag for click handlers because hydration gives click
                // dedicated fast path.
                name.toLowerCase() !== 'onclick' &&
                // omit v-model handlers
                name !== 'onUpdate:modelValue' &&
                // omit onVnodeXXX hooks
                !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isReservedProp)(
                  name
                )
              ) {
                hasHydrationEventBinding = true;
              }
              if (
                isEventHandler &&
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isReservedProp)(
                  name
                )
              ) {
                hasVnodeHook = true;
              }
              if (
                value.type === 20 /* JS_CACHE_EXPRESSION */ ||
                ((value.type === 4 /* SIMPLE_EXPRESSION */ ||
                  value.type === 8) /* COMPOUND_EXPRESSION */ &&
                  getConstantType(value, context) > 0)
              ) {
                // skip if the prop is a cached handler or has constant value
                return;
              }
              if (name === 'ref') {
                hasRef = true;
              } else if (name === 'class') {
                hasClassBinding = true;
              } else if (name === 'style') {
                hasStyleBinding = true;
              } else if (name !== 'key' && !dynamicPropNames.includes(name)) {
                dynamicPropNames.push(name);
              }
              // treat the dynamic class and style binding of the component as dynamic props
              if (
                isComponent &&
                (name === 'class' || name === 'style') &&
                !dynamicPropNames.includes(name)
              ) {
                dynamicPropNames.push(name);
              }
            } else {
              hasDynamicKeys = true;
            }
          };
          for (let i = 0; i < props.length; i++) {
            // static attribute
            const prop = props[i];
            if (prop.type === 6 /* ATTRIBUTE */) {
              const { loc, name, value } = prop;
              let isStatic = true;
              if (name === 'ref') {
                hasRef = true;
                if (context.scopes.vFor > 0) {
                  properties.push(
                    createObjectProperty(
                      createSimpleExpression('ref_for', true),
                      createSimpleExpression('true')
                    )
                  );
                }
              }
              // skip is on <component>, or is="vue:xxx"
              if (
                name === 'is' &&
                (isComponentTag(tag) ||
                  (value && value.content.startsWith('vue:')) ||
                  isCompatEnabled(
                    'COMPILER_IS_ON_ELEMENT' /* COMPILER_IS_ON_ELEMENT */,
                    context
                  ))
              ) {
                continue;
              }
              properties.push(
                createObjectProperty(
                  createSimpleExpression(
                    name,
                    true,
                    getInnerRange(loc, 0, name.length)
                  ),
                  createSimpleExpression(
                    value ? value.content : '',
                    isStatic,
                    value ? value.loc : loc
                  )
                )
              );
            } else {
              // directives
              const { name, arg, exp, loc } = prop;
              const isVBind = name === 'bind';
              const isVOn = name === 'on';
              // skip v-slot - it is handled by its dedicated transform.
              if (name === 'slot') {
                if (!isComponent) {
                  context.onError(
                    createCompilerError(40 /* X_V_SLOT_MISPLACED */, loc)
                  );
                }
                continue;
              }
              // skip v-once/v-memo - they are handled by dedicated transforms.
              if (name === 'once' || name === 'memo') {
                continue;
              }
              // skip v-is and :is on <component>
              if (
                name === 'is' ||
                (isVBind &&
                  isStaticArgOf(arg, 'is') &&
                  (isComponentTag(tag) ||
                    isCompatEnabled(
                      'COMPILER_IS_ON_ELEMENT' /* COMPILER_IS_ON_ELEMENT */,
                      context
                    )))
              ) {
                continue;
              }
              // skip v-on in SSR compilation
              if (isVOn && ssr) {
                continue;
              }
              if (
                // #938: elements with dynamic keys should be forced into blocks
                (isVBind && isStaticArgOf(arg, 'key')) ||
                // inline before-update hooks need to force block so that it is invoked
                // before children
                (isVOn &&
                  hasChildren &&
                  isStaticArgOf(arg, 'vue:before-update'))
              ) {
                shouldUseBlock = true;
              }
              if (
                isVBind &&
                isStaticArgOf(arg, 'ref') &&
                context.scopes.vFor > 0
              ) {
                properties.push(
                  createObjectProperty(
                    createSimpleExpression('ref_for', true),
                    createSimpleExpression('true')
                  )
                );
              }
              // special case for v-bind and v-on with no argument
              if (!arg && (isVBind || isVOn)) {
                hasDynamicKeys = true;
                if (exp) {
                  if (properties.length) {
                    mergeArgs.push(
                      createObjectExpression(
                        dedupeProperties(properties),
                        elementLoc
                      )
                    );
                    properties = [];
                  }
                  if (isVBind) {
                    {
                      // 2.x v-bind object order compat
                      if (true) {
                        const hasOverridableKeys = mergeArgs.some((arg) => {
                          if (arg.type === 15 /* JS_OBJECT_EXPRESSION */) {
                            return arg.properties.some(({ key }) => {
                              if (
                                key.type !== 4 /* SIMPLE_EXPRESSION */ ||
                                !key.isStatic
                              ) {
                                return true;
                              }
                              return (
                                key.content !== 'class' &&
                                key.content !== 'style' &&
                                !(0,
                                _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isOn)(
                                  key.content
                                )
                              );
                            });
                          } else {
                            // dynamic expression
                            return true;
                          }
                        });
                        if (hasOverridableKeys) {
                          checkCompatEnabled(
                            'COMPILER_V_BIND_OBJECT_ORDER' /* COMPILER_V_BIND_OBJECT_ORDER */,
                            context,
                            loc
                          );
                        }
                      }
                      if (
                        isCompatEnabled(
                          'COMPILER_V_BIND_OBJECT_ORDER' /* COMPILER_V_BIND_OBJECT_ORDER */,
                          context
                        )
                      ) {
                        mergeArgs.unshift(exp);
                        continue;
                      }
                    }
                    mergeArgs.push(exp);
                  } else {
                    // v-on="obj" -> toHandlers(obj)
                    mergeArgs.push({
                      type: 14 /* JS_CALL_EXPRESSION */,
                      loc,
                      callee: context.helper(TO_HANDLERS),
                      arguments: [exp],
                    });
                  }
                } else {
                  context.onError(
                    createCompilerError(
                      isVBind
                        ? 34 /* X_V_BIND_NO_EXPRESSION */
                        : 35 /* X_V_ON_NO_EXPRESSION */,
                      loc
                    )
                  );
                }
                continue;
              }
              const directiveTransform = context.directiveTransforms[name];
              if (directiveTransform) {
                // has built-in directive transform.
                const { props, needRuntime } = directiveTransform(
                  prop,
                  node,
                  context
                );
                !ssr && props.forEach(analyzePatchFlag);
                properties.push(...props);
                if (needRuntime) {
                  runtimeDirectives.push(prop);
                  if (
                    (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(
                      needRuntime
                    )
                  ) {
                    directiveImportMap.set(prop, needRuntime);
                  }
                }
              } else if (
                !(0,
                _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isBuiltInDirective)(
                  name
                )
              ) {
                // no built-in transform, this is a user custom directive.
                runtimeDirectives.push(prop);
                // custom dirs may use beforeUpdate so they need to force blocks
                // to ensure before-update gets called before children update
                if (hasChildren) {
                  shouldUseBlock = true;
                }
              }
            }
          }
          let propsExpression = undefined;
          // has v-bind="object" or v-on="object", wrap with mergeProps
          if (mergeArgs.length) {
            if (properties.length) {
              mergeArgs.push(
                createObjectExpression(dedupeProperties(properties), elementLoc)
              );
            }
            if (mergeArgs.length > 1) {
              propsExpression = createCallExpression(
                context.helper(MERGE_PROPS),
                mergeArgs,
                elementLoc
              );
            } else {
              // single v-bind with nothing else - no need for a mergeProps call
              propsExpression = mergeArgs[0];
            }
          } else if (properties.length) {
            propsExpression = createObjectExpression(
              dedupeProperties(properties),
              elementLoc
            );
          }
          // patchFlag analysis
          if (hasDynamicKeys) {
            patchFlag |= 16 /* FULL_PROPS */;
          } else {
            if (hasClassBinding && !isComponent) {
              patchFlag |= 2 /* CLASS */;
            }
            if (hasStyleBinding && !isComponent) {
              patchFlag |= 4 /* STYLE */;
            }
            if (dynamicPropNames.length) {
              patchFlag |= 8 /* PROPS */;
            }
            if (hasHydrationEventBinding) {
              patchFlag |= 32 /* HYDRATE_EVENTS */;
            }
          }
          if (
            !shouldUseBlock &&
            (patchFlag === 0 || patchFlag === 32) /* HYDRATE_EVENTS */ &&
            (hasRef || hasVnodeHook || runtimeDirectives.length > 0)
          ) {
            patchFlag |= 512 /* NEED_PATCH */;
          }
          // pre-normalize props, SSR is skipped for now
          if (!context.inSSR && propsExpression) {
            switch (propsExpression.type) {
              case 15 /* JS_OBJECT_EXPRESSION */:
                // means that there is no v-bind,
                // but still need to deal with dynamic key binding
                let classKeyIndex = -1;
                let styleKeyIndex = -1;
                let hasDynamicKey = false;
                for (let i = 0; i < propsExpression.properties.length; i++) {
                  const key = propsExpression.properties[i].key;
                  if (isStaticExp(key)) {
                    if (key.content === 'class') {
                      classKeyIndex = i;
                    } else if (key.content === 'style') {
                      styleKeyIndex = i;
                    }
                  } else if (!key.isHandlerKey) {
                    hasDynamicKey = true;
                  }
                }
                const classProp = propsExpression.properties[classKeyIndex];
                const styleProp = propsExpression.properties[styleKeyIndex];
                // no dynamic key
                if (!hasDynamicKey) {
                  if (classProp && !isStaticExp(classProp.value)) {
                    classProp.value = createCallExpression(
                      context.helper(NORMALIZE_CLASS),
                      [classProp.value]
                    );
                  }
                  if (
                    styleProp &&
                    !isStaticExp(styleProp.value) &&
                    // the static style is compiled into an object,
                    // so use `hasStyleBinding` to ensure that it is a dynamic style binding
                    (hasStyleBinding ||
                      // v-bind:style and style both exist,
                      // v-bind:style with static literal object
                      styleProp.value.type === 17) /* JS_ARRAY_EXPRESSION */
                  ) {
                    styleProp.value = createCallExpression(
                      context.helper(NORMALIZE_STYLE),
                      [styleProp.value]
                    );
                  }
                } else {
                  // dynamic key binding, wrap with `normalizeProps`
                  propsExpression = createCallExpression(
                    context.helper(NORMALIZE_PROPS),
                    [propsExpression]
                  );
                }
                break;
              case 14 /* JS_CALL_EXPRESSION */:
                // mergeProps call, do nothing
                break;
              default:
                // single v-bind
                propsExpression = createCallExpression(
                  context.helper(NORMALIZE_PROPS),
                  [
                    createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
                      propsExpression,
                    ]),
                  ]
                );
                break;
            }
          }
          return {
            props: propsExpression,
            directives: runtimeDirectives,
            patchFlag,
            dynamicPropNames,
            shouldUseBlock,
          };
        }
        // Dedupe props in an object literal.
        // Literal duplicated attributes would have been warned during the parse phase,
        // however, it's possible to encounter duplicated `onXXX` handlers with different
        // modifiers. We also need to merge static and dynamic class / style attributes.
        // - onXXX handlers / style: merge into array
        // - class: merge into single expression with concatenation
        function dedupeProperties(properties) {
          const knownProps = new Map();
          const deduped = [];
          for (let i = 0; i < properties.length; i++) {
            const prop = properties[i];
            // dynamic keys are always allowed
            if (
              prop.key.type === 8 /* COMPOUND_EXPRESSION */ ||
              !prop.key.isStatic
            ) {
              deduped.push(prop);
              continue;
            }
            const name = prop.key.content;
            const existing = knownProps.get(name);
            if (existing) {
              if (
                name === 'style' ||
                name === 'class' ||
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isOn)(name)
              ) {
                mergeAsArray(existing, prop);
              }
              // unexpected duplicate, should have emitted error during parse
            } else {
              knownProps.set(name, prop);
              deduped.push(prop);
            }
          }
          return deduped;
        }
        function mergeAsArray(existing, incoming) {
          if (existing.value.type === 17 /* JS_ARRAY_EXPRESSION */) {
            existing.value.elements.push(incoming.value);
          } else {
            existing.value = createArrayExpression(
              [existing.value, incoming.value],
              existing.loc
            );
          }
        }
        function buildDirectiveArgs(dir, context) {
          const dirArgs = [];
          const runtime = directiveImportMap.get(dir);
          if (runtime) {
            // built-in directive with runtime
            dirArgs.push(context.helperString(runtime));
          } else {
            {
              // inject statement for resolving directive
              context.helper(RESOLVE_DIRECTIVE);
              context.directives.add(dir.name);
              dirArgs.push(toValidAssetId(dir.name, `directive`));
            }
          }
          const { loc } = dir;
          if (dir.exp) dirArgs.push(dir.exp);
          if (dir.arg) {
            if (!dir.exp) {
              dirArgs.push(`void 0`);
            }
            dirArgs.push(dir.arg);
          }
          if (Object.keys(dir.modifiers).length) {
            if (!dir.arg) {
              if (!dir.exp) {
                dirArgs.push(`void 0`);
              }
              dirArgs.push(`void 0`);
            }
            const trueExpression = createSimpleExpression(`true`, false, loc);
            dirArgs.push(
              createObjectExpression(
                dir.modifiers.map((modifier) =>
                  createObjectProperty(modifier, trueExpression)
                ),
                loc
              )
            );
          }
          return createArrayExpression(dirArgs, dir.loc);
        }
        function stringifyDynamicPropNames(props) {
          let propsNamesString = `[`;
          for (let i = 0, l = props.length; i < l; i++) {
            propsNamesString += JSON.stringify(props[i]);
            if (i < l - 1) propsNamesString += ', ';
          }
          return propsNamesString + `]`;
        }
        function isComponentTag(tag) {
          return tag === 'component' || tag === 'Component';
        }

        true ? Object.freeze({}) : 0;
        true ? Object.freeze([]) : 0;
        const cacheStringFunction = (fn) => {
          const cache = Object.create(null);
          return (str) => {
            const hit = cache[str];
            return hit || (cache[str] = fn(str));
          };
        };
        const camelizeRE = /-(\w)/g;
        /**
         * @private
         */
        const camelize = cacheStringFunction((str) => {
          return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
        });

        const transformSlotOutlet = (node, context) => {
          if (isSlotOutlet(node)) {
            const { children, loc } = node;
            const { slotName, slotProps } = processSlotOutlet(node, context);
            const slotArgs = [
              context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
              slotName,
              '{}',
              'undefined',
              'true',
            ];
            let expectedLen = 2;
            if (slotProps) {
              slotArgs[2] = slotProps;
              expectedLen = 3;
            }
            if (children.length) {
              slotArgs[3] = createFunctionExpression(
                [],
                children,
                false,
                false,
                loc
              );
              expectedLen = 4;
            }
            if (context.scopeId && !context.slotted) {
              expectedLen = 5;
            }
            slotArgs.splice(expectedLen); // remove unused arguments
            node.codegenNode = createCallExpression(
              context.helper(RENDER_SLOT),
              slotArgs,
              loc
            );
          }
        };
        function processSlotOutlet(node, context) {
          let slotName = `"default"`;
          let slotProps = undefined;
          const nonNameProps = [];
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 6 /* ATTRIBUTE */) {
              if (p.value) {
                if (p.name === 'name') {
                  slotName = JSON.stringify(p.value.content);
                } else {
                  p.name = camelize(p.name);
                  nonNameProps.push(p);
                }
              }
            } else {
              if (p.name === 'bind' && isStaticArgOf(p.arg, 'name')) {
                if (p.exp) slotName = p.exp;
              } else {
                if (p.name === 'bind' && p.arg && isStaticExp(p.arg)) {
                  p.arg.content = camelize(p.arg.content);
                }
                nonNameProps.push(p);
              }
            }
          }
          if (nonNameProps.length > 0) {
            const { props, directives } = buildProps(
              node,
              context,
              nonNameProps
            );
            slotProps = props;
            if (directives.length) {
              context.onError(
                createCompilerError(
                  36 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */,
                  directives[0].loc
                )
              );
            }
          }
          return {
            slotName,
            slotProps,
          };
        }

        const fnExpRE =
          /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
        const transformOn = (dir, node, context, augmentor) => {
          const { loc, modifiers, arg } = dir;
          if (!dir.exp && !modifiers.length) {
            context.onError(
              createCompilerError(35 /* X_V_ON_NO_EXPRESSION */, loc)
            );
          }
          let eventName;
          if (arg.type === 4 /* SIMPLE_EXPRESSION */) {
            if (arg.isStatic) {
              let rawName = arg.content;
              // TODO deprecate @vnodeXXX usage
              if (rawName.startsWith('vue:')) {
                rawName = `vnode-${rawName.slice(4)}`;
              }
              // for all event listeners, auto convert it to camelCase. See issue #2249
              eventName = createSimpleExpression(
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey)(
                  (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(
                    rawName
                  )
                ),
                true,
                arg.loc
              );
            } else {
              // #2388
              eventName = createCompoundExpression([
                `${context.helperString(TO_HANDLER_KEY)}(`,
                arg,
                `)`,
              ]);
            }
          } else {
            // already a compound expression.
            eventName = arg;
            eventName.children.unshift(
              `${context.helperString(TO_HANDLER_KEY)}(`
            );
            eventName.children.push(`)`);
          }
          // handler processing
          let exp = dir.exp;
          if (exp && !exp.content.trim()) {
            exp = undefined;
          }
          let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
          if (exp) {
            const isMemberExp = isMemberExpression(exp.content);
            const isInlineStatement = !(
              isMemberExp || fnExpRE.test(exp.content)
            );
            const hasMultipleStatements = exp.content.includes(`;`);
            if (true) {
              validateBrowserExpression(
                exp,
                context,
                false,
                hasMultipleStatements
              );
            }
            if (isInlineStatement || (shouldCache && isMemberExp)) {
              // wrap inline statement in a function expression
              exp = createCompoundExpression([
                `${isInlineStatement ? `$event` : `${``}(...args)`} => ${
                  hasMultipleStatements ? `{` : `(`
                }`,
                exp,
                hasMultipleStatements ? `}` : `)`,
              ]);
            }
          }
          let ret = {
            props: [
              createObjectProperty(
                eventName,
                exp || createSimpleExpression(`() => {}`, false, loc)
              ),
            ],
          };
          // apply extended compiler augmentor
          if (augmentor) {
            ret = augmentor(ret);
          }
          if (shouldCache) {
            // cache handlers so that it's always the same handler being passed down.
            // this avoids unnecessary re-renders when users use inline handlers on
            // components.
            ret.props[0].value = context.cache(ret.props[0].value);
          }
          // mark the key as handler for props normalization check
          ret.props.forEach((p) => (p.key.isHandlerKey = true));
          return ret;
        };

        // v-bind without arg is handled directly in ./transformElements.ts due to it affecting
        // codegen for the entire props object. This transform here is only for v-bind
        // *with* args.
        const transformBind = (dir, _node, context) => {
          const { exp, modifiers, loc } = dir;
          const arg = dir.arg;
          if (arg.type !== 4 /* SIMPLE_EXPRESSION */) {
            arg.children.unshift(`(`);
            arg.children.push(`) || ""`);
          } else if (!arg.isStatic) {
            arg.content = `${arg.content} || ""`;
          }
          // .sync is replaced by v-model:arg
          if (modifiers.includes('camel')) {
            if (arg.type === 4 /* SIMPLE_EXPRESSION */) {
              if (arg.isStatic) {
                arg.content = (0,
                _vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(arg.content);
              } else {
                arg.content = `${context.helperString(CAMELIZE)}(${
                  arg.content
                })`;
              }
            } else {
              arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
              arg.children.push(`)`);
            }
          }
          if (!context.inSSR) {
            if (modifiers.includes('prop')) {
              injectPrefix(arg, '.');
            }
            if (modifiers.includes('attr')) {
              injectPrefix(arg, '^');
            }
          }
          if (
            !exp ||
            (exp.type === 4 /* SIMPLE_EXPRESSION */ && !exp.content.trim())
          ) {
            context.onError(
              createCompilerError(34 /* X_V_BIND_NO_EXPRESSION */, loc)
            );
            return {
              props: [
                createObjectProperty(
                  arg,
                  createSimpleExpression('', true, loc)
                ),
              ],
            };
          }
          return {
            props: [createObjectProperty(arg, exp)],
          };
        };
        const injectPrefix = (arg, prefix) => {
          if (arg.type === 4 /* SIMPLE_EXPRESSION */) {
            if (arg.isStatic) {
              arg.content = prefix + arg.content;
            } else {
              arg.content = `\`${prefix}\${${arg.content}}\``;
            }
          } else {
            arg.children.unshift(`'${prefix}' + (`);
            arg.children.push(`)`);
          }
        };

        // Merge adjacent text nodes and expressions into a single expression
        // e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.
        const transformText = (node, context) => {
          if (
            node.type === 0 /* ROOT */ ||
            node.type === 1 /* ELEMENT */ ||
            node.type === 11 /* FOR */ ||
            node.type === 10 /* IF_BRANCH */
          ) {
            // perform the transform on node exit so that all expressions have already
            // been processed.
            return () => {
              const children = node.children;
              let currentContainer = undefined;
              let hasText = false;
              for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (isText(child)) {
                  hasText = true;
                  for (let j = i + 1; j < children.length; j++) {
                    const next = children[j];
                    if (isText(next)) {
                      if (!currentContainer) {
                        currentContainer = children[i] = {
                          type: 8 /* COMPOUND_EXPRESSION */,
                          loc: child.loc,
                          children: [child],
                        };
                      }
                      // merge adjacent text node into current
                      currentContainer.children.push(` + `, next);
                      children.splice(j, 1);
                      j--;
                    } else {
                      currentContainer = undefined;
                      break;
                    }
                  }
                }
              }
              if (
                !hasText ||
                // if this is a plain element with a single text child, leave it
                // as-is since the runtime has dedicated fast path for this by directly
                // setting textContent of the element.
                // for component root it's always normalized anyway.
                (children.length === 1 &&
                  (node.type === 0 /* ROOT */ ||
                    (node.type === 1 /* ELEMENT */ &&
                      node.tagType === 0 /* ELEMENT */ &&
                      // #3756
                      // custom directives can potentially add DOM elements arbitrarily,
                      // we need to avoid setting textContent of the element at runtime
                      // to avoid accidentally overwriting the DOM elements added
                      // by the user through custom directives.
                      !node.props.find(
                        (p) =>
                          p.type === 7 /* DIRECTIVE */ &&
                          !context.directiveTransforms[p.name]
                      ) &&
                      // in compat mode, <template> tags with no special directives
                      // will be rendered as a fragment so its children must be
                      // converted into vnodes.
                      !(node.tag === 'template'))))
              ) {
                return;
              }
              // pre-convert text nodes into createTextVNode(text) calls to avoid
              // runtime normalization.
              for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (
                  isText(child) ||
                  child.type === 8 /* COMPOUND_EXPRESSION */
                ) {
                  const callArgs = [];
                  // createTextVNode defaults to single whitespace, so if it is a
                  // single space the code could be an empty call to save bytes.
                  if (child.type !== 2 /* TEXT */ || child.content !== ' ') {
                    callArgs.push(child);
                  }
                  // mark dynamic text with flag so it gets patched inside a block
                  if (
                    !context.ssr &&
                    getConstantType(child, context) === 0 /* NOT_CONSTANT */
                  ) {
                    callArgs.push(
                      1 /* TEXT */ +
                        (true
                          ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[1]} */`
                          : 0)
                    );
                  }
                  children[i] = {
                    type: 12 /* TEXT_CALL */,
                    content: child,
                    loc: child.loc,
                    codegenNode: createCallExpression(
                      context.helper(CREATE_TEXT),
                      callArgs
                    ),
                  };
                }
              }
            };
          }
        };

        const seen = new WeakSet();
        const transformOnce = (node, context) => {
          if (node.type === 1 /* ELEMENT */ && findDir(node, 'once', true)) {
            if (seen.has(node) || context.inVOnce) {
              return;
            }
            seen.add(node);
            context.inVOnce = true;
            context.helper(SET_BLOCK_TRACKING);
            return () => {
              context.inVOnce = false;
              const cur = context.currentNode;
              if (cur.codegenNode) {
                cur.codegenNode = context.cache(
                  cur.codegenNode,
                  true /* isVNode */
                );
              }
            };
          }
        };

        const transformModel = (dir, node, context) => {
          const { exp, arg } = dir;
          if (!exp) {
            context.onError(
              createCompilerError(41 /* X_V_MODEL_NO_EXPRESSION */, dir.loc)
            );
            return createTransformProps();
          }
          const rawExp = exp.loc.source;
          const expString =
            exp.type === 4 /* SIMPLE_EXPRESSION */ ? exp.content : rawExp;
          // im SFC <script setup> inline mode, the exp may have been transformed into
          // _unref(exp)
          context.bindingMetadata[rawExp];
          const maybeRef = !true; /* SETUP_CONST */
          if (
            !expString.trim() ||
            (!isMemberExpression(expString) && !maybeRef)
          ) {
            context.onError(
              createCompilerError(
                42 /* X_V_MODEL_MALFORMED_EXPRESSION */,
                exp.loc
              )
            );
            return createTransformProps();
          }
          const propName = arg
            ? arg
            : createSimpleExpression('modelValue', true);
          const eventName = arg
            ? isStaticExp(arg)
              ? `onUpdate:${arg.content}`
              : createCompoundExpression(['"onUpdate:" + ', arg])
            : `onUpdate:modelValue`;
          let assignmentExp;
          const eventArg = context.isTS ? `($event: any)` : `$event`;
          {
            assignmentExp = createCompoundExpression([
              `${eventArg} => ((`,
              exp,
              `) = $event)`,
            ]);
          }
          const props = [
            // modelValue: foo
            createObjectProperty(propName, dir.exp),
            // "onUpdate:modelValue": $event => (foo = $event)
            createObjectProperty(eventName, assignmentExp),
          ];
          // modelModifiers: { foo: true, "bar-baz": true }
          if (dir.modifiers.length && node.tagType === 1 /* COMPONENT */) {
            const modifiers = dir.modifiers
              .map(
                (m) =>
                  (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`
              )
              .join(`, `);
            const modifiersKey = arg
              ? isStaticExp(arg)
                ? `${arg.content}Modifiers`
                : createCompoundExpression([arg, ' + "Modifiers"'])
              : `modelModifiers`;
            props.push(
              createObjectProperty(
                modifiersKey,
                createSimpleExpression(
                  `{ ${modifiers} }`,
                  false,
                  dir.loc,
                  2 /* CAN_HOIST */
                )
              )
            );
          }
          return createTransformProps(props);
        };
        function createTransformProps(props = []) {
          return { props };
        }

        const validDivisionCharRE = /[\w).+\-_$\]]/;
        const transformFilter = (node, context) => {
          if (
            !isCompatEnabled('COMPILER_FILTER' /* COMPILER_FILTERS */, context)
          ) {
            return;
          }
          if (node.type === 5 /* INTERPOLATION */) {
            // filter rewrite is applied before expression transform so only
            // simple expressions are possible at this stage
            rewriteFilter(node.content, context);
          }
          if (node.type === 1 /* ELEMENT */) {
            node.props.forEach((prop) => {
              if (
                prop.type === 7 /* DIRECTIVE */ &&
                prop.name !== 'for' &&
                prop.exp
              ) {
                rewriteFilter(prop.exp, context);
              }
            });
          }
        };
        function rewriteFilter(node, context) {
          if (node.type === 4 /* SIMPLE_EXPRESSION */) {
            parseFilter(node, context);
          } else {
            for (let i = 0; i < node.children.length; i++) {
              const child = node.children[i];
              if (typeof child !== 'object') continue;
              if (child.type === 4 /* SIMPLE_EXPRESSION */) {
                parseFilter(child, context);
              } else if (child.type === 8 /* COMPOUND_EXPRESSION */) {
                rewriteFilter(node, context);
              } else if (child.type === 5 /* INTERPOLATION */) {
                rewriteFilter(child.content, context);
              }
            }
          }
        }
        function parseFilter(node, context) {
          const exp = node.content;
          let inSingle = false;
          let inDouble = false;
          let inTemplateString = false;
          let inRegex = false;
          let curly = 0;
          let square = 0;
          let paren = 0;
          let lastFilterIndex = 0;
          let c,
            prev,
            i,
            expression,
            filters = [];
          for (i = 0; i < exp.length; i++) {
            prev = c;
            c = exp.charCodeAt(i);
            if (inSingle) {
              if (c === 0x27 && prev !== 0x5c) inSingle = false;
            } else if (inDouble) {
              if (c === 0x22 && prev !== 0x5c) inDouble = false;
            } else if (inTemplateString) {
              if (c === 0x60 && prev !== 0x5c) inTemplateString = false;
            } else if (inRegex) {
              if (c === 0x2f && prev !== 0x5c) inRegex = false;
            } else if (
              c === 0x7c && // pipe
              exp.charCodeAt(i + 1) !== 0x7c &&
              exp.charCodeAt(i - 1) !== 0x7c &&
              !curly &&
              !square &&
              !paren
            ) {
              if (expression === undefined) {
                // first filter, end of expression
                lastFilterIndex = i + 1;
                expression = exp.slice(0, i).trim();
              } else {
                pushFilter();
              }
            } else {
              switch (c) {
                case 0x22:
                  inDouble = true;
                  break; // "
                case 0x27:
                  inSingle = true;
                  break; // '
                case 0x60:
                  inTemplateString = true;
                  break; // `
                case 0x28:
                  paren++;
                  break; // (
                case 0x29:
                  paren--;
                  break; // )
                case 0x5b:
                  square++;
                  break; // [
                case 0x5d:
                  square--;
                  break; // ]
                case 0x7b:
                  curly++;
                  break; // {
                case 0x7d:
                  curly--;
                  break; // }
              }
              if (c === 0x2f) {
                // /
                let j = i - 1;
                let p;
                // find first non-whitespace prev char
                for (; j >= 0; j--) {
                  p = exp.charAt(j);
                  if (p !== ' ') break;
                }
                if (!p || !validDivisionCharRE.test(p)) {
                  inRegex = true;
                }
              }
            }
          }
          if (expression === undefined) {
            expression = exp.slice(0, i).trim();
          } else if (lastFilterIndex !== 0) {
            pushFilter();
          }
          function pushFilter() {
            filters.push(exp.slice(lastFilterIndex, i).trim());
            lastFilterIndex = i + 1;
          }
          if (filters.length) {
            true &&
              warnDeprecation(
                'COMPILER_FILTER' /* COMPILER_FILTERS */,
                context,
                node.loc
              );
            for (i = 0; i < filters.length; i++) {
              expression = wrapFilter(expression, filters[i], context);
            }
            node.content = expression;
          }
        }
        function wrapFilter(exp, filter, context) {
          context.helper(RESOLVE_FILTER);
          const i = filter.indexOf('(');
          if (i < 0) {
            context.filters.add(filter);
            return `${toValidAssetId(filter, 'filter')}(${exp})`;
          } else {
            const name = filter.slice(0, i);
            const args = filter.slice(i + 1);
            context.filters.add(name);
            return `${toValidAssetId(name, 'filter')}(${exp}${
              args !== ')' ? ',' + args : args
            }`;
          }
        }

        const seen$1 = new WeakSet();
        const transformMemo = (node, context) => {
          if (node.type === 1 /* ELEMENT */) {
            const dir = findDir(node, 'memo');
            if (!dir || seen$1.has(node)) {
              return;
            }
            seen$1.add(node);
            return () => {
              const codegenNode =
                node.codegenNode || context.currentNode.codegenNode;
              if (codegenNode && codegenNode.type === 13 /* VNODE_CALL */) {
                // non-component sub tree should be turned into a block
                if (node.tagType !== 1 /* COMPONENT */) {
                  makeBlock(codegenNode, context);
                }
                node.codegenNode = createCallExpression(
                  context.helper(WITH_MEMO),
                  [
                    dir.exp,
                    createFunctionExpression(undefined, codegenNode),
                    `_cache`,
                    String(context.cached++),
                  ]
                );
              }
            };
          }
        };

        function getBaseTransformPreset(prefixIdentifiers) {
          return [
            [
              transformOnce,
              transformIf,
              transformMemo,
              transformFor,
              ...[transformFilter],
              ...(true ? [transformExpression] : 0),
              transformSlotOutlet,
              transformElement,
              trackSlotScopes,
              transformText,
            ],
            {
              on: transformOn,
              bind: transformBind,
              model: transformModel,
            },
          ];
        }
        // we name it `baseCompile` so that higher order compilers like
        // @vue/compiler-dom can export `compile` while re-exporting everything else.
        function baseCompile(template, options = {}) {
          const onError = options.onError || defaultOnError;
          const isModuleMode = options.mode === 'module';
          /* istanbul ignore if */
          {
            if (options.prefixIdentifiers === true) {
              onError(createCompilerError(46 /* X_PREFIX_ID_NOT_SUPPORTED */));
            } else if (isModuleMode) {
              onError(
                createCompilerError(47 /* X_MODULE_MODE_NOT_SUPPORTED */)
              );
            }
          }
          const prefixIdentifiers = !true;
          if (options.cacheHandlers) {
            onError(
              createCompilerError(48 /* X_CACHE_HANDLER_NOT_SUPPORTED */)
            );
          }
          if (options.scopeId && !isModuleMode) {
            onError(createCompilerError(49 /* X_SCOPE_ID_NOT_SUPPORTED */));
          }
          const ast = (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(
            template
          )
            ? baseParse(template, options)
            : template;
          const [nodeTransforms, directiveTransforms] =
            getBaseTransformPreset();
          transform(
            ast,
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, options, {
              prefixIdentifiers,
              nodeTransforms: [
                ...nodeTransforms,
                ...(options.nodeTransforms || []), // user transforms
              ],
              directiveTransforms: (0,
              _vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(
                {},
                directiveTransforms,
                options.directiveTransforms || {} // user transforms
              ),
            })
          );
          return generate(
            ast,
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, options, {
              prefixIdentifiers,
            })
          );
        }

        const noopDirectiveTransform = () => ({ props: [] });

        /***/
      },

    /***/ './node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js':
      /*!*************************************************************************!*\
  !*** ./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js ***!
  \*************************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ BASE_TRANSITION: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.BASE_TRANSITION,
          /* harmony export */ CAMELIZE: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CAMELIZE,
          /* harmony export */ CAPITALIZE: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CAPITALIZE,
          /* harmony export */ CREATE_BLOCK: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_BLOCK,
          /* harmony export */ CREATE_COMMENT: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_COMMENT,
          /* harmony export */ CREATE_ELEMENT_BLOCK: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_ELEMENT_BLOCK,
          /* harmony export */ CREATE_ELEMENT_VNODE: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_ELEMENT_VNODE,
          /* harmony export */ CREATE_SLOTS: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_SLOTS,
          /* harmony export */ CREATE_STATIC: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_STATIC,
          /* harmony export */ CREATE_TEXT: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_TEXT,
          /* harmony export */ CREATE_VNODE: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_VNODE,
          /* harmony export */ FRAGMENT: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.FRAGMENT,
          /* harmony export */ GUARD_REACTIVE_PROPS: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.GUARD_REACTIVE_PROPS,
          /* harmony export */ IS_MEMO_SAME: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.IS_MEMO_SAME,
          /* harmony export */ IS_REF: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.IS_REF,
          /* harmony export */ KEEP_ALIVE: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.KEEP_ALIVE,
          /* harmony export */ MERGE_PROPS: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.MERGE_PROPS,
          /* harmony export */ NORMALIZE_CLASS: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.NORMALIZE_CLASS,
          /* harmony export */ NORMALIZE_PROPS: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.NORMALIZE_PROPS,
          /* harmony export */ NORMALIZE_STYLE: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.NORMALIZE_STYLE,
          /* harmony export */ OPEN_BLOCK: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.OPEN_BLOCK,
          /* harmony export */ POP_SCOPE_ID: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.POP_SCOPE_ID,
          /* harmony export */ PUSH_SCOPE_ID: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.PUSH_SCOPE_ID,
          /* harmony export */ RENDER_LIST: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RENDER_LIST,
          /* harmony export */ RENDER_SLOT: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RENDER_SLOT,
          /* harmony export */ RESOLVE_COMPONENT: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_COMPONENT,
          /* harmony export */ RESOLVE_DIRECTIVE: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_DIRECTIVE,
          /* harmony export */ RESOLVE_DYNAMIC_COMPONENT: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_DYNAMIC_COMPONENT,
          /* harmony export */ RESOLVE_FILTER: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_FILTER,
          /* harmony export */ SET_BLOCK_TRACKING: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.SET_BLOCK_TRACKING,
          /* harmony export */ SUSPENSE: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.SUSPENSE,
          /* harmony export */ TELEPORT: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TELEPORT,
          /* harmony export */ TO_DISPLAY_STRING: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_DISPLAY_STRING,
          /* harmony export */ TO_HANDLERS: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_HANDLERS,
          /* harmony export */ TO_HANDLER_KEY: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_HANDLER_KEY,
          /* harmony export */ UNREF: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.UNREF,
          /* harmony export */ WITH_CTX: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_CTX,
          /* harmony export */ WITH_DIRECTIVES: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_DIRECTIVES,
          /* harmony export */ WITH_MEMO: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_MEMO,
          /* harmony export */ advancePositionWithClone: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.advancePositionWithClone,
          /* harmony export */ advancePositionWithMutation: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.advancePositionWithMutation,
          /* harmony export */ assert: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.assert,
          /* harmony export */ baseCompile: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseCompile,
          /* harmony export */ baseParse: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseParse,
          /* harmony export */ buildDirectiveArgs: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.buildDirectiveArgs,
          /* harmony export */ buildProps: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.buildProps,
          /* harmony export */ buildSlots: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.buildSlots,
          /* harmony export */ checkCompatEnabled: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.checkCompatEnabled,
          /* harmony export */ createArrayExpression: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createArrayExpression,
          /* harmony export */ createAssignmentExpression: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createAssignmentExpression,
          /* harmony export */ createBlockStatement: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createBlockStatement,
          /* harmony export */ createCacheExpression: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCacheExpression,
          /* harmony export */ createCallExpression: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression,
          /* harmony export */ createCompilerError: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompilerError,
          /* harmony export */ createCompoundExpression: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression,
          /* harmony export */ createConditionalExpression: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createConditionalExpression,
          /* harmony export */ createForLoopParams: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createForLoopParams,
          /* harmony export */ createFunctionExpression: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createFunctionExpression,
          /* harmony export */ createIfStatement: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createIfStatement,
          /* harmony export */ createInterpolation: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createInterpolation,
          /* harmony export */ createObjectExpression: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectExpression,
          /* harmony export */ createObjectProperty: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty,
          /* harmony export */ createReturnStatement: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createReturnStatement,
          /* harmony export */ createRoot: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createRoot,
          /* harmony export */ createSequenceExpression: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSequenceExpression,
          /* harmony export */ createSimpleExpression: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression,
          /* harmony export */ createStructuralDirectiveTransform: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createStructuralDirectiveTransform,
          /* harmony export */ createTemplateLiteral: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createTemplateLiteral,
          /* harmony export */ createTransformContext: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createTransformContext,
          /* harmony export */ createVNodeCall: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createVNodeCall,
          /* harmony export */ extractIdentifiers: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.extractIdentifiers,
          /* harmony export */ findDir: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findDir,
          /* harmony export */ findProp: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp,
          /* harmony export */ generate: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.generate,
          /* harmony export */ generateCodeFrame: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.generateCodeFrame,
          /* harmony export */ getBaseTransformPreset: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getBaseTransformPreset,
          /* harmony export */ getInnerRange: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getInnerRange,
          /* harmony export */ getMemoedVNodeCall: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getMemoedVNodeCall,
          /* harmony export */ getVNodeBlockHelper: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getVNodeBlockHelper,
          /* harmony export */ getVNodeHelper: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getVNodeHelper,
          /* harmony export */ hasDynamicKeyVBind: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasDynamicKeyVBind,
          /* harmony export */ hasScopeRef: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasScopeRef,
          /* harmony export */ helperNameMap: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.helperNameMap,
          /* harmony export */ injectProp: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.injectProp,
          /* harmony export */ isBuiltInType: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isBuiltInType,
          /* harmony export */ isCoreComponent: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isCoreComponent,
          /* harmony export */ isFunctionType: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isFunctionType,
          /* harmony export */ isInDestructureAssignment: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isInDestructureAssignment,
          /* harmony export */ isMemberExpression: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isMemberExpression,
          /* harmony export */ isMemberExpressionBrowser: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isMemberExpressionBrowser,
          /* harmony export */ isMemberExpressionNode: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isMemberExpressionNode,
          /* harmony export */ isReferencedIdentifier: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isReferencedIdentifier,
          /* harmony export */ isSimpleIdentifier: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isSimpleIdentifier,
          /* harmony export */ isSlotOutlet: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isSlotOutlet,
          /* harmony export */ isStaticArgOf: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticArgOf,
          /* harmony export */ isStaticExp: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp,
          /* harmony export */ isStaticProperty: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticProperty,
          /* harmony export */ isStaticPropertyKey: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticPropertyKey,
          /* harmony export */ isTemplateNode: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isTemplateNode,
          /* harmony export */ isText: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isText,
          /* harmony export */ isVSlot: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isVSlot,
          /* harmony export */ locStub: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.locStub,
          /* harmony export */ makeBlock: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.makeBlock,
          /* harmony export */ noopDirectiveTransform: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.noopDirectiveTransform,
          /* harmony export */ processExpression: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processExpression,
          /* harmony export */ processFor: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processFor,
          /* harmony export */ processIf: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processIf,
          /* harmony export */ processSlotOutlet: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processSlotOutlet,
          /* harmony export */ registerRuntimeHelpers: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeHelpers,
          /* harmony export */ resolveComponentType: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.resolveComponentType,
          /* harmony export */ toValidAssetId: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.toValidAssetId,
          /* harmony export */ trackSlotScopes: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.trackSlotScopes,
          /* harmony export */ trackVForSlotScopes: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.trackVForSlotScopes,
          /* harmony export */ transform: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transform,
          /* harmony export */ transformBind: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformBind,
          /* harmony export */ transformElement: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformElement,
          /* harmony export */ transformExpression: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformExpression,
          /* harmony export */ transformModel: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformModel,
          /* harmony export */ transformOn: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformOn,
          /* harmony export */ traverseNode: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.traverseNode,
          /* harmony export */ walkBlockDeclarations: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.walkBlockDeclarations,
          /* harmony export */ walkFunctionParams: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.walkFunctionParams,
          /* harmony export */ walkIdentifiers: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.walkIdentifiers,
          /* harmony export */ warnDeprecation: () =>
            /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.warnDeprecation,
          /* harmony export */ DOMDirectiveTransforms: () =>
            /* binding */ DOMDirectiveTransforms,
          /* harmony export */ DOMNodeTransforms: () =>
            /* binding */ DOMNodeTransforms,
          /* harmony export */ TRANSITION: () => /* binding */ TRANSITION,
          /* harmony export */ TRANSITION_GROUP: () =>
            /* binding */ TRANSITION_GROUP,
          /* harmony export */ V_MODEL_CHECKBOX: () =>
            /* binding */ V_MODEL_CHECKBOX,
          /* harmony export */ V_MODEL_DYNAMIC: () =>
            /* binding */ V_MODEL_DYNAMIC,
          /* harmony export */ V_MODEL_RADIO: () => /* binding */ V_MODEL_RADIO,
          /* harmony export */ V_MODEL_SELECT: () =>
            /* binding */ V_MODEL_SELECT,
          /* harmony export */ V_MODEL_TEXT: () => /* binding */ V_MODEL_TEXT,
          /* harmony export */ V_ON_WITH_KEYS: () =>
            /* binding */ V_ON_WITH_KEYS,
          /* harmony export */ V_ON_WITH_MODIFIERS: () =>
            /* binding */ V_ON_WITH_MODIFIERS,
          /* harmony export */ V_SHOW: () => /* binding */ V_SHOW,
          /* harmony export */ compile: () => /* binding */ compile,
          /* harmony export */ createDOMCompilerError: () =>
            /* binding */ createDOMCompilerError,
          /* harmony export */ parse: () => /* binding */ parse,
          /* harmony export */ parserOptions: () => /* binding */ parserOptions,
          /* harmony export */ transformStyle: () =>
            /* binding */ transformStyle,
          /* harmony export */
        });
        /* harmony import */ var _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! @vue/compiler-core */ './node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js'
          );
        /* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! @vue/shared */ './node_modules/@vue/shared/dist/shared.esm-bundler.js'
          );

        const V_MODEL_RADIO = Symbol(true ? `vModelRadio` : 0);
        const V_MODEL_CHECKBOX = Symbol(true ? `vModelCheckbox` : 0);
        const V_MODEL_TEXT = Symbol(true ? `vModelText` : 0);
        const V_MODEL_SELECT = Symbol(true ? `vModelSelect` : 0);
        const V_MODEL_DYNAMIC = Symbol(true ? `vModelDynamic` : 0);
        const V_ON_WITH_MODIFIERS = Symbol(true ? `vOnModifiersGuard` : 0);
        const V_ON_WITH_KEYS = Symbol(true ? `vOnKeysGuard` : 0);
        const V_SHOW = Symbol(true ? `vShow` : 0);
        const TRANSITION = Symbol(true ? `Transition` : 0);
        const TRANSITION_GROUP = Symbol(true ? `TransitionGroup` : 0);
        (0,
        _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeHelpers)(
          {
            [V_MODEL_RADIO]: `vModelRadio`,
            [V_MODEL_CHECKBOX]: `vModelCheckbox`,
            [V_MODEL_TEXT]: `vModelText`,
            [V_MODEL_SELECT]: `vModelSelect`,
            [V_MODEL_DYNAMIC]: `vModelDynamic`,
            [V_ON_WITH_MODIFIERS]: `withModifiers`,
            [V_ON_WITH_KEYS]: `withKeys`,
            [V_SHOW]: `vShow`,
            [TRANSITION]: `Transition`,
            [TRANSITION_GROUP]: `TransitionGroup`,
          }
        );

        /* eslint-disable no-restricted-globals */
        let decoder;
        function decodeHtmlBrowser(raw, asAttr = false) {
          if (!decoder) {
            decoder = document.createElement('div');
          }
          if (asAttr) {
            decoder.innerHTML = `<div foo="${raw.replace(/"/g, '&quot;')}">`;
            return decoder.children[0].getAttribute('foo');
          } else {
            decoder.innerHTML = raw;
            return decoder.textContent;
          }
        }

        const isRawTextContainer = /*#__PURE__*/ (0,
        _vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(
          'style,iframe,script,noscript',
          true
        );
        const parserOptions = {
          isVoidTag: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isVoidTag,
          isNativeTag: (tag) =>
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isHTMLTag)(tag) ||
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSVGTag)(tag),
          isPreTag: (tag) => tag === 'pre',
          decodeEntities: decodeHtmlBrowser,
          isBuiltInComponent: (tag) => {
            if (
              (0,
              _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isBuiltInType)(
                tag,
                `Transition`
              )
            ) {
              return TRANSITION;
            } else if (
              (0,
              _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isBuiltInType)(
                tag,
                `TransitionGroup`
              )
            ) {
              return TRANSITION_GROUP;
            }
          },
          // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
          getNamespace(tag, parent) {
            let ns = parent ? parent.ns : 0; /* HTML */
            if (parent && ns === 2 /* MATH_ML */) {
              if (parent.tag === 'annotation-xml') {
                if (tag === 'svg') {
                  return 1 /* SVG */;
                }
                if (
                  parent.props.some(
                    (a) =>
                      a.type === 6 /* ATTRIBUTE */ &&
                      a.name === 'encoding' &&
                      a.value != null &&
                      (a.value.content === 'text/html' ||
                        a.value.content === 'application/xhtml+xml')
                  )
                ) {
                  ns = 0 /* HTML */;
                }
              } else if (
                /^m(?:[ions]|text)$/.test(parent.tag) &&
                tag !== 'mglyph' &&
                tag !== 'malignmark'
              ) {
                ns = 0 /* HTML */;
              }
            } else if (parent && ns === 1 /* SVG */) {
              if (
                parent.tag === 'foreignObject' ||
                parent.tag === 'desc' ||
                parent.tag === 'title'
              ) {
                ns = 0 /* HTML */;
              }
            }
            if (ns === 0 /* HTML */) {
              if (tag === 'svg') {
                return 1 /* SVG */;
              }
              if (tag === 'math') {
                return 2 /* MATH_ML */;
              }
            }
            return ns;
          },
          // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
          getTextMode({ tag, ns }) {
            if (ns === 0 /* HTML */) {
              if (tag === 'textarea' || tag === 'title') {
                return 1 /* RCDATA */;
              }
              if (isRawTextContainer(tag)) {
                return 2 /* RAWTEXT */;
              }
            }
            return 0 /* DATA */;
          },
        };

        // Parse inline CSS strings for static style attributes into an object.
        // This is a NodeTransform since it works on the static `style` attribute and
        // converts it into a dynamic equivalent:
        // style="color: red" -> :style='{ "color": "red" }'
        // It is then processed by `transformElement` and included in the generated
        // props.
        const transformStyle = (node) => {
          if (node.type === 1 /* ELEMENT */) {
            node.props.forEach((p, i) => {
              if (
                p.type === 6 /* ATTRIBUTE */ &&
                p.name === 'style' &&
                p.value
              ) {
                // replace p with an expression node
                node.props[i] = {
                  type: 7 /* DIRECTIVE */,
                  name: `bind`,
                  arg: (0,
                  _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(
                    `style`,
                    true,
                    p.loc
                  ),
                  exp: parseInlineCSS(p.value.content, p.loc),
                  modifiers: [],
                  loc: p.loc,
                };
              }
            });
          }
        };
        const parseInlineCSS = (cssText, loc) => {
          const normalized = (0,
          _vue_shared__WEBPACK_IMPORTED_MODULE_1__.parseStringStyle)(cssText);
          return (0,
          _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(
            JSON.stringify(normalized),
            false,
            loc,
            3 /* CAN_STRINGIFY */
          );
        };

        function createDOMCompilerError(code, loc) {
          return (0,
          _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompilerError)(
            code,
            loc,
            true ? DOMErrorMessages : 0
          );
        }
        const DOMErrorMessages = {
          [50 /* X_V_HTML_NO_EXPRESSION */]: `v-html is missing expression.`,
          [51 /* X_V_HTML_WITH_CHILDREN */]: `v-html will override element children.`,
          [52 /* X_V_TEXT_NO_EXPRESSION */]: `v-text is missing expression.`,
          [53 /* X_V_TEXT_WITH_CHILDREN */]: `v-text will override element children.`,
          [54 /* X_V_MODEL_ON_INVALID_ELEMENT */]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
          [55 /* X_V_MODEL_ARG_ON_ELEMENT */]: `v-model argument is not supported on plain elements.`,
          [56 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
          [57 /* X_V_MODEL_UNNECESSARY_VALUE */]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
          [58 /* X_V_SHOW_NO_EXPRESSION */]: `v-show is missing expression.`,
          [59 /* X_TRANSITION_INVALID_CHILDREN */]: `<Transition> expects exactly one child element or component.`,
          [60 /* X_IGNORED_SIDE_EFFECT_TAG */]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`,
        };

        const transformVHtml = (dir, node, context) => {
          const { exp, loc } = dir;
          if (!exp) {
            context.onError(
              createDOMCompilerError(50 /* X_V_HTML_NO_EXPRESSION */, loc)
            );
          }
          if (node.children.length) {
            context.onError(
              createDOMCompilerError(51 /* X_V_HTML_WITH_CHILDREN */, loc)
            );
            node.children.length = 0;
          }
          return {
            props: [
              (0,
              _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)(
                (0,
                _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(
                  `innerHTML`,
                  true,
                  loc
                ),
                exp ||
                  (0,
                  _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(
                    '',
                    true
                  )
              ),
            ],
          };
        };

        const transformVText = (dir, node, context) => {
          const { exp, loc } = dir;
          if (!exp) {
            context.onError(
              createDOMCompilerError(52 /* X_V_TEXT_NO_EXPRESSION */, loc)
            );
          }
          if (node.children.length) {
            context.onError(
              createDOMCompilerError(53 /* X_V_TEXT_WITH_CHILDREN */, loc)
            );
            node.children.length = 0;
          }
          return {
            props: [
              (0,
              _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)(
                (0,
                _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(
                  `textContent`,
                  true
                ),
                exp
                  ? (0,
                    _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(
                      context.helperString(
                        _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_DISPLAY_STRING
                      ),
                      [exp],
                      loc
                    )
                  : (0,
                    _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(
                      '',
                      true
                    )
              ),
            ],
          };
        };

        const transformModel = (dir, node, context) => {
          const baseResult = (0,
          _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformModel)(
            dir,
            node,
            context
          );
          // base transform has errors OR component v-model (only need props)
          if (!baseResult.props.length || node.tagType === 1 /* COMPONENT */) {
            return baseResult;
          }
          if (dir.arg) {
            context.onError(
              createDOMCompilerError(
                55 /* X_V_MODEL_ARG_ON_ELEMENT */,
                dir.arg.loc
              )
            );
          }
          function checkDuplicatedValue() {
            const value = (0,
            _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp)(
              node,
              'value'
            );
            if (value) {
              context.onError(
                createDOMCompilerError(
                  57 /* X_V_MODEL_UNNECESSARY_VALUE */,
                  value.loc
                )
              );
            }
          }
          const { tag } = node;
          const isCustomElement = context.isCustomElement(tag);
          if (
            tag === 'input' ||
            tag === 'textarea' ||
            tag === 'select' ||
            isCustomElement
          ) {
            let directiveToUse = V_MODEL_TEXT;
            let isInvalidType = false;
            if (tag === 'input' || isCustomElement) {
              const type = (0,
              _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp)(
                node,
                `type`
              );
              if (type) {
                if (type.type === 7 /* DIRECTIVE */) {
                  // :type="foo"
                  directiveToUse = V_MODEL_DYNAMIC;
                } else if (type.value) {
                  switch (type.value.content) {
                    case 'radio':
                      directiveToUse = V_MODEL_RADIO;
                      break;
                    case 'checkbox':
                      directiveToUse = V_MODEL_CHECKBOX;
                      break;
                    case 'file':
                      isInvalidType = true;
                      context.onError(
                        createDOMCompilerError(
                          56 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */,
                          dir.loc
                        )
                      );
                      break;
                    default:
                      // text type
                      true && checkDuplicatedValue();
                      break;
                  }
                }
              } else if (
                (0,
                _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasDynamicKeyVBind)(
                  node
                )
              ) {
                // element has bindings with dynamic keys, which can possibly contain
                // "type".
                directiveToUse = V_MODEL_DYNAMIC;
              } else {
                // text type
                true && checkDuplicatedValue();
              }
            } else if (tag === 'select') {
              directiveToUse = V_MODEL_SELECT;
            } else {
              // textarea
              true && checkDuplicatedValue();
            }
            // inject runtime directive
            // by returning the helper symbol via needRuntime
            // the import will replaced a resolveDirective call.
            if (!isInvalidType) {
              baseResult.needRuntime = context.helper(directiveToUse);
            }
          } else {
            context.onError(
              createDOMCompilerError(
                54 /* X_V_MODEL_ON_INVALID_ELEMENT */,
                dir.loc
              )
            );
          }
          // native vmodel doesn't need the `modelValue` props since they are also
          // passed to the runtime as `binding.value`. removing it reduces code size.
          baseResult.props = baseResult.props.filter(
            (p) =>
              !(
                p.key.type === 4 /* SIMPLE_EXPRESSION */ &&
                p.key.content === 'modelValue'
              )
          );
          return baseResult;
        };

        const isEventOptionModifier = /*#__PURE__*/ (0,
        _vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(
          `passive,once,capture`
        );
        const isNonKeyModifier = /*#__PURE__*/ (0,
        _vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(
          // event propagation management
          `stop,prevent,self,` +
            // system modifiers + exact
            `ctrl,shift,alt,meta,exact,` +
            // mouse
            `middle`
        );
        // left & right could be mouse or key modifiers based on event type
        const maybeKeyModifier = /*#__PURE__*/ (0,
        _vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('left,right');
        const isKeyboardEvent = /*#__PURE__*/ (0,
        _vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(
          `onkeyup,onkeydown,onkeypress`,
          true
        );
        const resolveModifiers = (key, modifiers, context, loc) => {
          const keyModifiers = [];
          const nonKeyModifiers = [];
          const eventOptionModifiers = [];
          for (let i = 0; i < modifiers.length; i++) {
            const modifier = modifiers[i];
            if (
              modifier === 'native' &&
              (0,
              _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.checkCompatEnabled)(
                'COMPILER_V_ON_NATIVE' /* COMPILER_V_ON_NATIVE */,
                context,
                loc
              )
            ) {
              eventOptionModifiers.push(modifier);
            } else if (isEventOptionModifier(modifier)) {
              // eventOptionModifiers: modifiers for addEventListener() options,
              // e.g. .passive & .capture
              eventOptionModifiers.push(modifier);
            } else {
              // runtimeModifiers: modifiers that needs runtime guards
              if (maybeKeyModifier(modifier)) {
                if (
                  (0,
                  _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(
                    key
                  )
                ) {
                  if (isKeyboardEvent(key.content)) {
                    keyModifiers.push(modifier);
                  } else {
                    nonKeyModifiers.push(modifier);
                  }
                } else {
                  keyModifiers.push(modifier);
                  nonKeyModifiers.push(modifier);
                }
              } else {
                if (isNonKeyModifier(modifier)) {
                  nonKeyModifiers.push(modifier);
                } else {
                  keyModifiers.push(modifier);
                }
              }
            }
          }
          return {
            keyModifiers,
            nonKeyModifiers,
            eventOptionModifiers,
          };
        };
        const transformClick = (key, event) => {
          const isStaticClick =
            (0, _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(
              key
            ) && key.content.toLowerCase() === 'onclick';
          return isStaticClick
            ? (0,
              _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(
                event,
                true
              )
            : key.type !== 4 /* SIMPLE_EXPRESSION */
            ? (0,
              _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression)(
                [`(`, key, `) === "onClick" ? "${event}" : (`, key, `)`]
              )
            : key;
        };
        const transformOn = (dir, node, context) => {
          return (0,
          _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformOn)(
            dir,
            node,
            context,
            (baseResult) => {
              const { modifiers } = dir;
              if (!modifiers.length) return baseResult;
              let { key, value: handlerExp } = baseResult.props[0];
              const { keyModifiers, nonKeyModifiers, eventOptionModifiers } =
                resolveModifiers(key, modifiers, context, dir.loc);
              // normalize click.right and click.middle since they don't actually fire
              if (nonKeyModifiers.includes('right')) {
                key = transformClick(key, `onContextmenu`);
              }
              if (nonKeyModifiers.includes('middle')) {
                key = transformClick(key, `onMouseup`);
              }
              if (nonKeyModifiers.length) {
                handlerExp = (0,
                _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(
                  context.helper(V_ON_WITH_MODIFIERS),
                  [handlerExp, JSON.stringify(nonKeyModifiers)]
                );
              }
              if (
                keyModifiers.length &&
                // if event name is dynamic, always wrap with keys guard
                (!(0,
                _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(
                  key
                ) ||
                  isKeyboardEvent(key.content))
              ) {
                handlerExp = (0,
                _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(
                  context.helper(V_ON_WITH_KEYS),
                  [handlerExp, JSON.stringify(keyModifiers)]
                );
              }
              if (eventOptionModifiers.length) {
                const modifierPostfix = eventOptionModifiers
                  .map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)
                  .join('');
                key = (0,
                _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(
                  key
                )
                  ? (0,
                    _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(
                      `${key.content}${modifierPostfix}`,
                      true
                    )
                  : (0,
                    _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression)(
                      [`(`, key, `) + "${modifierPostfix}"`]
                    );
              }
              return {
                props: [
                  (0,
                  _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)(
                    key,
                    handlerExp
                  ),
                ],
              };
            }
          );
        };

        const transformShow = (dir, node, context) => {
          const { exp, loc } = dir;
          if (!exp) {
            context.onError(
              createDOMCompilerError(58 /* X_V_SHOW_NO_EXPRESSION */, loc)
            );
          }
          return {
            props: [],
            needRuntime: context.helper(V_SHOW),
          };
        };

        const warnTransitionChildren = (node, context) => {
          if (
            node.type === 1 /* ELEMENT */ &&
            node.tagType === 1 /* COMPONENT */
          ) {
            const component = context.isBuiltInComponent(node.tag);
            if (component === TRANSITION) {
              return () => {
                if (node.children.length && hasMultipleChildren(node)) {
                  context.onError(
                    createDOMCompilerError(
                      59 /* X_TRANSITION_INVALID_CHILDREN */,
                      {
                        start: node.children[0].loc.start,
                        end: node.children[node.children.length - 1].loc.end,
                        source: '',
                      }
                    )
                  );
                }
              };
            }
          }
        };
        function hasMultipleChildren(node) {
          // #1352 filter out potential comment nodes.
          const children = (node.children = node.children.filter(
            (c) =>
              c.type !== 3 /* COMMENT */ &&
              !(c.type === 2 /* TEXT */ && !c.content.trim())
          ));
          const child = children[0];
          return (
            children.length !== 1 ||
            child.type === 11 /* FOR */ ||
            (child.type === 9 /* IF */ &&
              child.branches.some(hasMultipleChildren))
          );
        }

        const ignoreSideEffectTags = (node, context) => {
          if (
            node.type === 1 /* ELEMENT */ &&
            node.tagType === 0 /* ELEMENT */ &&
            (node.tag === 'script' || node.tag === 'style')
          ) {
            context.onError(
              createDOMCompilerError(
                60 /* X_IGNORED_SIDE_EFFECT_TAG */,
                node.loc
              )
            );
            context.removeNode();
          }
        };

        const DOMNodeTransforms = [
          transformStyle,
          ...(true ? [warnTransitionChildren] : 0),
        ];
        const DOMDirectiveTransforms = {
          cloak:
            _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.noopDirectiveTransform,
          html: transformVHtml,
          text: transformVText,
          model: transformModel,
          on: transformOn,
          show: transformShow,
        };
        function compile(template, options = {}) {
          return (0,
          _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseCompile)(
            template,
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(
              {},
              parserOptions,
              options,
              {
                nodeTransforms: [
                  // ignore <script> and <tag>
                  // this is not put inside DOMNodeTransforms because that list is used
                  // by compiler-ssr to generate vnode fallback branches
                  ignoreSideEffectTags,
                  ...DOMNodeTransforms,
                  ...(options.nodeTransforms || []),
                ],
                directiveTransforms: (0,
                _vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(
                  {},
                  DOMDirectiveTransforms,
                  options.directiveTransforms || {}
                ),
                transformHoist: null,
              }
            )
          );
        }
        function parse(template, options = {}) {
          return (0, _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseParse)(
            template,
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(
              {},
              parserOptions,
              options
            )
          );
        }

        /***/
      },

    /***/ './node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js':
      /*!*********************************************************************!*\
  !*** ./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js ***!
  \*********************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ EffectScope: () => /* binding */ EffectScope,
          /* harmony export */ ITERATE_KEY: () => /* binding */ ITERATE_KEY,
          /* harmony export */ ReactiveEffect: () =>
            /* binding */ ReactiveEffect,
          /* harmony export */ computed: () => /* binding */ computed,
          /* harmony export */ customRef: () => /* binding */ customRef,
          /* harmony export */ deferredComputed: () =>
            /* binding */ deferredComputed,
          /* harmony export */ effect: () => /* binding */ effect,
          /* harmony export */ effectScope: () => /* binding */ effectScope,
          /* harmony export */ enableTracking: () =>
            /* binding */ enableTracking,
          /* harmony export */ getCurrentScope: () =>
            /* binding */ getCurrentScope,
          /* harmony export */ isProxy: () => /* binding */ isProxy,
          /* harmony export */ isReactive: () => /* binding */ isReactive,
          /* harmony export */ isReadonly: () => /* binding */ isReadonly,
          /* harmony export */ isRef: () => /* binding */ isRef,
          /* harmony export */ isShallow: () => /* binding */ isShallow,
          /* harmony export */ markRaw: () => /* binding */ markRaw,
          /* harmony export */ onScopeDispose: () =>
            /* binding */ onScopeDispose,
          /* harmony export */ pauseTracking: () => /* binding */ pauseTracking,
          /* harmony export */ proxyRefs: () => /* binding */ proxyRefs,
          /* harmony export */ reactive: () => /* binding */ reactive,
          /* harmony export */ readonly: () => /* binding */ readonly,
          /* harmony export */ ref: () => /* binding */ ref,
          /* harmony export */ resetTracking: () => /* binding */ resetTracking,
          /* harmony export */ shallowReactive: () =>
            /* binding */ shallowReactive,
          /* harmony export */ shallowReadonly: () =>
            /* binding */ shallowReadonly,
          /* harmony export */ shallowRef: () => /* binding */ shallowRef,
          /* harmony export */ stop: () => /* binding */ stop,
          /* harmony export */ toRaw: () => /* binding */ toRaw,
          /* harmony export */ toRef: () => /* binding */ toRef,
          /* harmony export */ toRefs: () => /* binding */ toRefs,
          /* harmony export */ track: () => /* binding */ track,
          /* harmony export */ trigger: () => /* binding */ trigger,
          /* harmony export */ triggerRef: () => /* binding */ triggerRef,
          /* harmony export */ unref: () => /* binding */ unref,
          /* harmony export */
        });
        /* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! @vue/shared */ './node_modules/@vue/shared/dist/shared.esm-bundler.js'
          );

        function warn(msg, ...args) {
          console.warn(`[Vue warn] ${msg}`, ...args);
        }

        let activeEffectScope;
        class EffectScope {
          constructor(detached = false) {
            this.active = true;
            this.effects = [];
            this.cleanups = [];
            if (!detached && activeEffectScope) {
              this.parent = activeEffectScope;
              this.index =
                (
                  activeEffectScope.scopes || (activeEffectScope.scopes = [])
                ).push(this) - 1;
            }
          }
          run(fn) {
            if (this.active) {
              try {
                activeEffectScope = this;
                return fn();
              } finally {
                activeEffectScope = this.parent;
              }
            } else if (true) {
              warn(`cannot run an inactive effect scope.`);
            }
          }
          on() {
            activeEffectScope = this;
          }
          off() {
            activeEffectScope = this.parent;
          }
          stop(fromParent) {
            if (this.active) {
              let i, l;
              for (i = 0, l = this.effects.length; i < l; i++) {
                this.effects[i].stop();
              }
              for (i = 0, l = this.cleanups.length; i < l; i++) {
                this.cleanups[i]();
              }
              if (this.scopes) {
                for (i = 0, l = this.scopes.length; i < l; i++) {
                  this.scopes[i].stop(true);
                }
              }
              // nested scope, dereference from parent to avoid memory leaks
              if (this.parent && !fromParent) {
                // optimized O(1) removal
                const last = this.parent.scopes.pop();
                if (last && last !== this) {
                  this.parent.scopes[this.index] = last;
                  last.index = this.index;
                }
              }
              this.active = false;
            }
          }
        }
        function effectScope(detached) {
          return new EffectScope(detached);
        }
        function recordEffectScope(effect, scope = activeEffectScope) {
          if (scope && scope.active) {
            scope.effects.push(effect);
          }
        }
        function getCurrentScope() {
          return activeEffectScope;
        }
        function onScopeDispose(fn) {
          if (activeEffectScope) {
            activeEffectScope.cleanups.push(fn);
          } else if (true) {
            warn(
              `onScopeDispose() is called when there is no active effect scope` +
                ` to be associated with.`
            );
          }
        }

        const createDep = (effects) => {
          const dep = new Set(effects);
          dep.w = 0;
          dep.n = 0;
          return dep;
        };
        const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
        const newTracked = (dep) => (dep.n & trackOpBit) > 0;
        const initDepMarkers = ({ deps }) => {
          if (deps.length) {
            for (let i = 0; i < deps.length; i++) {
              deps[i].w |= trackOpBit; // set was tracked
            }
          }
        };
        const finalizeDepMarkers = (effect) => {
          const { deps } = effect;
          if (deps.length) {
            let ptr = 0;
            for (let i = 0; i < deps.length; i++) {
              const dep = deps[i];
              if (wasTracked(dep) && !newTracked(dep)) {
                dep.delete(effect);
              } else {
                deps[ptr++] = dep;
              }
              // clear bits
              dep.w &= ~trackOpBit;
              dep.n &= ~trackOpBit;
            }
            deps.length = ptr;
          }
        };

        const targetMap = new WeakMap();
        // The number of effects currently being tracked recursively.
        let effectTrackDepth = 0;
        let trackOpBit = 1;
        /**
         * The bitwise track markers support at most 30 levels of recursion.
         * This value is chosen to enable modern JS engines to use a SMI on all platforms.
         * When recursion depth is greater, fall back to using a full cleanup.
         */
        const maxMarkerBits = 30;
        let activeEffect;
        const ITERATE_KEY = Symbol(true ? 'iterate' : 0);
        const MAP_KEY_ITERATE_KEY = Symbol(true ? 'Map key iterate' : 0);
        class ReactiveEffect {
          constructor(fn, scheduler = null, scope) {
            this.fn = fn;
            this.scheduler = scheduler;
            this.active = true;
            this.deps = [];
            this.parent = undefined;
            recordEffectScope(this, scope);
          }
          run() {
            if (!this.active) {
              return this.fn();
            }
            let parent = activeEffect;
            let lastShouldTrack = shouldTrack;
            while (parent) {
              if (parent === this) {
                return;
              }
              parent = parent.parent;
            }
            try {
              this.parent = activeEffect;
              activeEffect = this;
              shouldTrack = true;
              trackOpBit = 1 << ++effectTrackDepth;
              if (effectTrackDepth <= maxMarkerBits) {
                initDepMarkers(this);
              } else {
                cleanupEffect(this);
              }
              return this.fn();
            } finally {
              if (effectTrackDepth <= maxMarkerBits) {
                finalizeDepMarkers(this);
              }
              trackOpBit = 1 << --effectTrackDepth;
              activeEffect = this.parent;
              shouldTrack = lastShouldTrack;
              this.parent = undefined;
            }
          }
          stop() {
            if (this.active) {
              cleanupEffect(this);
              if (this.onStop) {
                this.onStop();
              }
              this.active = false;
            }
          }
        }
        function cleanupEffect(effect) {
          const { deps } = effect;
          if (deps.length) {
            for (let i = 0; i < deps.length; i++) {
              deps[i].delete(effect);
            }
            deps.length = 0;
          }
        }
        function effect(fn, options) {
          if (fn.effect) {
            fn = fn.effect.fn;
          }
          const _effect = new ReactiveEffect(fn);
          if (options) {
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(
              _effect,
              options
            );
            if (options.scope) recordEffectScope(_effect, options.scope);
          }
          if (!options || !options.lazy) {
            _effect.run();
          }
          const runner = _effect.run.bind(_effect);
          runner.effect = _effect;
          return runner;
        }
        function stop(runner) {
          runner.effect.stop();
        }
        let shouldTrack = true;
        const trackStack = [];
        function pauseTracking() {
          trackStack.push(shouldTrack);
          shouldTrack = false;
        }
        function enableTracking() {
          trackStack.push(shouldTrack);
          shouldTrack = true;
        }
        function resetTracking() {
          const last = trackStack.pop();
          shouldTrack = last === undefined ? true : last;
        }
        function track(target, type, key) {
          if (shouldTrack && activeEffect) {
            let depsMap = targetMap.get(target);
            if (!depsMap) {
              targetMap.set(target, (depsMap = new Map()));
            }
            let dep = depsMap.get(key);
            if (!dep) {
              depsMap.set(key, (dep = createDep()));
            }
            const eventInfo = true
              ? { effect: activeEffect, target, type, key }
              : 0;
            trackEffects(dep, eventInfo);
          }
        }
        function trackEffects(dep, debuggerEventExtraInfo) {
          let shouldTrack = false;
          if (effectTrackDepth <= maxMarkerBits) {
            if (!newTracked(dep)) {
              dep.n |= trackOpBit; // set newly tracked
              shouldTrack = !wasTracked(dep);
            }
          } else {
            // Full cleanup mode.
            shouldTrack = !dep.has(activeEffect);
          }
          if (shouldTrack) {
            dep.add(activeEffect);
            activeEffect.deps.push(dep);
            if (true && activeEffect.onTrack) {
              activeEffect.onTrack(
                Object.assign(
                  {
                    effect: activeEffect,
                  },
                  debuggerEventExtraInfo
                )
              );
            }
          }
        }
        function trigger(target, type, key, newValue, oldValue, oldTarget) {
          const depsMap = targetMap.get(target);
          if (!depsMap) {
            // never been tracked
            return;
          }
          let deps = [];
          if (type === 'clear' /* CLEAR */) {
            // collection being cleared
            // trigger all effects for target
            deps = [...depsMap.values()];
          } else if (
            key === 'length' &&
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)
          ) {
            depsMap.forEach((dep, key) => {
              if (key === 'length' || key >= newValue) {
                deps.push(dep);
              }
            });
          } else {
            // schedule runs for SET | ADD | DELETE
            if (key !== void 0) {
              deps.push(depsMap.get(key));
            }
            // also run for iteration key on ADD | DELETE | Map.SET
            switch (type) {
              case 'add' /* ADD */:
                if (
                  !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)
                ) {
                  deps.push(depsMap.get(ITERATE_KEY));
                  if (
                    (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)
                  ) {
                    deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                  }
                } else if (
                  (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(
                    key
                  )
                ) {
                  // new index added to array -> length changes
                  deps.push(depsMap.get('length'));
                }
                break;
              case 'delete' /* DELETE */:
                if (
                  !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)
                ) {
                  deps.push(depsMap.get(ITERATE_KEY));
                  if (
                    (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)
                  ) {
                    deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                  }
                }
                break;
              case 'set' /* SET */:
                if (
                  (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)
                ) {
                  deps.push(depsMap.get(ITERATE_KEY));
                }
                break;
            }
          }
          const eventInfo = true
            ? { target, type, key, newValue, oldValue, oldTarget }
            : 0;
          if (deps.length === 1) {
            if (deps[0]) {
              if (true) {
                triggerEffects(deps[0], eventInfo);
              } else {
              }
            }
          } else {
            const effects = [];
            for (const dep of deps) {
              if (dep) {
                effects.push(...dep);
              }
            }
            if (true) {
              triggerEffects(createDep(effects), eventInfo);
            } else {
            }
          }
        }
        function triggerEffects(dep, debuggerEventExtraInfo) {
          // spread into array for stabilization
          for (const effect of (0,
          _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(dep)
            ? dep
            : [...dep]) {
            if (effect !== activeEffect || effect.allowRecurse) {
              if (true && effect.onTrigger) {
                effect.onTrigger(
                  (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(
                    { effect },
                    debuggerEventExtraInfo
                  )
                );
              }
              if (effect.scheduler) {
                effect.scheduler();
              } else {
                effect.run();
              }
            }
          }
        }

        const isNonTrackableKeys = /*#__PURE__*/ (0,
        _vue_shared__WEBPACK_IMPORTED_MODULE_0__.makeMap)(
          `__proto__,__v_isRef,__isVue`
        );
        const builtInSymbols = new Set(
          Object.getOwnPropertyNames(Symbol)
            .map((key) => Symbol[key])
            .filter(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)
        );
        const get = /*#__PURE__*/ createGetter();
        const shallowGet = /*#__PURE__*/ createGetter(false, true);
        const readonlyGet = /*#__PURE__*/ createGetter(true);
        const shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);
        const arrayInstrumentations =
          /*#__PURE__*/ createArrayInstrumentations();
        function createArrayInstrumentations() {
          const instrumentations = {};
          ['includes', 'indexOf', 'lastIndexOf'].forEach((key) => {
            instrumentations[key] = function (...args) {
              const arr = toRaw(this);
              for (let i = 0, l = this.length; i < l; i++) {
                track(arr, 'get' /* GET */, i + '');
              }
              // we run the method using the original args first (which may be reactive)
              const res = arr[key](...args);
              if (res === -1 || res === false) {
                // if that didn't work, run it again using raw values.
                return arr[key](...args.map(toRaw));
              } else {
                return res;
              }
            };
          });
          ['push', 'pop', 'shift', 'unshift', 'splice'].forEach((key) => {
            instrumentations[key] = function (...args) {
              pauseTracking();
              const res = toRaw(this)[key].apply(this, args);
              resetTracking();
              return res;
            };
          });
          return instrumentations;
        }
        function createGetter(isReadonly = false, shallow = false) {
          return function get(target, key, receiver) {
            if (key === '__v_isReactive' /* IS_REACTIVE */) {
              return !isReadonly;
            } else if (key === '__v_isReadonly' /* IS_READONLY */) {
              return isReadonly;
            } else if (key === '__v_isShallow' /* IS_SHALLOW */) {
              return shallow;
            } else if (
              key === '__v_raw' /* RAW */ &&
              receiver ===
                (isReadonly
                  ? shallow
                    ? shallowReadonlyMap
                    : readonlyMap
                  : shallow
                  ? shallowReactiveMap
                  : reactiveMap
                ).get(target)
            ) {
              return target;
            }
            const targetIsArray = (0,
            _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target);
            if (
              !isReadonly &&
              targetIsArray &&
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(
                arrayInstrumentations,
                key
              )
            ) {
              return Reflect.get(arrayInstrumentations, key, receiver);
            }
            const res = Reflect.get(target, key, receiver);
            if (
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key)
                ? builtInSymbols.has(key)
                : isNonTrackableKeys(key)
            ) {
              return res;
            }
            if (!isReadonly) {
              track(target, 'get' /* GET */, key);
            }
            if (shallow) {
              return res;
            }
            if (isRef(res)) {
              // ref unwrapping - does not apply for Array + integer key.
              const shouldUnwrap =
                !targetIsArray ||
                !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(
                  key
                );
              return shouldUnwrap ? res.value : res;
            }
            if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(res)) {
              // Convert returned value into a proxy as well. we do the isObject check
              // here to avoid invalid value warning. Also need to lazy access readonly
              // and reactive here to avoid circular dependency.
              return isReadonly ? readonly(res) : reactive(res);
            }
            return res;
          };
        }
        const set = /*#__PURE__*/ createSetter();
        const shallowSet = /*#__PURE__*/ createSetter(true);
        function createSetter(shallow = false) {
          return function set(target, key, value, receiver) {
            let oldValue = target[key];
            if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
              return false;
            }
            if (!shallow && !isReadonly(value)) {
              if (!isShallow(value)) {
                value = toRaw(value);
                oldValue = toRaw(oldValue);
              }
              if (
                !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(
                  target
                ) &&
                isRef(oldValue) &&
                !isRef(value)
              ) {
                oldValue.value = value;
                return true;
              }
            }
            const hadKey =
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) &&
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key)
                ? Number(key) < target.length
                : (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(
                    target,
                    key
                  );
            const result = Reflect.set(target, key, value, receiver);
            // don't trigger if target is something up in the prototype chain of original
            if (target === toRaw(receiver)) {
              if (!hadKey) {
                trigger(target, 'add' /* ADD */, key, value);
              } else if (
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(
                  value,
                  oldValue
                )
              ) {
                trigger(target, 'set' /* SET */, key, value, oldValue);
              }
            }
            return result;
          };
        }
        function deleteProperty(target, key) {
          const hadKey = (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(
            target,
            key
          );
          const oldValue = target[key];
          const result = Reflect.deleteProperty(target, key);
          if (result && hadKey) {
            trigger(target, 'delete' /* DELETE */, key, undefined, oldValue);
          }
          return result;
        }
        function has(target, key) {
          const result = Reflect.has(target, key);
          if (
            !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) ||
            !builtInSymbols.has(key)
          ) {
            track(target, 'has' /* HAS */, key);
          }
          return result;
        }
        function ownKeys(target) {
          track(
            target,
            'iterate' /* ITERATE */,
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)
              ? 'length'
              : ITERATE_KEY
          );
          return Reflect.ownKeys(target);
        }
        const mutableHandlers = {
          get,
          set,
          deleteProperty,
          has,
          ownKeys,
        };
        const readonlyHandlers = {
          get: readonlyGet,
          set(target, key) {
            if (true) {
              console.warn(
                `Set operation on key "${String(
                  key
                )}" failed: target is readonly.`,
                target
              );
            }
            return true;
          },
          deleteProperty(target, key) {
            if (true) {
              console.warn(
                `Delete operation on key "${String(
                  key
                )}" failed: target is readonly.`,
                target
              );
            }
            return true;
          },
        };
        const shallowReactiveHandlers = /*#__PURE__*/ (0,
        _vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, mutableHandlers, {
          get: shallowGet,
          set: shallowSet,
        });
        // Props handlers are special in the sense that it should not unwrap top-level
        // refs (in order to allow refs to be explicitly passed down), but should
        // retain the reactivity of the normal readonly object.
        const shallowReadonlyHandlers = /*#__PURE__*/ (0,
        _vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, readonlyHandlers, {
          get: shallowReadonlyGet,
        });

        const toShallow = (value) => value;
        const getProto = (v) => Reflect.getPrototypeOf(v);
        function get$1(target, key, isReadonly = false, isShallow = false) {
          // #1772: readonly(reactive(Map)) should return readonly + reactive version
          // of the value
          target = target['__v_raw' /* RAW */];
          const rawTarget = toRaw(target);
          const rawKey = toRaw(key);
          if (key !== rawKey) {
            !isReadonly && track(rawTarget, 'get' /* GET */, key);
          }
          !isReadonly && track(rawTarget, 'get' /* GET */, rawKey);
          const { has } = getProto(rawTarget);
          const wrap = isShallow
            ? toShallow
            : isReadonly
            ? toReadonly
            : toReactive;
          if (has.call(rawTarget, key)) {
            return wrap(target.get(key));
          } else if (has.call(rawTarget, rawKey)) {
            return wrap(target.get(rawKey));
          } else if (target !== rawTarget) {
            // #3602 readonly(reactive(Map))
            // ensure that the nested reactive `Map` can do tracking for itself
            target.get(key);
          }
        }
        function has$1(key, isReadonly = false) {
          const target = this['__v_raw' /* RAW */];
          const rawTarget = toRaw(target);
          const rawKey = toRaw(key);
          if (key !== rawKey) {
            !isReadonly && track(rawTarget, 'has' /* HAS */, key);
          }
          !isReadonly && track(rawTarget, 'has' /* HAS */, rawKey);
          return key === rawKey
            ? target.has(key)
            : target.has(key) || target.has(rawKey);
        }
        function size(target, isReadonly = false) {
          target = target['__v_raw' /* RAW */];
          !isReadonly &&
            track(toRaw(target), 'iterate' /* ITERATE */, ITERATE_KEY);
          return Reflect.get(target, 'size', target);
        }
        function add(value) {
          value = toRaw(value);
          const target = toRaw(this);
          const proto = getProto(target);
          const hadKey = proto.has.call(target, value);
          if (!hadKey) {
            target.add(value);
            trigger(target, 'add' /* ADD */, value, value);
          }
          return this;
        }
        function set$1(key, value) {
          value = toRaw(value);
          const target = toRaw(this);
          const { has, get } = getProto(target);
          let hadKey = has.call(target, key);
          if (!hadKey) {
            key = toRaw(key);
            hadKey = has.call(target, key);
          } else if (true) {
            checkIdentityKeys(target, has, key);
          }
          const oldValue = get.call(target, key);
          target.set(key, value);
          if (!hadKey) {
            trigger(target, 'add' /* ADD */, key, value);
          } else if (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(
              value,
              oldValue
            )
          ) {
            trigger(target, 'set' /* SET */, key, value, oldValue);
          }
          return this;
        }
        function deleteEntry(key) {
          const target = toRaw(this);
          const { has, get } = getProto(target);
          let hadKey = has.call(target, key);
          if (!hadKey) {
            key = toRaw(key);
            hadKey = has.call(target, key);
          } else if (true) {
            checkIdentityKeys(target, has, key);
          }
          const oldValue = get ? get.call(target, key) : undefined;
          // forward the operation before queueing reactions
          const result = target.delete(key);
          if (hadKey) {
            trigger(target, 'delete' /* DELETE */, key, undefined, oldValue);
          }
          return result;
        }
        function clear() {
          const target = toRaw(this);
          const hadItems = target.size !== 0;
          const oldTarget = true
            ? (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)
              ? new Map(target)
              : new Set(target)
            : 0;
          // forward the operation before queueing reactions
          const result = target.clear();
          if (hadItems) {
            trigger(
              target,
              'clear' /* CLEAR */,
              undefined,
              undefined,
              oldTarget
            );
          }
          return result;
        }
        function createForEach(isReadonly, isShallow) {
          return function forEach(callback, thisArg) {
            const observed = this;
            const target = observed['__v_raw' /* RAW */];
            const rawTarget = toRaw(target);
            const wrap = isShallow
              ? toShallow
              : isReadonly
              ? toReadonly
              : toReactive;
            !isReadonly &&
              track(rawTarget, 'iterate' /* ITERATE */, ITERATE_KEY);
            return target.forEach((value, key) => {
              // important: make sure the callback is
              // 1. invoked with the reactive map as `this` and 3rd arg
              // 2. the value received should be a corresponding reactive/readonly.
              return callback.call(thisArg, wrap(value), wrap(key), observed);
            });
          };
        }
        function createIterableMethod(method, isReadonly, isShallow) {
          return function (...args) {
            const target = this['__v_raw' /* RAW */];
            const rawTarget = toRaw(target);
            const targetIsMap = (0,
            _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(rawTarget);
            const isPair =
              method === 'entries' ||
              (method === Symbol.iterator && targetIsMap);
            const isKeyOnly = method === 'keys' && targetIsMap;
            const innerIterator = target[method](...args);
            const wrap = isShallow
              ? toShallow
              : isReadonly
              ? toReadonly
              : toReactive;
            !isReadonly &&
              track(
                rawTarget,
                'iterate' /* ITERATE */,
                isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
              );
            // return a wrapped iterator which returns observed versions of the
            // values emitted from the real iterator
            return {
              // iterator protocol
              next() {
                const { value, done } = innerIterator.next();
                return done
                  ? { value, done }
                  : {
                      value: isPair
                        ? [wrap(value[0]), wrap(value[1])]
                        : wrap(value),
                      done,
                    };
              },
              // iterable protocol
              [Symbol.iterator]() {
                return this;
              },
            };
          };
        }
        function createReadonlyMethod(type) {
          return function (...args) {
            if (true) {
              const key = args[0] ? `on key "${args[0]}" ` : ``;
              console.warn(
                `${(0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.capitalize)(
                  type
                )} operation ${key}failed: target is readonly.`,
                toRaw(this)
              );
            }
            return type === 'delete' /* DELETE */ ? false : this;
          };
        }
        function createInstrumentations() {
          const mutableInstrumentations = {
            get(key) {
              return get$1(this, key);
            },
            get size() {
              return size(this);
            },
            has: has$1,
            add,
            set: set$1,
            delete: deleteEntry,
            clear,
            forEach: createForEach(false, false),
          };
          const shallowInstrumentations = {
            get(key) {
              return get$1(this, key, false, true);
            },
            get size() {
              return size(this);
            },
            has: has$1,
            add,
            set: set$1,
            delete: deleteEntry,
            clear,
            forEach: createForEach(false, true),
          };
          const readonlyInstrumentations = {
            get(key) {
              return get$1(this, key, true);
            },
            get size() {
              return size(this, true);
            },
            has(key) {
              return has$1.call(this, key, true);
            },
            add: createReadonlyMethod('add' /* ADD */),
            set: createReadonlyMethod('set' /* SET */),
            delete: createReadonlyMethod('delete' /* DELETE */),
            clear: createReadonlyMethod('clear' /* CLEAR */),
            forEach: createForEach(true, false),
          };
          const shallowReadonlyInstrumentations = {
            get(key) {
              return get$1(this, key, true, true);
            },
            get size() {
              return size(this, true);
            },
            has(key) {
              return has$1.call(this, key, true);
            },
            add: createReadonlyMethod('add' /* ADD */),
            set: createReadonlyMethod('set' /* SET */),
            delete: createReadonlyMethod('delete' /* DELETE */),
            clear: createReadonlyMethod('clear' /* CLEAR */),
            forEach: createForEach(true, true),
          };
          const iteratorMethods = [
            'keys',
            'values',
            'entries',
            Symbol.iterator,
          ];
          iteratorMethods.forEach((method) => {
            mutableInstrumentations[method] = createIterableMethod(
              method,
              false,
              false
            );
            readonlyInstrumentations[method] = createIterableMethod(
              method,
              true,
              false
            );
            shallowInstrumentations[method] = createIterableMethod(
              method,
              false,
              true
            );
            shallowReadonlyInstrumentations[method] = createIterableMethod(
              method,
              true,
              true
            );
          });
          return [
            mutableInstrumentations,
            readonlyInstrumentations,
            shallowInstrumentations,
            shallowReadonlyInstrumentations,
          ];
        }
        const [
          mutableInstrumentations,
          readonlyInstrumentations,
          shallowInstrumentations,
          shallowReadonlyInstrumentations,
        ] = /* #__PURE__*/ createInstrumentations();
        function createInstrumentationGetter(isReadonly, shallow) {
          const instrumentations = shallow
            ? isReadonly
              ? shallowReadonlyInstrumentations
              : shallowInstrumentations
            : isReadonly
            ? readonlyInstrumentations
            : mutableInstrumentations;
          return (target, key, receiver) => {
            if (key === '__v_isReactive' /* IS_REACTIVE */) {
              return !isReadonly;
            } else if (key === '__v_isReadonly' /* IS_READONLY */) {
              return isReadonly;
            } else if (key === '__v_raw' /* RAW */) {
              return target;
            }
            return Reflect.get(
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(
                instrumentations,
                key
              ) && key in target
                ? instrumentations
                : target,
              key,
              receiver
            );
          };
        }
        const mutableCollectionHandlers = {
          get: /*#__PURE__*/ createInstrumentationGetter(false, false),
        };
        const shallowCollectionHandlers = {
          get: /*#__PURE__*/ createInstrumentationGetter(false, true),
        };
        const readonlyCollectionHandlers = {
          get: /*#__PURE__*/ createInstrumentationGetter(true, false),
        };
        const shallowReadonlyCollectionHandlers = {
          get: /*#__PURE__*/ createInstrumentationGetter(true, true),
        };
        function checkIdentityKeys(target, has, key) {
          const rawKey = toRaw(key);
          if (rawKey !== key && has.call(target, rawKey)) {
            const type = (0,
            _vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(target);
            console.warn(
              `Reactive ${type} contains both the raw and reactive ` +
                `versions of the same object${
                  type === `Map` ? ` as keys` : ``
                }, ` +
                `which can lead to inconsistencies. ` +
                `Avoid differentiating between the raw and reactive versions ` +
                `of an object and only use the reactive version if possible.`
            );
          }
        }

        const reactiveMap = new WeakMap();
        const shallowReactiveMap = new WeakMap();
        const readonlyMap = new WeakMap();
        const shallowReadonlyMap = new WeakMap();
        function targetTypeMap(rawType) {
          switch (rawType) {
            case 'Object':
            case 'Array':
              return 1 /* COMMON */;
            case 'Map':
            case 'Set':
            case 'WeakMap':
            case 'WeakSet':
              return 2 /* COLLECTION */;
            default:
              return 0 /* INVALID */;
          }
        }
        function getTargetType(value) {
          return value['__v_skip' /* SKIP */] || !Object.isExtensible(value)
            ? 0 /* INVALID */
            : targetTypeMap(
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(value)
              );
        }
        function reactive(target) {
          // if trying to observe a readonly proxy, return the readonly version.
          if (isReadonly(target)) {
            return target;
          }
          return createReactiveObject(
            target,
            false,
            mutableHandlers,
            mutableCollectionHandlers,
            reactiveMap
          );
        }
        /**
         * Return a shallowly-reactive copy of the original object, where only the root
         * level properties are reactive. It also does not auto-unwrap refs (even at the
         * root level).
         */
        function shallowReactive(target) {
          return createReactiveObject(
            target,
            false,
            shallowReactiveHandlers,
            shallowCollectionHandlers,
            shallowReactiveMap
          );
        }
        /**
         * Creates a readonly copy of the original object. Note the returned copy is not
         * made reactive, but `readonly` can be called on an already reactive object.
         */
        function readonly(target) {
          return createReactiveObject(
            target,
            true,
            readonlyHandlers,
            readonlyCollectionHandlers,
            readonlyMap
          );
        }
        /**
         * Returns a reactive-copy of the original object, where only the root level
         * properties are readonly, and does NOT unwrap refs nor recursively convert
         * returned properties.
         * This is used for creating the props proxy object for stateful components.
         */
        function shallowReadonly(target) {
          return createReactiveObject(
            target,
            true,
            shallowReadonlyHandlers,
            shallowReadonlyCollectionHandlers,
            shallowReadonlyMap
          );
        }
        function createReactiveObject(
          target,
          isReadonly,
          baseHandlers,
          collectionHandlers,
          proxyMap
        ) {
          if (!(0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(target)) {
            if (true) {
              console.warn(`value cannot be made reactive: ${String(target)}`);
            }
            return target;
          }
          // target is already a Proxy, return it.
          // exception: calling readonly() on a reactive object
          if (
            target['__v_raw' /* RAW */] &&
            !(isReadonly && target['__v_isReactive' /* IS_REACTIVE */])
          ) {
            return target;
          }
          // target already has corresponding Proxy
          const existingProxy = proxyMap.get(target);
          if (existingProxy) {
            return existingProxy;
          }
          // only a whitelist of value types can be observed.
          const targetType = getTargetType(target);
          if (targetType === 0 /* INVALID */) {
            return target;
          }
          const proxy = new Proxy(
            target,
            targetType === 2 /* COLLECTION */
              ? collectionHandlers
              : baseHandlers
          );
          proxyMap.set(target, proxy);
          return proxy;
        }
        function isReactive(value) {
          if (isReadonly(value)) {
            return isReactive(value['__v_raw' /* RAW */]);
          }
          return !!(value && value['__v_isReactive' /* IS_REACTIVE */]);
        }
        function isReadonly(value) {
          return !!(value && value['__v_isReadonly' /* IS_READONLY */]);
        }
        function isShallow(value) {
          return !!(value && value['__v_isShallow' /* IS_SHALLOW */]);
        }
        function isProxy(value) {
          return isReactive(value) || isReadonly(value);
        }
        function toRaw(observed) {
          const raw = observed && observed['__v_raw' /* RAW */];
          return raw ? toRaw(raw) : observed;
        }
        function markRaw(value) {
          (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.def)(
            value,
            '__v_skip' /* SKIP */,
            true
          );
          return value;
        }
        const toReactive = (value) =>
          (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value)
            ? reactive(value)
            : value;
        const toReadonly = (value) =>
          (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value)
            ? readonly(value)
            : value;

        function trackRefValue(ref) {
          if (shouldTrack && activeEffect) {
            ref = toRaw(ref);
            if (true) {
              trackEffects(ref.dep || (ref.dep = createDep()), {
                target: ref,
                type: 'get' /* GET */,
                key: 'value',
              });
            } else {
            }
          }
        }
        function triggerRefValue(ref, newVal) {
          ref = toRaw(ref);
          if (ref.dep) {
            if (true) {
              triggerEffects(ref.dep, {
                target: ref,
                type: 'set' /* SET */,
                key: 'value',
                newValue: newVal,
              });
            } else {
            }
          }
        }
        function isRef(r) {
          return !!(r && r.__v_isRef === true);
        }
        function ref(value) {
          return createRef(value, false);
        }
        function shallowRef(value) {
          return createRef(value, true);
        }
        function createRef(rawValue, shallow) {
          if (isRef(rawValue)) {
            return rawValue;
          }
          return new RefImpl(rawValue, shallow);
        }
        class RefImpl {
          constructor(value, __v_isShallow) {
            this.__v_isShallow = __v_isShallow;
            this.dep = undefined;
            this.__v_isRef = true;
            this._rawValue = __v_isShallow ? value : toRaw(value);
            this._value = __v_isShallow ? value : toReactive(value);
          }
          get value() {
            trackRefValue(this);
            return this._value;
          }
          set value(newVal) {
            newVal = this.__v_isShallow ? newVal : toRaw(newVal);
            if (
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(
                newVal,
                this._rawValue
              )
            ) {
              this._rawValue = newVal;
              this._value = this.__v_isShallow ? newVal : toReactive(newVal);
              triggerRefValue(this, newVal);
            }
          }
        }
        function triggerRef(ref) {
          triggerRefValue(ref, true ? ref.value : 0);
        }
        function unref(ref) {
          return isRef(ref) ? ref.value : ref;
        }
        const shallowUnwrapHandlers = {
          get: (target, key, receiver) =>
            unref(Reflect.get(target, key, receiver)),
          set: (target, key, value, receiver) => {
            const oldValue = target[key];
            if (isRef(oldValue) && !isRef(value)) {
              oldValue.value = value;
              return true;
            } else {
              return Reflect.set(target, key, value, receiver);
            }
          },
        };
        function proxyRefs(objectWithRefs) {
          return isReactive(objectWithRefs)
            ? objectWithRefs
            : new Proxy(objectWithRefs, shallowUnwrapHandlers);
        }
        class CustomRefImpl {
          constructor(factory) {
            this.dep = undefined;
            this.__v_isRef = true;
            const { get, set } = factory(
              () => trackRefValue(this),
              () => triggerRefValue(this)
            );
            this._get = get;
            this._set = set;
          }
          get value() {
            return this._get();
          }
          set value(newVal) {
            this._set(newVal);
          }
        }
        function customRef(factory) {
          return new CustomRefImpl(factory);
        }
        function toRefs(object) {
          if (true && !isProxy(object)) {
            console.warn(
              `toRefs() expects a reactive object but received a plain one.`
            );
          }
          const ret = (0, _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(
            object
          )
            ? new Array(object.length)
            : {};
          for (const key in object) {
            ret[key] = toRef(object, key);
          }
          return ret;
        }
        class ObjectRefImpl {
          constructor(_object, _key, _defaultValue) {
            this._object = _object;
            this._key = _key;
            this._defaultValue = _defaultValue;
            this.__v_isRef = true;
          }
          get value() {
            const val = this._object[this._key];
            return val === undefined ? this._defaultValue : val;
          }
          set value(newVal) {
            this._object[this._key] = newVal;
          }
        }
        function toRef(object, key, defaultValue) {
          const val = object[key];
          return isRef(val)
            ? val
            : new ObjectRefImpl(object, key, defaultValue);
        }

        class ComputedRefImpl {
          constructor(getter, _setter, isReadonly, isSSR) {
            this._setter = _setter;
            this.dep = undefined;
            this.__v_isRef = true;
            this._dirty = true;
            this.effect = new ReactiveEffect(getter, () => {
              if (!this._dirty) {
                this._dirty = true;
                triggerRefValue(this);
              }
            });
            this.effect.computed = this;
            this.effect.active = this._cacheable = !isSSR;
            this['__v_isReadonly' /* IS_READONLY */] = isReadonly;
          }
          get value() {
            // the computed ref may get wrapped by other proxies e.g. readonly() #3376
            const self = toRaw(this);
            trackRefValue(self);
            if (self._dirty || !self._cacheable) {
              self._dirty = false;
              self._value = self.effect.run();
            }
            return self._value;
          }
          set value(newValue) {
            this._setter(newValue);
          }
        }
        function computed(getterOrOptions, debugOptions, isSSR = false) {
          let getter;
          let setter;
          const onlyGetter = (0,
          _vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(getterOrOptions);
          if (onlyGetter) {
            getter = getterOrOptions;
            setter = true
              ? () => {
                  console.warn(
                    'Write operation failed: computed value is readonly'
                  );
                }
              : 0;
          } else {
            getter = getterOrOptions.get;
            setter = getterOrOptions.set;
          }
          const cRef = new ComputedRefImpl(
            getter,
            setter,
            onlyGetter || !setter,
            isSSR
          );
          if (true && debugOptions && !isSSR) {
            cRef.effect.onTrack = debugOptions.onTrack;
            cRef.effect.onTrigger = debugOptions.onTrigger;
          }
          return cRef;
        }

        var _a;
        const tick = Promise.resolve();
        const queue = [];
        let queued = false;
        const scheduler = (fn) => {
          queue.push(fn);
          if (!queued) {
            queued = true;
            tick.then(flush);
          }
        };
        const flush = () => {
          for (let i = 0; i < queue.length; i++) {
            queue[i]();
          }
          queue.length = 0;
          queued = false;
        };
        class DeferredComputedRefImpl {
          constructor(getter) {
            this.dep = undefined;
            this._dirty = true;
            this.__v_isRef = true;
            this[_a] = true;
            let compareTarget;
            let hasCompareTarget = false;
            let scheduled = false;
            this.effect = new ReactiveEffect(getter, (computedTrigger) => {
              if (this.dep) {
                if (computedTrigger) {
                  compareTarget = this._value;
                  hasCompareTarget = true;
                } else if (!scheduled) {
                  const valueToCompare = hasCompareTarget
                    ? compareTarget
                    : this._value;
                  scheduled = true;
                  hasCompareTarget = false;
                  scheduler(() => {
                    if (this.effect.active && this._get() !== valueToCompare) {
                      triggerRefValue(this);
                    }
                    scheduled = false;
                  });
                }
                // chained upstream computeds are notified synchronously to ensure
                // value invalidation in case of sync access; normal effects are
                // deferred to be triggered in scheduler.
                for (const e of this.dep) {
                  if (e.computed instanceof DeferredComputedRefImpl) {
                    e.scheduler(true /* computedTrigger */);
                  }
                }
              }
              this._dirty = true;
            });
            this.effect.computed = this;
          }
          _get() {
            if (this._dirty) {
              this._dirty = false;
              return (this._value = this.effect.run());
            }
            return this._value;
          }
          get value() {
            trackRefValue(this);
            // the computed ref may get wrapped by other proxies e.g. readonly() #3376
            return toRaw(this)._get();
          }
        }
        _a = '__v_isReadonly' /* IS_READONLY */;
        function deferredComputed(getter) {
          return new DeferredComputedRefImpl(getter);
        }

        /***/
      },

    /***/ './node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js':
      /*!*************************************************************************!*\
  !*** ./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js ***!
  \*************************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ EffectScope: () =>
            /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.EffectScope,
          /* harmony export */ ReactiveEffect: () =>
            /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect,
          /* harmony export */ customRef: () =>
            /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.customRef,
          /* harmony export */ effect: () =>
            /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effect,
          /* harmony export */ effectScope: () =>
            /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effectScope,
          /* harmony export */ getCurrentScope: () =>
            /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope,
          /* harmony export */ isProxy: () =>
            /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy,
          /* harmony export */ isReactive: () =>
            /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive,
          /* harmony export */ isReadonly: () =>
            /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly,
          /* harmony export */ isRef: () =>
            /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef,
          /* harmony export */ isShallow: () =>
            /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow,
          /* harmony export */ markRaw: () =>
            /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw,
          /* harmony export */ onScopeDispose: () =>
            /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose,
          /* harmony export */ proxyRefs: () =>
            /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs,
          /* harmony export */ reactive: () =>
            /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive,
          /* harmony export */ readonly: () =>
            /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.readonly,
          /* harmony export */ ref: () =>
            /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref,
          /* harmony export */ shallowReactive: () =>
            /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive,
          /* harmony export */ shallowReadonly: () =>
            /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly,
          /* harmony export */ shallowRef: () =>
            /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowRef,
          /* harmony export */ stop: () =>
            /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.stop,
          /* harmony export */ toRaw: () =>
            /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw,
          /* harmony export */ toRef: () =>
            /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef,
          /* harmony export */ toRefs: () =>
            /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRefs,
          /* harmony export */ triggerRef: () =>
            /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.triggerRef,
          /* harmony export */ unref: () =>
            /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.unref,
          /* harmony export */ camelize: () =>
            /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize,
          /* harmony export */ capitalize: () =>
            /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize,
          /* harmony export */ normalizeClass: () =>
            /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass,
          /* harmony export */ normalizeProps: () =>
            /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeProps,
          /* harmony export */ normalizeStyle: () =>
            /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle,
          /* harmony export */ toDisplayString: () =>
            /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toDisplayString,
          /* harmony export */ toHandlerKey: () =>
            /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey,
          /* harmony export */ BaseTransition: () =>
            /* binding */ BaseTransition,
          /* harmony export */ Comment: () => /* binding */ Comment,
          /* harmony export */ Fragment: () => /* binding */ Fragment,
          /* harmony export */ KeepAlive: () => /* binding */ KeepAlive,
          /* harmony export */ Static: () => /* binding */ Static,
          /* harmony export */ Suspense: () => /* binding */ Suspense,
          /* harmony export */ Teleport: () => /* binding */ Teleport,
          /* harmony export */ Text: () => /* binding */ Text,
          /* harmony export */ callWithAsyncErrorHandling: () =>
            /* binding */ callWithAsyncErrorHandling,
          /* harmony export */ callWithErrorHandling: () =>
            /* binding */ callWithErrorHandling,
          /* harmony export */ cloneVNode: () => /* binding */ cloneVNode,
          /* harmony export */ compatUtils: () => /* binding */ compatUtils,
          /* harmony export */ computed: () => /* binding */ computed,
          /* harmony export */ createBlock: () => /* binding */ createBlock,
          /* harmony export */ createCommentVNode: () =>
            /* binding */ createCommentVNode,
          /* harmony export */ createElementBlock: () =>
            /* binding */ createElementBlock,
          /* harmony export */ createElementVNode: () =>
            /* binding */ createBaseVNode,
          /* harmony export */ createHydrationRenderer: () =>
            /* binding */ createHydrationRenderer,
          /* harmony export */ createPropsRestProxy: () =>
            /* binding */ createPropsRestProxy,
          /* harmony export */ createRenderer: () =>
            /* binding */ createRenderer,
          /* harmony export */ createSlots: () => /* binding */ createSlots,
          /* harmony export */ createStaticVNode: () =>
            /* binding */ createStaticVNode,
          /* harmony export */ createTextVNode: () =>
            /* binding */ createTextVNode,
          /* harmony export */ createVNode: () => /* binding */ createVNode,
          /* harmony export */ defineAsyncComponent: () =>
            /* binding */ defineAsyncComponent,
          /* harmony export */ defineComponent: () =>
            /* binding */ defineComponent,
          /* harmony export */ defineEmits: () => /* binding */ defineEmits,
          /* harmony export */ defineExpose: () => /* binding */ defineExpose,
          /* harmony export */ defineProps: () => /* binding */ defineProps,
          /* harmony export */ devtools: () => /* binding */ devtools,
          /* harmony export */ getCurrentInstance: () =>
            /* binding */ getCurrentInstance,
          /* harmony export */ getTransitionRawChildren: () =>
            /* binding */ getTransitionRawChildren,
          /* harmony export */ guardReactiveProps: () =>
            /* binding */ guardReactiveProps,
          /* harmony export */ h: () => /* binding */ h,
          /* harmony export */ handleError: () => /* binding */ handleError,
          /* harmony export */ initCustomFormatter: () =>
            /* binding */ initCustomFormatter,
          /* harmony export */ inject: () => /* binding */ inject,
          /* harmony export */ isMemoSame: () => /* binding */ isMemoSame,
          /* harmony export */ isRuntimeOnly: () => /* binding */ isRuntimeOnly,
          /* harmony export */ isVNode: () => /* binding */ isVNode,
          /* harmony export */ mergeDefaults: () => /* binding */ mergeDefaults,
          /* harmony export */ mergeProps: () => /* binding */ mergeProps,
          /* harmony export */ nextTick: () => /* binding */ nextTick,
          /* harmony export */ onActivated: () => /* binding */ onActivated,
          /* harmony export */ onBeforeMount: () => /* binding */ onBeforeMount,
          /* harmony export */ onBeforeUnmount: () =>
            /* binding */ onBeforeUnmount,
          /* harmony export */ onBeforeUpdate: () =>
            /* binding */ onBeforeUpdate,
          /* harmony export */ onDeactivated: () => /* binding */ onDeactivated,
          /* harmony export */ onErrorCaptured: () =>
            /* binding */ onErrorCaptured,
          /* harmony export */ onMounted: () => /* binding */ onMounted,
          /* harmony export */ onRenderTracked: () =>
            /* binding */ onRenderTracked,
          /* harmony export */ onRenderTriggered: () =>
            /* binding */ onRenderTriggered,
          /* harmony export */ onServerPrefetch: () =>
            /* binding */ onServerPrefetch,
          /* harmony export */ onUnmounted: () => /* binding */ onUnmounted,
          /* harmony export */ onUpdated: () => /* binding */ onUpdated,
          /* harmony export */ openBlock: () => /* binding */ openBlock,
          /* harmony export */ popScopeId: () => /* binding */ popScopeId,
          /* harmony export */ provide: () => /* binding */ provide,
          /* harmony export */ pushScopeId: () => /* binding */ pushScopeId,
          /* harmony export */ queuePostFlushCb: () =>
            /* binding */ queuePostFlushCb,
          /* harmony export */ registerRuntimeCompiler: () =>
            /* binding */ registerRuntimeCompiler,
          /* harmony export */ renderList: () => /* binding */ renderList,
          /* harmony export */ renderSlot: () => /* binding */ renderSlot,
          /* harmony export */ resolveComponent: () =>
            /* binding */ resolveComponent,
          /* harmony export */ resolveDirective: () =>
            /* binding */ resolveDirective,
          /* harmony export */ resolveDynamicComponent: () =>
            /* binding */ resolveDynamicComponent,
          /* harmony export */ resolveFilter: () => /* binding */ resolveFilter,
          /* harmony export */ resolveTransitionHooks: () =>
            /* binding */ resolveTransitionHooks,
          /* harmony export */ setBlockTracking: () =>
            /* binding */ setBlockTracking,
          /* harmony export */ setDevtoolsHook: () =>
            /* binding */ setDevtoolsHook,
          /* harmony export */ setTransitionHooks: () =>
            /* binding */ setTransitionHooks,
          /* harmony export */ ssrContextKey: () => /* binding */ ssrContextKey,
          /* harmony export */ ssrUtils: () => /* binding */ ssrUtils,
          /* harmony export */ toHandlers: () => /* binding */ toHandlers,
          /* harmony export */ transformVNodeArgs: () =>
            /* binding */ transformVNodeArgs,
          /* harmony export */ useAttrs: () => /* binding */ useAttrs,
          /* harmony export */ useSSRContext: () => /* binding */ useSSRContext,
          /* harmony export */ useSlots: () => /* binding */ useSlots,
          /* harmony export */ useTransitionState: () =>
            /* binding */ useTransitionState,
          /* harmony export */ version: () => /* binding */ version,
          /* harmony export */ warn: () => /* binding */ warn,
          /* harmony export */ watch: () => /* binding */ watch,
          /* harmony export */ watchEffect: () => /* binding */ watchEffect,
          /* harmony export */ watchPostEffect: () =>
            /* binding */ watchPostEffect,
          /* harmony export */ watchSyncEffect: () =>
            /* binding */ watchSyncEffect,
          /* harmony export */ withAsyncContext: () =>
            /* binding */ withAsyncContext,
          /* harmony export */ withCtx: () => /* binding */ withCtx,
          /* harmony export */ withDefaults: () => /* binding */ withDefaults,
          /* harmony export */ withDirectives: () =>
            /* binding */ withDirectives,
          /* harmony export */ withMemo: () => /* binding */ withMemo,
          /* harmony export */ withScopeId: () => /* binding */ withScopeId,
          /* harmony export */
        });
        /* harmony import */ var _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! @vue/reactivity */ './node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js'
          );
        /* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! @vue/shared */ './node_modules/@vue/shared/dist/shared.esm-bundler.js'
          );

        const stack = [];
        function pushWarningContext(vnode) {
          stack.push(vnode);
        }
        function popWarningContext() {
          stack.pop();
        }
        function warn(msg, ...args) {
          // avoid props formatting or warn handler tracking deps that might be mutated
          // during patch, leading to infinite recursion.
          (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
          const instance = stack.length
            ? stack[stack.length - 1].component
            : null;
          const appWarnHandler =
            instance && instance.appContext.config.warnHandler;
          const trace = getComponentTrace();
          if (appWarnHandler) {
            callWithErrorHandling(
              appWarnHandler,
              instance,
              11 /* APP_WARN_HANDLER */,
              [
                msg + args.join(''),
                instance && instance.proxy,
                trace
                  .map(
                    ({ vnode }) =>
                      `at <${formatComponentName(instance, vnode.type)}>`
                  )
                  .join('\n'),
                trace,
              ]
            );
          } else {
            const warnArgs = [`[Vue warn]: ${msg}`, ...args];
            /* istanbul ignore if */
            if (
              trace.length &&
              // avoid spamming console during tests
              !false
            ) {
              warnArgs.push(`\n`, ...formatTrace(trace));
            }
            console.warn(...warnArgs);
          }
          (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
        }
        function getComponentTrace() {
          let currentVNode = stack[stack.length - 1];
          if (!currentVNode) {
            return [];
          }
          // we can't just use the stack because it will be incomplete during updates
          // that did not start from the root. Re-construct the parent chain using
          // instance parent pointers.
          const normalizedStack = [];
          while (currentVNode) {
            const last = normalizedStack[0];
            if (last && last.vnode === currentVNode) {
              last.recurseCount++;
            } else {
              normalizedStack.push({
                vnode: currentVNode,
                recurseCount: 0,
              });
            }
            const parentInstance =
              currentVNode.component && currentVNode.component.parent;
            currentVNode = parentInstance && parentInstance.vnode;
          }
          return normalizedStack;
        }
        /* istanbul ignore next */
        function formatTrace(trace) {
          const logs = [];
          trace.forEach((entry, i) => {
            logs.push(...(i === 0 ? [] : [`\n`]), ...formatTraceEntry(entry));
          });
          return logs;
        }
        function formatTraceEntry({ vnode, recurseCount }) {
          const postfix =
            recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
          const isRoot = vnode.component
            ? vnode.component.parent == null
            : false;
          const open = ` at <${formatComponentName(
            vnode.component,
            vnode.type,
            isRoot
          )}`;
          const close = `>` + postfix;
          return vnode.props
            ? [open, ...formatProps(vnode.props), close]
            : [open + close];
        }
        /* istanbul ignore next */
        function formatProps(props) {
          const res = [];
          const keys = Object.keys(props);
          keys.slice(0, 3).forEach((key) => {
            res.push(...formatProp(key, props[key]));
          });
          if (keys.length > 3) {
            res.push(` ...`);
          }
          return res;
        }
        /* istanbul ignore next */
        function formatProp(key, value, raw) {
          if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {
            value = JSON.stringify(value);
            return raw ? value : [`${key}=${value}`];
          } else if (
            typeof value === 'number' ||
            typeof value === 'boolean' ||
            value == null
          ) {
            return raw ? value : [`${key}=${value}`];
          } else if (
            (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(value)
          ) {
            value = formatProp(
              key,
              (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(
                value.value
              ),
              true
            );
            return raw ? value : [`${key}=Ref<`, value, `>`];
          } else if (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)
          ) {
            return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
          } else {
            value = (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(
              value
            );
            return raw ? value : [`${key}=`, value];
          }
        }

        const ErrorTypeStrings = {
          ['sp' /* SERVER_PREFETCH */]: 'serverPrefetch hook',
          ['bc' /* BEFORE_CREATE */]: 'beforeCreate hook',
          ['c' /* CREATED */]: 'created hook',
          ['bm' /* BEFORE_MOUNT */]: 'beforeMount hook',
          ['m' /* MOUNTED */]: 'mounted hook',
          ['bu' /* BEFORE_UPDATE */]: 'beforeUpdate hook',
          ['u' /* UPDATED */]: 'updated',
          ['bum' /* BEFORE_UNMOUNT */]: 'beforeUnmount hook',
          ['um' /* UNMOUNTED */]: 'unmounted hook',
          ['a' /* ACTIVATED */]: 'activated hook',
          ['da' /* DEACTIVATED */]: 'deactivated hook',
          ['ec' /* ERROR_CAPTURED */]: 'errorCaptured hook',
          ['rtc' /* RENDER_TRACKED */]: 'renderTracked hook',
          ['rtg' /* RENDER_TRIGGERED */]: 'renderTriggered hook',
          [0 /* SETUP_FUNCTION */]: 'setup function',
          [1 /* RENDER_FUNCTION */]: 'render function',
          [2 /* WATCH_GETTER */]: 'watcher getter',
          [3 /* WATCH_CALLBACK */]: 'watcher callback',
          [4 /* WATCH_CLEANUP */]: 'watcher cleanup function',
          [5 /* NATIVE_EVENT_HANDLER */]: 'native event handler',
          [6 /* COMPONENT_EVENT_HANDLER */]: 'component event handler',
          [7 /* VNODE_HOOK */]: 'vnode hook',
          [8 /* DIRECTIVE_HOOK */]: 'directive hook',
          [9 /* TRANSITION_HOOK */]: 'transition hook',
          [10 /* APP_ERROR_HANDLER */]: 'app errorHandler',
          [11 /* APP_WARN_HANDLER */]: 'app warnHandler',
          [12 /* FUNCTION_REF */]: 'ref function',
          [13 /* ASYNC_COMPONENT_LOADER */]: 'async component loader',
          [14 /* SCHEDULER */]:
            'scheduler flush. This is likely a Vue internals bug. ' +
            'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core',
        };
        function callWithErrorHandling(fn, instance, type, args) {
          let res;
          try {
            res = args ? fn(...args) : fn();
          } catch (err) {
            handleError(err, instance, type);
          }
          return res;
        }
        function callWithAsyncErrorHandling(fn, instance, type, args) {
          if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(fn)) {
            const res = callWithErrorHandling(fn, instance, type, args);
            if (
              res &&
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(res)
            ) {
              res.catch((err) => {
                handleError(err, instance, type);
              });
            }
            return res;
          }
          const values = [];
          for (let i = 0; i < fn.length; i++) {
            values.push(
              callWithAsyncErrorHandling(fn[i], instance, type, args)
            );
          }
          return values;
        }
        function handleError(err, instance, type, throwInDev = true) {
          const contextVNode = instance ? instance.vnode : null;
          if (instance) {
            let cur = instance.parent;
            // the exposed instance is the render proxy to keep it consistent with 2.x
            const exposedInstance = instance.proxy;
            // in production the hook receives only the error code
            const errorInfo = true ? ErrorTypeStrings[type] : 0;
            while (cur) {
              const errorCapturedHooks = cur.ec;
              if (errorCapturedHooks) {
                for (let i = 0; i < errorCapturedHooks.length; i++) {
                  if (
                    errorCapturedHooks[i](err, exposedInstance, errorInfo) ===
                    false
                  ) {
                    return;
                  }
                }
              }
              cur = cur.parent;
            }
            // app-level handling
            const appErrorHandler = instance.appContext.config.errorHandler;
            if (appErrorHandler) {
              callWithErrorHandling(
                appErrorHandler,
                null,
                10 /* APP_ERROR_HANDLER */,
                [err, exposedInstance, errorInfo]
              );
              return;
            }
          }
          logError(err, type, contextVNode, throwInDev);
        }
        function logError(err, type, contextVNode, throwInDev = true) {
          if (true) {
            const info = ErrorTypeStrings[type];
            if (contextVNode) {
              pushWarningContext(contextVNode);
            }
            warn(
              `Unhandled error${info ? ` during execution of ${info}` : ``}`
            );
            if (contextVNode) {
              popWarningContext();
            }
            // crash in dev by default so it's more noticeable
            if (throwInDev) {
              throw err;
            } else {
              console.error(err);
            }
          } else {
          }
        }

        let isFlushing = false;
        let isFlushPending = false;
        const queue = [];
        let flushIndex = 0;
        const pendingPreFlushCbs = [];
        let activePreFlushCbs = null;
        let preFlushIndex = 0;
        const pendingPostFlushCbs = [];
        let activePostFlushCbs = null;
        let postFlushIndex = 0;
        const resolvedPromise = Promise.resolve();
        let currentFlushPromise = null;
        let currentPreFlushParentJob = null;
        const RECURSION_LIMIT = 100;
        function nextTick(fn) {
          const p = currentFlushPromise || resolvedPromise;
          return fn ? p.then(this ? fn.bind(this) : fn) : p;
        }
        // #2768
        // Use binary-search to find a suitable position in the queue,
        // so that the queue maintains the increasing order of job's id,
        // which can prevent the job from being skipped and also can avoid repeated patching.
        function findInsertionIndex(id) {
          // the start index should be `flushIndex + 1`
          let start = flushIndex + 1;
          let end = queue.length;
          while (start < end) {
            const middle = (start + end) >>> 1;
            const middleJobId = getId(queue[middle]);
            middleJobId < id ? (start = middle + 1) : (end = middle);
          }
          return start;
        }
        function queueJob(job) {
          // the dedupe search uses the startIndex argument of Array.includes()
          // by default the search index includes the current job that is being run
          // so it cannot recursively trigger itself again.
          // if the job is a watch() callback, the search will start with a +1 index to
          // allow it recursively trigger itself - it is the user's responsibility to
          // ensure it doesn't end up in an infinite loop.
          if (
            (!queue.length ||
              !queue.includes(
                job,
                isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
              )) &&
            job !== currentPreFlushParentJob
          ) {
            if (job.id == null) {
              queue.push(job);
            } else {
              queue.splice(findInsertionIndex(job.id), 0, job);
            }
            queueFlush();
          }
        }
        function queueFlush() {
          if (!isFlushing && !isFlushPending) {
            isFlushPending = true;
            currentFlushPromise = resolvedPromise.then(flushJobs);
          }
        }
        function invalidateJob(job) {
          const i = queue.indexOf(job);
          if (i > flushIndex) {
            queue.splice(i, 1);
          }
        }
        function queueCb(cb, activeQueue, pendingQueue, index) {
          if (!(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(cb)) {
            if (
              !activeQueue ||
              !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)
            ) {
              pendingQueue.push(cb);
            }
          } else {
            // if cb is an array, it is a component lifecycle hook which can only be
            // triggered by a job, which is already deduped in the main queue, so
            // we can skip duplicate check here to improve perf
            pendingQueue.push(...cb);
          }
          queueFlush();
        }
        function queuePreFlushCb(cb) {
          queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
        }
        function queuePostFlushCb(cb) {
          queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
        }
        function flushPreFlushCbs(seen, parentJob = null) {
          if (pendingPreFlushCbs.length) {
            currentPreFlushParentJob = parentJob;
            activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
            pendingPreFlushCbs.length = 0;
            if (true) {
              seen = seen || new Map();
            }
            for (
              preFlushIndex = 0;
              preFlushIndex < activePreFlushCbs.length;
              preFlushIndex++
            ) {
              if (
                true &&
                checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex])
              ) {
                continue;
              }
              activePreFlushCbs[preFlushIndex]();
            }
            activePreFlushCbs = null;
            preFlushIndex = 0;
            currentPreFlushParentJob = null;
            // recursively flush until it drains
            flushPreFlushCbs(seen, parentJob);
          }
        }
        function flushPostFlushCbs(seen) {
          if (pendingPostFlushCbs.length) {
            const deduped = [...new Set(pendingPostFlushCbs)];
            pendingPostFlushCbs.length = 0;
            // #1947 already has active queue, nested flushPostFlushCbs call
            if (activePostFlushCbs) {
              activePostFlushCbs.push(...deduped);
              return;
            }
            activePostFlushCbs = deduped;
            if (true) {
              seen = seen || new Map();
            }
            activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
            for (
              postFlushIndex = 0;
              postFlushIndex < activePostFlushCbs.length;
              postFlushIndex++
            ) {
              if (
                true &&
                checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])
              ) {
                continue;
              }
              activePostFlushCbs[postFlushIndex]();
            }
            activePostFlushCbs = null;
            postFlushIndex = 0;
          }
        }
        const getId = (job) => (job.id == null ? Infinity : job.id);
        function flushJobs(seen) {
          isFlushPending = false;
          isFlushing = true;
          if (true) {
            seen = seen || new Map();
          }
          flushPreFlushCbs(seen);
          // Sort queue before flush.
          // This ensures that:
          // 1. Components are updated from parent to child. (because parent is always
          //    created before the child so its render effect will have smaller
          //    priority number)
          // 2. If a component is unmounted during a parent component's update,
          //    its update can be skipped.
          queue.sort((a, b) => getId(a) - getId(b));
          // conditional usage of checkRecursiveUpdate must be determined out of
          // try ... catch block since Rollup by default de-optimizes treeshaking
          // inside try-catch. This can leave all warning code unshaked. Although
          // they would get eventually shaken by a minifier like terser, some minifiers
          // would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)
          const check = true ? (job) => checkRecursiveUpdates(seen, job) : 0;
          try {
            for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
              const job = queue[flushIndex];
              if (job && job.active !== false) {
                if (true && check(job)) {
                  continue;
                }
                // console.log(`running:`, job.id)
                callWithErrorHandling(job, null, 14 /* SCHEDULER */);
              }
            }
          } finally {
            flushIndex = 0;
            queue.length = 0;
            flushPostFlushCbs(seen);
            isFlushing = false;
            currentFlushPromise = null;
            // some postFlushCb queued jobs!
            // keep flushing until it drains.
            if (
              queue.length ||
              pendingPreFlushCbs.length ||
              pendingPostFlushCbs.length
            ) {
              flushJobs(seen);
            }
          }
        }
        function checkRecursiveUpdates(seen, fn) {
          if (!seen.has(fn)) {
            seen.set(fn, 1);
          } else {
            const count = seen.get(fn);
            if (count > RECURSION_LIMIT) {
              const instance = fn.ownerInstance;
              const componentName = instance && getComponentName(instance.type);
              warn(
                `Maximum recursive updates exceeded${
                  componentName ? ` in component <${componentName}>` : ``
                }. ` +
                  `This means you have a reactive effect that is mutating its own ` +
                  `dependencies and thus recursively triggering itself. Possible sources ` +
                  `include component template, render function, updated hook or ` +
                  `watcher source function.`
              );
              return true;
            } else {
              seen.set(fn, count + 1);
            }
          }
        }

        /* eslint-disable no-restricted-globals */
        let isHmrUpdating = false;
        const hmrDirtyComponents = new Set();
        // Expose the HMR runtime on the global object
        // This makes it entirely tree-shakable without polluting the exports and makes
        // it easier to be used in toolings like vue-loader
        // Note: for a component to be eligible for HMR it also needs the __hmrId option
        // to be set so that its instances can be registered / removed.
        if (true) {
          (0,
          _vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_HMR_RUNTIME__ =
            {
              createRecord: tryWrap(createRecord),
              rerender: tryWrap(rerender),
              reload: tryWrap(reload),
            };
        }
        const map = new Map();
        function registerHMR(instance) {
          const id = instance.type.__hmrId;
          let record = map.get(id);
          if (!record) {
            createRecord(id, instance.type);
            record = map.get(id);
          }
          record.instances.add(instance);
        }
        function unregisterHMR(instance) {
          map.get(instance.type.__hmrId).instances.delete(instance);
        }
        function createRecord(id, initialDef) {
          if (map.has(id)) {
            return false;
          }
          map.set(id, {
            initialDef: normalizeClassComponent(initialDef),
            instances: new Set(),
          });
          return true;
        }
        function normalizeClassComponent(component) {
          return isClassComponent(component) ? component.__vccOpts : component;
        }
        function rerender(id, newRender) {
          const record = map.get(id);
          if (!record) {
            return;
          }
          // update initial record (for not-yet-rendered component)
          record.initialDef.render = newRender;
          [...record.instances].forEach((instance) => {
            if (newRender) {
              instance.render = newRender;
              normalizeClassComponent(instance.type).render = newRender;
            }
            instance.renderCache = [];
            // this flag forces child components with slot content to update
            isHmrUpdating = true;
            instance.update();
            isHmrUpdating = false;
          });
        }
        function reload(id, newComp) {
          const record = map.get(id);
          if (!record) return;
          newComp = normalizeClassComponent(newComp);
          // update initial def (for not-yet-rendered components)
          updateComponentDef(record.initialDef, newComp);
          // create a snapshot which avoids the set being mutated during updates
          const instances = [...record.instances];
          for (const instance of instances) {
            const oldComp = normalizeClassComponent(instance.type);
            if (!hmrDirtyComponents.has(oldComp)) {
              // 1. Update existing comp definition to match new one
              if (oldComp !== record.initialDef) {
                updateComponentDef(oldComp, newComp);
              }
              // 2. mark definition dirty. This forces the renderer to replace the
              // component on patch.
              hmrDirtyComponents.add(oldComp);
            }
            // 3. invalidate options resolution cache
            instance.appContext.optionsCache.delete(instance.type);
            // 4. actually update
            if (instance.ceReload) {
              // custom element
              hmrDirtyComponents.add(oldComp);
              instance.ceReload(newComp.styles);
              hmrDirtyComponents.delete(oldComp);
            } else if (instance.parent) {
              // 4. Force the parent instance to re-render. This will cause all updated
              // components to be unmounted and re-mounted. Queue the update so that we
              // don't end up forcing the same parent to re-render multiple times.
              queueJob(instance.parent.update);
              // instance is the inner component of an async custom element
              // invoke to reset styles
              if (
                instance.parent.type.__asyncLoader &&
                instance.parent.ceReload
              ) {
                instance.parent.ceReload(newComp.styles);
              }
            } else if (instance.appContext.reload) {
              // root instance mounted via createApp() has a reload method
              instance.appContext.reload();
            } else if (typeof window !== 'undefined') {
              // root instance inside tree created via raw render(). Force reload.
              window.location.reload();
            } else {
              console.warn(
                '[HMR] Root or manually mounted instance modified. Full reload required.'
              );
            }
          }
          // 5. make sure to cleanup dirty hmr components after update
          queuePostFlushCb(() => {
            for (const instance of instances) {
              hmrDirtyComponents.delete(normalizeClassComponent(instance.type));
            }
          });
        }
        function updateComponentDef(oldComp, newComp) {
          (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(
            oldComp,
            newComp
          );
          for (const key in oldComp) {
            if (key !== '__file' && !(key in newComp)) {
              delete oldComp[key];
            }
          }
        }
        function tryWrap(fn) {
          return (id, arg) => {
            try {
              return fn(id, arg);
            } catch (e) {
              console.error(e);
              console.warn(
                `[HMR] Something went wrong during Vue component hot-reload. ` +
                  `Full reload required.`
              );
            }
          };
        }

        let devtools;
        let buffer = [];
        let devtoolsNotInstalled = false;
        function emit(event, ...args) {
          if (devtools) {
            devtools.emit(event, ...args);
          } else if (!devtoolsNotInstalled) {
            buffer.push({ event, args });
          }
        }
        function setDevtoolsHook(hook, target) {
          var _a, _b;
          devtools = hook;
          if (devtools) {
            devtools.enabled = true;
            buffer.forEach(({ event, args }) => devtools.emit(event, ...args));
            buffer = [];
          } else if (
            // handle late devtools injection - only do this if we are in an actual
            // browser environment to avoid the timer handle stalling test runner exit
            // (#4815)
            // eslint-disable-next-line no-restricted-globals
            typeof window !== 'undefined' &&
            // some envs mock window but not fully
            window.HTMLElement &&
            // also exclude jsdom
            !((_b =
              (_a = window.navigator) === null || _a === void 0
                ? void 0
                : _a.userAgent) === null || _b === void 0
              ? void 0
              : _b.includes('jsdom'))
          ) {
            const replay = (target.__VUE_DEVTOOLS_HOOK_REPLAY__ =
              target.__VUE_DEVTOOLS_HOOK_REPLAY__ || []);
            replay.push((newHook) => {
              setDevtoolsHook(newHook, target);
            });
            // clear buffer after 3s - the user probably doesn't have devtools installed
            // at all, and keeping the buffer will cause memory leaks (#4738)
            setTimeout(() => {
              if (!devtools) {
                target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
                devtoolsNotInstalled = true;
                buffer = [];
              }
            }, 3000);
          } else {
            // non-browser env, assume not installed
            devtoolsNotInstalled = true;
            buffer = [];
          }
        }
        function devtoolsInitApp(app, version) {
          emit('app:init' /* APP_INIT */, app, version, {
            Fragment,
            Text,
            Comment,
            Static,
          });
        }
        function devtoolsUnmountApp(app) {
          emit('app:unmount' /* APP_UNMOUNT */, app);
        }
        const devtoolsComponentAdded =
          /*#__PURE__*/ createDevtoolsComponentHook(
            'component:added' /* COMPONENT_ADDED */
          );
        const devtoolsComponentUpdated =
          /*#__PURE__*/ createDevtoolsComponentHook(
            'component:updated' /* COMPONENT_UPDATED */
          );
        const devtoolsComponentRemoved =
          /*#__PURE__*/ createDevtoolsComponentHook(
            'component:removed' /* COMPONENT_REMOVED */
          );
        function createDevtoolsComponentHook(hook) {
          return (component) => {
            emit(
              hook,
              component.appContext.app,
              component.uid,
              component.parent ? component.parent.uid : undefined,
              component
            );
          };
        }
        const devtoolsPerfStart = /*#__PURE__*/ createDevtoolsPerformanceHook(
          'perf:start' /* PERFORMANCE_START */
        );
        const devtoolsPerfEnd = /*#__PURE__*/ createDevtoolsPerformanceHook(
          'perf:end' /* PERFORMANCE_END */
        );
        function createDevtoolsPerformanceHook(hook) {
          return (component, type, time) => {
            emit(
              hook,
              component.appContext.app,
              component.uid,
              component,
              type,
              time
            );
          };
        }
        function devtoolsComponentEmit(component, event, params) {
          emit(
            'component:emit' /* COMPONENT_EMIT */,
            component.appContext.app,
            component,
            event,
            params
          );
        }

        function emit$1(instance, event, ...rawArgs) {
          const props =
            instance.vnode.props ||
            _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
          if (true) {
            const {
              emitsOptions,
              propsOptions: [propsOptions],
            } = instance;
            if (emitsOptions) {
              if (!(event in emitsOptions) && !false) {
                if (
                  !propsOptions ||
                  !(
                    (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(
                      event
                    ) in propsOptions
                  )
                ) {
                  warn(
                    `Component emitted event "${event}" but it is neither declared in ` +
                      `the emits option nor as an "${(0,
                      _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(
                        event
                      )}" prop.`
                  );
                }
              } else {
                const validator = emitsOptions[event];
                if (
                  (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(
                    validator
                  )
                ) {
                  const isValid = validator(...rawArgs);
                  if (!isValid) {
                    warn(
                      `Invalid event arguments: event validation failed for event "${event}".`
                    );
                  }
                }
              }
            }
          }
          let args = rawArgs;
          const isModelListener = event.startsWith('update:');
          // for v-model update:xxx events, apply modifiers on args
          const modelArg = isModelListener && event.slice(7);
          if (modelArg && modelArg in props) {
            const modifiersKey = `${
              modelArg === 'modelValue' ? 'model' : modelArg
            }Modifiers`;
            const { number, trim } =
              props[modifiersKey] ||
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
            if (trim) {
              args = rawArgs.map((a) => a.trim());
            } else if (number) {
              args = rawArgs.map(
                _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber
              );
            }
          }
          if (true) {
            devtoolsComponentEmit(instance, event, args);
          }
          if (true) {
            const lowerCaseEvent = event.toLowerCase();
            if (
              lowerCaseEvent !== event &&
              props[
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(
                  lowerCaseEvent
                )
              ]
            ) {
              warn(
                `Event "${lowerCaseEvent}" is emitted in component ` +
                  `${formatComponentName(
                    instance,
                    instance.type
                  )} but the handler is registered for "${event}". ` +
                  `Note that HTML attributes are case-insensitive and you cannot use ` +
                  `v-on to listen to camelCase events when using in-DOM templates. ` +
                  `You should probably use "${(0,
                  _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(
                    event
                  )}" instead of "${event}".`
              );
            }
          }
          let handlerName;
          let handler =
            props[
              (handlerName = (0,
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event))
            ] ||
            // also try camelCase event handler (#2249)
            props[
              (handlerName = (0,
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(event)
              ))
            ];
          // for v-model update:xxx events, also trigger kebab-case equivalent
          // for props passed via kebab-case
          if (!handler && isModelListener) {
            handler =
              props[
                (handlerName = (0,
                _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(
                  (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event)
                ))
              ];
          }
          if (handler) {
            callWithAsyncErrorHandling(
              handler,
              instance,
              6 /* COMPONENT_EVENT_HANDLER */,
              args
            );
          }
          const onceHandler = props[handlerName + `Once`];
          if (onceHandler) {
            if (!instance.emitted) {
              instance.emitted = {};
            } else if (instance.emitted[handlerName]) {
              return;
            }
            instance.emitted[handlerName] = true;
            callWithAsyncErrorHandling(
              onceHandler,
              instance,
              6 /* COMPONENT_EVENT_HANDLER */,
              args
            );
          }
        }
        function normalizeEmitsOptions(comp, appContext, asMixin = false) {
          const cache = appContext.emitsCache;
          const cached = cache.get(comp);
          if (cached !== undefined) {
            return cached;
          }
          const raw = comp.emits;
          let normalized = {};
          // apply mixin/extends props
          let hasExtends = false;
          if (
            true &&
            !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)
          ) {
            const extendEmits = (raw) => {
              const normalizedFromExtend = normalizeEmitsOptions(
                raw,
                appContext,
                true
              );
              if (normalizedFromExtend) {
                hasExtends = true;
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(
                  normalized,
                  normalizedFromExtend
                );
              }
            };
            if (!asMixin && appContext.mixins.length) {
              appContext.mixins.forEach(extendEmits);
            }
            if (comp.extends) {
              extendEmits(comp.extends);
            }
            if (comp.mixins) {
              comp.mixins.forEach(extendEmits);
            }
          }
          if (!raw && !hasExtends) {
            cache.set(comp, null);
            return null;
          }
          if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
            raw.forEach((key) => (normalized[key] = null));
          } else {
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(
              normalized,
              raw
            );
          }
          cache.set(comp, normalized);
          return normalized;
        }
        // Check if an incoming prop key is a declared emit event listener.
        // e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are
        // both considered matched listeners.
        function isEmitListener(options, key) {
          if (
            !options ||
            !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)
          ) {
            return false;
          }
          key = key.slice(2).replace(/Once$/, '');
          return (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(
              options,
              key[0].toLowerCase() + key.slice(1)
            ) ||
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(
              options,
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)
            ) ||
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, key)
          );
        }

        /**
         * mark the current rendering instance for asset resolution (e.g.
         * resolveComponent, resolveDirective) during render
         */
        let currentRenderingInstance = null;
        let currentScopeId = null;
        /**
         * Note: rendering calls maybe nested. The function returns the parent rendering
         * instance if present, which should be restored after the render is done:
         *
         * ```js
         * const prev = setCurrentRenderingInstance(i)
         * // ...render
         * setCurrentRenderingInstance(prev)
         * ```
         */
        function setCurrentRenderingInstance(instance) {
          const prev = currentRenderingInstance;
          currentRenderingInstance = instance;
          currentScopeId = (instance && instance.type.__scopeId) || null;
          return prev;
        }
        /**
         * Set scope id when creating hoisted vnodes.
         * @private compiler helper
         */
        function pushScopeId(id) {
          currentScopeId = id;
        }
        /**
         * Technically we no longer need this after 3.0.8 but we need to keep the same
         * API for backwards compat w/ code generated by compilers.
         * @private
         */
        function popScopeId() {
          currentScopeId = null;
        }
        /**
         * Only for backwards compat
         * @private
         */
        const withScopeId = (_id) => withCtx;
        /**
         * Wrap a slot function to memoize current rendering instance
         * @private compiler helper
         */
        function withCtx(
          fn,
          ctx = currentRenderingInstance,
          isNonScopedSlot // false only
        ) {
          if (!ctx) return fn;
          // already normalized
          if (fn._n) {
            return fn;
          }
          const renderFnWithContext = (...args) => {
            // If a user calls a compiled slot inside a template expression (#1745), it
            // can mess up block tracking, so by default we disable block tracking and
            // force bail out when invoking a compiled slot (indicated by the ._d flag).
            // This isn't necessary if rendering a compiled `<slot>`, so we flip the
            // ._d flag off when invoking the wrapped fn inside `renderSlot`.
            if (renderFnWithContext._d) {
              setBlockTracking(-1);
            }
            const prevInstance = setCurrentRenderingInstance(ctx);
            const res = fn(...args);
            setCurrentRenderingInstance(prevInstance);
            if (renderFnWithContext._d) {
              setBlockTracking(1);
            }
            if (true) {
              devtoolsComponentUpdated(ctx);
            }
            return res;
          };
          // mark normalized to avoid duplicated wrapping
          renderFnWithContext._n = true;
          // mark this as compiled by default
          // this is used in vnode.ts -> normalizeChildren() to set the slot
          // rendering flag.
          renderFnWithContext._c = true;
          // disable block tracking by default
          renderFnWithContext._d = true;
          return renderFnWithContext;
        }

        /**
         * dev only flag to track whether $attrs was used during render.
         * If $attrs was used during render then the warning for failed attrs
         * fallthrough can be suppressed.
         */
        let accessedAttrs = false;
        function markAttrsAccessed() {
          accessedAttrs = true;
        }
        function renderComponentRoot(instance) {
          const {
            type: Component,
            vnode,
            proxy,
            withProxy,
            props,
            propsOptions: [propsOptions],
            slots,
            attrs,
            emit,
            render,
            renderCache,
            data,
            setupState,
            ctx,
            inheritAttrs,
          } = instance;
          let result;
          let fallthroughAttrs;
          const prev = setCurrentRenderingInstance(instance);
          if (true) {
            accessedAttrs = false;
          }
          try {
            if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {
              // withProxy is a proxy with a different `has` trap only for
              // runtime-compiled render functions using `with` block.
              const proxyToUse = withProxy || proxy;
              result = normalizeVNode(
                render.call(
                  proxyToUse,
                  proxyToUse,
                  renderCache,
                  props,
                  setupState,
                  data,
                  ctx
                )
              );
              fallthroughAttrs = attrs;
            } else {
              // functional
              const render = Component;
              // in dev, mark attrs accessed if optional props (attrs === props)
              if (true && attrs === props) {
                markAttrsAccessed();
              }
              result = normalizeVNode(
                render.length > 1
                  ? render(
                      props,
                      true
                        ? {
                            get attrs() {
                              markAttrsAccessed();
                              return attrs;
                            },
                            slots,
                            emit,
                          }
                        : 0
                    )
                  : render(props, null /* we know it doesn't need it */)
              );
              fallthroughAttrs = Component.props
                ? attrs
                : getFunctionalFallthrough(attrs);
            }
          } catch (err) {
            blockStack.length = 0;
            handleError(err, instance, 1 /* RENDER_FUNCTION */);
            result = createVNode(Comment);
          }
          // attr merging
          // in dev mode, comments are preserved, and it's possible for a template
          // to have comments along side the root element which makes it a fragment
          let root = result;
          let setRoot = undefined;
          if (
            true &&
            result.patchFlag > 0 &&
            result.patchFlag & 2048 /* DEV_ROOT_FRAGMENT */
          ) {
            [root, setRoot] = getChildRoot(result);
          }
          if (fallthroughAttrs && inheritAttrs !== false) {
            const keys = Object.keys(fallthroughAttrs);
            const { shapeFlag } = root;
            if (keys.length) {
              if (shapeFlag & (1 /* ELEMENT */ | 6) /* COMPONENT */) {
                if (
                  propsOptions &&
                  keys.some(
                    _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener
                  )
                ) {
                  // If a v-model listener (onUpdate:xxx) has a corresponding declared
                  // prop, it indicates this component expects to handle v-model and
                  // it should not fallthrough.
                  // related: #1543, #1643, #1989
                  fallthroughAttrs = filterModelListeners(
                    fallthroughAttrs,
                    propsOptions
                  );
                }
                root = cloneVNode(root, fallthroughAttrs);
              } else if (true && !accessedAttrs && root.type !== Comment) {
                const allAttrs = Object.keys(attrs);
                const eventAttrs = [];
                const extraAttrs = [];
                for (let i = 0, l = allAttrs.length; i < l; i++) {
                  const key = allAttrs[i];
                  if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
                    // ignore v-model handlers when they fail to fallthrough
                    if (
                      !(0,
                      _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(
                        key
                      )
                    ) {
                      // remove `on`, lowercase first letter to reflect event casing
                      // accurately
                      eventAttrs.push(key[2].toLowerCase() + key.slice(3));
                    }
                  } else {
                    extraAttrs.push(key);
                  }
                }
                if (extraAttrs.length) {
                  warn(
                    `Extraneous non-props attributes (` +
                      `${extraAttrs.join(', ')}) ` +
                      `were passed to component but could not be automatically inherited ` +
                      `because component renders fragment or text root nodes.`
                  );
                }
                if (eventAttrs.length) {
                  warn(
                    `Extraneous non-emits event listeners (` +
                      `${eventAttrs.join(', ')}) ` +
                      `were passed to component but could not be automatically inherited ` +
                      `because component renders fragment or text root nodes. ` +
                      `If the listener is intended to be a component custom event listener only, ` +
                      `declare it using the "emits" option.`
                  );
                }
              }
            }
          }
          // inherit directives
          if (vnode.dirs) {
            if (true && !isElementRoot(root)) {
              warn(
                `Runtime directive used on component with non-element root node. ` +
                  `The directives will not function as intended.`
              );
            }
            root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
          }
          // inherit transition data
          if (vnode.transition) {
            if (true && !isElementRoot(root)) {
              warn(
                `Component inside <Transition> renders non-element root node ` +
                  `that cannot be animated.`
              );
            }
            root.transition = vnode.transition;
          }
          if (true && setRoot) {
            setRoot(root);
          } else {
            result = root;
          }
          setCurrentRenderingInstance(prev);
          return result;
        }
        /**
         * dev only
         * In dev mode, template root level comments are rendered, which turns the
         * template into a fragment root, but we need to locate the single element
         * root for attrs and scope id processing.
         */
        const getChildRoot = (vnode) => {
          const rawChildren = vnode.children;
          const dynamicChildren = vnode.dynamicChildren;
          const childRoot = filterSingleRoot(rawChildren);
          if (!childRoot) {
            return [vnode, undefined];
          }
          const index = rawChildren.indexOf(childRoot);
          const dynamicIndex = dynamicChildren
            ? dynamicChildren.indexOf(childRoot)
            : -1;
          const setRoot = (updatedRoot) => {
            rawChildren[index] = updatedRoot;
            if (dynamicChildren) {
              if (dynamicIndex > -1) {
                dynamicChildren[dynamicIndex] = updatedRoot;
              } else if (updatedRoot.patchFlag > 0) {
                vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
              }
            }
          };
          return [normalizeVNode(childRoot), setRoot];
        };
        function filterSingleRoot(children) {
          let singleRoot;
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (isVNode(child)) {
              // ignore user comment
              if (child.type !== Comment || child.children === 'v-if') {
                if (singleRoot) {
                  // has more than 1 non-comment child, return now
                  return;
                } else {
                  singleRoot = child;
                }
              }
            } else {
              return;
            }
          }
          return singleRoot;
        }
        const getFunctionalFallthrough = (attrs) => {
          let res;
          for (const key in attrs) {
            if (
              key === 'class' ||
              key === 'style' ||
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)
            ) {
              (res || (res = {}))[key] = attrs[key];
            }
          }
          return res;
        };
        const filterModelListeners = (attrs, props) => {
          const res = {};
          for (const key in attrs) {
            if (
              !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(
                key
              ) ||
              !(key.slice(9) in props)
            ) {
              res[key] = attrs[key];
            }
          }
          return res;
        };
        const isElementRoot = (vnode) => {
          return (
            vnode.shapeFlag & (6 /* COMPONENT */ | 1) /* ELEMENT */ ||
            vnode.type === Comment // potential v-if branch switch
          );
        };
        function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
          const {
            props: prevProps,
            children: prevChildren,
            component,
          } = prevVNode;
          const {
            props: nextProps,
            children: nextChildren,
            patchFlag,
          } = nextVNode;
          const emits = component.emitsOptions;
          // Parent component's render function was hot-updated. Since this may have
          // caused the child component's slots content to have changed, we need to
          // force the child to update as well.
          if (true && (prevChildren || nextChildren) && isHmrUpdating) {
            return true;
          }
          // force child update for runtime directive or transition on component vnode.
          if (nextVNode.dirs || nextVNode.transition) {
            return true;
          }
          if (optimized && patchFlag >= 0) {
            if (patchFlag & 1024 /* DYNAMIC_SLOTS */) {
              // slot content that references values that might have changed,
              // e.g. in a v-for
              return true;
            }
            if (patchFlag & 16 /* FULL_PROPS */) {
              if (!prevProps) {
                return !!nextProps;
              }
              // presence of this flag indicates props are always non-null
              return hasPropsChanged(prevProps, nextProps, emits);
            } else if (patchFlag & 8 /* PROPS */) {
              const dynamicProps = nextVNode.dynamicProps;
              for (let i = 0; i < dynamicProps.length; i++) {
                const key = dynamicProps[i];
                if (
                  nextProps[key] !== prevProps[key] &&
                  !isEmitListener(emits, key)
                ) {
                  return true;
                }
              }
            }
          } else {
            // this path is only taken by manually written render functions
            // so presence of any children leads to a forced update
            if (prevChildren || nextChildren) {
              if (!nextChildren || !nextChildren.$stable) {
                return true;
              }
            }
            if (prevProps === nextProps) {
              return false;
            }
            if (!prevProps) {
              return !!nextProps;
            }
            if (!nextProps) {
              return true;
            }
            return hasPropsChanged(prevProps, nextProps, emits);
          }
          return false;
        }
        function hasPropsChanged(prevProps, nextProps, emitsOptions) {
          const nextKeys = Object.keys(nextProps);
          if (nextKeys.length !== Object.keys(prevProps).length) {
            return true;
          }
          for (let i = 0; i < nextKeys.length; i++) {
            const key = nextKeys[i];
            if (
              nextProps[key] !== prevProps[key] &&
              !isEmitListener(emitsOptions, key)
            ) {
              return true;
            }
          }
          return false;
        }
        function updateHOCHostEl(
          { vnode, parent },
          el // HostNode
        ) {
          while (parent && parent.subTree === vnode) {
            (vnode = parent.vnode).el = el;
            parent = parent.parent;
          }
        }

        const isSuspense = (type) => type.__isSuspense;
        // Suspense exposes a component-like API, and is treated like a component
        // in the compiler, but internally it's a special built-in type that hooks
        // directly into the renderer.
        const SuspenseImpl = {
          name: 'Suspense',
          // In order to make Suspense tree-shakable, we need to avoid importing it
          // directly in the renderer. The renderer checks for the __isSuspense flag
          // on a vnode's type and calls the `process` method, passing in renderer
          // internals.
          __isSuspense: true,
          process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized,
            // platform-specific impl passed from renderer
            rendererInternals
          ) {
            if (n1 == null) {
              mountSuspense(
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized,
                rendererInternals
              );
            } else {
              patchSuspense(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                isSVG,
                slotScopeIds,
                optimized,
                rendererInternals
              );
            }
          },
          hydrate: hydrateSuspense,
          create: createSuspenseBoundary,
          normalize: normalizeSuspenseChildren,
        };
        // Force-casted public typing for h and TSX props inference
        const Suspense = SuspenseImpl;
        function triggerEvent(vnode, name) {
          const eventListener = vnode.props && vnode.props[name];
          if (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(
              eventListener
            )
          ) {
            eventListener();
          }
        }
        function mountSuspense(
          vnode,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized,
          rendererInternals
        ) {
          const {
            p: patch,
            o: { createElement },
          } = rendererInternals;
          const hiddenContainer = createElement('div');
          const suspense = (vnode.suspense = createSuspenseBoundary(
            vnode,
            parentSuspense,
            parentComponent,
            container,
            hiddenContainer,
            anchor,
            isSVG,
            slotScopeIds,
            optimized,
            rendererInternals
          ));
          // start mounting the content subtree in an off-dom container
          patch(
            null,
            (suspense.pendingBranch = vnode.ssContent),
            hiddenContainer,
            null,
            parentComponent,
            suspense,
            isSVG,
            slotScopeIds
          );
          // now check if we have encountered any async deps
          if (suspense.deps > 0) {
            // has async
            // invoke @fallback event
            triggerEvent(vnode, 'onPending');
            triggerEvent(vnode, 'onFallback');
            // mount the fallback tree
            patch(
              null,
              vnode.ssFallback,
              container,
              anchor,
              parentComponent,
              null, // fallback tree will not have suspense context
              isSVG,
              slotScopeIds
            );
            setActiveBranch(suspense, vnode.ssFallback);
          } else {
            // Suspense has no async deps. Just resolve.
            suspense.resolve();
          }
        }
        function patchSuspense(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          isSVG,
          slotScopeIds,
          optimized,
          { p: patch, um: unmount, o: { createElement } }
        ) {
          const suspense = (n2.suspense = n1.suspense);
          suspense.vnode = n2;
          n2.el = n1.el;
          const newBranch = n2.ssContent;
          const newFallback = n2.ssFallback;
          const { activeBranch, pendingBranch, isInFallback, isHydrating } =
            suspense;
          if (pendingBranch) {
            suspense.pendingBranch = newBranch;
            if (isSameVNodeType(newBranch, pendingBranch)) {
              // same root type but content may have changed.
              patch(
                pendingBranch,
                newBranch,
                suspense.hiddenContainer,
                null,
                parentComponent,
                suspense,
                isSVG,
                slotScopeIds,
                optimized
              );
              if (suspense.deps <= 0) {
                suspense.resolve();
              } else if (isInFallback) {
                patch(
                  activeBranch,
                  newFallback,
                  container,
                  anchor,
                  parentComponent,
                  null, // fallback tree will not have suspense context
                  isSVG,
                  slotScopeIds,
                  optimized
                );
                setActiveBranch(suspense, newFallback);
              }
            } else {
              // toggled before pending tree is resolved
              suspense.pendingId++;
              if (isHydrating) {
                // if toggled before hydration is finished, the current DOM tree is
                // no longer valid. set it as the active branch so it will be unmounted
                // when resolved
                suspense.isHydrating = false;
                suspense.activeBranch = pendingBranch;
              } else {
                unmount(pendingBranch, parentComponent, suspense);
              }
              // increment pending ID. this is used to invalidate async callbacks
              // reset suspense state
              suspense.deps = 0;
              // discard effects from pending branch
              suspense.effects.length = 0;
              // discard previous container
              suspense.hiddenContainer = createElement('div');
              if (isInFallback) {
                // already in fallback state
                patch(
                  null,
                  newBranch,
                  suspense.hiddenContainer,
                  null,
                  parentComponent,
                  suspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
                if (suspense.deps <= 0) {
                  suspense.resolve();
                } else {
                  patch(
                    activeBranch,
                    newFallback,
                    container,
                    anchor,
                    parentComponent,
                    null, // fallback tree will not have suspense context
                    isSVG,
                    slotScopeIds,
                    optimized
                  );
                  setActiveBranch(suspense, newFallback);
                }
              } else if (
                activeBranch &&
                isSameVNodeType(newBranch, activeBranch)
              ) {
                // toggled "back" to current active branch
                patch(
                  activeBranch,
                  newBranch,
                  container,
                  anchor,
                  parentComponent,
                  suspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
                // force resolve
                suspense.resolve(true);
              } else {
                // switched to a 3rd branch
                patch(
                  null,
                  newBranch,
                  suspense.hiddenContainer,
                  null,
                  parentComponent,
                  suspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
                if (suspense.deps <= 0) {
                  suspense.resolve();
                }
              }
            }
          } else {
            if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
              // root did not change, just normal patch
              patch(
                activeBranch,
                newBranch,
                container,
                anchor,
                parentComponent,
                suspense,
                isSVG,
                slotScopeIds,
                optimized
              );
              setActiveBranch(suspense, newBranch);
            } else {
              // root node toggled
              // invoke @pending event
              triggerEvent(n2, 'onPending');
              // mount pending branch in off-dom container
              suspense.pendingBranch = newBranch;
              suspense.pendingId++;
              patch(
                null,
                newBranch,
                suspense.hiddenContainer,
                null,
                parentComponent,
                suspense,
                isSVG,
                slotScopeIds,
                optimized
              );
              if (suspense.deps <= 0) {
                // incoming branch has no async deps, resolve now.
                suspense.resolve();
              } else {
                const { timeout, pendingId } = suspense;
                if (timeout > 0) {
                  setTimeout(() => {
                    if (suspense.pendingId === pendingId) {
                      suspense.fallback(newFallback);
                    }
                  }, timeout);
                } else if (timeout === 0) {
                  suspense.fallback(newFallback);
                }
              }
            }
          }
        }
        let hasWarned = false;
        function createSuspenseBoundary(
          vnode,
          parent,
          parentComponent,
          container,
          hiddenContainer,
          anchor,
          isSVG,
          slotScopeIds,
          optimized,
          rendererInternals,
          isHydrating = false
        ) {
          /* istanbul ignore if */
          if (true && !hasWarned) {
            hasWarned = true;
            // @ts-ignore `console.info` cannot be null error
            console[console.info ? 'info' : 'log'](
              `<Suspense> is an experimental feature and its API will likely change.`
            );
          }
          const {
            p: patch,
            m: move,
            um: unmount,
            n: next,
            o: { parentNode, remove },
          } = rendererInternals;
          const timeout = (0,
          _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(
            vnode.props && vnode.props.timeout
          );
          const suspense = {
            vnode,
            parent,
            parentComponent,
            isSVG,
            container,
            hiddenContainer,
            anchor,
            deps: 0,
            pendingId: 0,
            timeout: typeof timeout === 'number' ? timeout : -1,
            activeBranch: null,
            pendingBranch: null,
            isInFallback: true,
            isHydrating,
            isUnmounted: false,
            effects: [],
            resolve(resume = false) {
              if (true) {
                if (!resume && !suspense.pendingBranch) {
                  throw new Error(
                    `suspense.resolve() is called without a pending branch.`
                  );
                }
                if (suspense.isUnmounted) {
                  throw new Error(
                    `suspense.resolve() is called on an already unmounted suspense boundary.`
                  );
                }
              }
              const {
                vnode,
                activeBranch,
                pendingBranch,
                pendingId,
                effects,
                parentComponent,
                container,
              } = suspense;
              if (suspense.isHydrating) {
                suspense.isHydrating = false;
              } else if (!resume) {
                const delayEnter =
                  activeBranch &&
                  pendingBranch.transition &&
                  pendingBranch.transition.mode === 'out-in';
                if (delayEnter) {
                  activeBranch.transition.afterLeave = () => {
                    if (pendingId === suspense.pendingId) {
                      move(pendingBranch, container, anchor, 0 /* ENTER */);
                    }
                  };
                }
                // this is initial anchor on mount
                let { anchor } = suspense;
                // unmount current active tree
                if (activeBranch) {
                  // if the fallback tree was mounted, it may have been moved
                  // as part of a parent suspense. get the latest anchor for insertion
                  anchor = next(activeBranch);
                  unmount(activeBranch, parentComponent, suspense, true);
                }
                if (!delayEnter) {
                  // move content from off-dom container to actual container
                  move(pendingBranch, container, anchor, 0 /* ENTER */);
                }
              }
              setActiveBranch(suspense, pendingBranch);
              suspense.pendingBranch = null;
              suspense.isInFallback = false;
              // flush buffered effects
              // check if there is a pending parent suspense
              let parent = suspense.parent;
              let hasUnresolvedAncestor = false;
              while (parent) {
                if (parent.pendingBranch) {
                  // found a pending parent suspense, merge buffered post jobs
                  // into that parent
                  parent.effects.push(...effects);
                  hasUnresolvedAncestor = true;
                  break;
                }
                parent = parent.parent;
              }
              // no pending parent suspense, flush all jobs
              if (!hasUnresolvedAncestor) {
                queuePostFlushCb(effects);
              }
              suspense.effects = [];
              // invoke @resolve event
              triggerEvent(vnode, 'onResolve');
            },
            fallback(fallbackVNode) {
              if (!suspense.pendingBranch) {
                return;
              }
              const { vnode, activeBranch, parentComponent, container, isSVG } =
                suspense;
              // invoke @fallback event
              triggerEvent(vnode, 'onFallback');
              const anchor = next(activeBranch);
              const mountFallback = () => {
                if (!suspense.isInFallback) {
                  return;
                }
                // mount the fallback tree
                patch(
                  null,
                  fallbackVNode,
                  container,
                  anchor,
                  parentComponent,
                  null, // fallback tree will not have suspense context
                  isSVG,
                  slotScopeIds,
                  optimized
                );
                setActiveBranch(suspense, fallbackVNode);
              };
              const delayEnter =
                fallbackVNode.transition &&
                fallbackVNode.transition.mode === 'out-in';
              if (delayEnter) {
                activeBranch.transition.afterLeave = mountFallback;
              }
              suspense.isInFallback = true;
              // unmount current active branch
              unmount(
                activeBranch,
                parentComponent,
                null, // no suspense so unmount hooks fire now
                true // shouldRemove
              );
              if (!delayEnter) {
                mountFallback();
              }
            },
            move(container, anchor, type) {
              suspense.activeBranch &&
                move(suspense.activeBranch, container, anchor, type);
              suspense.container = container;
            },
            next() {
              return suspense.activeBranch && next(suspense.activeBranch);
            },
            registerDep(instance, setupRenderEffect) {
              const isInPendingSuspense = !!suspense.pendingBranch;
              if (isInPendingSuspense) {
                suspense.deps++;
              }
              const hydratedEl = instance.vnode.el;
              instance.asyncDep
                .catch((err) => {
                  handleError(err, instance, 0 /* SETUP_FUNCTION */);
                })
                .then((asyncSetupResult) => {
                  // retry when the setup() promise resolves.
                  // component may have been unmounted before resolve.
                  if (
                    instance.isUnmounted ||
                    suspense.isUnmounted ||
                    suspense.pendingId !== instance.suspenseId
                  ) {
                    return;
                  }
                  // retry from this component
                  instance.asyncResolved = true;
                  const { vnode } = instance;
                  if (true) {
                    pushWarningContext(vnode);
                  }
                  handleSetupResult(instance, asyncSetupResult, false);
                  if (hydratedEl) {
                    // vnode may have been replaced if an update happened before the
                    // async dep is resolved.
                    vnode.el = hydratedEl;
                  }
                  const placeholder = !hydratedEl && instance.subTree.el;
                  setupRenderEffect(
                    instance,
                    vnode,
                    // component may have been moved before resolve.
                    // if this is not a hydration, instance.subTree will be the comment
                    // placeholder.
                    parentNode(hydratedEl || instance.subTree.el),
                    // anchor will not be used if this is hydration, so only need to
                    // consider the comment placeholder case.
                    hydratedEl ? null : next(instance.subTree),
                    suspense,
                    isSVG,
                    optimized
                  );
                  if (placeholder) {
                    remove(placeholder);
                  }
                  updateHOCHostEl(instance, vnode.el);
                  if (true) {
                    popWarningContext();
                  }
                  // only decrease deps count if suspense is not already resolved
                  if (isInPendingSuspense && --suspense.deps === 0) {
                    suspense.resolve();
                  }
                });
            },
            unmount(parentSuspense, doRemove) {
              suspense.isUnmounted = true;
              if (suspense.activeBranch) {
                unmount(
                  suspense.activeBranch,
                  parentComponent,
                  parentSuspense,
                  doRemove
                );
              }
              if (suspense.pendingBranch) {
                unmount(
                  suspense.pendingBranch,
                  parentComponent,
                  parentSuspense,
                  doRemove
                );
              }
            },
          };
          return suspense;
        }
        function hydrateSuspense(
          node,
          vnode,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized,
          rendererInternals,
          hydrateNode
        ) {
          /* eslint-disable no-restricted-globals */
          const suspense = (vnode.suspense = createSuspenseBoundary(
            vnode,
            parentSuspense,
            parentComponent,
            node.parentNode,
            document.createElement('div'),
            null,
            isSVG,
            slotScopeIds,
            optimized,
            rendererInternals,
            true /* hydrating */
          ));
          // there are two possible scenarios for server-rendered suspense:
          // - success: ssr content should be fully resolved
          // - failure: ssr content should be the fallback branch.
          // however, on the client we don't really know if it has failed or not
          // attempt to hydrate the DOM assuming it has succeeded, but we still
          // need to construct a suspense boundary first
          const result = hydrateNode(
            node,
            (suspense.pendingBranch = vnode.ssContent),
            parentComponent,
            suspense,
            slotScopeIds,
            optimized
          );
          if (suspense.deps === 0) {
            suspense.resolve();
          }
          return result;
          /* eslint-enable no-restricted-globals */
        }
        function normalizeSuspenseChildren(vnode) {
          const { shapeFlag, children } = vnode;
          const isSlotChildren = shapeFlag & 32; /* SLOTS_CHILDREN */
          vnode.ssContent = normalizeSuspenseSlot(
            isSlotChildren ? children.default : children
          );
          vnode.ssFallback = isSlotChildren
            ? normalizeSuspenseSlot(children.fallback)
            : createVNode(Comment);
        }
        function normalizeSuspenseSlot(s) {
          let block;
          if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) {
            const trackBlock = isBlockTreeEnabled && s._c;
            if (trackBlock) {
              // disableTracking: false
              // allow block tracking for compiled slots
              // (see ./componentRenderContext.ts)
              s._d = false;
              openBlock();
            }
            s = s();
            if (trackBlock) {
              s._d = true;
              block = currentBlock;
              closeBlock();
            }
          }
          if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(s)) {
            const singleChild = filterSingleRoot(s);
            if (true && !singleChild) {
              warn(`<Suspense> slots expect a single root node.`);
            }
            s = singleChild;
          }
          s = normalizeVNode(s);
          if (block && !s.dynamicChildren) {
            s.dynamicChildren = block.filter((c) => c !== s);
          }
          return s;
        }
        function queueEffectWithSuspense(fn, suspense) {
          if (suspense && suspense.pendingBranch) {
            if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn)) {
              suspense.effects.push(...fn);
            } else {
              suspense.effects.push(fn);
            }
          } else {
            queuePostFlushCb(fn);
          }
        }
        function setActiveBranch(suspense, branch) {
          suspense.activeBranch = branch;
          const { vnode, parentComponent } = suspense;
          const el = (vnode.el = branch.el);
          // in case suspense is the root node of a component,
          // recursively update the HOC el
          if (parentComponent && parentComponent.subTree === vnode) {
            parentComponent.vnode.el = el;
            updateHOCHostEl(parentComponent, el);
          }
        }

        function provide(key, value) {
          if (!currentInstance) {
            if (true) {
              warn(`provide() can only be used inside setup().`);
            }
          } else {
            let provides = currentInstance.provides;
            // by default an instance inherits its parent's provides object
            // but when it needs to provide values of its own, it creates its
            // own provides object using parent provides object as prototype.
            // this way in `inject` we can simply look up injections from direct
            // parent and let the prototype chain do the work.
            const parentProvides =
              currentInstance.parent && currentInstance.parent.provides;
            if (parentProvides === provides) {
              provides = currentInstance.provides =
                Object.create(parentProvides);
            }
            // TS doesn't allow symbol as index type
            provides[key] = value;
          }
        }
        function inject(key, defaultValue, treatDefaultAsFactory = false) {
          // fallback to `currentRenderingInstance` so that this can be called in
          // a functional component
          const instance = currentInstance || currentRenderingInstance;
          if (instance) {
            // #2400
            // to support `app.use` plugins,
            // fallback to appContext's `provides` if the instance is at root
            const provides =
              instance.parent == null
                ? instance.vnode.appContext &&
                  instance.vnode.appContext.provides
                : instance.parent.provides;
            if (provides && key in provides) {
              // TS doesn't allow symbol as index type
              return provides[key];
            } else if (arguments.length > 1) {
              return treatDefaultAsFactory &&
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(
                  defaultValue
                )
                ? defaultValue.call(instance.proxy)
                : defaultValue;
            } else if (true) {
              warn(`injection "${String(key)}" not found.`);
            }
          } else if (true) {
            warn(
              `inject() can only be used inside setup() or functional components.`
            );
          }
        }

        // Simple effect.
        function watchEffect(effect, options) {
          return doWatch(effect, null, options);
        }
        function watchPostEffect(effect, options) {
          return doWatch(
            effect,
            null,
            true ? Object.assign(options || {}, { flush: 'post' }) : 0
          );
        }
        function watchSyncEffect(effect, options) {
          return doWatch(
            effect,
            null,
            true ? Object.assign(options || {}, { flush: 'sync' }) : 0
          );
        }
        // initial value for watchers to trigger on undefined initial values
        const INITIAL_WATCHER_VALUE = {};
        // implementation
        function watch(source, cb, options) {
          if (
            true &&
            !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(cb)
          ) {
            warn(
              `\`watch(fn, options?)\` signature has been moved to a separate API. ` +
                `Use \`watchEffect(fn, options?)\` instead. \`watch\` now only ` +
                `supports \`watch(source, cb, options?) signature.`
            );
          }
          return doWatch(source, cb, options);
        }
        function doWatch(
          source,
          cb,
          {
            immediate,
            deep,
            flush,
            onTrack,
            onTrigger,
          } = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ
        ) {
          if (true && !cb) {
            if (immediate !== undefined) {
              warn(
                `watch() "immediate" option is only respected when using the ` +
                  `watch(source, callback, options?) signature.`
              );
            }
            if (deep !== undefined) {
              warn(
                `watch() "deep" option is only respected when using the ` +
                  `watch(source, callback, options?) signature.`
              );
            }
          }
          const warnInvalidSource = (s) => {
            warn(
              `Invalid watch source: `,
              s,
              `A watch source can only be a getter/effect function, a ref, ` +
                `a reactive object, or an array of these types.`
            );
          };
          const instance = currentInstance;
          let getter;
          let forceTrigger = false;
          let isMultiSource = false;
          if ((0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(source)) {
            getter = () => source.value;
            forceTrigger = (0,
            _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow)(source);
          } else if (
            (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(source)
          ) {
            getter = () => source;
            deep = true;
          } else if (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(source)
          ) {
            isMultiSource = true;
            forceTrigger = source.some(
              _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive
            );
            getter = () =>
              source.map((s) => {
                if (
                  (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(s)
                ) {
                  return s.value;
                } else if (
                  (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(
                    s
                  )
                ) {
                  return traverse(s);
                } else if (
                  (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)
                ) {
                  return callWithErrorHandling(
                    s,
                    instance,
                    2 /* WATCH_GETTER */
                  );
                } else {
                  true && warnInvalidSource(s);
                }
              });
          } else if (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source)
          ) {
            if (cb) {
              // getter with cb
              getter = () =>
                callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */);
            } else {
              // no cb -> simple effect
              getter = () => {
                if (instance && instance.isUnmounted) {
                  return;
                }
                if (cleanup) {
                  cleanup();
                }
                return callWithAsyncErrorHandling(
                  source,
                  instance,
                  3 /* WATCH_CALLBACK */,
                  [onCleanup]
                );
              };
            }
          } else {
            getter = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
            true && warnInvalidSource(source);
          }
          if (cb && deep) {
            const baseGetter = getter;
            getter = () => traverse(baseGetter());
          }
          let cleanup;
          let onCleanup = (fn) => {
            cleanup = effect.onStop = () => {
              callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */);
            };
          };
          // in SSR there is no need to setup an actual effect, and it should be noop
          // unless it's eager
          if (isInSSRComponentSetup) {
            // we will also not call the invalidate callback (+ runner is not set up)
            onCleanup = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
            if (!cb) {
              getter();
            } else if (immediate) {
              callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [
                getter(),
                isMultiSource ? [] : undefined,
                onCleanup,
              ]);
            }
            return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
          }
          let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
          const job = () => {
            if (!effect.active) {
              return;
            }
            if (cb) {
              // watch(source, cb)
              const newValue = effect.run();
              if (
                deep ||
                forceTrigger ||
                (isMultiSource
                  ? newValue.some((v, i) =>
                      (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(
                        v,
                        oldValue[i]
                      )
                    )
                  : (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(
                      newValue,
                      oldValue
                    )) ||
                false
              ) {
                // cleanup before running cb again
                if (cleanup) {
                  cleanup();
                }
                callWithAsyncErrorHandling(
                  cb,
                  instance,
                  3 /* WATCH_CALLBACK */,
                  [
                    newValue,
                    // pass undefined as the old value when it's changed for the first time
                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,
                    onCleanup,
                  ]
                );
                oldValue = newValue;
              }
            } else {
              // watchEffect
              effect.run();
            }
          };
          // important: mark the job as a watcher callback so that scheduler knows
          // it is allowed to self-trigger (#1727)
          job.allowRecurse = !!cb;
          let scheduler;
          if (flush === 'sync') {
            scheduler = job; // the scheduler function gets called directly
          } else if (flush === 'post') {
            scheduler = () =>
              queuePostRenderEffect(job, instance && instance.suspense);
          } else {
            // default: 'pre'
            scheduler = () => {
              if (!instance || instance.isMounted) {
                queuePreFlushCb(job);
              } else {
                // with 'pre' option, the first call must happen before
                // the component is mounted so it is called synchronously.
                job();
              }
            };
          }
          const effect =
            new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect(
              getter,
              scheduler
            );
          if (true) {
            effect.onTrack = onTrack;
            effect.onTrigger = onTrigger;
          }
          // initial run
          if (cb) {
            if (immediate) {
              job();
            } else {
              oldValue = effect.run();
            }
          } else if (flush === 'post') {
            queuePostRenderEffect(
              effect.run.bind(effect),
              instance && instance.suspense
            );
          } else {
            effect.run();
          }
          return () => {
            effect.stop();
            if (instance && instance.scope) {
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(
                instance.scope.effects,
                effect
              );
            }
          };
        }
        // this.$watch
        function instanceWatch(source, value, options) {
          const publicThis = this.proxy;
          const getter = (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(
            source
          )
            ? source.includes('.')
              ? createPathGetter(publicThis, source)
              : () => publicThis[source]
            : source.bind(publicThis, publicThis);
          let cb;
          if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
            cb = value;
          } else {
            cb = value.handler;
            options = value;
          }
          const cur = currentInstance;
          setCurrentInstance(this);
          const res = doWatch(getter, cb.bind(publicThis), options);
          if (cur) {
            setCurrentInstance(cur);
          } else {
            unsetCurrentInstance();
          }
          return res;
        }
        function createPathGetter(ctx, path) {
          const segments = path.split('.');
          return () => {
            let cur = ctx;
            for (let i = 0; i < segments.length && cur; i++) {
              cur = cur[segments[i]];
            }
            return cur;
          };
        }
        function traverse(value, seen) {
          if (
            !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(value) ||
            value['__v_skip' /* SKIP */]
          ) {
            return value;
          }
          seen = seen || new Set();
          if (seen.has(value)) {
            return value;
          }
          seen.add(value);
          if ((0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(value)) {
            traverse(value.value, seen);
          } else if (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)
          ) {
            for (let i = 0; i < value.length; i++) {
              traverse(value[i], seen);
            }
          } else if (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value) ||
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isMap)(value)
          ) {
            value.forEach((v) => {
              traverse(v, seen);
            });
          } else if (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(value)
          ) {
            for (const key in value) {
              traverse(value[key], seen);
            }
          }
          return value;
        }

        function useTransitionState() {
          const state = {
            isMounted: false,
            isLeaving: false,
            isUnmounting: false,
            leavingVNodes: new Map(),
          };
          onMounted(() => {
            state.isMounted = true;
          });
          onBeforeUnmount(() => {
            state.isUnmounting = true;
          });
          return state;
        }
        const TransitionHookValidator = [Function, Array];
        const BaseTransitionImpl = {
          name: `BaseTransition`,
          props: {
            mode: String,
            appear: Boolean,
            persisted: Boolean,
            // enter
            onBeforeEnter: TransitionHookValidator,
            onEnter: TransitionHookValidator,
            onAfterEnter: TransitionHookValidator,
            onEnterCancelled: TransitionHookValidator,
            // leave
            onBeforeLeave: TransitionHookValidator,
            onLeave: TransitionHookValidator,
            onAfterLeave: TransitionHookValidator,
            onLeaveCancelled: TransitionHookValidator,
            // appear
            onBeforeAppear: TransitionHookValidator,
            onAppear: TransitionHookValidator,
            onAfterAppear: TransitionHookValidator,
            onAppearCancelled: TransitionHookValidator,
          },
          setup(props, { slots }) {
            const instance = getCurrentInstance();
            const state = useTransitionState();
            let prevTransitionKey;
            return () => {
              const children =
                slots.default &&
                getTransitionRawChildren(slots.default(), true);
              if (!children || !children.length) {
                return;
              }
              // warn multiple elements
              if (true && children.length > 1) {
                warn(
                  '<transition> can only be used on a single element or component. Use ' +
                    '<transition-group> for lists.'
                );
              }
              // there's no need to track reactivity for these props so use the raw
              // props for a bit better perf
              const rawProps = (0,
              _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
              const { mode } = rawProps;
              // check mode
              if (
                true &&
                mode &&
                mode !== 'in-out' &&
                mode !== 'out-in' &&
                mode !== 'default'
              ) {
                warn(`invalid <transition> mode: ${mode}`);
              }
              // at this point children has a guaranteed length of 1.
              const child = children[0];
              if (state.isLeaving) {
                return emptyPlaceholder(child);
              }
              // in the case of <transition><keep-alive/></transition>, we need to
              // compare the type of the kept-alive children.
              const innerChild = getKeepAliveChild(child);
              if (!innerChild) {
                return emptyPlaceholder(child);
              }
              const enterHooks = resolveTransitionHooks(
                innerChild,
                rawProps,
                state,
                instance
              );
              setTransitionHooks(innerChild, enterHooks);
              const oldChild = instance.subTree;
              const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
              let transitionKeyChanged = false;
              const { getTransitionKey } = innerChild.type;
              if (getTransitionKey) {
                const key = getTransitionKey();
                if (prevTransitionKey === undefined) {
                  prevTransitionKey = key;
                } else if (key !== prevTransitionKey) {
                  prevTransitionKey = key;
                  transitionKeyChanged = true;
                }
              }
              // handle mode
              if (
                oldInnerChild &&
                oldInnerChild.type !== Comment &&
                (!isSameVNodeType(innerChild, oldInnerChild) ||
                  transitionKeyChanged)
              ) {
                const leavingHooks = resolveTransitionHooks(
                  oldInnerChild,
                  rawProps,
                  state,
                  instance
                );
                // update old tree's hooks in case of dynamic transition
                setTransitionHooks(oldInnerChild, leavingHooks);
                // switching between different views
                if (mode === 'out-in') {
                  state.isLeaving = true;
                  // return placeholder node and queue update when leave finishes
                  leavingHooks.afterLeave = () => {
                    state.isLeaving = false;
                    instance.update();
                  };
                  return emptyPlaceholder(child);
                } else if (mode === 'in-out' && innerChild.type !== Comment) {
                  leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                    const leavingVNodesCache = getLeavingNodesForType(
                      state,
                      oldInnerChild
                    );
                    leavingVNodesCache[String(oldInnerChild.key)] =
                      oldInnerChild;
                    // early removal callback
                    el._leaveCb = () => {
                      earlyRemove();
                      el._leaveCb = undefined;
                      delete enterHooks.delayedLeave;
                    };
                    enterHooks.delayedLeave = delayedLeave;
                  };
                }
              }
              return child;
            };
          },
        };
        // export the public type for h/tsx inference
        // also to avoid inline import() in generated d.ts files
        const BaseTransition = BaseTransitionImpl;
        function getLeavingNodesForType(state, vnode) {
          const { leavingVNodes } = state;
          let leavingVNodesCache = leavingVNodes.get(vnode.type);
          if (!leavingVNodesCache) {
            leavingVNodesCache = Object.create(null);
            leavingVNodes.set(vnode.type, leavingVNodesCache);
          }
          return leavingVNodesCache;
        }
        // The transition hooks are attached to the vnode as vnode.transition
        // and will be called at appropriate timing in the renderer.
        function resolveTransitionHooks(vnode, props, state, instance) {
          const {
            appear,
            mode,
            persisted = false,
            onBeforeEnter,
            onEnter,
            onAfterEnter,
            onEnterCancelled,
            onBeforeLeave,
            onLeave,
            onAfterLeave,
            onLeaveCancelled,
            onBeforeAppear,
            onAppear,
            onAfterAppear,
            onAppearCancelled,
          } = props;
          const key = String(vnode.key);
          const leavingVNodesCache = getLeavingNodesForType(state, vnode);
          const callHook = (hook, args) => {
            hook &&
              callWithAsyncErrorHandling(
                hook,
                instance,
                9 /* TRANSITION_HOOK */,
                args
              );
          };
          const hooks = {
            mode,
            persisted,
            beforeEnter(el) {
              let hook = onBeforeEnter;
              if (!state.isMounted) {
                if (appear) {
                  hook = onBeforeAppear || onBeforeEnter;
                } else {
                  return;
                }
              }
              // for same element (v-show)
              if (el._leaveCb) {
                el._leaveCb(true /* cancelled */);
              }
              // for toggled element with same key (v-if)
              const leavingVNode = leavingVNodesCache[key];
              if (
                leavingVNode &&
                isSameVNodeType(vnode, leavingVNode) &&
                leavingVNode.el._leaveCb
              ) {
                // force early removal (not cancelled)
                leavingVNode.el._leaveCb();
              }
              callHook(hook, [el]);
            },
            enter(el) {
              let hook = onEnter;
              let afterHook = onAfterEnter;
              let cancelHook = onEnterCancelled;
              if (!state.isMounted) {
                if (appear) {
                  hook = onAppear || onEnter;
                  afterHook = onAfterAppear || onAfterEnter;
                  cancelHook = onAppearCancelled || onEnterCancelled;
                } else {
                  return;
                }
              }
              let called = false;
              const done = (el._enterCb = (cancelled) => {
                if (called) return;
                called = true;
                if (cancelled) {
                  callHook(cancelHook, [el]);
                } else {
                  callHook(afterHook, [el]);
                }
                if (hooks.delayedLeave) {
                  hooks.delayedLeave();
                }
                el._enterCb = undefined;
              });
              if (hook) {
                hook(el, done);
                if (hook.length <= 1) {
                  done();
                }
              } else {
                done();
              }
            },
            leave(el, remove) {
              const key = String(vnode.key);
              if (el._enterCb) {
                el._enterCb(true /* cancelled */);
              }
              if (state.isUnmounting) {
                return remove();
              }
              callHook(onBeforeLeave, [el]);
              let called = false;
              const done = (el._leaveCb = (cancelled) => {
                if (called) return;
                called = true;
                remove();
                if (cancelled) {
                  callHook(onLeaveCancelled, [el]);
                } else {
                  callHook(onAfterLeave, [el]);
                }
                el._leaveCb = undefined;
                if (leavingVNodesCache[key] === vnode) {
                  delete leavingVNodesCache[key];
                }
              });
              leavingVNodesCache[key] = vnode;
              if (onLeave) {
                onLeave(el, done);
                if (onLeave.length <= 1) {
                  done();
                }
              } else {
                done();
              }
            },
            clone(vnode) {
              return resolveTransitionHooks(vnode, props, state, instance);
            },
          };
          return hooks;
        }
        // the placeholder really only handles one special case: KeepAlive
        // in the case of a KeepAlive in a leave phase we need to return a KeepAlive
        // placeholder with empty content to avoid the KeepAlive instance from being
        // unmounted.
        function emptyPlaceholder(vnode) {
          if (isKeepAlive(vnode)) {
            vnode = cloneVNode(vnode);
            vnode.children = null;
            return vnode;
          }
        }
        function getKeepAliveChild(vnode) {
          return isKeepAlive(vnode)
            ? vnode.children
              ? vnode.children[0]
              : undefined
            : vnode;
        }
        function setTransitionHooks(vnode, hooks) {
          if (vnode.shapeFlag & 6 /* COMPONENT */ && vnode.component) {
            setTransitionHooks(vnode.component.subTree, hooks);
          } else if (vnode.shapeFlag & 128 /* SUSPENSE */) {
            vnode.ssContent.transition = hooks.clone(vnode.ssContent);
            vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
          } else {
            vnode.transition = hooks;
          }
        }
        function getTransitionRawChildren(children, keepComment = false) {
          let ret = [];
          let keyedFragmentCount = 0;
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            // handle fragment children case, e.g. v-for
            if (child.type === Fragment) {
              if (child.patchFlag & 128 /* KEYED_FRAGMENT */)
                keyedFragmentCount++;
              ret = ret.concat(
                getTransitionRawChildren(child.children, keepComment)
              );
            }
            // comment placeholders should be skipped, e.g. v-if
            else if (keepComment || child.type !== Comment) {
              ret.push(child);
            }
          }
          // #1126 if a transition children list contains multiple sub fragments, these
          // fragments will be merged into a flat children array. Since each v-for
          // fragment may contain different static bindings inside, we need to de-op
          // these children to force full diffs to ensure correct behavior.
          if (keyedFragmentCount > 1) {
            for (let i = 0; i < ret.length; i++) {
              ret[i].patchFlag = -2 /* BAIL */;
            }
          }
          return ret;
        }

        // implementation, close to no-op
        function defineComponent(options) {
          return (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(
            options
          )
            ? { setup: options, name: options.name }
            : options;
        }

        const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
        function defineAsyncComponent(source) {
          if (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source)
          ) {
            source = { loader: source };
          }
          const {
            loader,
            loadingComponent,
            errorComponent,
            delay = 200,
            timeout, // undefined = never times out
            suspensible = true,
            onError: userOnError,
          } = source;
          let pendingRequest = null;
          let resolvedComp;
          let retries = 0;
          const retry = () => {
            retries++;
            pendingRequest = null;
            return load();
          };
          const load = () => {
            let thisRequest;
            return (
              pendingRequest ||
              (thisRequest = pendingRequest =
                loader()
                  .catch((err) => {
                    err = err instanceof Error ? err : new Error(String(err));
                    if (userOnError) {
                      return new Promise((resolve, reject) => {
                        const userRetry = () => resolve(retry());
                        const userFail = () => reject(err);
                        userOnError(err, userRetry, userFail, retries + 1);
                      });
                    } else {
                      throw err;
                    }
                  })
                  .then((comp) => {
                    if (thisRequest !== pendingRequest && pendingRequest) {
                      return pendingRequest;
                    }
                    if (true && !comp) {
                      warn(
                        `Async component loader resolved to undefined. ` +
                          `If you are using retry(), make sure to return its return value.`
                      );
                    }
                    // interop module default
                    if (
                      comp &&
                      (comp.__esModule || comp[Symbol.toStringTag] === 'Module')
                    ) {
                      comp = comp.default;
                    }
                    if (
                      true &&
                      comp &&
                      !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(
                        comp
                      ) &&
                      !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(
                        comp
                      )
                    ) {
                      throw new Error(
                        `Invalid async component load result: ${comp}`
                      );
                    }
                    resolvedComp = comp;
                    return comp;
                  }))
            );
          };
          return defineComponent({
            name: 'AsyncComponentWrapper',
            __asyncLoader: load,
            get __asyncResolved() {
              return resolvedComp;
            },
            setup() {
              const instance = currentInstance;
              // already resolved
              if (resolvedComp) {
                return () => createInnerComp(resolvedComp, instance);
              }
              const onError = (err) => {
                pendingRequest = null;
                handleError(
                  err,
                  instance,
                  13 /* ASYNC_COMPONENT_LOADER */,
                  !errorComponent /* do not throw in dev if user provided error component */
                );
              };
              // suspense-controlled or SSR.
              if ((suspensible && instance.suspense) || isInSSRComponentSetup) {
                return load()
                  .then((comp) => {
                    return () => createInnerComp(comp, instance);
                  })
                  .catch((err) => {
                    onError(err);
                    return () =>
                      errorComponent
                        ? createVNode(errorComponent, {
                            error: err,
                          })
                        : null;
                  });
              }
              const loaded = (0,
              _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(false);
              const error = (0,
              _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)();
              const delayed = (0,
              _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(!!delay);
              if (delay) {
                setTimeout(() => {
                  delayed.value = false;
                }, delay);
              }
              if (timeout != null) {
                setTimeout(() => {
                  if (!loaded.value && !error.value) {
                    const err = new Error(
                      `Async component timed out after ${timeout}ms.`
                    );
                    onError(err);
                    error.value = err;
                  }
                }, timeout);
              }
              load()
                .then(() => {
                  loaded.value = true;
                  if (instance.parent && isKeepAlive(instance.parent.vnode)) {
                    // parent is keep-alive, force update so the loaded component's
                    // name is taken into account
                    queueJob(instance.parent.update);
                  }
                })
                .catch((err) => {
                  onError(err);
                  error.value = err;
                });
              return () => {
                if (loaded.value && resolvedComp) {
                  return createInnerComp(resolvedComp, instance);
                } else if (error.value && errorComponent) {
                  return createVNode(errorComponent, {
                    error: error.value,
                  });
                } else if (loadingComponent && !delayed.value) {
                  return createVNode(loadingComponent);
                }
              };
            },
          });
        }
        function createInnerComp(comp, { vnode: { ref, props, children } }) {
          const vnode = createVNode(comp, props, children);
          // ensure inner component inherits the async wrapper's ref owner
          vnode.ref = ref;
          return vnode;
        }

        const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
        const KeepAliveImpl = {
          name: `KeepAlive`,
          // Marker for special handling inside the renderer. We are not using a ===
          // check directly on KeepAlive in the renderer, because importing it directly
          // would prevent it from being tree-shaken.
          __isKeepAlive: true,
          props: {
            include: [String, RegExp, Array],
            exclude: [String, RegExp, Array],
            max: [String, Number],
          },
          setup(props, { slots }) {
            const instance = getCurrentInstance();
            // KeepAlive communicates with the instantiated renderer via the
            // ctx where the renderer passes in its internals,
            // and the KeepAlive instance exposes activate/deactivate implementations.
            // The whole point of this is to avoid importing KeepAlive directly in the
            // renderer to facilitate tree-shaking.
            const sharedContext = instance.ctx;
            // if the internal renderer is not registered, it indicates that this is server-side rendering,
            // for KeepAlive, we just need to render its children
            if (!sharedContext.renderer) {
              return slots.default;
            }
            const cache = new Map();
            const keys = new Set();
            let current = null;
            if (true) {
              instance.__v_cache = cache;
            }
            const parentSuspense = instance.suspense;
            const {
              renderer: {
                p: patch,
                m: move,
                um: _unmount,
                o: { createElement },
              },
            } = sharedContext;
            const storageContainer = createElement('div');
            sharedContext.activate = (
              vnode,
              container,
              anchor,
              isSVG,
              optimized
            ) => {
              const instance = vnode.component;
              move(vnode, container, anchor, 0 /* ENTER */, parentSuspense);
              // in case props have changed
              patch(
                instance.vnode,
                vnode,
                container,
                anchor,
                instance,
                parentSuspense,
                isSVG,
                vnode.slotScopeIds,
                optimized
              );
              queuePostRenderEffect(() => {
                instance.isDeactivated = false;
                if (instance.a) {
                  (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(
                    instance.a
                  );
                }
                const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
                if (vnodeHook) {
                  invokeVNodeHook(vnodeHook, instance.parent, vnode);
                }
              }, parentSuspense);
              if (true) {
                // Update components tree
                devtoolsComponentAdded(instance);
              }
            };
            sharedContext.deactivate = (vnode) => {
              const instance = vnode.component;
              move(
                vnode,
                storageContainer,
                null,
                1 /* LEAVE */,
                parentSuspense
              );
              queuePostRenderEffect(() => {
                if (instance.da) {
                  (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(
                    instance.da
                  );
                }
                const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
                if (vnodeHook) {
                  invokeVNodeHook(vnodeHook, instance.parent, vnode);
                }
                instance.isDeactivated = true;
              }, parentSuspense);
              if (true) {
                // Update components tree
                devtoolsComponentAdded(instance);
              }
            };
            function unmount(vnode) {
              // reset the shapeFlag so it can be properly unmounted
              resetShapeFlag(vnode);
              _unmount(vnode, instance, parentSuspense, true);
            }
            function pruneCache(filter) {
              cache.forEach((vnode, key) => {
                const name = getComponentName(vnode.type);
                if (name && (!filter || !filter(name))) {
                  pruneCacheEntry(key);
                }
              });
            }
            function pruneCacheEntry(key) {
              const cached = cache.get(key);
              if (!current || cached.type !== current.type) {
                unmount(cached);
              } else if (current) {
                // current active instance should no longer be kept-alive.
                // we can't unmount it now but it might be later, so reset its flag now.
                resetShapeFlag(current);
              }
              cache.delete(key);
              keys.delete(key);
            }
            // prune cache on include/exclude prop change
            watch(
              () => [props.include, props.exclude],
              ([include, exclude]) => {
                include && pruneCache((name) => matches(include, name));
                exclude && pruneCache((name) => !matches(exclude, name));
              },
              // prune post-render after `current` has been updated
              { flush: 'post', deep: true }
            );
            // cache sub tree after render
            let pendingCacheKey = null;
            const cacheSubtree = () => {
              // fix #1621, the pendingCacheKey could be 0
              if (pendingCacheKey != null) {
                cache.set(pendingCacheKey, getInnerChild(instance.subTree));
              }
            };
            onMounted(cacheSubtree);
            onUpdated(cacheSubtree);
            onBeforeUnmount(() => {
              cache.forEach((cached) => {
                const { subTree, suspense } = instance;
                const vnode = getInnerChild(subTree);
                if (cached.type === vnode.type) {
                  // current instance will be unmounted as part of keep-alive's unmount
                  resetShapeFlag(vnode);
                  // but invoke its deactivated hook here
                  const da = vnode.component.da;
                  da && queuePostRenderEffect(da, suspense);
                  return;
                }
                unmount(cached);
              });
            });
            return () => {
              pendingCacheKey = null;
              if (!slots.default) {
                return null;
              }
              const children = slots.default();
              const rawVNode = children[0];
              if (children.length > 1) {
                if (true) {
                  warn(`KeepAlive should contain exactly one component child.`);
                }
                current = null;
                return children;
              } else if (
                !isVNode(rawVNode) ||
                (!((rawVNode.shapeFlag & 4) /* STATEFUL_COMPONENT */) &&
                  !((rawVNode.shapeFlag & 128) /* SUSPENSE */))
              ) {
                current = null;
                return rawVNode;
              }
              let vnode = getInnerChild(rawVNode);
              const comp = vnode.type;
              // for async components, name check should be based in its loaded
              // inner component if available
              const name = getComponentName(
                isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp
              );
              const { include, exclude, max } = props;
              if (
                (include && (!name || !matches(include, name))) ||
                (exclude && name && matches(exclude, name))
              ) {
                current = vnode;
                return rawVNode;
              }
              const key = vnode.key == null ? comp : vnode.key;
              const cachedVNode = cache.get(key);
              // clone vnode if it's reused because we are going to mutate it
              if (vnode.el) {
                vnode = cloneVNode(vnode);
                if (rawVNode.shapeFlag & 128 /* SUSPENSE */) {
                  rawVNode.ssContent = vnode;
                }
              }
              // #1513 it's possible for the returned vnode to be cloned due to attr
              // fallthrough or scopeId, so the vnode here may not be the final vnode
              // that is mounted. Instead of caching it directly, we store the pending
              // key and cache `instance.subTree` (the normalized vnode) in
              // beforeMount/beforeUpdate hooks.
              pendingCacheKey = key;
              if (cachedVNode) {
                // copy over mounted state
                vnode.el = cachedVNode.el;
                vnode.component = cachedVNode.component;
                if (vnode.transition) {
                  // recursively update transition hooks on subTree
                  setTransitionHooks(vnode, vnode.transition);
                }
                // avoid vnode being mounted as fresh
                vnode.shapeFlag |= 512 /* COMPONENT_KEPT_ALIVE */;
                // make this key the freshest
                keys.delete(key);
                keys.add(key);
              } else {
                keys.add(key);
                // prune oldest entry
                if (max && keys.size > parseInt(max, 10)) {
                  pruneCacheEntry(keys.values().next().value);
                }
              }
              // avoid vnode being unmounted
              vnode.shapeFlag |= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;
              current = vnode;
              return rawVNode;
            };
          },
        };
        // export the public type for h/tsx inference
        // also to avoid inline import() in generated d.ts files
        const KeepAlive = KeepAliveImpl;
        function matches(pattern, name) {
          if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(pattern)) {
            return pattern.some((p) => matches(p, name));
          } else if (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(pattern)
          ) {
            return pattern.split(',').includes(name);
          } else if (pattern.test) {
            return pattern.test(name);
          }
          /* istanbul ignore next */
          return false;
        }
        function onActivated(hook, target) {
          registerKeepAliveHook(hook, 'a' /* ACTIVATED */, target);
        }
        function onDeactivated(hook, target) {
          registerKeepAliveHook(hook, 'da' /* DEACTIVATED */, target);
        }
        function registerKeepAliveHook(hook, type, target = currentInstance) {
          // cache the deactivate branch check wrapper for injected hooks so the same
          // hook can be properly deduped by the scheduler. "__wdc" stands for "with
          // deactivation check".
          const wrappedHook =
            hook.__wdc ||
            (hook.__wdc = () => {
              // only fire the hook if the target instance is NOT in a deactivated branch.
              let current = target;
              while (current) {
                if (current.isDeactivated) {
                  return;
                }
                current = current.parent;
              }
              return hook();
            });
          injectHook(type, wrappedHook, target);
          // In addition to registering it on the target instance, we walk up the parent
          // chain and register it on all ancestor instances that are keep-alive roots.
          // This avoids the need to walk the entire component tree when invoking these
          // hooks, and more importantly, avoids the need to track child components in
          // arrays.
          if (target) {
            let current = target.parent;
            while (current && current.parent) {
              if (isKeepAlive(current.parent.vnode)) {
                injectToKeepAliveRoot(wrappedHook, type, target, current);
              }
              current = current.parent;
            }
          }
        }
        function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
          // injectHook wraps the original for error handling, so make sure to remove
          // the wrapped version.
          const injected = injectHook(
            type,
            hook,
            keepAliveRoot,
            true /* prepend */
          );
          onUnmounted(() => {
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(
              keepAliveRoot[type],
              injected
            );
          }, target);
        }
        function resetShapeFlag(vnode) {
          let shapeFlag = vnode.shapeFlag;
          if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
            shapeFlag -= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;
          }
          if (shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {
            shapeFlag -= 512 /* COMPONENT_KEPT_ALIVE */;
          }
          vnode.shapeFlag = shapeFlag;
        }
        function getInnerChild(vnode) {
          return vnode.shapeFlag & 128 /* SUSPENSE */ ? vnode.ssContent : vnode;
        }

        function injectHook(
          type,
          hook,
          target = currentInstance,
          prepend = false
        ) {
          if (target) {
            const hooks = target[type] || (target[type] = []);
            // cache the error handling wrapper for injected hooks so the same hook
            // can be properly deduped by the scheduler. "__weh" stands for "with error
            // handling".
            const wrappedHook =
              hook.__weh ||
              (hook.__weh = (...args) => {
                if (target.isUnmounted) {
                  return;
                }
                // disable tracking inside all lifecycle hooks
                // since they can potentially be called inside effects.
                (0,
                _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
                // Set currentInstance during hook invocation.
                // This assumes the hook does not synchronously trigger other hooks, which
                // can only be false when the user does something really funky.
                setCurrentInstance(target);
                const res = callWithAsyncErrorHandling(
                  hook,
                  target,
                  type,
                  args
                );
                unsetCurrentInstance();
                (0,
                _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
                return res;
              });
            if (prepend) {
              hooks.unshift(wrappedHook);
            } else {
              hooks.push(wrappedHook);
            }
            return wrappedHook;
          } else if (true) {
            const apiName = (0,
            _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(
              ErrorTypeStrings[type].replace(/ hook$/, '')
            );
            warn(
              `${apiName} is called when there is no active component instance to be ` +
                `associated with. ` +
                `Lifecycle injection APIs can only be used during execution of setup().` +
                (` If you are using async setup(), make sure to register lifecycle ` +
                  `hooks before the first await statement.`)
            );
          }
        }
        const createHook =
          (lifecycle) =>
          (hook, target = currentInstance) =>
            // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
            (!isInSSRComponentSetup ||
              lifecycle === 'sp') /* SERVER_PREFETCH */ &&
            injectHook(lifecycle, hook, target);
        const onBeforeMount = createHook('bm' /* BEFORE_MOUNT */);
        const onMounted = createHook('m' /* MOUNTED */);
        const onBeforeUpdate = createHook('bu' /* BEFORE_UPDATE */);
        const onUpdated = createHook('u' /* UPDATED */);
        const onBeforeUnmount = createHook('bum' /* BEFORE_UNMOUNT */);
        const onUnmounted = createHook('um' /* UNMOUNTED */);
        const onServerPrefetch = createHook('sp' /* SERVER_PREFETCH */);
        const onRenderTriggered = createHook('rtg' /* RENDER_TRIGGERED */);
        const onRenderTracked = createHook('rtc' /* RENDER_TRACKED */);
        function onErrorCaptured(hook, target = currentInstance) {
          injectHook('ec' /* ERROR_CAPTURED */, hook, target);
        }

        function createDuplicateChecker() {
          const cache = Object.create(null);
          return (type, key) => {
            if (cache[key]) {
              warn(
                `${type} property "${key}" is already defined in ${cache[key]}.`
              );
            } else {
              cache[key] = type;
            }
          };
        }
        let shouldCacheAccess = true;
        function applyOptions(instance) {
          const options = resolveMergedOptions(instance);
          const publicThis = instance.proxy;
          const ctx = instance.ctx;
          // do not cache property access on public proxy during state initialization
          shouldCacheAccess = false;
          // call beforeCreate first before accessing other options since
          // the hook may mutate resolved options (#2791)
          if (options.beforeCreate) {
            callHook(options.beforeCreate, instance, 'bc' /* BEFORE_CREATE */);
          }
          const {
            // state
            data: dataOptions,
            computed: computedOptions,
            methods,
            watch: watchOptions,
            provide: provideOptions,
            inject: injectOptions,
            // lifecycle
            created,
            beforeMount,
            mounted,
            beforeUpdate,
            updated,
            activated,
            deactivated,
            beforeDestroy,
            beforeUnmount,
            destroyed,
            unmounted,
            render,
            renderTracked,
            renderTriggered,
            errorCaptured,
            serverPrefetch,
            // public API
            expose,
            inheritAttrs,
            // assets
            components,
            directives,
            filters,
          } = options;
          const checkDuplicateProperties = true ? createDuplicateChecker() : 0;
          if (true) {
            const [propsOptions] = instance.propsOptions;
            if (propsOptions) {
              for (const key in propsOptions) {
                checkDuplicateProperties('Props' /* PROPS */, key);
              }
            }
          }
          // options initialization order (to be consistent with Vue 2):
          // - props (already done outside of this function)
          // - inject
          // - methods
          // - data (deferred since it relies on `this` access)
          // - computed
          // - watch (deferred since it relies on `this` access)
          if (injectOptions) {
            resolveInjections(
              injectOptions,
              ctx,
              checkDuplicateProperties,
              instance.appContext.config.unwrapInjectedRef
            );
          }
          if (methods) {
            for (const key in methods) {
              const methodHandler = methods[key];
              if (
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(
                  methodHandler
                )
              ) {
                // In dev mode, we use the `createRenderContext` function to define
                // methods to the proxy target, and those are read-only but
                // reconfigurable, so it needs to be redefined here
                if (true) {
                  Object.defineProperty(ctx, key, {
                    value: methodHandler.bind(publicThis),
                    configurable: true,
                    enumerable: true,
                    writable: true,
                  });
                } else {
                }
                if (true) {
                  checkDuplicateProperties('Methods' /* METHODS */, key);
                }
              } else if (true) {
                warn(
                  `Method "${key}" has type "${typeof methodHandler}" in the component definition. ` +
                    `Did you reference the function correctly?`
                );
              }
            }
          }
          if (dataOptions) {
            if (
              true &&
              !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(
                dataOptions
              )
            ) {
              warn(
                `The data option must be a function. ` +
                  `Plain object usage is no longer supported.`
              );
            }
            const data = dataOptions.call(publicThis, publicThis);
            if (
              true &&
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(data)
            ) {
              warn(
                `data() returned a Promise - note data() cannot be async; If you ` +
                  `intend to perform data fetching before component renders, use ` +
                  `async setup() + <Suspense>.`
              );
            }
            if (!(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(data)) {
              true && warn(`data() should return an object.`);
            } else {
              instance.data = (0,
              _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive)(data);
              if (true) {
                for (const key in data) {
                  checkDuplicateProperties('Data' /* DATA */, key);
                  // expose data on ctx during dev
                  if (key[0] !== '$' && key[0] !== '_') {
                    Object.defineProperty(ctx, key, {
                      configurable: true,
                      enumerable: true,
                      get: () => data[key],
                      set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP,
                    });
                  }
                }
              }
            }
          }
          // state initialization complete at this point - start caching access
          shouldCacheAccess = true;
          if (computedOptions) {
            for (const key in computedOptions) {
              const opt = computedOptions[key];
              const get = (0,
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt)
                ? opt.bind(publicThis, publicThis)
                : (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(
                    opt.get
                  )
                ? opt.get.bind(publicThis, publicThis)
                : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
              if (
                true &&
                get === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
              ) {
                warn(`Computed property "${key}" has no getter.`);
              }
              const set =
                !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(
                  opt
                ) &&
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(
                  opt.set
                )
                  ? opt.set.bind(publicThis)
                  : true
                  ? () => {
                      warn(
                        `Write operation failed: computed property "${key}" is readonly.`
                      );
                    }
                  : 0;
              const c = computed({
                get,
                set,
              });
              Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: () => c.value,
                set: (v) => (c.value = v),
              });
              if (true) {
                checkDuplicateProperties('Computed' /* COMPUTED */, key);
              }
            }
          }
          if (watchOptions) {
            for (const key in watchOptions) {
              createWatcher(watchOptions[key], ctx, publicThis, key);
            }
          }
          if (provideOptions) {
            const provides = (0,
            _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(provideOptions)
              ? provideOptions.call(publicThis)
              : provideOptions;
            Reflect.ownKeys(provides).forEach((key) => {
              provide(key, provides[key]);
            });
          }
          if (created) {
            callHook(created, instance, 'c' /* CREATED */);
          }
          function registerLifecycleHook(register, hook) {
            if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {
              hook.forEach((_hook) => register(_hook.bind(publicThis)));
            } else if (hook) {
              register(hook.bind(publicThis));
            }
          }
          registerLifecycleHook(onBeforeMount, beforeMount);
          registerLifecycleHook(onMounted, mounted);
          registerLifecycleHook(onBeforeUpdate, beforeUpdate);
          registerLifecycleHook(onUpdated, updated);
          registerLifecycleHook(onActivated, activated);
          registerLifecycleHook(onDeactivated, deactivated);
          registerLifecycleHook(onErrorCaptured, errorCaptured);
          registerLifecycleHook(onRenderTracked, renderTracked);
          registerLifecycleHook(onRenderTriggered, renderTriggered);
          registerLifecycleHook(onBeforeUnmount, beforeUnmount);
          registerLifecycleHook(onUnmounted, unmounted);
          registerLifecycleHook(onServerPrefetch, serverPrefetch);
          if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(expose)) {
            if (expose.length) {
              const exposed = instance.exposed || (instance.exposed = {});
              expose.forEach((key) => {
                Object.defineProperty(exposed, key, {
                  get: () => publicThis[key],
                  set: (val) => (publicThis[key] = val),
                });
              });
            } else if (!instance.exposed) {
              instance.exposed = {};
            }
          }
          // options that are handled when creating the instance but also need to be
          // applied from mixins
          if (
            render &&
            instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
          ) {
            instance.render = render;
          }
          if (inheritAttrs != null) {
            instance.inheritAttrs = inheritAttrs;
          }
          // asset options.
          if (components) instance.components = components;
          if (directives) instance.directives = directives;
        }
        function resolveInjections(
          injectOptions,
          ctx,
          checkDuplicateProperties = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP,
          unwrapRef = false
        ) {
          if (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(injectOptions)
          ) {
            injectOptions = normalizeInject(injectOptions);
          }
          for (const key in injectOptions) {
            const opt = injectOptions[key];
            let injected;
            if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opt)) {
              if ('default' in opt) {
                injected = inject(
                  opt.from || key,
                  opt.default,
                  true /* treat default function as factory */
                );
              } else {
                injected = inject(opt.from || key);
              }
            } else {
              injected = inject(opt);
            }
            if (
              (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(injected)
            ) {
              // TODO remove the check in 3.3
              if (unwrapRef) {
                Object.defineProperty(ctx, key, {
                  enumerable: true,
                  configurable: true,
                  get: () => injected.value,
                  set: (v) => (injected.value = v),
                });
              } else {
                if (true) {
                  warn(
                    `injected property "${key}" is a ref and will be auto-unwrapped ` +
                      `and no longer needs \`.value\` in the next minor release. ` +
                      `To opt-in to the new behavior now, ` +
                      `set \`app.config.unwrapInjectedRef = true\` (this config is ` +
                      `temporary and will not be needed in the future.)`
                  );
                }
                ctx[key] = injected;
              }
            } else {
              ctx[key] = injected;
            }
            if (true) {
              checkDuplicateProperties('Inject' /* INJECT */, key);
            }
          }
        }
        function callHook(hook, instance, type) {
          callWithAsyncErrorHandling(
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)
              ? hook.map((h) => h.bind(instance.proxy))
              : hook.bind(instance.proxy),
            instance,
            type
          );
        }
        function createWatcher(raw, ctx, publicThis, key) {
          const getter = key.includes('.')
            ? createPathGetter(publicThis, key)
            : () => publicThis[key];
          if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw)) {
            const handler = ctx[raw];
            if (
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(handler)
            ) {
              watch(getter, handler);
            } else if (true) {
              warn(`Invalid watch handler specified by key "${raw}"`, handler);
            }
          } else if (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw)
          ) {
            watch(getter, raw.bind(publicThis));
          } else if (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)
          ) {
            if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
              raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
            } else {
              const handler = (0,
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw.handler)
                ? raw.handler.bind(publicThis)
                : ctx[raw.handler];
              if (
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(
                  handler
                )
              ) {
                watch(getter, handler, raw);
              } else if (true) {
                warn(
                  `Invalid watch handler specified by key "${raw.handler}"`,
                  handler
                );
              }
            }
          } else if (true) {
            warn(`Invalid watch option: "${key}"`, raw);
          }
        }
        /**
         * Resolve merged options and cache it on the component.
         * This is done only once per-component since the merging does not involve
         * instances.
         */
        function resolveMergedOptions(instance) {
          const base = instance.type;
          const { mixins, extends: extendsOptions } = base;
          const {
            mixins: globalMixins,
            optionsCache: cache,
            config: { optionMergeStrategies },
          } = instance.appContext;
          const cached = cache.get(base);
          let resolved;
          if (cached) {
            resolved = cached;
          } else if (!globalMixins.length && !mixins && !extendsOptions) {
            {
              resolved = base;
            }
          } else {
            resolved = {};
            if (globalMixins.length) {
              globalMixins.forEach((m) =>
                mergeOptions(resolved, m, optionMergeStrategies, true)
              );
            }
            mergeOptions(resolved, base, optionMergeStrategies);
          }
          cache.set(base, resolved);
          return resolved;
        }
        function mergeOptions(to, from, strats, asMixin = false) {
          const { mixins, extends: extendsOptions } = from;
          if (extendsOptions) {
            mergeOptions(to, extendsOptions, strats, true);
          }
          if (mixins) {
            mixins.forEach((m) => mergeOptions(to, m, strats, true));
          }
          for (const key in from) {
            if (asMixin && key === 'expose') {
              true &&
                warn(
                  `"expose" option is ignored when declared in mixins or extends. ` +
                    `It should only be declared in the base component itself.`
                );
            } else {
              const strat =
                internalOptionMergeStrats[key] || (strats && strats[key]);
              to[key] = strat ? strat(to[key], from[key]) : from[key];
            }
          }
          return to;
        }
        const internalOptionMergeStrats = {
          data: mergeDataFn,
          props: mergeObjectOptions,
          emits: mergeObjectOptions,
          // objects
          methods: mergeObjectOptions,
          computed: mergeObjectOptions,
          // lifecycle
          beforeCreate: mergeAsArray,
          created: mergeAsArray,
          beforeMount: mergeAsArray,
          mounted: mergeAsArray,
          beforeUpdate: mergeAsArray,
          updated: mergeAsArray,
          beforeDestroy: mergeAsArray,
          beforeUnmount: mergeAsArray,
          destroyed: mergeAsArray,
          unmounted: mergeAsArray,
          activated: mergeAsArray,
          deactivated: mergeAsArray,
          errorCaptured: mergeAsArray,
          serverPrefetch: mergeAsArray,
          // assets
          components: mergeObjectOptions,
          directives: mergeObjectOptions,
          // watch
          watch: mergeWatchOptions,
          // provide / inject
          provide: mergeDataFn,
          inject: mergeInject,
        };
        function mergeDataFn(to, from) {
          if (!from) {
            return to;
          }
          if (!to) {
            return from;
          }
          return function mergedDataFn() {
            return (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(to)
                ? to.call(this, this)
                : to,
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(from)
                ? from.call(this, this)
                : from
            );
          };
        }
        function mergeInject(to, from) {
          return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
        }
        function normalizeInject(raw) {
          if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
            const res = {};
            for (let i = 0; i < raw.length; i++) {
              res[raw[i]] = raw[i];
            }
            return res;
          }
          return raw;
        }
        function mergeAsArray(to, from) {
          return to ? [...new Set([].concat(to, from))] : from;
        }
        function mergeObjectOptions(to, from) {
          return to
            ? (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(
                  Object.create(null),
                  to
                ),
                from
              )
            : from;
        }
        function mergeWatchOptions(to, from) {
          if (!to) return from;
          if (!from) return to;
          const merged = (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(
            Object.create(null),
            to
          );
          for (const key in from) {
            merged[key] = mergeAsArray(to[key], from[key]);
          }
          return merged;
        }

        function initProps(
          instance,
          rawProps,
          isStateful, // result of bitwise flag comparison
          isSSR = false
        ) {
          const props = {};
          const attrs = {};
          (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(
            attrs,
            InternalObjectKey,
            1
          );
          instance.propsDefaults = Object.create(null);
          setFullProps(instance, rawProps, props, attrs);
          // ensure all declared prop keys are present
          for (const key in instance.propsOptions[0]) {
            if (!(key in props)) {
              props[key] = undefined;
            }
          }
          // validation
          if (true) {
            validateProps(rawProps || {}, props, instance);
          }
          if (isStateful) {
            // stateful
            instance.props = isSSR
              ? props
              : (0,
                _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive)(
                  props
                );
          } else {
            if (!instance.type.props) {
              // functional w/ optional props, props === attrs
              instance.props = attrs;
            } else {
              // functional w/ declared props
              instance.props = props;
            }
          }
          instance.attrs = attrs;
        }
        function updateProps(instance, rawProps, rawPrevProps, optimized) {
          const {
            props,
            attrs,
            vnode: { patchFlag },
          } = instance;
          const rawCurrentProps = (0,
          _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
          const [options] = instance.propsOptions;
          let hasAttrsChanged = false;
          if (
            // always force full diff in dev
            // - #1942 if hmr is enabled with sfc component
            // - vite#872 non-sfc component used by sfc component
            !(
              true &&
              (instance.type.__hmrId ||
                (instance.parent && instance.parent.type.__hmrId))
            ) &&
            (optimized || patchFlag > 0) &&
            !((patchFlag & 16) /* FULL_PROPS */)
          ) {
            if (patchFlag & 8 /* PROPS */) {
              // Compiler-generated props & no keys change, just set the updated
              // the props.
              const propsToUpdate = instance.vnode.dynamicProps;
              for (let i = 0; i < propsToUpdate.length; i++) {
                let key = propsToUpdate[i];
                // PROPS flag guarantees rawProps to be non-null
                const value = rawProps[key];
                if (options) {
                  // attr / props separation was done on init and will be consistent
                  // in this code path, so just check if attrs have it.
                  if (
                    (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(
                      attrs,
                      key
                    )
                  ) {
                    if (value !== attrs[key]) {
                      attrs[key] = value;
                      hasAttrsChanged = true;
                    }
                  } else {
                    const camelizedKey = (0,
                    _vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);
                    props[camelizedKey] = resolvePropValue(
                      options,
                      rawCurrentProps,
                      camelizedKey,
                      value,
                      instance,
                      false /* isAbsent */
                    );
                  }
                } else {
                  if (value !== attrs[key]) {
                    attrs[key] = value;
                    hasAttrsChanged = true;
                  }
                }
              }
            }
          } else {
            // full props update.
            if (setFullProps(instance, rawProps, props, attrs)) {
              hasAttrsChanged = true;
            }
            // in case of dynamic props, check if we need to delete keys from
            // the props object
            let kebabKey;
            for (const key in rawCurrentProps) {
              if (
                !rawProps ||
                // for camelCase
                (!(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(
                  rawProps,
                  key
                ) &&
                  // it's possible the original props was passed in as kebab-case
                  // and converted to camelCase (#955)
                  ((kebabKey = (0,
                  _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)) ===
                    key ||
                    !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(
                      rawProps,
                      kebabKey
                    )))
              ) {
                if (options) {
                  if (
                    rawPrevProps &&
                    // for camelCase
                    (rawPrevProps[key] !== undefined ||
                      // for kebab-case
                      rawPrevProps[kebabKey] !== undefined)
                  ) {
                    props[key] = resolvePropValue(
                      options,
                      rawCurrentProps,
                      key,
                      undefined,
                      instance,
                      true /* isAbsent */
                    );
                  }
                } else {
                  delete props[key];
                }
              }
            }
            // in the case of functional component w/o props declaration, props and
            // attrs point to the same object so it should already have been updated.
            if (attrs !== rawCurrentProps) {
              for (const key in attrs) {
                if (
                  !rawProps ||
                  (!(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(
                    rawProps,
                    key
                  ) &&
                    !false)
                ) {
                  delete attrs[key];
                  hasAttrsChanged = true;
                }
              }
            }
          }
          // trigger updates for $attrs in case it's used in component slots
          if (hasAttrsChanged) {
            (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.trigger)(
              instance,
              'set' /* SET */,
              '$attrs'
            );
          }
          if (true) {
            validateProps(rawProps || {}, props, instance);
          }
        }
        function setFullProps(instance, rawProps, props, attrs) {
          const [options, needCastKeys] = instance.propsOptions;
          let hasAttrsChanged = false;
          let rawCastValues;
          if (rawProps) {
            for (let key in rawProps) {
              // key, ref are reserved and never passed down
              if (
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(
                  key
                )
              ) {
                continue;
              }
              const value = rawProps[key];
              // prop option names are camelized during normalization, so to support
              // kebab -> camel conversion here we need to camelize the key.
              let camelKey;
              if (
                options &&
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(
                  options,
                  (camelKey = (0,
                  _vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key))
                )
              ) {
                if (!needCastKeys || !needCastKeys.includes(camelKey)) {
                  props[camelKey] = value;
                } else {
                  (rawCastValues || (rawCastValues = {}))[camelKey] = value;
                }
              } else if (!isEmitListener(instance.emitsOptions, key)) {
                if (!(key in attrs) || value !== attrs[key]) {
                  attrs[key] = value;
                  hasAttrsChanged = true;
                }
              }
            }
          }
          if (needCastKeys) {
            const rawCurrentProps = (0,
            _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
            const castValues =
              rawCastValues ||
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
            for (let i = 0; i < needCastKeys.length; i++) {
              const key = needCastKeys[i];
              props[key] = resolvePropValue(
                options,
                rawCurrentProps,
                key,
                castValues[key],
                instance,
                !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(
                  castValues,
                  key
                )
              );
            }
          }
          return hasAttrsChanged;
        }
        function resolvePropValue(
          options,
          props,
          key,
          value,
          instance,
          isAbsent
        ) {
          const opt = options[key];
          if (opt != null) {
            const hasDefault = (0,
            _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(opt, 'default');
            // default values
            if (hasDefault && value === undefined) {
              const defaultValue = opt.default;
              if (
                opt.type !== Function &&
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(
                  defaultValue
                )
              ) {
                const { propsDefaults } = instance;
                if (key in propsDefaults) {
                  value = propsDefaults[key];
                } else {
                  setCurrentInstance(instance);
                  value = propsDefaults[key] = defaultValue.call(null, props);
                  unsetCurrentInstance();
                }
              } else {
                value = defaultValue;
              }
            }
            // boolean casting
            if (opt[0 /* shouldCast */]) {
              if (isAbsent && !hasDefault) {
                value = false;
              } else if (
                opt[1 /* shouldCastTrue */] &&
                (value === '' ||
                  value ===
                    (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(
                      key
                    ))
              ) {
                value = true;
              }
            }
          }
          return value;
        }
        function normalizePropsOptions(comp, appContext, asMixin = false) {
          const cache = appContext.propsCache;
          const cached = cache.get(comp);
          if (cached) {
            return cached;
          }
          const raw = comp.props;
          const normalized = {};
          const needCastKeys = [];
          // apply mixin/extends props
          let hasExtends = false;
          if (
            true &&
            !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)
          ) {
            const extendProps = (raw) => {
              hasExtends = true;
              const [props, keys] = normalizePropsOptions(
                raw,
                appContext,
                true
              );
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(
                normalized,
                props
              );
              if (keys) needCastKeys.push(...keys);
            };
            if (!asMixin && appContext.mixins.length) {
              appContext.mixins.forEach(extendProps);
            }
            if (comp.extends) {
              extendProps(comp.extends);
            }
            if (comp.mixins) {
              comp.mixins.forEach(extendProps);
            }
          }
          if (!raw && !hasExtends) {
            cache.set(comp, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR);
            return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
          }
          if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
            for (let i = 0; i < raw.length; i++) {
              if (
                true &&
                !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw[i])
              ) {
                warn(`props must be strings when using array syntax.`, raw[i]);
              }
              const normalizedKey = (0,
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(raw[i]);
              if (validatePropName(normalizedKey)) {
                normalized[normalizedKey] =
                  _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
              }
            }
          } else if (raw) {
            if (
              true &&
              !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)
            ) {
              warn(`invalid props options`, raw);
            }
            for (const key in raw) {
              const normalizedKey = (0,
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);
              if (validatePropName(normalizedKey)) {
                const opt = raw[key];
                const prop = (normalized[normalizedKey] =
                  (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opt) ||
                  (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt)
                    ? { type: opt }
                    : opt);
                if (prop) {
                  const booleanIndex = getTypeIndex(Boolean, prop.type);
                  const stringIndex = getTypeIndex(String, prop.type);
                  prop[0 /* shouldCast */] = booleanIndex > -1;
                  prop[1 /* shouldCastTrue */] =
                    stringIndex < 0 || booleanIndex < stringIndex;
                  // if the prop needs boolean casting or default value
                  if (
                    booleanIndex > -1 ||
                    (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(
                      prop,
                      'default'
                    )
                  ) {
                    needCastKeys.push(normalizedKey);
                  }
                }
              }
            }
          }
          const res = [normalized, needCastKeys];
          cache.set(comp, res);
          return res;
        }
        function validatePropName(key) {
          if (key[0] !== '$') {
            return true;
          } else if (true) {
            warn(`Invalid prop name: "${key}" is a reserved property.`);
          }
          return false;
        }
        // use function string name to check type constructors
        // so that it works across vms / iframes.
        function getType(ctor) {
          const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
          return match ? match[1] : ctor === null ? 'null' : '';
        }
        function isSameType(a, b) {
          return getType(a) === getType(b);
        }
        function getTypeIndex(type, expectedTypes) {
          if (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(expectedTypes)
          ) {
            return expectedTypes.findIndex((t) => isSameType(t, type));
          } else if (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(
              expectedTypes
            )
          ) {
            return isSameType(expectedTypes, type) ? 0 : -1;
          }
          return -1;
        }
        /**
         * dev only
         */
        function validateProps(rawProps, props, instance) {
          const resolvedValues = (0,
          _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
          const options = instance.propsOptions[0];
          for (const key in options) {
            let opt = options[key];
            if (opt == null) continue;
            validateProp(
              key,
              resolvedValues[key],
              opt,
              !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(
                rawProps,
                key
              ) &&
                !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(
                  rawProps,
                  (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)
                )
            );
          }
        }
        /**
         * dev only
         */
        function validateProp(name, value, prop, isAbsent) {
          const { type, required, validator } = prop;
          // required!
          if (required && isAbsent) {
            warn('Missing required prop: "' + name + '"');
            return;
          }
          // missing but optional
          if (value == null && !prop.required) {
            return;
          }
          // type check
          if (type != null && type !== true) {
            let isValid = false;
            const types = (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(
              type
            )
              ? type
              : [type];
            const expectedTypes = [];
            // value is valid as long as one of the specified types match
            for (let i = 0; i < types.length && !isValid; i++) {
              const { valid, expectedType } = assertType(value, types[i]);
              expectedTypes.push(expectedType || '');
              isValid = valid;
            }
            if (!isValid) {
              warn(getInvalidTypeMessage(name, value, expectedTypes));
              return;
            }
          }
          // custom validator
          if (validator && !validator(value)) {
            warn(
              'Invalid prop: custom validator check failed for prop "' +
                name +
                '".'
            );
          }
        }
        const isSimpleType = /*#__PURE__*/ (0,
        _vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(
          'String,Number,Boolean,Function,Symbol,BigInt'
        );
        /**
         * dev only
         */
        function assertType(value, type) {
          let valid;
          const expectedType = getType(type);
          if (isSimpleType(expectedType)) {
            const t = typeof value;
            valid = t === expectedType.toLowerCase();
            // for primitive wrapper objects
            if (!valid && t === 'object') {
              valid = value instanceof type;
            }
          } else if (expectedType === 'Object') {
            valid = (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(
              value
            );
          } else if (expectedType === 'Array') {
            valid = (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(
              value
            );
          } else if (expectedType === 'null') {
            valid = value === null;
          } else {
            valid = value instanceof type;
          }
          return {
            valid,
            expectedType,
          };
        }
        /**
         * dev only
         */
        function getInvalidTypeMessage(name, value, expectedTypes) {
          let message =
            `Invalid prop: type check failed for prop "${name}".` +
            ` Expected ${expectedTypes
              .map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)
              .join(' | ')}`;
          const expectedType = expectedTypes[0];
          const receivedType = (0,
          _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toRawType)(value);
          const expectedValue = styleValue(value, expectedType);
          const receivedValue = styleValue(value, receivedType);
          // check if we need to specify expected value
          if (
            expectedTypes.length === 1 &&
            isExplicable(expectedType) &&
            !isBoolean(expectedType, receivedType)
          ) {
            message += ` with value ${expectedValue}`;
          }
          message += `, got ${receivedType} `;
          // check if we need to specify received value
          if (isExplicable(receivedType)) {
            message += `with value ${receivedValue}.`;
          }
          return message;
        }
        /**
         * dev only
         */
        function styleValue(value, type) {
          if (type === 'String') {
            return `"${value}"`;
          } else if (type === 'Number') {
            return `${Number(value)}`;
          } else {
            return `${value}`;
          }
        }
        /**
         * dev only
         */
        function isExplicable(type) {
          const explicitTypes = ['string', 'number', 'boolean'];
          return explicitTypes.some((elem) => type.toLowerCase() === elem);
        }
        /**
         * dev only
         */
        function isBoolean(...args) {
          return args.some((elem) => elem.toLowerCase() === 'boolean');
        }

        const isInternalKey = (key) => key[0] === '_' || key === '$stable';
        const normalizeSlotValue = (value) =>
          (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)
            ? value.map(normalizeVNode)
            : [normalizeVNode(value)];
        const normalizeSlot = (key, rawSlot, ctx) => {
          const normalized = withCtx((...args) => {
            if (true && currentInstance) {
              warn(
                `Slot "${key}" invoked outside of the render function: ` +
                  `this will not track dependencies used in the slot. ` +
                  `Invoke the slot function inside the render function instead.`
              );
            }
            return normalizeSlotValue(rawSlot(...args));
          }, ctx);
          normalized._c = false;
          return normalized;
        };
        const normalizeObjectSlots = (rawSlots, slots, instance) => {
          const ctx = rawSlots._ctx;
          for (const key in rawSlots) {
            if (isInternalKey(key)) continue;
            const value = rawSlots[key];
            if (
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)
            ) {
              slots[key] = normalizeSlot(key, value, ctx);
            } else if (value != null) {
              if (true) {
                warn(
                  `Non-function value encountered for slot "${key}". ` +
                    `Prefer function slots for better performance.`
                );
              }
              const normalized = normalizeSlotValue(value);
              slots[key] = () => normalized;
            }
          }
        };
        const normalizeVNodeSlots = (instance, children) => {
          if (true && !isKeepAlive(instance.vnode) && !false) {
            warn(
              `Non-function value encountered for default slot. ` +
                `Prefer function slots for better performance.`
            );
          }
          const normalized = normalizeSlotValue(children);
          instance.slots.default = () => normalized;
        };
        const initSlots = (instance, children) => {
          if (instance.vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {
            const type = children._;
            if (type) {
              // users can get the shallow readonly version of the slots object through `this.$slots`,
              // we should avoid the proxy object polluting the slots of the internal instance
              instance.slots = (0,
              _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(children);
              // make compiler marker non-enumerable
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(
                children,
                '_',
                type
              );
            } else {
              normalizeObjectSlots(children, (instance.slots = {}));
            }
          } else {
            instance.slots = {};
            if (children) {
              normalizeVNodeSlots(instance, children);
            }
          }
          (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(
            instance.slots,
            InternalObjectKey,
            1
          );
        };
        const updateSlots = (instance, children, optimized) => {
          const { vnode, slots } = instance;
          let needDeletionCheck = true;
          let deletionComparisonTarget =
            _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
          if (vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {
            const type = children._;
            if (type) {
              // compiled slots.
              if (true && isHmrUpdating) {
                // Parent was HMR updated so slot content may have changed.
                // force update slots and mark instance for hmr as well
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(
                  slots,
                  children
                );
              } else if (optimized && type === 1 /* STABLE */) {
                // compiled AND stable.
                // no need to update, and skip stale slots removal.
                needDeletionCheck = false;
              } else {
                // compiled but dynamic (v-if/v-for on slots) - update slots, but skip
                // normalization.
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(
                  slots,
                  children
                );
                // #2893
                // when rendering the optimized slots by manually written render function,
                // we need to delete the `slots._` flag if necessary to make subsequent updates reliable,
                // i.e. let the `renderSlot` create the bailed Fragment
                if (!optimized && type === 1 /* STABLE */) {
                  delete slots._;
                }
              }
            } else {
              needDeletionCheck = !children.$stable;
              normalizeObjectSlots(children, slots);
            }
            deletionComparisonTarget = children;
          } else if (children) {
            // non slot object children (direct value) passed to a component
            normalizeVNodeSlots(instance, children);
            deletionComparisonTarget = { default: 1 };
          }
          // delete stale slots
          if (needDeletionCheck) {
            for (const key in slots) {
              if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
                delete slots[key];
              }
            }
          }
        };

        /**
Runtime helper for applying directives to a vnode. Example usage:

const comp = resolveComponent('comp')
const foo = resolveDirective('foo')
const bar = resolveDirective('bar')

return withDirectives(h(comp), [
  [foo, this.x],
  [bar, this.y]
])
*/
        function validateDirectiveName(name) {
          if (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isBuiltInDirective)(
              name
            )
          ) {
            warn(
              'Do not use built-in directive ids as custom directive id: ' +
                name
            );
          }
        }
        /**
         * Adds directives to a VNode.
         */
        function withDirectives(vnode, directives) {
          const internalInstance = currentRenderingInstance;
          if (internalInstance === null) {
            true &&
              warn(`withDirectives can only be used inside render functions.`);
            return vnode;
          }
          const instance = internalInstance.proxy;
          const bindings = vnode.dirs || (vnode.dirs = []);
          for (let i = 0; i < directives.length; i++) {
            let [
              dir,
              value,
              arg,
              modifiers = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
            ] = directives[i];
            if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dir)) {
              dir = {
                mounted: dir,
                updated: dir,
              };
            }
            if (dir.deep) {
              traverse(value);
            }
            bindings.push({
              dir,
              instance,
              value,
              oldValue: void 0,
              arg,
              modifiers,
            });
          }
          return vnode;
        }
        function invokeDirectiveHook(vnode, prevVNode, instance, name) {
          const bindings = vnode.dirs;
          const oldBindings = prevVNode && prevVNode.dirs;
          for (let i = 0; i < bindings.length; i++) {
            const binding = bindings[i];
            if (oldBindings) {
              binding.oldValue = oldBindings[i].value;
            }
            let hook = binding.dir[name];
            if (hook) {
              // disable tracking inside all lifecycle hooks
              // since they can potentially be called inside effects.
              (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
              callWithAsyncErrorHandling(
                hook,
                instance,
                8 /* DIRECTIVE_HOOK */,
                [vnode.el, binding, vnode, prevVNode]
              );
              (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
            }
          }
        }

        function createAppContext() {
          return {
            app: null,
            config: {
              isNativeTag: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO,
              performance: false,
              globalProperties: {},
              optionMergeStrategies: {},
              errorHandler: undefined,
              warnHandler: undefined,
              compilerOptions: {},
            },
            mixins: [],
            components: {},
            directives: {},
            provides: Object.create(null),
            optionsCache: new WeakMap(),
            propsCache: new WeakMap(),
            emitsCache: new WeakMap(),
          };
        }
        let uid = 0;
        function createAppAPI(render, hydrate) {
          return function createApp(rootComponent, rootProps = null) {
            if (
              rootProps != null &&
              !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(rootProps)
            ) {
              true &&
                warn(`root props passed to app.mount() must be an object.`);
              rootProps = null;
            }
            const context = createAppContext();
            const installedPlugins = new Set();
            let isMounted = false;
            const app = (context.app = {
              _uid: uid++,
              _component: rootComponent,
              _props: rootProps,
              _container: null,
              _context: context,
              _instance: null,
              version,
              get config() {
                return context.config;
              },
              set config(v) {
                if (true) {
                  warn(
                    `app.config cannot be replaced. Modify individual options instead.`
                  );
                }
              },
              use(plugin, ...options) {
                if (installedPlugins.has(plugin)) {
                  true &&
                    warn(`Plugin has already been applied to target app.`);
                } else if (
                  plugin &&
                  (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(
                    plugin.install
                  )
                ) {
                  installedPlugins.add(plugin);
                  plugin.install(app, ...options);
                } else if (
                  (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(
                    plugin
                  )
                ) {
                  installedPlugins.add(plugin);
                  plugin(app, ...options);
                } else if (true) {
                  warn(
                    `A plugin must either be a function or an object with an "install" ` +
                      `function.`
                  );
                }
                return app;
              },
              mixin(mixin) {
                if (true) {
                  if (!context.mixins.includes(mixin)) {
                    context.mixins.push(mixin);
                  } else if (true) {
                    warn(
                      'Mixin has already been applied to target app' +
                        (mixin.name ? `: ${mixin.name}` : '')
                    );
                  }
                } else {
                }
                return app;
              },
              component(name, component) {
                if (true) {
                  validateComponentName(name, context.config);
                }
                if (!component) {
                  return context.components[name];
                }
                if (true && context.components[name]) {
                  warn(
                    `Component "${name}" has already been registered in target app.`
                  );
                }
                context.components[name] = component;
                return app;
              },
              directive(name, directive) {
                if (true) {
                  validateDirectiveName(name);
                }
                if (!directive) {
                  return context.directives[name];
                }
                if (true && context.directives[name]) {
                  warn(
                    `Directive "${name}" has already been registered in target app.`
                  );
                }
                context.directives[name] = directive;
                return app;
              },
              mount(rootContainer, isHydrate, isSVG) {
                if (!isMounted) {
                  const vnode = createVNode(rootComponent, rootProps);
                  // store app context on the root VNode.
                  // this will be set on the root instance on initial mount.
                  vnode.appContext = context;
                  // HMR root reload
                  if (true) {
                    context.reload = () => {
                      render(cloneVNode(vnode), rootContainer, isSVG);
                    };
                  }
                  if (isHydrate && hydrate) {
                    hydrate(vnode, rootContainer);
                  } else {
                    render(vnode, rootContainer, isSVG);
                  }
                  isMounted = true;
                  app._container = rootContainer;
                  rootContainer.__vue_app__ = app;
                  if (true) {
                    app._instance = vnode.component;
                    devtoolsInitApp(app, version);
                  }
                  return (
                    getExposeProxy(vnode.component) || vnode.component.proxy
                  );
                } else if (true) {
                  warn(
                    `App has already been mounted.\n` +
                      `If you want to remount the same app, move your app creation logic ` +
                      `into a factory function and create fresh app instances for each ` +
                      `mount - e.g. \`const createMyApp = () => createApp(App)\``
                  );
                }
              },
              unmount() {
                if (isMounted) {
                  render(null, app._container);
                  if (true) {
                    app._instance = null;
                    devtoolsUnmountApp(app);
                  }
                  delete app._container.__vue_app__;
                } else if (true) {
                  warn(`Cannot unmount an app that is not mounted.`);
                }
              },
              provide(key, value) {
                if (true && key in context.provides) {
                  warn(
                    `App already provides property with key "${String(
                      key
                    )}". ` + `It will be overwritten with the new value.`
                  );
                }
                // TypeScript doesn't allow symbols as index type
                // https://github.com/Microsoft/TypeScript/issues/24587
                context.provides[key] = value;
                return app;
              },
            });
            return app;
          };
        }

        /**
         * Function for handling a template ref
         */
        function setRef(
          rawRef,
          oldRawRef,
          parentSuspense,
          vnode,
          isUnmount = false
        ) {
          if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(rawRef)) {
            rawRef.forEach((r, i) =>
              setRef(
                r,
                oldRawRef &&
                  ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(
                    oldRawRef
                  )
                    ? oldRawRef[i]
                    : oldRawRef),
                parentSuspense,
                vnode,
                isUnmount
              )
            );
            return;
          }
          if (isAsyncWrapper(vnode) && !isUnmount) {
            // when mounting async components, nothing needs to be done,
            // because the template ref is forwarded to inner component
            return;
          }
          const refValue =
            vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */
              ? getExposeProxy(vnode.component) || vnode.component.proxy
              : vnode.el;
          const value = isUnmount ? null : refValue;
          const { i: owner, r: ref } = rawRef;
          if (true && !owner) {
            warn(
              `Missing ref owner context. ref cannot be used on hoisted vnodes. ` +
                `A vnode with ref must be created inside the render function.`
            );
            return;
          }
          const oldRef = oldRawRef && oldRawRef.r;
          const refs =
            owner.refs === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ
              ? (owner.refs = {})
              : owner.refs;
          const setupState = owner.setupState;
          // dynamic ref changed. unset old ref
          if (oldRef != null && oldRef !== ref) {
            if (
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(oldRef)
            ) {
              refs[oldRef] = null;
              if (
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(
                  setupState,
                  oldRef
                )
              ) {
                setupState[oldRef] = null;
              }
            } else if (
              (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(oldRef)
            ) {
              oldRef.value = null;
            }
          }
          if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref)) {
            callWithErrorHandling(ref, owner, 12 /* FUNCTION_REF */, [
              value,
              refs,
            ]);
          } else {
            const _isString = (0,
            _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref);
            const _isRef = (0,
            _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref);
            if (_isString || _isRef) {
              const doSet = () => {
                if (rawRef.f) {
                  const existing = _isString ? refs[ref] : ref.value;
                  if (isUnmount) {
                    (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(
                      existing
                    ) &&
                      (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(
                        existing,
                        refValue
                      );
                  } else {
                    if (
                      !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(
                        existing
                      )
                    ) {
                      if (_isString) {
                        refs[ref] = [refValue];
                      } else {
                        ref.value = [refValue];
                        if (rawRef.k) refs[rawRef.k] = ref.value;
                      }
                    } else if (!existing.includes(refValue)) {
                      existing.push(refValue);
                    }
                  }
                } else if (_isString) {
                  refs[ref] = value;
                  if (
                    (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(
                      setupState,
                      ref
                    )
                  ) {
                    setupState[ref] = value;
                  }
                } else if (
                  (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref)
                ) {
                  ref.value = value;
                  if (rawRef.k) refs[rawRef.k] = value;
                } else if (true) {
                  warn('Invalid template ref type:', ref, `(${typeof ref})`);
                }
              };
              if (value) {
                doSet.id = -1;
                queuePostRenderEffect(doSet, parentSuspense);
              } else {
                doSet();
              }
            } else if (true) {
              warn('Invalid template ref type:', ref, `(${typeof ref})`);
            }
          }
        }

        let hasMismatch = false;
        const isSVGContainer = (container) =>
          /svg/.test(container.namespaceURI) &&
          container.tagName !== 'foreignObject';
        const isComment = (node) => node.nodeType === 8; /* COMMENT */
        // Note: hydration is DOM-specific
        // But we have to place it in core due to tight coupling with core - splitting
        // it out creates a ton of unnecessary complexity.
        // Hydration also depends on some renderer internal logic which needs to be
        // passed in via arguments.
        function createHydrationFunctions(rendererInternals) {
          const {
            mt: mountComponent,
            p: patch,
            o: {
              patchProp,
              nextSibling,
              parentNode,
              remove,
              insert,
              createComment,
            },
          } = rendererInternals;
          const hydrate = (vnode, container) => {
            if (!container.hasChildNodes()) {
              true &&
                warn(
                  `Attempting to hydrate existing markup but container is empty. ` +
                    `Performing full mount instead.`
                );
              patch(null, vnode, container);
              flushPostFlushCbs();
              return;
            }
            hasMismatch = false;
            hydrateNode(container.firstChild, vnode, null, null, null);
            flushPostFlushCbs();
            if (hasMismatch && !false) {
              // this error should show up in production
              console.error(`Hydration completed but contains mismatches.`);
            }
          };
          const hydrateNode = (
            node,
            vnode,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized = false
          ) => {
            const isFragmentStart = isComment(node) && node.data === '[';
            const onMismatch = () =>
              handleMismatch(
                node,
                vnode,
                parentComponent,
                parentSuspense,
                slotScopeIds,
                isFragmentStart
              );
            const { type, ref, shapeFlag } = vnode;
            const domType = node.nodeType;
            vnode.el = node;
            let nextNode = null;
            switch (type) {
              case Text:
                if (domType !== 3 /* TEXT */) {
                  nextNode = onMismatch();
                } else {
                  if (node.data !== vnode.children) {
                    hasMismatch = true;
                    true &&
                      warn(
                        `Hydration text mismatch:` +
                          `\n- Client: ${JSON.stringify(node.data)}` +
                          `\n- Server: ${JSON.stringify(vnode.children)}`
                      );
                    node.data = vnode.children;
                  }
                  nextNode = nextSibling(node);
                }
                break;
              case Comment:
                if (domType !== 8 /* COMMENT */ || isFragmentStart) {
                  nextNode = onMismatch();
                } else {
                  nextNode = nextSibling(node);
                }
                break;
              case Static:
                if (domType !== 1 /* ELEMENT */) {
                  nextNode = onMismatch();
                } else {
                  // determine anchor, adopt content
                  nextNode = node;
                  // if the static vnode has its content stripped during build,
                  // adopt it from the server-rendered HTML.
                  const needToAdoptContent = !vnode.children.length;
                  for (let i = 0; i < vnode.staticCount; i++) {
                    if (needToAdoptContent)
                      vnode.children += nextNode.outerHTML;
                    if (i === vnode.staticCount - 1) {
                      vnode.anchor = nextNode;
                    }
                    nextNode = nextSibling(nextNode);
                  }
                  return nextNode;
                }
                break;
              case Fragment:
                if (!isFragmentStart) {
                  nextNode = onMismatch();
                } else {
                  nextNode = hydrateFragment(
                    node,
                    vnode,
                    parentComponent,
                    parentSuspense,
                    slotScopeIds,
                    optimized
                  );
                }
                break;
              default:
                if (shapeFlag & 1 /* ELEMENT */) {
                  if (
                    domType !== 1 /* ELEMENT */ ||
                    vnode.type.toLowerCase() !== node.tagName.toLowerCase()
                  ) {
                    nextNode = onMismatch();
                  } else {
                    nextNode = hydrateElement(
                      node,
                      vnode,
                      parentComponent,
                      parentSuspense,
                      slotScopeIds,
                      optimized
                    );
                  }
                } else if (shapeFlag & 6 /* COMPONENT */) {
                  // when setting up the render effect, if the initial vnode already
                  // has .el set, the component will perform hydration instead of mount
                  // on its sub-tree.
                  vnode.slotScopeIds = slotScopeIds;
                  const container = parentNode(node);
                  mountComponent(
                    vnode,
                    container,
                    null,
                    parentComponent,
                    parentSuspense,
                    isSVGContainer(container),
                    optimized
                  );
                  // component may be async, so in the case of fragments we cannot rely
                  // on component's rendered output to determine the end of the fragment
                  // instead, we do a lookahead to find the end anchor node.
                  nextNode = isFragmentStart
                    ? locateClosingAsyncAnchor(node)
                    : nextSibling(node);
                  // #3787
                  // if component is async, it may get moved / unmounted before its
                  // inner component is loaded, so we need to give it a placeholder
                  // vnode that matches its adopted DOM.
                  if (isAsyncWrapper(vnode)) {
                    let subTree;
                    if (isFragmentStart) {
                      subTree = createVNode(Fragment);
                      subTree.anchor = nextNode
                        ? nextNode.previousSibling
                        : container.lastChild;
                    } else {
                      subTree =
                        node.nodeType === 3
                          ? createTextVNode('')
                          : createVNode('div');
                    }
                    subTree.el = node;
                    vnode.component.subTree = subTree;
                  }
                } else if (shapeFlag & 64 /* TELEPORT */) {
                  if (domType !== 8 /* COMMENT */) {
                    nextNode = onMismatch();
                  } else {
                    nextNode = vnode.type.hydrate(
                      node,
                      vnode,
                      parentComponent,
                      parentSuspense,
                      slotScopeIds,
                      optimized,
                      rendererInternals,
                      hydrateChildren
                    );
                  }
                } else if (shapeFlag & 128 /* SUSPENSE */) {
                  nextNode = vnode.type.hydrate(
                    node,
                    vnode,
                    parentComponent,
                    parentSuspense,
                    isSVGContainer(parentNode(node)),
                    slotScopeIds,
                    optimized,
                    rendererInternals,
                    hydrateNode
                  );
                } else if (true) {
                  warn('Invalid HostVNode type:', type, `(${typeof type})`);
                }
            }
            if (ref != null) {
              setRef(ref, null, parentSuspense, vnode);
            }
            return nextNode;
          };
          const hydrateElement = (
            el,
            vnode,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          ) => {
            optimized = optimized || !!vnode.dynamicChildren;
            const { type, props, patchFlag, shapeFlag, dirs } = vnode;
            // #4006 for form elements with non-string v-model value bindings
            // e.g. <option :value="obj">, <input type="checkbox" :true-value="1">
            const forcePatchValue =
              (type === 'input' && dirs) || type === 'option';
            // skip props & children if this is hoisted static nodes
            // #5405 in dev, always hydrate children for HMR
            if (true /* HOISTED */) {
              if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'created');
              }
              // props
              if (props) {
                if (
                  forcePatchValue ||
                  !optimized ||
                  patchFlag & (16 /* FULL_PROPS */ | 32) /* HYDRATE_EVENTS */
                ) {
                  for (const key in props) {
                    if (
                      (forcePatchValue && key.endsWith('value')) ||
                      ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(
                        key
                      ) &&
                        !(0,
                        _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(
                          key
                        ))
                    ) {
                      patchProp(
                        el,
                        key,
                        null,
                        props[key],
                        false,
                        undefined,
                        parentComponent
                      );
                    }
                  }
                } else if (props.onClick) {
                  // Fast path for click listeners (which is most often) to avoid
                  // iterating through props.
                  patchProp(
                    el,
                    'onClick',
                    null,
                    props.onClick,
                    false,
                    undefined,
                    parentComponent
                  );
                }
              }
              // vnode / directive hooks
              let vnodeHooks;
              if ((vnodeHooks = props && props.onVnodeBeforeMount)) {
                invokeVNodeHook(vnodeHooks, parentComponent, vnode);
              }
              if (dirs) {
                invokeDirectiveHook(
                  vnode,
                  null,
                  parentComponent,
                  'beforeMount'
                );
              }
              if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {
                queueEffectWithSuspense(() => {
                  vnodeHooks &&
                    invokeVNodeHook(vnodeHooks, parentComponent, vnode);
                  dirs &&
                    invokeDirectiveHook(
                      vnode,
                      null,
                      parentComponent,
                      'mounted'
                    );
                }, parentSuspense);
              }
              // children
              if (
                shapeFlag & 16 /* ARRAY_CHILDREN */ &&
                // skip if element has innerHTML / textContent
                !(props && (props.innerHTML || props.textContent))
              ) {
                let next = hydrateChildren(
                  el.firstChild,
                  vnode,
                  el,
                  parentComponent,
                  parentSuspense,
                  slotScopeIds,
                  optimized
                );
                let hasWarned = false;
                while (next) {
                  hasMismatch = true;
                  if (true && !hasWarned) {
                    warn(
                      `Hydration children mismatch in <${vnode.type}>: ` +
                        `server rendered element contains more child nodes than client vdom.`
                    );
                    hasWarned = true;
                  }
                  // The SSRed DOM contains more nodes than it should. Remove them.
                  const cur = next;
                  next = next.nextSibling;
                  remove(cur);
                }
              } else if (shapeFlag & 8 /* TEXT_CHILDREN */) {
                if (el.textContent !== vnode.children) {
                  hasMismatch = true;
                  true &&
                    warn(
                      `Hydration text content mismatch in <${vnode.type}>:\n` +
                        `- Client: ${el.textContent}\n` +
                        `- Server: ${vnode.children}`
                    );
                  el.textContent = vnode.children;
                }
              }
            }
            return el.nextSibling;
          };
          const hydrateChildren = (
            node,
            parentVNode,
            container,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          ) => {
            optimized = optimized || !!parentVNode.dynamicChildren;
            const children = parentVNode.children;
            const l = children.length;
            let hasWarned = false;
            for (let i = 0; i < l; i++) {
              const vnode = optimized
                ? children[i]
                : (children[i] = normalizeVNode(children[i]));
              if (node) {
                node = hydrateNode(
                  node,
                  vnode,
                  parentComponent,
                  parentSuspense,
                  slotScopeIds,
                  optimized
                );
              } else if (vnode.type === Text && !vnode.children) {
                continue;
              } else {
                hasMismatch = true;
                if (true && !hasWarned) {
                  warn(
                    `Hydration children mismatch in <${container.tagName.toLowerCase()}>: ` +
                      `server rendered element contains fewer child nodes than client vdom.`
                  );
                  hasWarned = true;
                }
                // the SSRed DOM didn't contain enough nodes. Mount the missing ones.
                patch(
                  null,
                  vnode,
                  container,
                  null,
                  parentComponent,
                  parentSuspense,
                  isSVGContainer(container),
                  slotScopeIds
                );
              }
            }
            return node;
          };
          const hydrateFragment = (
            node,
            vnode,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          ) => {
            const { slotScopeIds: fragmentSlotScopeIds } = vnode;
            if (fragmentSlotScopeIds) {
              slotScopeIds = slotScopeIds
                ? slotScopeIds.concat(fragmentSlotScopeIds)
                : fragmentSlotScopeIds;
            }
            const container = parentNode(node);
            const next = hydrateChildren(
              nextSibling(node),
              vnode,
              container,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
            if (next && isComment(next) && next.data === ']') {
              return nextSibling((vnode.anchor = next));
            } else {
              // fragment didn't hydrate successfully, since we didn't get a end anchor
              // back. This should have led to node/children mismatch warnings.
              hasMismatch = true;
              // since the anchor is missing, we need to create one and insert it
              insert((vnode.anchor = createComment(`]`)), container, next);
              return next;
            }
          };
          const handleMismatch = (
            node,
            vnode,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            isFragment
          ) => {
            hasMismatch = true;
            true &&
              warn(
                `Hydration node mismatch:\n- Client vnode:`,
                vnode.type,
                `\n- Server rendered DOM:`,
                node,
                node.nodeType === 3 /* TEXT */
                  ? `(text)`
                  : isComment(node) && node.data === '['
                  ? `(start of fragment)`
                  : ``
              );
            vnode.el = null;
            if (isFragment) {
              // remove excessive fragment nodes
              const end = locateClosingAsyncAnchor(node);
              while (true) {
                const next = nextSibling(node);
                if (next && next !== end) {
                  remove(next);
                } else {
                  break;
                }
              }
            }
            const next = nextSibling(node);
            const container = parentNode(node);
            remove(node);
            patch(
              null,
              vnode,
              container,
              next,
              parentComponent,
              parentSuspense,
              isSVGContainer(container),
              slotScopeIds
            );
            return next;
          };
          const locateClosingAsyncAnchor = (node) => {
            let match = 0;
            while (node) {
              node = nextSibling(node);
              if (node && isComment(node)) {
                if (node.data === '[') match++;
                if (node.data === ']') {
                  if (match === 0) {
                    return nextSibling(node);
                  } else {
                    match--;
                  }
                }
              }
            }
            return node;
          };
          return [hydrate, hydrateNode];
        }

        /* eslint-disable no-restricted-globals */
        let supported;
        let perf;
        function startMeasure(instance, type) {
          if (instance.appContext.config.performance && isSupported()) {
            perf.mark(`vue-${type}-${instance.uid}`);
          }
          if (true) {
            devtoolsPerfStart(
              instance,
              type,
              supported ? perf.now() : Date.now()
            );
          }
        }
        function endMeasure(instance, type) {
          if (instance.appContext.config.performance && isSupported()) {
            const startTag = `vue-${type}-${instance.uid}`;
            const endTag = startTag + `:end`;
            perf.mark(endTag);
            perf.measure(
              `<${formatComponentName(instance, instance.type)}> ${type}`,
              startTag,
              endTag
            );
            perf.clearMarks(startTag);
            perf.clearMarks(endTag);
          }
          if (true) {
            devtoolsPerfEnd(
              instance,
              type,
              supported ? perf.now() : Date.now()
            );
          }
        }
        function isSupported() {
          if (supported !== undefined) {
            return supported;
          }
          if (typeof window !== 'undefined' && window.performance) {
            supported = true;
            perf = window.performance;
          } else {
            supported = false;
          }
          return supported;
        }

        /**
         * This is only called in esm-bundler builds.
         * It is called when a renderer is created, in `baseCreateRenderer` so that
         * importing runtime-core is side-effects free.
         *
         * istanbul-ignore-next
         */
        function initFeatureFlags() {
          const needWarn = [];
          if (false) {
          }
          if (false) {
          }
          if (true && needWarn.length) {
            const multi = needWarn.length > 1;
            console.warn(
              `Feature flag${multi ? `s` : ``} ${needWarn.join(', ')} ${
                multi ? `are` : `is`
              } not explicitly defined. You are running the esm-bundler build of Vue, ` +
                `which expects these compile-time feature flags to be globally injected ` +
                `via the bundler config in order to get better tree-shaking in the ` +
                `production bundle.\n\n` +
                `For more details, see https://link.vuejs.org/feature-flags.`
            );
          }
        }

        const queuePostRenderEffect = queueEffectWithSuspense;
        /**
         * The createRenderer function accepts two generic arguments:
         * HostNode and HostElement, corresponding to Node and Element types in the
         * host environment. For example, for runtime-dom, HostNode would be the DOM
         * `Node` interface and HostElement would be the DOM `Element` interface.
         *
         * Custom renderers can pass in the platform specific types like this:
         *
         * ``` js
         * const { render, createApp } = createRenderer<Node, Element>({
         *   patchProp,
         *   ...nodeOps
         * })
         * ```
         */
        function createRenderer(options) {
          return baseCreateRenderer(options);
        }
        // Separate API for creating hydration-enabled renderer.
        // Hydration logic is only used when calling this function, making it
        // tree-shakable.
        function createHydrationRenderer(options) {
          return baseCreateRenderer(options, createHydrationFunctions);
        }
        // implementation
        function baseCreateRenderer(options, createHydrationFns) {
          // compile-time feature flags check
          {
            initFeatureFlags();
          }
          const target = (0,
          _vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)();
          target.__VUE__ = true;
          if (true) {
            setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
          }
          const {
            insert: hostInsert,
            remove: hostRemove,
            patchProp: hostPatchProp,
            createElement: hostCreateElement,
            createText: hostCreateText,
            createComment: hostCreateComment,
            setText: hostSetText,
            setElementText: hostSetElementText,
            parentNode: hostParentNode,
            nextSibling: hostNextSibling,
            setScopeId:
              hostSetScopeId = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP,
            cloneNode: hostCloneNode,
            insertStaticContent: hostInsertStaticContent,
          } = options;
          // Note: functions inside this closure should use `const xxx = () => {}`
          // style in order to prevent being inlined by minifiers.
          const patch = (
            n1,
            n2,
            container,
            anchor = null,
            parentComponent = null,
            parentSuspense = null,
            isSVG = false,
            slotScopeIds = null,
            optimized = true && isHmrUpdating ? false : !!n2.dynamicChildren
          ) => {
            if (n1 === n2) {
              return;
            }
            // patching & not same type, unmount old tree
            if (n1 && !isSameVNodeType(n1, n2)) {
              anchor = getNextHostNode(n1);
              unmount(n1, parentComponent, parentSuspense, true);
              n1 = null;
            }
            if (n2.patchFlag === -2 /* BAIL */) {
              optimized = false;
              n2.dynamicChildren = null;
            }
            const { type, ref, shapeFlag } = n2;
            switch (type) {
              case Text:
                processText(n1, n2, container, anchor);
                break;
              case Comment:
                processCommentNode(n1, n2, container, anchor);
                break;
              case Static:
                if (n1 == null) {
                  mountStaticNode(n2, container, anchor, isSVG);
                } else if (true) {
                  patchStaticNode(n1, n2, container, isSVG);
                }
                break;
              case Fragment:
                processFragment(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
                break;
              default:
                if (shapeFlag & 1 /* ELEMENT */) {
                  processElement(
                    n1,
                    n2,
                    container,
                    anchor,
                    parentComponent,
                    parentSuspense,
                    isSVG,
                    slotScopeIds,
                    optimized
                  );
                } else if (shapeFlag & 6 /* COMPONENT */) {
                  processComponent(
                    n1,
                    n2,
                    container,
                    anchor,
                    parentComponent,
                    parentSuspense,
                    isSVG,
                    slotScopeIds,
                    optimized
                  );
                } else if (shapeFlag & 64 /* TELEPORT */) {
                  type.process(
                    n1,
                    n2,
                    container,
                    anchor,
                    parentComponent,
                    parentSuspense,
                    isSVG,
                    slotScopeIds,
                    optimized,
                    internals
                  );
                } else if (shapeFlag & 128 /* SUSPENSE */) {
                  type.process(
                    n1,
                    n2,
                    container,
                    anchor,
                    parentComponent,
                    parentSuspense,
                    isSVG,
                    slotScopeIds,
                    optimized,
                    internals
                  );
                } else if (true) {
                  warn('Invalid VNode type:', type, `(${typeof type})`);
                }
            }
            // set ref
            if (ref != null && parentComponent) {
              setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
            }
          };
          const processText = (n1, n2, container, anchor) => {
            if (n1 == null) {
              hostInsert(
                (n2.el = hostCreateText(n2.children)),
                container,
                anchor
              );
            } else {
              const el = (n2.el = n1.el);
              if (n2.children !== n1.children) {
                hostSetText(el, n2.children);
              }
            }
          };
          const processCommentNode = (n1, n2, container, anchor) => {
            if (n1 == null) {
              hostInsert(
                (n2.el = hostCreateComment(n2.children || '')),
                container,
                anchor
              );
            } else {
              // there's no support for dynamic comments
              n2.el = n1.el;
            }
          };
          const mountStaticNode = (n2, container, anchor, isSVG) => {
            [n2.el, n2.anchor] = hostInsertStaticContent(
              n2.children,
              container,
              anchor,
              isSVG,
              n2.el,
              n2.anchor
            );
          };
          /**
           * Dev / HMR only
           */
          const patchStaticNode = (n1, n2, container, isSVG) => {
            // static nodes are only patched during dev for HMR
            if (n2.children !== n1.children) {
              const anchor = hostNextSibling(n1.anchor);
              // remove existing
              removeStaticNode(n1);
              [n2.el, n2.anchor] = hostInsertStaticContent(
                n2.children,
                container,
                anchor,
                isSVG
              );
            } else {
              n2.el = n1.el;
              n2.anchor = n1.anchor;
            }
          };
          const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
            let next;
            while (el && el !== anchor) {
              next = hostNextSibling(el);
              hostInsert(el, container, nextSibling);
              el = next;
            }
            hostInsert(anchor, container, nextSibling);
          };
          const removeStaticNode = ({ el, anchor }) => {
            let next;
            while (el && el !== anchor) {
              next = hostNextSibling(el);
              hostRemove(el);
              el = next;
            }
            hostRemove(anchor);
          };
          const processElement = (
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          ) => {
            isSVG = isSVG || n2.type === 'svg';
            if (n1 == null) {
              mountElement(
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
            } else {
              patchElement(
                n1,
                n2,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
            }
          };
          const mountElement = (
            vnode,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          ) => {
            let el;
            let vnodeHook;
            const { type, props, shapeFlag, transition, patchFlag, dirs } =
              vnode;
            if (false /* HOISTED */) {
            } else {
              el = vnode.el = hostCreateElement(
                vnode.type,
                isSVG,
                props && props.is,
                props
              );
              // mount children first, since some props may rely on child content
              // being already rendered, e.g. `<select value>`
              if (shapeFlag & 8 /* TEXT_CHILDREN */) {
                hostSetElementText(el, vnode.children);
              } else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                mountChildren(
                  vnode.children,
                  el,
                  null,
                  parentComponent,
                  parentSuspense,
                  isSVG && type !== 'foreignObject',
                  slotScopeIds,
                  optimized
                );
              }
              if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'created');
              }
              // props
              if (props) {
                for (const key in props) {
                  if (
                    key !== 'value' &&
                    !(0,
                    _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(
                      key
                    )
                  ) {
                    hostPatchProp(
                      el,
                      key,
                      null,
                      props[key],
                      isSVG,
                      vnode.children,
                      parentComponent,
                      parentSuspense,
                      unmountChildren
                    );
                  }
                }
                /**
                 * Special case for setting value on DOM elements:
                 * - it can be order-sensitive (e.g. should be set *after* min/max, #2325, #4024)
                 * - it needs to be forced (#1471)
                 * #2353 proposes adding another renderer option to configure this, but
                 * the properties affects are so finite it is worth special casing it
                 * here to reduce the complexity. (Special casing it also should not
                 * affect non-DOM renderers)
                 */
                if ('value' in props) {
                  hostPatchProp(el, 'value', null, props.value);
                }
                if ((vnodeHook = props.onVnodeBeforeMount)) {
                  invokeVNodeHook(vnodeHook, parentComponent, vnode);
                }
              }
              // scopeId
              setScopeId(
                el,
                vnode,
                vnode.scopeId,
                slotScopeIds,
                parentComponent
              );
            }
            if (true) {
              Object.defineProperty(el, '__vnode', {
                value: vnode,
                enumerable: false,
              });
              Object.defineProperty(el, '__vueParentComponent', {
                value: parentComponent,
                enumerable: false,
              });
            }
            if (dirs) {
              invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
            }
            // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved
            // #1689 For inside suspense + suspense resolved case, just call it
            const needCallTransitionHooks =
              (!parentSuspense ||
                (parentSuspense && !parentSuspense.pendingBranch)) &&
              transition &&
              !transition.persisted;
            if (needCallTransitionHooks) {
              transition.beforeEnter(el);
            }
            hostInsert(el, container, anchor);
            if (
              (vnodeHook = props && props.onVnodeMounted) ||
              needCallTransitionHooks ||
              dirs
            ) {
              queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                needCallTransitionHooks && transition.enter(el);
                dirs &&
                  invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
              }, parentSuspense);
            }
          };
          const setScopeId = (
            el,
            vnode,
            scopeId,
            slotScopeIds,
            parentComponent
          ) => {
            if (scopeId) {
              hostSetScopeId(el, scopeId);
            }
            if (slotScopeIds) {
              for (let i = 0; i < slotScopeIds.length; i++) {
                hostSetScopeId(el, slotScopeIds[i]);
              }
            }
            if (parentComponent) {
              let subTree = parentComponent.subTree;
              if (
                true &&
                subTree.patchFlag > 0 &&
                subTree.patchFlag & 2048 /* DEV_ROOT_FRAGMENT */
              ) {
                subTree = filterSingleRoot(subTree.children) || subTree;
              }
              if (vnode === subTree) {
                const parentVNode = parentComponent.vnode;
                setScopeId(
                  el,
                  parentVNode,
                  parentVNode.scopeId,
                  parentVNode.slotScopeIds,
                  parentComponent.parent
                );
              }
            }
          };
          const mountChildren = (
            children,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized,
            start = 0
          ) => {
            for (let i = start; i < children.length; i++) {
              const child = (children[i] = optimized
                ? cloneIfMounted(children[i])
                : normalizeVNode(children[i]));
              patch(
                null,
                child,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
            }
          };
          const patchElement = (
            n1,
            n2,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          ) => {
            const el = (n2.el = n1.el);
            let { patchFlag, dynamicChildren, dirs } = n2;
            // #1426 take the old vnode's patch flag into account since user may clone a
            // compiler-generated vnode, which de-opts to FULL_PROPS
            patchFlag |= n1.patchFlag & 16 /* FULL_PROPS */;
            const oldProps =
              n1.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
            const newProps =
              n2.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
            let vnodeHook;
            // disable recurse in beforeUpdate hooks
            parentComponent && toggleRecurse(parentComponent, false);
            if ((vnodeHook = newProps.onVnodeBeforeUpdate)) {
              invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
            }
            if (dirs) {
              invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate');
            }
            parentComponent && toggleRecurse(parentComponent, true);
            if (true && isHmrUpdating) {
              // HMR updated, force full diff
              patchFlag = 0;
              optimized = false;
              dynamicChildren = null;
            }
            const areChildrenSVG = isSVG && n2.type !== 'foreignObject';
            if (dynamicChildren) {
              patchBlockChildren(
                n1.dynamicChildren,
                dynamicChildren,
                el,
                parentComponent,
                parentSuspense,
                areChildrenSVG,
                slotScopeIds
              );
              if (true && parentComponent && parentComponent.type.__hmrId) {
                traverseStaticChildren(n1, n2);
              }
            } else if (!optimized) {
              // full diff
              patchChildren(
                n1,
                n2,
                el,
                null,
                parentComponent,
                parentSuspense,
                areChildrenSVG,
                slotScopeIds,
                false
              );
            }
            if (patchFlag > 0) {
              // the presence of a patchFlag means this element's render code was
              // generated by the compiler and can take the fast path.
              // in this path old node and new node are guaranteed to have the same shape
              // (i.e. at the exact same position in the source template)
              if (patchFlag & 16 /* FULL_PROPS */) {
                // element props contain dynamic keys, full diff needed
                patchProps(
                  el,
                  n2,
                  oldProps,
                  newProps,
                  parentComponent,
                  parentSuspense,
                  isSVG
                );
              } else {
                // class
                // this flag is matched when the element has dynamic class bindings.
                if (patchFlag & 2 /* CLASS */) {
                  if (oldProps.class !== newProps.class) {
                    hostPatchProp(el, 'class', null, newProps.class, isSVG);
                  }
                }
                // style
                // this flag is matched when the element has dynamic style bindings
                if (patchFlag & 4 /* STYLE */) {
                  hostPatchProp(
                    el,
                    'style',
                    oldProps.style,
                    newProps.style,
                    isSVG
                  );
                }
                // props
                // This flag is matched when the element has dynamic prop/attr bindings
                // other than class and style. The keys of dynamic prop/attrs are saved for
                // faster iteration.
                // Note dynamic keys like :[foo]="bar" will cause this optimization to
                // bail out and go through a full diff because we need to unset the old key
                if (patchFlag & 8 /* PROPS */) {
                  // if the flag is present then dynamicProps must be non-null
                  const propsToUpdate = n2.dynamicProps;
                  for (let i = 0; i < propsToUpdate.length; i++) {
                    const key = propsToUpdate[i];
                    const prev = oldProps[key];
                    const next = newProps[key];
                    // #1471 force patch value
                    if (next !== prev || key === 'value') {
                      hostPatchProp(
                        el,
                        key,
                        prev,
                        next,
                        isSVG,
                        n1.children,
                        parentComponent,
                        parentSuspense,
                        unmountChildren
                      );
                    }
                  }
                }
              }
              // text
              // This flag is matched when the element has only dynamic text children.
              if (patchFlag & 1 /* TEXT */) {
                if (n1.children !== n2.children) {
                  hostSetElementText(el, n2.children);
                }
              }
            } else if (!optimized && dynamicChildren == null) {
              // unoptimized, full diff
              patchProps(
                el,
                n2,
                oldProps,
                newProps,
                parentComponent,
                parentSuspense,
                isSVG
              );
            }
            if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
              queuePostRenderEffect(() => {
                vnodeHook &&
                  invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
                dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated');
              }, parentSuspense);
            }
          };
          // The fast path for blocks.
          const patchBlockChildren = (
            oldChildren,
            newChildren,
            fallbackContainer,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds
          ) => {
            for (let i = 0; i < newChildren.length; i++) {
              const oldVNode = oldChildren[i];
              const newVNode = newChildren[i];
              // Determine the container (parent element) for the patch.
              const container =
                // oldVNode may be an errored async setup() component inside Suspense
                // which will not have a mounted element
                oldVNode.el &&
                // - In the case of a Fragment, we need to provide the actual parent
                // of the Fragment itself so it can move its children.
                (oldVNode.type === Fragment ||
                  // - In the case of different nodes, there is going to be a replacement
                  // which also requires the correct parent container
                  !isSameVNodeType(oldVNode, newVNode) ||
                  // - In the case of a component, it could contain anything.
                  oldVNode.shapeFlag & (6 /* COMPONENT */ | 64) /* TELEPORT */)
                  ? hostParentNode(oldVNode.el)
                  : // In other cases, the parent container is not actually used so we
                    // just pass the block element here to avoid a DOM parentNode call.
                    fallbackContainer;
              patch(
                oldVNode,
                newVNode,
                container,
                null,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                true
              );
            }
          };
          const patchProps = (
            el,
            vnode,
            oldProps,
            newProps,
            parentComponent,
            parentSuspense,
            isSVG
          ) => {
            if (oldProps !== newProps) {
              for (const key in newProps) {
                // empty string is not valid prop
                if (
                  (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(
                    key
                  )
                )
                  continue;
                const next = newProps[key];
                const prev = oldProps[key];
                // defer patching value
                if (next !== prev && key !== 'value') {
                  hostPatchProp(
                    el,
                    key,
                    prev,
                    next,
                    isSVG,
                    vnode.children,
                    parentComponent,
                    parentSuspense,
                    unmountChildren
                  );
                }
              }
              if (
                oldProps !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ
              ) {
                for (const key in oldProps) {
                  if (
                    !(0,
                    _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(
                      key
                    ) &&
                    !(key in newProps)
                  ) {
                    hostPatchProp(
                      el,
                      key,
                      oldProps[key],
                      null,
                      isSVG,
                      vnode.children,
                      parentComponent,
                      parentSuspense,
                      unmountChildren
                    );
                  }
                }
              }
              if ('value' in newProps) {
                hostPatchProp(el, 'value', oldProps.value, newProps.value);
              }
            }
          };
          const processFragment = (
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          ) => {
            const fragmentStartAnchor = (n2.el = n1
              ? n1.el
              : hostCreateText(''));
            const fragmentEndAnchor = (n2.anchor = n1
              ? n1.anchor
              : hostCreateText(''));
            let {
              patchFlag,
              dynamicChildren,
              slotScopeIds: fragmentSlotScopeIds,
            } = n2;
            if (true && isHmrUpdating) {
              // HMR updated, force full diff
              patchFlag = 0;
              optimized = false;
              dynamicChildren = null;
            }
            // check if this is a slot fragment with :slotted scope ids
            if (fragmentSlotScopeIds) {
              slotScopeIds = slotScopeIds
                ? slotScopeIds.concat(fragmentSlotScopeIds)
                : fragmentSlotScopeIds;
            }
            if (n1 == null) {
              hostInsert(fragmentStartAnchor, container, anchor);
              hostInsert(fragmentEndAnchor, container, anchor);
              // a fragment can only have array children
              // since they are either generated by the compiler, or implicitly created
              // from arrays.
              mountChildren(
                n2.children,
                container,
                fragmentEndAnchor,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
            } else {
              if (
                patchFlag > 0 &&
                patchFlag & 64 /* STABLE_FRAGMENT */ &&
                dynamicChildren &&
                // #2715 the previous fragment could've been a BAILed one as a result
                // of renderSlot() with no valid children
                n1.dynamicChildren
              ) {
                // a stable fragment (template root or <template v-for>) doesn't need to
                // patch children order, but it may contain dynamicChildren.
                patchBlockChildren(
                  n1.dynamicChildren,
                  dynamicChildren,
                  container,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds
                );
                if (true && parentComponent && parentComponent.type.__hmrId) {
                  traverseStaticChildren(n1, n2);
                } else if (
                  // #2080 if the stable fragment has a key, it's a <template v-for> that may
                  //  get moved around. Make sure all root level vnodes inherit el.
                  // #2134 or if it's a component root, it may also get moved around
                  // as the component is being moved.
                  n2.key != null ||
                  (parentComponent && n2 === parentComponent.subTree)
                ) {
                  traverseStaticChildren(n1, n2, true /* shallow */);
                }
              } else {
                // keyed / unkeyed, or manual fragments.
                // for keyed & unkeyed, since they are compiler generated from v-for,
                // each child is guaranteed to be a block so the fragment will never
                // have dynamicChildren.
                patchChildren(
                  n1,
                  n2,
                  container,
                  fragmentEndAnchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
              }
            }
          };
          const processComponent = (
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          ) => {
            n2.slotScopeIds = slotScopeIds;
            if (n1 == null) {
              if (n2.shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {
                parentComponent.ctx.activate(
                  n2,
                  container,
                  anchor,
                  isSVG,
                  optimized
                );
              } else {
                mountComponent(
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  optimized
                );
              }
            } else {
              updateComponent(n1, n2, optimized);
            }
          };
          const mountComponent = (
            initialVNode,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            optimized
          ) => {
            const instance = (initialVNode.component = createComponentInstance(
              initialVNode,
              parentComponent,
              parentSuspense
            ));
            if (true && instance.type.__hmrId) {
              registerHMR(instance);
            }
            if (true) {
              pushWarningContext(initialVNode);
              startMeasure(instance, `mount`);
            }
            // inject renderer internals for keepAlive
            if (isKeepAlive(initialVNode)) {
              instance.ctx.renderer = internals;
            }
            // resolve props and slots for setup context
            {
              if (true) {
                startMeasure(instance, `init`);
              }
              setupComponent(instance);
              if (true) {
                endMeasure(instance, `init`);
              }
            }
            // setup() is async. This component relies on async logic to be resolved
            // before proceeding
            if (instance.asyncDep) {
              parentSuspense &&
                parentSuspense.registerDep(instance, setupRenderEffect);
              // Give it a placeholder if this is not hydration
              // TODO handle self-defined fallback
              if (!initialVNode.el) {
                const placeholder = (instance.subTree = createVNode(Comment));
                processCommentNode(null, placeholder, container, anchor);
              }
              return;
            }
            setupRenderEffect(
              instance,
              initialVNode,
              container,
              anchor,
              parentSuspense,
              isSVG,
              optimized
            );
            if (true) {
              popWarningContext();
              endMeasure(instance, `mount`);
            }
          };
          const updateComponent = (n1, n2, optimized) => {
            const instance = (n2.component = n1.component);
            if (shouldUpdateComponent(n1, n2, optimized)) {
              if (instance.asyncDep && !instance.asyncResolved) {
                // async & still pending - just update props and slots
                // since the component's reactive effect for render isn't set-up yet
                if (true) {
                  pushWarningContext(n2);
                }
                updateComponentPreRender(instance, n2, optimized);
                if (true) {
                  popWarningContext();
                }
                return;
              } else {
                // normal update
                instance.next = n2;
                // in case the child component is also queued, remove it to avoid
                // double updating the same child component in the same flush.
                invalidateJob(instance.update);
                // instance.update is the reactive effect.
                instance.update();
              }
            } else {
              // no update needed. just copy over properties
              n2.component = n1.component;
              n2.el = n1.el;
              instance.vnode = n2;
            }
          };
          const setupRenderEffect = (
            instance,
            initialVNode,
            container,
            anchor,
            parentSuspense,
            isSVG,
            optimized
          ) => {
            const componentUpdateFn = () => {
              if (!instance.isMounted) {
                let vnodeHook;
                const { el, props } = initialVNode;
                const { bm, m, parent } = instance;
                const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
                toggleRecurse(instance, false);
                // beforeMount hook
                if (bm) {
                  (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(
                    bm
                  );
                }
                // onVnodeBeforeMount
                if (
                  !isAsyncWrapperVNode &&
                  (vnodeHook = props && props.onVnodeBeforeMount)
                ) {
                  invokeVNodeHook(vnodeHook, parent, initialVNode);
                }
                toggleRecurse(instance, true);
                if (el && hydrateNode) {
                  // vnode has adopted host node - perform hydration instead of mount.
                  const hydrateSubTree = () => {
                    if (true) {
                      startMeasure(instance, `render`);
                    }
                    instance.subTree = renderComponentRoot(instance);
                    if (true) {
                      endMeasure(instance, `render`);
                    }
                    if (true) {
                      startMeasure(instance, `hydrate`);
                    }
                    hydrateNode(
                      el,
                      instance.subTree,
                      instance,
                      parentSuspense,
                      null
                    );
                    if (true) {
                      endMeasure(instance, `hydrate`);
                    }
                  };
                  if (isAsyncWrapperVNode) {
                    initialVNode.type.__asyncLoader().then(
                      // note: we are moving the render call into an async callback,
                      // which means it won't track dependencies - but it's ok because
                      // a server-rendered async wrapper is already in resolved state
                      // and it will never need to change.
                      () => !instance.isUnmounted && hydrateSubTree()
                    );
                  } else {
                    hydrateSubTree();
                  }
                } else {
                  if (true) {
                    startMeasure(instance, `render`);
                  }
                  const subTree = (instance.subTree =
                    renderComponentRoot(instance));
                  if (true) {
                    endMeasure(instance, `render`);
                  }
                  if (true) {
                    startMeasure(instance, `patch`);
                  }
                  patch(
                    null,
                    subTree,
                    container,
                    anchor,
                    instance,
                    parentSuspense,
                    isSVG
                  );
                  if (true) {
                    endMeasure(instance, `patch`);
                  }
                  initialVNode.el = subTree.el;
                }
                // mounted hook
                if (m) {
                  queuePostRenderEffect(m, parentSuspense);
                }
                // onVnodeMounted
                if (
                  !isAsyncWrapperVNode &&
                  (vnodeHook = props && props.onVnodeMounted)
                ) {
                  const scopedInitialVNode = initialVNode;
                  queuePostRenderEffect(
                    () =>
                      invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
                    parentSuspense
                  );
                }
                // activated hook for keep-alive roots.
                // #1742 activated hook must be accessed after first render
                // since the hook may be injected by a child keep-alive
                if (
                  initialVNode.shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */
                ) {
                  instance.a &&
                    queuePostRenderEffect(instance.a, parentSuspense);
                }
                instance.isMounted = true;
                if (true) {
                  devtoolsComponentAdded(instance);
                }
                // #2458: deference mount-only object parameters to prevent memleaks
                initialVNode = container = anchor = null;
              } else {
                // updateComponent
                // This is triggered by mutation of component's own state (next: null)
                // OR parent calling processComponent (next: VNode)
                let { next, bu, u, parent, vnode } = instance;
                let originNext = next;
                let vnodeHook;
                if (true) {
                  pushWarningContext(next || instance.vnode);
                }
                // Disallow component effect recursion during pre-lifecycle hooks.
                toggleRecurse(instance, false);
                if (next) {
                  next.el = vnode.el;
                  updateComponentPreRender(instance, next, optimized);
                } else {
                  next = vnode;
                }
                // beforeUpdate hook
                if (bu) {
                  (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(
                    bu
                  );
                }
                // onVnodeBeforeUpdate
                if (
                  (vnodeHook = next.props && next.props.onVnodeBeforeUpdate)
                ) {
                  invokeVNodeHook(vnodeHook, parent, next, vnode);
                }
                toggleRecurse(instance, true);
                // render
                if (true) {
                  startMeasure(instance, `render`);
                }
                const nextTree = renderComponentRoot(instance);
                if (true) {
                  endMeasure(instance, `render`);
                }
                const prevTree = instance.subTree;
                instance.subTree = nextTree;
                if (true) {
                  startMeasure(instance, `patch`);
                }
                patch(
                  prevTree,
                  nextTree,
                  // parent may have changed if it's in a teleport
                  hostParentNode(prevTree.el),
                  // anchor may have changed if it's in a fragment
                  getNextHostNode(prevTree),
                  instance,
                  parentSuspense,
                  isSVG
                );
                if (true) {
                  endMeasure(instance, `patch`);
                }
                next.el = nextTree.el;
                if (originNext === null) {
                  // self-triggered update. In case of HOC, update parent component
                  // vnode el. HOC is indicated by parent instance's subTree pointing
                  // to child component's vnode
                  updateHOCHostEl(instance, nextTree.el);
                }
                // updated hook
                if (u) {
                  queuePostRenderEffect(u, parentSuspense);
                }
                // onVnodeUpdated
                if ((vnodeHook = next.props && next.props.onVnodeUpdated)) {
                  queuePostRenderEffect(
                    () => invokeVNodeHook(vnodeHook, parent, next, vnode),
                    parentSuspense
                  );
                }
                if (true) {
                  devtoolsComponentUpdated(instance);
                }
                if (true) {
                  popWarningContext();
                }
              }
            };
            // create reactive effect for rendering
            const effect = (instance.effect =
              new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect(
                componentUpdateFn,
                () => queueJob(instance.update),
                instance.scope // track it in component's effect scope
              ));
            const update = (instance.update = effect.run.bind(effect));
            update.id = instance.uid;
            // allowRecurse
            // #1801, #2043 component render effects should allow recursive updates
            toggleRecurse(instance, true);
            if (true) {
              effect.onTrack = instance.rtc
                ? (e) =>
                    (0,
                    _vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(
                      instance.rtc,
                      e
                    )
                : void 0;
              effect.onTrigger = instance.rtg
                ? (e) =>
                    (0,
                    _vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(
                      instance.rtg,
                      e
                    )
                : void 0;
              // @ts-ignore (for scheduler)
              update.ownerInstance = instance;
            }
            update();
          };
          const updateComponentPreRender = (instance, nextVNode, optimized) => {
            nextVNode.component = instance;
            const prevProps = instance.vnode.props;
            instance.vnode = nextVNode;
            instance.next = null;
            updateProps(instance, nextVNode.props, prevProps, optimized);
            updateSlots(instance, nextVNode.children, optimized);
            (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
            // props update may have triggered pre-flush watchers.
            // flush them before the render update.
            flushPreFlushCbs(undefined, instance.update);
            (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
          };
          const patchChildren = (
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized = false
          ) => {
            const c1 = n1 && n1.children;
            const prevShapeFlag = n1 ? n1.shapeFlag : 0;
            const c2 = n2.children;
            const { patchFlag, shapeFlag } = n2;
            // fast path
            if (patchFlag > 0) {
              if (patchFlag & 128 /* KEYED_FRAGMENT */) {
                // this could be either fully-keyed or mixed (some keyed some not)
                // presence of patchFlag means children are guaranteed to be arrays
                patchKeyedChildren(
                  c1,
                  c2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
                return;
              } else if (patchFlag & 256 /* UNKEYED_FRAGMENT */) {
                // unkeyed
                patchUnkeyedChildren(
                  c1,
                  c2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
                return;
              }
            }
            // children has 3 possibilities: text, array or no children.
            if (shapeFlag & 8 /* TEXT_CHILDREN */) {
              // text children fast path
              if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {
                unmountChildren(c1, parentComponent, parentSuspense);
              }
              if (c2 !== c1) {
                hostSetElementText(container, c2);
              }
            } else {
              if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {
                // prev children was array
                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                  // two arrays, cannot assume anything, do full diff
                  patchKeyedChildren(
                    c1,
                    c2,
                    container,
                    anchor,
                    parentComponent,
                    parentSuspense,
                    isSVG,
                    slotScopeIds,
                    optimized
                  );
                } else {
                  // no new children, just unmount old
                  unmountChildren(c1, parentComponent, parentSuspense, true);
                }
              } else {
                // prev children was text OR null
                // new children is array OR null
                if (prevShapeFlag & 8 /* TEXT_CHILDREN */) {
                  hostSetElementText(container, '');
                }
                // mount new if array
                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                  mountChildren(
                    c2,
                    container,
                    anchor,
                    parentComponent,
                    parentSuspense,
                    isSVG,
                    slotScopeIds,
                    optimized
                  );
                }
              }
            }
          };
          const patchUnkeyedChildren = (
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          ) => {
            c1 = c1 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
            c2 = c2 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
            const oldLength = c1.length;
            const newLength = c2.length;
            const commonLength = Math.min(oldLength, newLength);
            let i;
            for (i = 0; i < commonLength; i++) {
              const nextChild = (c2[i] = optimized
                ? cloneIfMounted(c2[i])
                : normalizeVNode(c2[i]));
              patch(
                c1[i],
                nextChild,
                container,
                null,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
            }
            if (oldLength > newLength) {
              // remove old
              unmountChildren(
                c1,
                parentComponent,
                parentSuspense,
                true,
                false,
                commonLength
              );
            } else {
              // mount new
              mountChildren(
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized,
                commonLength
              );
            }
          };
          // can be all-keyed or mixed
          const patchKeyedChildren = (
            c1,
            c2,
            container,
            parentAnchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          ) => {
            let i = 0;
            const l2 = c2.length;
            let e1 = c1.length - 1; // prev ending index
            let e2 = l2 - 1; // next ending index
            // 1. sync from start
            // (a b) c
            // (a b) d e
            while (i <= e1 && i <= e2) {
              const n1 = c1[i];
              const n2 = (c2[i] = optimized
                ? cloneIfMounted(c2[i])
                : normalizeVNode(c2[i]));
              if (isSameVNodeType(n1, n2)) {
                patch(
                  n1,
                  n2,
                  container,
                  null,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
              } else {
                break;
              }
              i++;
            }
            // 2. sync from end
            // a (b c)
            // d e (b c)
            while (i <= e1 && i <= e2) {
              const n1 = c1[e1];
              const n2 = (c2[e2] = optimized
                ? cloneIfMounted(c2[e2])
                : normalizeVNode(c2[e2]));
              if (isSameVNodeType(n1, n2)) {
                patch(
                  n1,
                  n2,
                  container,
                  null,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
              } else {
                break;
              }
              e1--;
              e2--;
            }
            // 3. common sequence + mount
            // (a b)
            // (a b) c
            // i = 2, e1 = 1, e2 = 2
            // (a b)
            // c (a b)
            // i = 0, e1 = -1, e2 = 0
            if (i > e1) {
              if (i <= e2) {
                const nextPos = e2 + 1;
                const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
                while (i <= e2) {
                  patch(
                    null,
                    (c2[i] = optimized
                      ? cloneIfMounted(c2[i])
                      : normalizeVNode(c2[i])),
                    container,
                    anchor,
                    parentComponent,
                    parentSuspense,
                    isSVG,
                    slotScopeIds,
                    optimized
                  );
                  i++;
                }
              }
            }
            // 4. common sequence + unmount
            // (a b) c
            // (a b)
            // i = 2, e1 = 2, e2 = 1
            // a (b c)
            // (b c)
            // i = 0, e1 = 0, e2 = -1
            else if (i > e2) {
              while (i <= e1) {
                unmount(c1[i], parentComponent, parentSuspense, true);
                i++;
              }
            }
            // 5. unknown sequence
            // [i ... e1 + 1]: a b [c d e] f g
            // [i ... e2 + 1]: a b [e d c h] f g
            // i = 2, e1 = 4, e2 = 5
            else {
              const s1 = i; // prev starting index
              const s2 = i; // next starting index
              // 5.1 build key:index map for newChildren
              const keyToNewIndexMap = new Map();
              for (i = s2; i <= e2; i++) {
                const nextChild = (c2[i] = optimized
                  ? cloneIfMounted(c2[i])
                  : normalizeVNode(c2[i]));
                if (nextChild.key != null) {
                  if (true && keyToNewIndexMap.has(nextChild.key)) {
                    warn(
                      `Duplicate keys found during update:`,
                      JSON.stringify(nextChild.key),
                      `Make sure keys are unique.`
                    );
                  }
                  keyToNewIndexMap.set(nextChild.key, i);
                }
              }
              // 5.2 loop through old children left to be patched and try to patch
              // matching nodes & remove nodes that are no longer present
              let j;
              let patched = 0;
              const toBePatched = e2 - s2 + 1;
              let moved = false;
              // used to track whether any node has moved
              let maxNewIndexSoFar = 0;
              // works as Map<newIndex, oldIndex>
              // Note that oldIndex is offset by +1
              // and oldIndex = 0 is a special value indicating the new node has
              // no corresponding old node.
              // used for determining longest stable subsequence
              const newIndexToOldIndexMap = new Array(toBePatched);
              for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
              for (i = s1; i <= e1; i++) {
                const prevChild = c1[i];
                if (patched >= toBePatched) {
                  // all new children have been patched so this can only be a removal
                  unmount(prevChild, parentComponent, parentSuspense, true);
                  continue;
                }
                let newIndex;
                if (prevChild.key != null) {
                  newIndex = keyToNewIndexMap.get(prevChild.key);
                } else {
                  // key-less node, try to locate a key-less node of the same type
                  for (j = s2; j <= e2; j++) {
                    if (
                      newIndexToOldIndexMap[j - s2] === 0 &&
                      isSameVNodeType(prevChild, c2[j])
                    ) {
                      newIndex = j;
                      break;
                    }
                  }
                }
                if (newIndex === undefined) {
                  unmount(prevChild, parentComponent, parentSuspense, true);
                } else {
                  newIndexToOldIndexMap[newIndex - s2] = i + 1;
                  if (newIndex >= maxNewIndexSoFar) {
                    maxNewIndexSoFar = newIndex;
                  } else {
                    moved = true;
                  }
                  patch(
                    prevChild,
                    c2[newIndex],
                    container,
                    null,
                    parentComponent,
                    parentSuspense,
                    isSVG,
                    slotScopeIds,
                    optimized
                  );
                  patched++;
                }
              }
              // 5.3 move and mount
              // generate longest stable subsequence only when nodes have moved
              const increasingNewIndexSequence = moved
                ? getSequence(newIndexToOldIndexMap)
                : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
              j = increasingNewIndexSequence.length - 1;
              // looping backwards so that we can use last patched node as anchor
              for (i = toBePatched - 1; i >= 0; i--) {
                const nextIndex = s2 + i;
                const nextChild = c2[nextIndex];
                const anchor =
                  nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
                if (newIndexToOldIndexMap[i] === 0) {
                  // mount new
                  patch(
                    null,
                    nextChild,
                    container,
                    anchor,
                    parentComponent,
                    parentSuspense,
                    isSVG,
                    slotScopeIds,
                    optimized
                  );
                } else if (moved) {
                  // move if:
                  // There is no stable subsequence (e.g. a reverse)
                  // OR current node is not among the stable sequence
                  if (j < 0 || i !== increasingNewIndexSequence[j]) {
                    move(nextChild, container, anchor, 2 /* REORDER */);
                  } else {
                    j--;
                  }
                }
              }
            }
          };
          const move = (
            vnode,
            container,
            anchor,
            moveType,
            parentSuspense = null
          ) => {
            const { el, type, transition, children, shapeFlag } = vnode;
            if (shapeFlag & 6 /* COMPONENT */) {
              move(vnode.component.subTree, container, anchor, moveType);
              return;
            }
            if (shapeFlag & 128 /* SUSPENSE */) {
              vnode.suspense.move(container, anchor, moveType);
              return;
            }
            if (shapeFlag & 64 /* TELEPORT */) {
              type.move(vnode, container, anchor, internals);
              return;
            }
            if (type === Fragment) {
              hostInsert(el, container, anchor);
              for (let i = 0; i < children.length; i++) {
                move(children[i], container, anchor, moveType);
              }
              hostInsert(vnode.anchor, container, anchor);
              return;
            }
            if (type === Static) {
              moveStaticNode(vnode, container, anchor);
              return;
            }
            // single nodes
            const needTransition =
              moveType !== 2 /* REORDER */ &&
              shapeFlag & 1 /* ELEMENT */ &&
              transition;
            if (needTransition) {
              if (moveType === 0 /* ENTER */) {
                transition.beforeEnter(el);
                hostInsert(el, container, anchor);
                queuePostRenderEffect(
                  () => transition.enter(el),
                  parentSuspense
                );
              } else {
                const { leave, delayLeave, afterLeave } = transition;
                const remove = () => hostInsert(el, container, anchor);
                const performLeave = () => {
                  leave(el, () => {
                    remove();
                    afterLeave && afterLeave();
                  });
                };
                if (delayLeave) {
                  delayLeave(el, remove, performLeave);
                } else {
                  performLeave();
                }
              }
            } else {
              hostInsert(el, container, anchor);
            }
          };
          const unmount = (
            vnode,
            parentComponent,
            parentSuspense,
            doRemove = false,
            optimized = false
          ) => {
            const {
              type,
              props,
              ref,
              children,
              dynamicChildren,
              shapeFlag,
              patchFlag,
              dirs,
            } = vnode;
            // unset ref
            if (ref != null) {
              setRef(ref, null, parentSuspense, vnode, true);
            }
            if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
              parentComponent.ctx.deactivate(vnode);
              return;
            }
            const shouldInvokeDirs = shapeFlag & 1 /* ELEMENT */ && dirs;
            const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
            let vnodeHook;
            if (
              shouldInvokeVnodeHook &&
              (vnodeHook = props && props.onVnodeBeforeUnmount)
            ) {
              invokeVNodeHook(vnodeHook, parentComponent, vnode);
            }
            if (shapeFlag & 6 /* COMPONENT */) {
              unmountComponent(vnode.component, parentSuspense, doRemove);
            } else {
              if (shapeFlag & 128 /* SUSPENSE */) {
                vnode.suspense.unmount(parentSuspense, doRemove);
                return;
              }
              if (shouldInvokeDirs) {
                invokeDirectiveHook(
                  vnode,
                  null,
                  parentComponent,
                  'beforeUnmount'
                );
              }
              if (shapeFlag & 64 /* TELEPORT */) {
                vnode.type.remove(
                  vnode,
                  parentComponent,
                  parentSuspense,
                  optimized,
                  internals,
                  doRemove
                );
              } else if (
                dynamicChildren &&
                // #1153: fast path should not be taken for non-stable (v-for) fragments
                (type !== Fragment ||
                  (patchFlag > 0 && patchFlag & 64) /* STABLE_FRAGMENT */)
              ) {
                // fast path for block nodes: only need to unmount dynamic children.
                unmountChildren(
                  dynamicChildren,
                  parentComponent,
                  parentSuspense,
                  false,
                  true
                );
              } else if (
                (type === Fragment &&
                  patchFlag &
                    (128 /* KEYED_FRAGMENT */ | 256) /* UNKEYED_FRAGMENT */) ||
                (!optimized && shapeFlag & 16) /* ARRAY_CHILDREN */
              ) {
                unmountChildren(children, parentComponent, parentSuspense);
              }
              if (doRemove) {
                remove(vnode);
              }
            }
            if (
              (shouldInvokeVnodeHook &&
                (vnodeHook = props && props.onVnodeUnmounted)) ||
              shouldInvokeDirs
            ) {
              queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                shouldInvokeDirs &&
                  invokeDirectiveHook(
                    vnode,
                    null,
                    parentComponent,
                    'unmounted'
                  );
              }, parentSuspense);
            }
          };
          const remove = (vnode) => {
            const { type, el, anchor, transition } = vnode;
            if (type === Fragment) {
              removeFragment(el, anchor);
              return;
            }
            if (type === Static) {
              removeStaticNode(vnode);
              return;
            }
            const performRemove = () => {
              hostRemove(el);
              if (
                transition &&
                !transition.persisted &&
                transition.afterLeave
              ) {
                transition.afterLeave();
              }
            };
            if (
              vnode.shapeFlag & 1 /* ELEMENT */ &&
              transition &&
              !transition.persisted
            ) {
              const { leave, delayLeave } = transition;
              const performLeave = () => leave(el, performRemove);
              if (delayLeave) {
                delayLeave(vnode.el, performRemove, performLeave);
              } else {
                performLeave();
              }
            } else {
              performRemove();
            }
          };
          const removeFragment = (cur, end) => {
            // For fragments, directly remove all contained DOM nodes.
            // (fragment child nodes cannot have transition)
            let next;
            while (cur !== end) {
              next = hostNextSibling(cur);
              hostRemove(cur);
              cur = next;
            }
            hostRemove(end);
          };
          const unmountComponent = (instance, parentSuspense, doRemove) => {
            if (true && instance.type.__hmrId) {
              unregisterHMR(instance);
            }
            const { bum, scope, update, subTree, um } = instance;
            // beforeUnmount hook
            if (bum) {
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bum);
            }
            // stop effects in component scope
            scope.stop();
            // update may be null if a component is unmounted before its async
            // setup has resolved.
            if (update) {
              // so that scheduler will no longer invoke it
              update.active = false;
              unmount(subTree, instance, parentSuspense, doRemove);
            }
            // unmounted hook
            if (um) {
              queuePostRenderEffect(um, parentSuspense);
            }
            queuePostRenderEffect(() => {
              instance.isUnmounted = true;
            }, parentSuspense);
            // A component with async dep inside a pending suspense is unmounted before
            // its async dep resolves. This should remove the dep from the suspense, and
            // cause the suspense to resolve immediately if that was the last dep.
            if (
              parentSuspense &&
              parentSuspense.pendingBranch &&
              !parentSuspense.isUnmounted &&
              instance.asyncDep &&
              !instance.asyncResolved &&
              instance.suspenseId === parentSuspense.pendingId
            ) {
              parentSuspense.deps--;
              if (parentSuspense.deps === 0) {
                parentSuspense.resolve();
              }
            }
            if (true) {
              devtoolsComponentRemoved(instance);
            }
          };
          const unmountChildren = (
            children,
            parentComponent,
            parentSuspense,
            doRemove = false,
            optimized = false,
            start = 0
          ) => {
            for (let i = start; i < children.length; i++) {
              unmount(
                children[i],
                parentComponent,
                parentSuspense,
                doRemove,
                optimized
              );
            }
          };
          const getNextHostNode = (vnode) => {
            if (vnode.shapeFlag & 6 /* COMPONENT */) {
              return getNextHostNode(vnode.component.subTree);
            }
            if (vnode.shapeFlag & 128 /* SUSPENSE */) {
              return vnode.suspense.next();
            }
            return hostNextSibling(vnode.anchor || vnode.el);
          };
          const render = (vnode, container, isSVG) => {
            if (vnode == null) {
              if (container._vnode) {
                unmount(container._vnode, null, null, true);
              }
            } else {
              patch(
                container._vnode || null,
                vnode,
                container,
                null,
                null,
                null,
                isSVG
              );
            }
            flushPostFlushCbs();
            container._vnode = vnode;
          };
          const internals = {
            p: patch,
            um: unmount,
            m: move,
            r: remove,
            mt: mountComponent,
            mc: mountChildren,
            pc: patchChildren,
            pbc: patchBlockChildren,
            n: getNextHostNode,
            o: options,
          };
          let hydrate;
          let hydrateNode;
          if (createHydrationFns) {
            [hydrate, hydrateNode] = createHydrationFns(internals);
          }
          return {
            render,
            hydrate,
            createApp: createAppAPI(render, hydrate),
          };
        }
        function toggleRecurse({ effect, update }, allowed) {
          effect.allowRecurse = update.allowRecurse = allowed;
        }
        /**
         * #1156
         * When a component is HMR-enabled, we need to make sure that all static nodes
         * inside a block also inherit the DOM element from the previous tree so that
         * HMR updates (which are full updates) can retrieve the element for patching.
         *
         * #2080
         * Inside keyed `template` fragment static children, if a fragment is moved,
         * the children will always be moved. Therefore, in order to ensure correct move
         * position, el should be inherited from previous nodes.
         */
        function traverseStaticChildren(n1, n2, shallow = false) {
          const ch1 = n1.children;
          const ch2 = n2.children;
          if (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch1) &&
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch2)
          ) {
            for (let i = 0; i < ch1.length; i++) {
              // this is only called in the optimized path so array children are
              // guaranteed to be vnodes
              const c1 = ch1[i];
              let c2 = ch2[i];
              if (c2.shapeFlag & 1 /* ELEMENT */ && !c2.dynamicChildren) {
                if (
                  c2.patchFlag <= 0 ||
                  c2.patchFlag === 32 /* HYDRATE_EVENTS */
                ) {
                  c2 = ch2[i] = cloneIfMounted(ch2[i]);
                  c2.el = c1.el;
                }
                if (!shallow) traverseStaticChildren(c1, c2);
              }
              // also inherit for comment nodes, but not placeholders (e.g. v-if which
              // would have received .el during block patch)
              if (true && c2.type === Comment && !c2.el) {
                c2.el = c1.el;
              }
            }
          }
        }
        // https://en.wikipedia.org/wiki/Longest_increasing_subsequence
        function getSequence(arr) {
          const p = arr.slice();
          const result = [0];
          let i, j, u, v, c;
          const len = arr.length;
          for (i = 0; i < len; i++) {
            const arrI = arr[i];
            if (arrI !== 0) {
              j = result[result.length - 1];
              if (arr[j] < arrI) {
                p[i] = j;
                result.push(i);
                continue;
              }
              u = 0;
              v = result.length - 1;
              while (u < v) {
                c = (u + v) >> 1;
                if (arr[result[c]] < arrI) {
                  u = c + 1;
                } else {
                  v = c;
                }
              }
              if (arrI < arr[result[u]]) {
                if (u > 0) {
                  p[i] = result[u - 1];
                }
                result[u] = i;
              }
            }
          }
          u = result.length;
          v = result[u - 1];
          while (u-- > 0) {
            result[u] = v;
            v = p[v];
          }
          return result;
        }

        const isTeleport = (type) => type.__isTeleport;
        const isTeleportDisabled = (props) =>
          props && (props.disabled || props.disabled === '');
        const isTargetSVG = (target) =>
          typeof SVGElement !== 'undefined' && target instanceof SVGElement;
        const resolveTarget = (props, select) => {
          const targetSelector = props && props.to;
          if (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(
              targetSelector
            )
          ) {
            if (!select) {
              true &&
                warn(
                  `Current renderer does not support string target for Teleports. ` +
                    `(missing querySelector renderer option)`
                );
              return null;
            } else {
              const target = select(targetSelector);
              if (!target) {
                true &&
                  warn(
                    `Failed to locate Teleport target with selector "${targetSelector}". ` +
                      `Note the target element must exist before the component is mounted - ` +
                      `i.e. the target cannot be rendered by the component itself, and ` +
                      `ideally should be outside of the entire Vue component tree.`
                  );
              }
              return target;
            }
          } else {
            if (true && !targetSelector && !isTeleportDisabled(props)) {
              warn(`Invalid Teleport target: ${targetSelector}`);
            }
            return targetSelector;
          }
        };
        const TeleportImpl = {
          __isTeleport: true,
          process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized,
            internals
          ) {
            const {
              mc: mountChildren,
              pc: patchChildren,
              pbc: patchBlockChildren,
              o: { insert, querySelector, createText, createComment },
            } = internals;
            const disabled = isTeleportDisabled(n2.props);
            let { shapeFlag, children, dynamicChildren } = n2;
            // #3302
            // HMR updated, force full diff
            if (true && isHmrUpdating) {
              optimized = false;
              dynamicChildren = null;
            }
            if (n1 == null) {
              // insert anchors in the main view
              const placeholder = (n2.el = true
                ? createComment('teleport start')
                : 0);
              const mainAnchor = (n2.anchor = true
                ? createComment('teleport end')
                : 0);
              insert(placeholder, container, anchor);
              insert(mainAnchor, container, anchor);
              const target = (n2.target = resolveTarget(
                n2.props,
                querySelector
              ));
              const targetAnchor = (n2.targetAnchor = createText(''));
              if (target) {
                insert(targetAnchor, target);
                // #2652 we could be teleporting from a non-SVG tree into an SVG tree
                isSVG = isSVG || isTargetSVG(target);
              } else if (true && !disabled) {
                warn(
                  'Invalid Teleport target on mount:',
                  target,
                  `(${typeof target})`
                );
              }
              const mount = (container, anchor) => {
                // Teleport *always* has Array children. This is enforced in both the
                // compiler and vnode children normalization.
                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                  mountChildren(
                    children,
                    container,
                    anchor,
                    parentComponent,
                    parentSuspense,
                    isSVG,
                    slotScopeIds,
                    optimized
                  );
                }
              };
              if (disabled) {
                mount(container, mainAnchor);
              } else if (target) {
                mount(target, targetAnchor);
              }
            } else {
              // update content
              n2.el = n1.el;
              const mainAnchor = (n2.anchor = n1.anchor);
              const target = (n2.target = n1.target);
              const targetAnchor = (n2.targetAnchor = n1.targetAnchor);
              const wasDisabled = isTeleportDisabled(n1.props);
              const currentContainer = wasDisabled ? container : target;
              const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
              isSVG = isSVG || isTargetSVG(target);
              if (dynamicChildren) {
                // fast path when the teleport happens to be a block root
                patchBlockChildren(
                  n1.dynamicChildren,
                  dynamicChildren,
                  currentContainer,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds
                );
                // even in block tree mode we need to make sure all root-level nodes
                // in the teleport inherit previous DOM references so that they can
                // be moved in future patches.
                traverseStaticChildren(n1, n2, true);
              } else if (!optimized) {
                patchChildren(
                  n1,
                  n2,
                  currentContainer,
                  currentAnchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  false
                );
              }
              if (disabled) {
                if (!wasDisabled) {
                  // enabled -> disabled
                  // move into main container
                  moveTeleport(
                    n2,
                    container,
                    mainAnchor,
                    internals,
                    1 /* TOGGLE */
                  );
                }
              } else {
                // target changed
                if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                  const nextTarget = (n2.target = resolveTarget(
                    n2.props,
                    querySelector
                  ));
                  if (nextTarget) {
                    moveTeleport(
                      n2,
                      nextTarget,
                      null,
                      internals,
                      0 /* TARGET_CHANGE */
                    );
                  } else if (true) {
                    warn(
                      'Invalid Teleport target on update:',
                      target,
                      `(${typeof target})`
                    );
                  }
                } else if (wasDisabled) {
                  // disabled -> enabled
                  // move into teleport target
                  moveTeleport(
                    n2,
                    target,
                    targetAnchor,
                    internals,
                    1 /* TOGGLE */
                  );
                }
              }
            }
          },
          remove(
            vnode,
            parentComponent,
            parentSuspense,
            optimized,
            { um: unmount, o: { remove: hostRemove } },
            doRemove
          ) {
            const { shapeFlag, children, anchor, targetAnchor, target, props } =
              vnode;
            if (target) {
              hostRemove(targetAnchor);
            }
            // an unmounted teleport should always remove its children if not disabled
            if (doRemove || !isTeleportDisabled(props)) {
              hostRemove(anchor);
              if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                for (let i = 0; i < children.length; i++) {
                  const child = children[i];
                  unmount(
                    child,
                    parentComponent,
                    parentSuspense,
                    true,
                    !!child.dynamicChildren
                  );
                }
              }
            }
          },
          move: moveTeleport,
          hydrate: hydrateTeleport,
        };
        function moveTeleport(
          vnode,
          container,
          parentAnchor,
          { o: { insert }, m: move },
          moveType = 2 /* REORDER */
        ) {
          // move target anchor if this is a target change.
          if (moveType === 0 /* TARGET_CHANGE */) {
            insert(vnode.targetAnchor, container, parentAnchor);
          }
          const { el, anchor, shapeFlag, children, props } = vnode;
          const isReorder = moveType === 2; /* REORDER */
          // move main view anchor if this is a re-order.
          if (isReorder) {
            insert(el, container, parentAnchor);
          }
          // if this is a re-order and teleport is enabled (content is in target)
          // do not move children. So the opposite is: only move children if this
          // is not a reorder, or the teleport is disabled
          if (!isReorder || isTeleportDisabled(props)) {
            // Teleport has either Array children or no children.
            if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
              for (let i = 0; i < children.length; i++) {
                move(children[i], container, parentAnchor, 2 /* REORDER */);
              }
            }
          }
          // move main view anchor if this is a re-order.
          if (isReorder) {
            insert(anchor, container, parentAnchor);
          }
        }
        function hydrateTeleport(
          node,
          vnode,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized,
          { o: { nextSibling, parentNode, querySelector } },
          hydrateChildren
        ) {
          const target = (vnode.target = resolveTarget(
            vnode.props,
            querySelector
          ));
          if (target) {
            // if multiple teleports rendered to the same target element, we need to
            // pick up from where the last teleport finished instead of the first node
            const targetNode = target._lpa || target.firstChild;
            if (vnode.shapeFlag & 16 /* ARRAY_CHILDREN */) {
              if (isTeleportDisabled(vnode.props)) {
                vnode.anchor = hydrateChildren(
                  nextSibling(node),
                  vnode,
                  parentNode(node),
                  parentComponent,
                  parentSuspense,
                  slotScopeIds,
                  optimized
                );
                vnode.targetAnchor = targetNode;
              } else {
                vnode.anchor = nextSibling(node);
                vnode.targetAnchor = hydrateChildren(
                  targetNode,
                  vnode,
                  target,
                  parentComponent,
                  parentSuspense,
                  slotScopeIds,
                  optimized
                );
              }
              target._lpa =
                vnode.targetAnchor && nextSibling(vnode.targetAnchor);
            }
          }
          return vnode.anchor && nextSibling(vnode.anchor);
        }
        // Force-casted public typing for h and TSX props inference
        const Teleport = TeleportImpl;

        const COMPONENTS = 'components';
        const DIRECTIVES = 'directives';
        /**
         * @private
         */
        function resolveComponent(name, maybeSelfReference) {
          return (
            resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name
          );
        }
        const NULL_DYNAMIC_COMPONENT = Symbol();
        /**
         * @private
         */
        function resolveDynamicComponent(component) {
          if (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(component)
          ) {
            return resolveAsset(COMPONENTS, component, false) || component;
          } else {
            // invalid types will fallthrough to createVNode and raise warning
            return component || NULL_DYNAMIC_COMPONENT;
          }
        }
        /**
         * @private
         */
        function resolveDirective(name) {
          return resolveAsset(DIRECTIVES, name);
        }
        // implementation
        function resolveAsset(
          type,
          name,
          warnMissing = true,
          maybeSelfReference = false
        ) {
          const instance = currentRenderingInstance || currentInstance;
          if (instance) {
            const Component = instance.type;
            // explicit self name has highest priority
            if (type === COMPONENTS) {
              const selfName = getComponentName(Component);
              if (
                selfName &&
                (selfName === name ||
                  selfName ===
                    (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(
                      name
                    ) ||
                  selfName ===
                    (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(
                      (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(
                        name
                      )
                    ))
              ) {
                return Component;
              }
            }
            const res =
              // local registration
              // check instance[type] first which is resolved for options API
              resolve(instance[type] || Component[type], name) ||
              // global registration
              resolve(instance.appContext[type], name);
            if (!res && maybeSelfReference) {
              // fallback to implicit self-reference
              return Component;
            }
            if (true && warnMissing && !res) {
              const extra =
                type === COMPONENTS
                  ? `\nIf this is a native custom element, make sure to exclude it from ` +
                    `component resolution via compilerOptions.isCustomElement.`
                  : ``;
              warn(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
            }
            return res;
          } else if (true) {
            warn(
              `resolve${(0,
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(
                type.slice(0, -1)
              )} ` + `can only be used in render() or setup().`
            );
          }
        }
        function resolve(registry, name) {
          return (
            registry &&
            (registry[name] ||
              registry[
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)
              ] ||
              registry[
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(
                  (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)
                )
              ])
          );
        }

        const Fragment = Symbol(true ? 'Fragment' : 0);
        const Text = Symbol(true ? 'Text' : 0);
        const Comment = Symbol(true ? 'Comment' : 0);
        const Static = Symbol(true ? 'Static' : 0);
        // Since v-if and v-for are the two possible ways node structure can dynamically
        // change, once we consider v-if branches and each v-for fragment a block, we
        // can divide a template into nested blocks, and within each block the node
        // structure would be stable. This allows us to skip most children diffing
        // and only worry about the dynamic nodes (indicated by patch flags).
        const blockStack = [];
        let currentBlock = null;
        /**
         * Open a block.
         * This must be called before `createBlock`. It cannot be part of `createBlock`
         * because the children of the block are evaluated before `createBlock` itself
         * is called. The generated code typically looks like this:
         *
         * ```js
         * function render() {
         *   return (openBlock(),createBlock('div', null, [...]))
         * }
         * ```
         * disableTracking is true when creating a v-for fragment block, since a v-for
         * fragment always diffs its children.
         *
         * @private
         */
        function openBlock(disableTracking = false) {
          blockStack.push((currentBlock = disableTracking ? null : []));
        }
        function closeBlock() {
          blockStack.pop();
          currentBlock = blockStack[blockStack.length - 1] || null;
        }
        // Whether we should be tracking dynamic child nodes inside a block.
        // Only tracks when this value is > 0
        // We are not using a simple boolean because this value may need to be
        // incremented/decremented by nested usage of v-once (see below)
        let isBlockTreeEnabled = 1;
        /**
         * Block tracking sometimes needs to be disabled, for example during the
         * creation of a tree that needs to be cached by v-once. The compiler generates
         * code like this:
         *
         * ``` js
         * _cache[1] || (
         *   setBlockTracking(-1),
         *   _cache[1] = createVNode(...),
         *   setBlockTracking(1),
         *   _cache[1]
         * )
         * ```
         *
         * @private
         */
        function setBlockTracking(value) {
          isBlockTreeEnabled += value;
        }
        function setupBlock(vnode) {
          // save current block children on the block vnode
          vnode.dynamicChildren =
            isBlockTreeEnabled > 0
              ? currentBlock ||
                _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR
              : null;
          // close block
          closeBlock();
          // a block is always going to be patched, so track it as a child of its
          // parent block
          if (isBlockTreeEnabled > 0 && currentBlock) {
            currentBlock.push(vnode);
          }
          return vnode;
        }
        /**
         * @private
         */
        function createElementBlock(
          type,
          props,
          children,
          patchFlag,
          dynamicProps,
          shapeFlag
        ) {
          return setupBlock(
            createBaseVNode(
              type,
              props,
              children,
              patchFlag,
              dynamicProps,
              shapeFlag,
              true /* isBlock */
            )
          );
        }
        /**
         * Create a block root vnode. Takes the same exact arguments as `createVNode`.
         * A block root keeps track of dynamic nodes within the block in the
         * `dynamicChildren` array.
         *
         * @private
         */
        function createBlock(type, props, children, patchFlag, dynamicProps) {
          return setupBlock(
            createVNode(
              type,
              props,
              children,
              patchFlag,
              dynamicProps,
              true /* isBlock: prevent a block from tracking itself */
            )
          );
        }
        function isVNode(value) {
          return value ? value.__v_isVNode === true : false;
        }
        function isSameVNodeType(n1, n2) {
          if (
            true &&
            n2.shapeFlag & 6 /* COMPONENT */ &&
            hmrDirtyComponents.has(n2.type)
          ) {
            // HMR only: if the component has been hot-updated, force a reload.
            return false;
          }
          return n1.type === n2.type && n1.key === n2.key;
        }
        let vnodeArgsTransformer;
        /**
         * Internal API for registering an arguments transform for createVNode
         * used for creating stubs in the test-utils
         * It is *internal* but needs to be exposed for test-utils to pick up proper
         * typings
         */
        function transformVNodeArgs(transformer) {
          vnodeArgsTransformer = transformer;
        }
        const createVNodeWithArgsTransform = (...args) => {
          return _createVNode(
            ...(vnodeArgsTransformer
              ? vnodeArgsTransformer(args, currentRenderingInstance)
              : args)
          );
        };
        const InternalObjectKey = `__vInternal`;
        const normalizeKey = ({ key }) => (key != null ? key : null);
        const normalizeRef = ({ ref, ref_key, ref_for }) => {
          return ref != null
            ? (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref) ||
              (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref) ||
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref)
              ? {
                  i: currentRenderingInstance,
                  r: ref,
                  k: ref_key,
                  f: !!ref_for,
                }
              : ref
            : null;
        };
        function createBaseVNode(
          type,
          props = null,
          children = null,
          patchFlag = 0,
          dynamicProps = null,
          shapeFlag = type === Fragment ? 0 : 1 /* ELEMENT */,
          isBlockNode = false,
          needFullChildrenNormalization = false
        ) {
          const vnode = {
            __v_isVNode: true,
            __v_skip: true,
            type,
            props,
            key: props && normalizeKey(props),
            ref: props && normalizeRef(props),
            scopeId: currentScopeId,
            slotScopeIds: null,
            children,
            component: null,
            suspense: null,
            ssContent: null,
            ssFallback: null,
            dirs: null,
            transition: null,
            el: null,
            anchor: null,
            target: null,
            targetAnchor: null,
            staticCount: 0,
            shapeFlag,
            patchFlag,
            dynamicProps,
            dynamicChildren: null,
            appContext: null,
          };
          if (needFullChildrenNormalization) {
            normalizeChildren(vnode, children);
            // normalize suspense children
            if (shapeFlag & 128 /* SUSPENSE */) {
              type.normalize(vnode);
            }
          } else if (children) {
            // compiled element vnode - if children is passed, only possible types are
            // string or Array.
            vnode.shapeFlag |= (0,
            _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(children)
              ? 8 /* TEXT_CHILDREN */
              : 16 /* ARRAY_CHILDREN */;
          }
          // validate key
          if (true && vnode.key !== vnode.key) {
            warn(
              `VNode created with invalid key (NaN). VNode type:`,
              vnode.type
            );
          }
          // track vnode for block tree
          if (
            isBlockTreeEnabled > 0 &&
            // avoid a block node from tracking itself
            !isBlockNode &&
            // has current parent block
            currentBlock &&
            // presence of a patch flag indicates this node needs patching on updates.
            // component nodes also should always be patched, because even if the
            // component doesn't need to update, it needs to persist the instance on to
            // the next vnode so that it can be properly unmounted later.
            (vnode.patchFlag > 0 || shapeFlag & 6) /* COMPONENT */ &&
            // the EVENTS flag is only for hydration and if it is the only flag, the
            // vnode should not be considered dynamic due to handler caching.
            vnode.patchFlag !== 32 /* HYDRATE_EVENTS */
          ) {
            currentBlock.push(vnode);
          }
          return vnode;
        }
        const createVNode = true ? createVNodeWithArgsTransform : 0;
        function _createVNode(
          type,
          props = null,
          children = null,
          patchFlag = 0,
          dynamicProps = null,
          isBlockNode = false
        ) {
          if (!type || type === NULL_DYNAMIC_COMPONENT) {
            if (true && !type) {
              warn(`Invalid vnode type when creating vnode: ${type}.`);
            }
            type = Comment;
          }
          if (isVNode(type)) {
            // createVNode receiving an existing vnode. This happens in cases like
            // <component :is="vnode"/>
            // #2078 make sure to merge refs during the clone instead of overwriting it
            const cloned = cloneVNode(type, props, true /* mergeRef: true */);
            if (children) {
              normalizeChildren(cloned, children);
            }
            return cloned;
          }
          // class component normalization.
          if (isClassComponent(type)) {
            type = type.__vccOpts;
          }
          // class & style normalization.
          if (props) {
            // for reactive or proxy objects, we need to clone it to enable mutation.
            props = guardReactiveProps(props);
            let { class: klass, style } = props;
            if (
              klass &&
              !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(klass)
            ) {
              props.class = (0,
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(klass);
            }
            if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(style)) {
              // reactive state objects need to be cloned since they are likely to be
              // mutated
              if (
                (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(
                  style
                ) &&
                !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(style)
              ) {
                style = (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(
                  {},
                  style
                );
              }
              props.style = (0,
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)(style);
            }
          }
          // encode the vnode type information into a bitmap
          const shapeFlag = (0,
          _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(type)
            ? 1 /* ELEMENT */
            : isSuspense(type)
            ? 128 /* SUSPENSE */
            : isTeleport(type)
            ? 64 /* TELEPORT */
            : (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(type)
            ? 4 /* STATEFUL_COMPONENT */
            : (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(type)
            ? 2 /* FUNCTIONAL_COMPONENT */
            : 0;
          if (
            true &&
            shapeFlag & 4 /* STATEFUL_COMPONENT */ &&
            (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(type)
          ) {
            type = (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(
              type
            );
            warn(
              `Vue received a Component which was made a reactive object. This can ` +
                `lead to unnecessary performance overhead, and should be avoided by ` +
                `marking the component with \`markRaw\` or using \`shallowRef\` ` +
                `instead of \`ref\`.`,
              `\nComponent that was made reactive: `,
              type
            );
          }
          return createBaseVNode(
            type,
            props,
            children,
            patchFlag,
            dynamicProps,
            shapeFlag,
            isBlockNode,
            true
          );
        }
        function guardReactiveProps(props) {
          if (!props) return null;
          return (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(
            props
          ) || InternalObjectKey in props
            ? (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, props)
            : props;
        }
        function cloneVNode(vnode, extraProps, mergeRef = false) {
          // This is intentionally NOT using spread or extend to avoid the runtime
          // key enumeration cost.
          const { props, ref, patchFlag, children } = vnode;
          const mergedProps = extraProps
            ? mergeProps(props || {}, extraProps)
            : props;
          const cloned = {
            __v_isVNode: true,
            __v_skip: true,
            type: vnode.type,
            props: mergedProps,
            key: mergedProps && normalizeKey(mergedProps),
            ref:
              extraProps && extraProps.ref
                ? // #2078 in the case of <component :is="vnode" ref="extra"/>
                  // if the vnode itself already has a ref, cloneVNode will need to merge
                  // the refs so the single vnode can be set on multiple refs
                  mergeRef && ref
                  ? (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ref)
                    ? ref.concat(normalizeRef(extraProps))
                    : [ref, normalizeRef(extraProps)]
                  : normalizeRef(extraProps)
                : ref,
            scopeId: vnode.scopeId,
            slotScopeIds: vnode.slotScopeIds,
            children:
              true &&
              patchFlag === -1 /* HOISTED */ &&
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children)
                ? children.map(deepCloneVNode)
                : children,
            target: vnode.target,
            targetAnchor: vnode.targetAnchor,
            staticCount: vnode.staticCount,
            shapeFlag: vnode.shapeFlag,
            // if the vnode is cloned with extra props, we can no longer assume its
            // existing patch flag to be reliable and need to add the FULL_PROPS flag.
            // note: preserve flag for fragments since they use the flag for children
            // fast paths only.
            patchFlag:
              extraProps && vnode.type !== Fragment
                ? patchFlag === -1 // hoisted node
                  ? 16 /* FULL_PROPS */
                  : patchFlag | 16 /* FULL_PROPS */
                : patchFlag,
            dynamicProps: vnode.dynamicProps,
            dynamicChildren: vnode.dynamicChildren,
            appContext: vnode.appContext,
            dirs: vnode.dirs,
            transition: vnode.transition,
            // These should technically only be non-null on mounted VNodes. However,
            // they *should* be copied for kept-alive vnodes. So we just always copy
            // them since them being non-null during a mount doesn't affect the logic as
            // they will simply be overwritten.
            component: vnode.component,
            suspense: vnode.suspense,
            ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
            ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
            el: vnode.el,
            anchor: vnode.anchor,
          };
          return cloned;
        }
        /**
         * Dev only, for HMR of hoisted vnodes reused in v-for
         * https://github.com/vitejs/vite/issues/2022
         */
        function deepCloneVNode(vnode) {
          const cloned = cloneVNode(vnode);
          if (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(
              vnode.children
            )
          ) {
            cloned.children = vnode.children.map(deepCloneVNode);
          }
          return cloned;
        }
        /**
         * @private
         */
        function createTextVNode(text = ' ', flag = 0) {
          return createVNode(Text, null, text, flag);
        }
        /**
         * @private
         */
        function createStaticVNode(content, numberOfNodes) {
          // A static vnode can contain multiple stringified elements, and the number
          // of elements is necessary for hydration.
          const vnode = createVNode(Static, null, content);
          vnode.staticCount = numberOfNodes;
          return vnode;
        }
        /**
         * @private
         */
        function createCommentVNode(
          text = '',
          // when used as the v-else branch, the comment node must be created as a
          // block to ensure correct updates.
          asBlock = false
        ) {
          return asBlock
            ? (openBlock(), createBlock(Comment, null, text))
            : createVNode(Comment, null, text);
        }
        function normalizeVNode(child) {
          if (child == null || typeof child === 'boolean') {
            // empty placeholder
            return createVNode(Comment);
          } else if (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(child)
          ) {
            // fragment
            return createVNode(
              Fragment,
              null,
              // #3666, avoid reference pollution when reusing vnode
              child.slice()
            );
          } else if (typeof child === 'object') {
            // already vnode, this should be the most common since compiled templates
            // always produce all-vnode children arrays
            return cloneIfMounted(child);
          } else {
            // strings and numbers
            return createVNode(Text, null, String(child));
          }
        }
        // optimized normalization for template-compiled render fns
        function cloneIfMounted(child) {
          return child.el === null || child.memo ? child : cloneVNode(child);
        }
        function normalizeChildren(vnode, children) {
          let type = 0;
          const { shapeFlag } = vnode;
          if (children == null) {
            children = null;
          } else if (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children)
          ) {
            type = 16 /* ARRAY_CHILDREN */;
          } else if (typeof children === 'object') {
            if (shapeFlag & (1 /* ELEMENT */ | 64) /* TELEPORT */) {
              // Normalize slot to plain children for plain element and Teleport
              const slot = children.default;
              if (slot) {
                // _c marker is added by withCtx() indicating this is a compiled slot
                slot._c && (slot._d = false);
                normalizeChildren(vnode, slot());
                slot._c && (slot._d = true);
              }
              return;
            } else {
              type = 32 /* SLOTS_CHILDREN */;
              const slotFlag = children._;
              if (!slotFlag && !(InternalObjectKey in children)) {
                children._ctx = currentRenderingInstance;
              } else if (
                slotFlag === 3 /* FORWARDED */ &&
                currentRenderingInstance
              ) {
                // a child component receives forwarded slots from the parent.
                // its slot type is determined by its parent's slot type.
                if (currentRenderingInstance.slots._ === 1 /* STABLE */) {
                  children._ = 1 /* STABLE */;
                } else {
                  children._ = 2 /* DYNAMIC */;
                  vnode.patchFlag |= 1024 /* DYNAMIC_SLOTS */;
                }
              }
            }
          } else if (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(children)
          ) {
            children = { default: children, _ctx: currentRenderingInstance };
            type = 32 /* SLOTS_CHILDREN */;
          } else {
            children = String(children);
            // force teleport children to array so it can be moved around
            if (shapeFlag & 64 /* TELEPORT */) {
              type = 16 /* ARRAY_CHILDREN */;
              children = [createTextVNode(children)];
            } else {
              type = 8 /* TEXT_CHILDREN */;
            }
          }
          vnode.children = children;
          vnode.shapeFlag |= type;
        }
        function mergeProps(...args) {
          const ret = {};
          for (let i = 0; i < args.length; i++) {
            const toMerge = args[i];
            for (const key in toMerge) {
              if (key === 'class') {
                if (ret.class !== toMerge.class) {
                  ret.class = (0,
                  _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)([
                    ret.class,
                    toMerge.class,
                  ]);
                }
              } else if (key === 'style') {
                ret.style = (0,
                _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)([
                  ret.style,
                  toMerge.style,
                ]);
              } else if (
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)
              ) {
                const existing = ret[key];
                const incoming = toMerge[key];
                if (
                  incoming &&
                  existing !== incoming &&
                  !(
                    (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(
                      existing
                    ) && existing.includes(incoming)
                  )
                ) {
                  ret[key] = existing
                    ? [].concat(existing, incoming)
                    : incoming;
                }
              } else if (key !== '') {
                ret[key] = toMerge[key];
              }
            }
          }
          return ret;
        }
        function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
          callWithAsyncErrorHandling(hook, instance, 7 /* VNODE_HOOK */, [
            vnode,
            prevVNode,
          ]);
        }

        /**
         * Actual implementation
         */
        function renderList(source, renderItem, cache, index) {
          let ret;
          const cached = cache && cache[index];
          if (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(source) ||
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(source)
          ) {
            ret = new Array(source.length);
            for (let i = 0, l = source.length; i < l; i++) {
              ret[i] = renderItem(source[i], i, undefined, cached && cached[i]);
            }
          } else if (typeof source === 'number') {
            if (true && !Number.isInteger(source)) {
              warn(
                `The v-for range expect an integer value but got ${source}.`
              );
              return [];
            }
            ret = new Array(source);
            for (let i = 0; i < source; i++) {
              ret[i] = renderItem(i + 1, i, undefined, cached && cached[i]);
            }
          } else if (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(source)
          ) {
            if (source[Symbol.iterator]) {
              ret = Array.from(source, (item, i) =>
                renderItem(item, i, undefined, cached && cached[i])
              );
            } else {
              const keys = Object.keys(source);
              ret = new Array(keys.length);
              for (let i = 0, l = keys.length; i < l; i++) {
                const key = keys[i];
                ret[i] = renderItem(source[key], key, i, cached && cached[i]);
              }
            }
          } else {
            ret = [];
          }
          if (cache) {
            cache[index] = ret;
          }
          return ret;
        }

        /**
         * Compiler runtime helper for creating dynamic slots object
         * @private
         */
        function createSlots(slots, dynamicSlots) {
          for (let i = 0; i < dynamicSlots.length; i++) {
            const slot = dynamicSlots[i];
            // array of dynamic slot generated by <template v-for="..." #[...]>
            if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(slot)) {
              for (let j = 0; j < slot.length; j++) {
                slots[slot[j].name] = slot[j].fn;
              }
            } else if (slot) {
              // conditional single slot generated by <template v-if="..." #foo>
              slots[slot.name] = slot.fn;
            }
          }
          return slots;
        }

        /**
         * Compiler runtime helper for rendering `<slot/>`
         * @private
         */
        function renderSlot(
          slots,
          name,
          props = {},
          // this is not a user-facing function, so the fallback is always generated by
          // the compiler and guaranteed to be a function returning an array
          fallback,
          noSlotted
        ) {
          if (currentRenderingInstance.isCE) {
            return createVNode(
              'slot',
              name === 'default' ? null : { name },
              fallback && fallback()
            );
          }
          let slot = slots[name];
          if (true && slot && slot.length > 1) {
            warn(
              `SSR-optimized slot function detected in a non-SSR-optimized render ` +
                `function. You need to mark this component with $dynamic-slots in the ` +
                `parent template.`
            );
            slot = () => [];
          }
          // a compiled slot disables block tracking by default to avoid manual
          // invocation interfering with template-based block tracking, but in
          // `renderSlot` we can be sure that it's template-based so we can force
          // enable it.
          if (slot && slot._c) {
            slot._d = false;
          }
          openBlock();
          const validSlotContent = slot && ensureValidVNode(slot(props));
          const rendered = createBlock(
            Fragment,
            { key: props.key || `_${name}` },
            validSlotContent || (fallback ? fallback() : []),
            validSlotContent && slots._ === 1 /* STABLE */
              ? 64 /* STABLE_FRAGMENT */
              : -2 /* BAIL */
          );
          if (!noSlotted && rendered.scopeId) {
            rendered.slotScopeIds = [rendered.scopeId + '-s'];
          }
          if (slot && slot._c) {
            slot._d = true;
          }
          return rendered;
        }
        function ensureValidVNode(vnodes) {
          return vnodes.some((child) => {
            if (!isVNode(child)) return true;
            if (child.type === Comment) return false;
            if (child.type === Fragment && !ensureValidVNode(child.children))
              return false;
            return true;
          })
            ? vnodes
            : null;
        }

        /**
         * For prefixing keys in v-on="obj" with "on"
         * @private
         */
        function toHandlers(obj) {
          const ret = {};
          if (
            true &&
            !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)
          ) {
            warn(`v-on with no argument expects an object value.`);
            return ret;
          }
          for (const key in obj) {
            ret[
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(key)
            ] = obj[key];
          }
          return ret;
        }

        /**
         * #2437 In Vue 3, functional components do not have a public instance proxy but
         * they exist in the internal parent chain. For code that relies on traversing
         * public $parent chains, skip functional ones and go to the parent instead.
         */
        const getPublicInstance = (i) => {
          if (!i) return null;
          if (isStatefulComponent(i)) return getExposeProxy(i) || i.proxy;
          return getPublicInstance(i.parent);
        };
        const publicPropertiesMap = (0,
        _vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Object.create(null), {
          $: (i) => i,
          $el: (i) => i.vnode.el,
          $data: (i) => i.data,
          $props: (i) =>
            true
              ? (0,
                _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(
                  i.props
                )
              : 0,
          $attrs: (i) =>
            true
              ? (0,
                _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(
                  i.attrs
                )
              : 0,
          $slots: (i) =>
            true
              ? (0,
                _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(
                  i.slots
                )
              : 0,
          $refs: (i) =>
            true
              ? (0,
                _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(
                  i.refs
                )
              : 0,
          $parent: (i) => getPublicInstance(i.parent),
          $root: (i) => getPublicInstance(i.root),
          $emit: (i) => i.emit,
          $options: (i) => (true ? resolveMergedOptions(i) : 0),
          $forceUpdate: (i) => () => queueJob(i.update),
          $nextTick: (i) => nextTick.bind(i.proxy),
          $watch: (i) => (true ? instanceWatch.bind(i) : 0),
        });
        const PublicInstanceProxyHandlers = {
          get({ _: instance }, key) {
            const {
              ctx,
              setupState,
              data,
              props,
              accessCache,
              type,
              appContext,
            } = instance;
            // for internal formatters to know that this is a Vue instance
            if (true && key === '__isVue') {
              return true;
            }
            // prioritize <script setup> bindings during dev.
            // this allows even properties that start with _ or $ to be used - so that
            // it aligns with the production behavior where the render fn is inlined and
            // indeed has access to all declared variables.
            if (
              true &&
              setupState !==
                _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ &&
              setupState.__isScriptSetup &&
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(
                setupState,
                key
              )
            ) {
              return setupState[key];
            }
            // data / props / ctx
            // This getter gets called for every property access on the render context
            // during render and is a major hotspot. The most expensive part of this
            // is the multiple hasOwn() calls. It's much faster to do a simple property
            // access on a plain object, so we use an accessCache object (with null
            // prototype) to memoize what access type a key corresponds to.
            let normalizedProps;
            if (key[0] !== '$') {
              const n = accessCache[key];
              if (n !== undefined) {
                switch (n) {
                  case 1 /* SETUP */:
                    return setupState[key];
                  case 2 /* DATA */:
                    return data[key];
                  case 4 /* CONTEXT */:
                    return ctx[key];
                  case 3 /* PROPS */:
                    return props[key];
                  // default: just fallthrough
                }
              } else if (
                setupState !==
                  _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ &&
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(
                  setupState,
                  key
                )
              ) {
                accessCache[key] = 1 /* SETUP */;
                return setupState[key];
              } else if (
                data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ &&
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)
              ) {
                accessCache[key] = 2 /* DATA */;
                return data[key];
              } else if (
                // only cache other properties when instance has declared (thus stable)
                // props
                (normalizedProps = instance.propsOptions[0]) &&
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(
                  normalizedProps,
                  key
                )
              ) {
                accessCache[key] = 3 /* PROPS */;
                return props[key];
              } else if (
                ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ &&
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)
              ) {
                accessCache[key] = 4 /* CONTEXT */;
                return ctx[key];
              } else if (false || shouldCacheAccess) {
                accessCache[key] = 0 /* OTHER */;
              }
            }
            const publicGetter = publicPropertiesMap[key];
            let cssModule, globalProperties;
            // public $xxx properties
            if (publicGetter) {
              if (key === '$attrs') {
                (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(
                  instance,
                  'get' /* GET */,
                  key
                );
                true && markAttrsAccessed();
              }
              return publicGetter(instance);
            } else if (
              // css module (injected by vue-loader)
              (cssModule = type.__cssModules) &&
              (cssModule = cssModule[key])
            ) {
              return cssModule;
            } else if (
              ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ &&
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)
            ) {
              // user may set custom properties to `this` that start with `$`
              accessCache[key] = 4 /* CONTEXT */;
              return ctx[key];
            } else if (
              // global properties
              ((globalProperties = appContext.config.globalProperties),
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(
                globalProperties,
                key
              ))
            ) {
              {
                return globalProperties[key];
              }
            } else if (
              true &&
              currentRenderingInstance &&
              (!(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(key) ||
                // #1091 avoid internal isRef/isVNode checks on component instance leading
                // to infinite warning loop
                key.indexOf('__v') !== 0)
            ) {
              if (
                data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ &&
                (key[0] === '$' || key[0] === '_') &&
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)
              ) {
                warn(
                  `Property ${JSON.stringify(
                    key
                  )} must be accessed via $data because it starts with a reserved ` +
                    `character ("$" or "_") and is not proxied on the render context.`
                );
              } else if (instance === currentRenderingInstance) {
                warn(
                  `Property ${JSON.stringify(
                    key
                  )} was accessed during render ` +
                    `but is not defined on instance.`
                );
              }
            }
          },
          set({ _: instance }, key, value) {
            const { data, setupState, ctx } = instance;
            if (
              setupState !==
                _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ &&
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(
                setupState,
                key
              )
            ) {
              setupState[key] = value;
              return true;
            } else if (
              data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ &&
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)
            ) {
              data[key] = value;
              return true;
            } else if (
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(
                instance.props,
                key
              )
            ) {
              true &&
                warn(
                  `Attempting to mutate prop "${key}". Props are readonly.`,
                  instance
                );
              return false;
            }
            if (key[0] === '$' && key.slice(1) in instance) {
              true &&
                warn(
                  `Attempting to mutate public property "${key}". ` +
                    `Properties starting with $ are reserved and readonly.`,
                  instance
                );
              return false;
            } else {
              if (true && key in instance.appContext.config.globalProperties) {
                Object.defineProperty(ctx, key, {
                  enumerable: true,
                  configurable: true,
                  value,
                });
              } else {
                ctx[key] = value;
              }
            }
            return true;
          },
          has(
            {
              _: {
                data,
                setupState,
                accessCache,
                ctx,
                appContext,
                propsOptions,
              },
            },
            key
          ) {
            let normalizedProps;
            return (
              !!accessCache[key] ||
              (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ &&
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(
                  data,
                  key
                )) ||
              (setupState !==
                _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ &&
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(
                  setupState,
                  key
                )) ||
              ((normalizedProps = propsOptions[0]) &&
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(
                  normalizedProps,
                  key
                )) ||
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key) ||
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(
                publicPropertiesMap,
                key
              ) ||
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(
                appContext.config.globalProperties,
                key
              )
            );
          },
          defineProperty(target, key, descriptor) {
            if (descriptor.get != null) {
              this.set(target, key, descriptor.get(), null);
            } else if (descriptor.value != null) {
              this.set(target, key, descriptor.value, null);
            }
            return Reflect.defineProperty(target, key, descriptor);
          },
        };
        if (true) {
          PublicInstanceProxyHandlers.ownKeys = (target) => {
            warn(
              `Avoid app logic that relies on enumerating keys on a component instance. ` +
                `The keys will be empty in production mode to avoid performance overhead.`
            );
            return Reflect.ownKeys(target);
          };
        }
        const RuntimeCompiledPublicInstanceProxyHandlers = /*#__PURE__*/ (0,
        _vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(
          {},
          PublicInstanceProxyHandlers,
          {
            get(target, key) {
              // fast path for unscopables when using `with` block
              if (key === Symbol.unscopables) {
                return;
              }
              return PublicInstanceProxyHandlers.get(target, key, target);
            },
            has(_, key) {
              const has =
                key[0] !== '_' &&
                !(0,
                _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isGloballyWhitelisted)(
                  key
                );
              if (true && !has && PublicInstanceProxyHandlers.has(_, key)) {
                warn(
                  `Property ${JSON.stringify(
                    key
                  )} should not start with _ which is a reserved prefix for Vue internals.`
                );
              }
              return has;
            },
          }
        );
        // dev only
        // In dev mode, the proxy target exposes the same properties as seen on `this`
        // for easier console inspection. In prod mode it will be an empty object so
        // these properties definitions can be skipped.
        function createDevRenderContext(instance) {
          const target = {};
          // expose internal instance for proxy handlers
          Object.defineProperty(target, `_`, {
            configurable: true,
            enumerable: false,
            get: () => instance,
          });
          // expose public properties
          Object.keys(publicPropertiesMap).forEach((key) => {
            Object.defineProperty(target, key, {
              configurable: true,
              enumerable: false,
              get: () => publicPropertiesMap[key](instance),
              // intercepted by the proxy so no need for implementation,
              // but needed to prevent set errors
              set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP,
            });
          });
          return target;
        }
        // dev only
        function exposePropsOnRenderContext(instance) {
          const {
            ctx,
            propsOptions: [propsOptions],
          } = instance;
          if (propsOptions) {
            Object.keys(propsOptions).forEach((key) => {
              Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: () => instance.props[key],
                set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP,
              });
            });
          }
        }
        // dev only
        function exposeSetupStateOnRenderContext(instance) {
          const { ctx, setupState } = instance;
          Object.keys(
            (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(setupState)
          ).forEach((key) => {
            if (!setupState.__isScriptSetup) {
              if (key[0] === '$' || key[0] === '_') {
                warn(
                  `setup() return property ${JSON.stringify(
                    key
                  )} should not start with "$" or "_" ` +
                    `which are reserved prefixes for Vue internals.`
                );
                return;
              }
              Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: () => setupState[key],
                set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP,
              });
            }
          });
        }

        const emptyAppContext = createAppContext();
        let uid$1 = 0;
        function createComponentInstance(vnode, parent, suspense) {
          const type = vnode.type;
          // inherit parent app context - or - if root, adopt from root vnode
          const appContext =
            (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
          const instance = {
            uid: uid$1++,
            vnode,
            type,
            parent,
            appContext,
            root: null,
            next: null,
            subTree: null,
            effect: null,
            update: null,
            scope: new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.EffectScope(
              true /* detached */
            ),
            render: null,
            proxy: null,
            exposed: null,
            exposeProxy: null,
            withProxy: null,
            provides: parent
              ? parent.provides
              : Object.create(appContext.provides),
            accessCache: null,
            renderCache: [],
            // local resovled assets
            components: null,
            directives: null,
            // resolved props and emits options
            propsOptions: normalizePropsOptions(type, appContext),
            emitsOptions: normalizeEmitsOptions(type, appContext),
            // emit
            emit: null,
            emitted: null,
            // props default value
            propsDefaults: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
            // inheritAttrs
            inheritAttrs: type.inheritAttrs,
            // state
            ctx: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
            data: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
            props: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
            attrs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
            slots: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
            refs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
            setupState: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
            setupContext: null,
            // suspense related
            suspense,
            suspenseId: suspense ? suspense.pendingId : 0,
            asyncDep: null,
            asyncResolved: false,
            // lifecycle hooks
            // not using enums here because it results in computed properties
            isMounted: false,
            isUnmounted: false,
            isDeactivated: false,
            bc: null,
            c: null,
            bm: null,
            m: null,
            bu: null,
            u: null,
            um: null,
            bum: null,
            da: null,
            a: null,
            rtg: null,
            rtc: null,
            ec: null,
            sp: null,
          };
          if (true) {
            instance.ctx = createDevRenderContext(instance);
          } else {
          }
          instance.root = parent ? parent.root : instance;
          instance.emit = emit$1.bind(null, instance);
          // apply custom element special handling
          if (vnode.ce) {
            vnode.ce(instance);
          }
          return instance;
        }
        let currentInstance = null;
        const getCurrentInstance = () =>
          currentInstance || currentRenderingInstance;
        const setCurrentInstance = (instance) => {
          currentInstance = instance;
          instance.scope.on();
        };
        const unsetCurrentInstance = () => {
          currentInstance && currentInstance.scope.off();
          currentInstance = null;
        };
        const isBuiltInTag = /*#__PURE__*/ (0,
        _vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('slot,component');
        function validateComponentName(name, config) {
          const appIsNativeTag =
            config.isNativeTag || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO;
          if (isBuiltInTag(name) || appIsNativeTag(name)) {
            warn(
              'Do not use built-in or reserved HTML elements as component id: ' +
                name
            );
          }
        }
        function isStatefulComponent(instance) {
          return instance.vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */;
        }
        let isInSSRComponentSetup = false;
        function setupComponent(instance, isSSR = false) {
          isInSSRComponentSetup = isSSR;
          const { props, children } = instance.vnode;
          const isStateful = isStatefulComponent(instance);
          initProps(instance, props, isStateful, isSSR);
          initSlots(instance, children);
          const setupResult = isStateful
            ? setupStatefulComponent(instance, isSSR)
            : undefined;
          isInSSRComponentSetup = false;
          return setupResult;
        }
        function setupStatefulComponent(instance, isSSR) {
          const Component = instance.type;
          if (true) {
            if (Component.name) {
              validateComponentName(Component.name, instance.appContext.config);
            }
            if (Component.components) {
              const names = Object.keys(Component.components);
              for (let i = 0; i < names.length; i++) {
                validateComponentName(names[i], instance.appContext.config);
              }
            }
            if (Component.directives) {
              const names = Object.keys(Component.directives);
              for (let i = 0; i < names.length; i++) {
                validateDirectiveName(names[i]);
              }
            }
            if (Component.compilerOptions && isRuntimeOnly()) {
              warn(
                `"compilerOptions" is only supported when using a build of Vue that ` +
                  `includes the runtime compiler. Since you are using a runtime-only ` +
                  `build, the options should be passed via your build tool config instead.`
              );
            }
          }
          // 0. create render proxy property access cache
          instance.accessCache = Object.create(null);
          // 1. create public instance / render proxy
          // also mark it raw so it's never observed
          instance.proxy = (0,
          _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw)(
            new Proxy(instance.ctx, PublicInstanceProxyHandlers)
          );
          if (true) {
            exposePropsOnRenderContext(instance);
          }
          // 2. call setup()
          const { setup } = Component;
          if (setup) {
            const setupContext = (instance.setupContext =
              setup.length > 1 ? createSetupContext(instance) : null);
            setCurrentInstance(instance);
            (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
            const setupResult = callWithErrorHandling(
              setup,
              instance,
              0 /* SETUP_FUNCTION */,
              [
                true
                  ? (0,
                    _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(
                      instance.props
                    )
                  : 0,
                setupContext,
              ]
            );
            (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
            unsetCurrentInstance();
            if (
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(
                setupResult
              )
            ) {
              setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
              if (isSSR) {
                // return the promise so server-renderer can wait on it
                return setupResult
                  .then((resolvedResult) => {
                    handleSetupResult(instance, resolvedResult, isSSR);
                  })
                  .catch((e) => {
                    handleError(e, instance, 0 /* SETUP_FUNCTION */);
                  });
              } else {
                // async setup returned Promise.
                // bail here and wait for re-entry.
                instance.asyncDep = setupResult;
              }
            } else {
              handleSetupResult(instance, setupResult, isSSR);
            }
          } else {
            finishComponentSetup(instance, isSSR);
          }
        }
        function handleSetupResult(instance, setupResult, isSSR) {
          if (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(
              setupResult
            )
          ) {
            // setup returned an inline render function
            if (instance.type.__ssrInlineRender) {
              // when the function's name is `ssrRender` (compiled by SFC inline mode),
              // set it as ssrRender instead.
              instance.ssrRender = setupResult;
            } else {
              instance.render = setupResult;
            }
          } else if (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(setupResult)
          ) {
            if (true && isVNode(setupResult)) {
              warn(
                `setup() should not return VNodes directly - ` +
                  `return a render function instead.`
              );
            }
            // setup returned bindings.
            // assuming a render function compiled from template is present.
            if (true) {
              instance.devtoolsRawSetupState = setupResult;
            }
            instance.setupState = (0,
            _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)(
              setupResult
            );
            if (true) {
              exposeSetupStateOnRenderContext(instance);
            }
          } else if (true && setupResult !== undefined) {
            warn(
              `setup() should return an object. Received: ${
                setupResult === null ? 'null' : typeof setupResult
              }`
            );
          }
          finishComponentSetup(instance, isSSR);
        }
        let compile;
        let installWithProxy;
        /**
         * For runtime-dom to register the compiler.
         * Note the exported method uses any to avoid d.ts relying on the compiler types.
         */
        function registerRuntimeCompiler(_compile) {
          compile = _compile;
          installWithProxy = (i) => {
            if (i.render._rc) {
              i.withProxy = new Proxy(
                i.ctx,
                RuntimeCompiledPublicInstanceProxyHandlers
              );
            }
          };
        }
        // dev only
        const isRuntimeOnly = () => !compile;
        function finishComponentSetup(instance, isSSR, skipOptions) {
          const Component = instance.type;
          // template / render function normalization
          // could be already set when returned from setup()
          if (!instance.render) {
            // only do on-the-fly compile if not in SSR - SSR on-the-fly compilation
            // is done by server-renderer
            if (!isSSR && compile && !Component.render) {
              const template = Component.template;
              if (template) {
                if (true) {
                  startMeasure(instance, `compile`);
                }
                const { isCustomElement, compilerOptions } =
                  instance.appContext.config;
                const {
                  delimiters,
                  compilerOptions: componentCompilerOptions,
                } = Component;
                const finalCompilerOptions = (0,
                _vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(
                  (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(
                    {
                      isCustomElement,
                      delimiters,
                    },
                    compilerOptions
                  ),
                  componentCompilerOptions
                );
                Component.render = compile(template, finalCompilerOptions);
                if (true) {
                  endMeasure(instance, `compile`);
                }
              }
            }
            instance.render =
              Component.render || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
            // for runtime-compiled render functions using `with` blocks, the render
            // proxy used needs a different `has` handler which is more performant and
            // also only allows a whitelist of globals to fallthrough.
            if (installWithProxy) {
              installWithProxy(instance);
            }
          }
          // support for 2.x options
          if (true) {
            setCurrentInstance(instance);
            (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
            applyOptions(instance);
            (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
            unsetCurrentInstance();
          }
          // warn missing template/render
          // the runtime compilation of template in SSR is done by server-render
          if (
            true &&
            !Component.render &&
            instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP &&
            !isSSR
          ) {
            /* istanbul ignore if */
            if (!compile && Component.template) {
              warn(
                `Component provided template option but ` +
                  `runtime compilation is not supported in this build of Vue.` +
                  ` Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".` /* should not happen */
              );
            } else {
              warn(`Component is missing template or render function.`);
            }
          }
        }
        function createAttrsProxy(instance) {
          return new Proxy(
            instance.attrs,
            true
              ? {
                  get(target, key) {
                    markAttrsAccessed();
                    (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(
                      instance,
                      'get' /* GET */,
                      '$attrs'
                    );
                    return target[key];
                  },
                  set() {
                    warn(`setupContext.attrs is readonly.`);
                    return false;
                  },
                  deleteProperty() {
                    warn(`setupContext.attrs is readonly.`);
                    return false;
                  },
                }
              : 0
          );
        }
        function createSetupContext(instance) {
          const expose = (exposed) => {
            if (true && instance.exposed) {
              warn(`expose() should be called only once per setup().`);
            }
            instance.exposed = exposed || {};
          };
          let attrs;
          if (true) {
            // We use getters in dev in case libs like test-utils overwrite instance
            // properties (overwrites should not be done in prod)
            return Object.freeze({
              get attrs() {
                return attrs || (attrs = createAttrsProxy(instance));
              },
              get slots() {
                return (0,
                _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(
                  instance.slots
                );
              },
              get emit() {
                return (event, ...args) => instance.emit(event, ...args);
              },
              expose,
            });
          } else {
          }
        }
        function getExposeProxy(instance) {
          if (instance.exposed) {
            return (
              instance.exposeProxy ||
              (instance.exposeProxy = new Proxy(
                (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)(
                  (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw)(
                    instance.exposed
                  )
                ),
                {
                  get(target, key) {
                    if (key in target) {
                      return target[key];
                    } else if (key in publicPropertiesMap) {
                      return publicPropertiesMap[key](instance);
                    }
                  },
                }
              ))
            );
          }
        }
        const classifyRE = /(?:^|[-_])(\w)/g;
        const classify = (str) =>
          str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, '');
        function getComponentName(Component) {
          return (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(
            Component
          )
            ? Component.displayName || Component.name
            : Component.name;
        }
        /* istanbul ignore next */
        function formatComponentName(instance, Component, isRoot = false) {
          let name = getComponentName(Component);
          if (!name && Component.__file) {
            const match = Component.__file.match(/([^/\\]+)\.\w+$/);
            if (match) {
              name = match[1];
            }
          }
          if (!name && instance && instance.parent) {
            // try to infer the name based on reverse resolution
            const inferFromRegistry = (registry) => {
              for (const key in registry) {
                if (registry[key] === Component) {
                  return key;
                }
              }
            };
            name =
              inferFromRegistry(
                instance.components || instance.parent.type.components
              ) || inferFromRegistry(instance.appContext.components);
          }
          return name ? classify(name) : isRoot ? `App` : `Anonymous`;
        }
        function isClassComponent(value) {
          return (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value) &&
            '__vccOpts' in value
          );
        }

        const computed = (getterOrOptions, debugOptions) => {
          // @ts-ignore
          return (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.computed)(
            getterOrOptions,
            debugOptions,
            isInSSRComponentSetup
          );
        };

        // dev only
        const warnRuntimeUsage = (method) =>
          warn(
            `${method}() is a compiler-hint helper that is only usable inside ` +
              `<script setup> of a single file component. Its arguments should be ` +
              `compiled away and passing it at runtime has no effect.`
          );
        // implementation
        function defineProps() {
          if (true) {
            warnRuntimeUsage(`defineProps`);
          }
          return null;
        }
        // implementation
        function defineEmits() {
          if (true) {
            warnRuntimeUsage(`defineEmits`);
          }
          return null;
        }
        /**
         * Vue `<script setup>` compiler macro for declaring a component's exposed
         * instance properties when it is accessed by a parent component via template
         * refs.
         *
         * `<script setup>` components are closed by default - i.e. variables inside
         * the `<script setup>` scope is not exposed to parent unless explicitly exposed
         * via `defineExpose`.
         *
         * This is only usable inside `<script setup>`, is compiled away in the
         * output and should **not** be actually called at runtime.
         */
        function defineExpose(exposed) {
          if (true) {
            warnRuntimeUsage(`defineExpose`);
          }
        }
        /**
         * Vue `<script setup>` compiler macro for providing props default values when
         * using type-based `defineProps` declaration.
         *
         * Example usage:
         * ```ts
         * withDefaults(defineProps<{
         *   size?: number
         *   labels?: string[]
         * }>(), {
         *   size: 3,
         *   labels: () => ['default label']
         * })
         * ```
         *
         * This is only usable inside `<script setup>`, is compiled away in the output
         * and should **not** be actually called at runtime.
         */
        function withDefaults(props, defaults) {
          if (true) {
            warnRuntimeUsage(`withDefaults`);
          }
          return null;
        }
        function useSlots() {
          return getContext().slots;
        }
        function useAttrs() {
          return getContext().attrs;
        }
        function getContext() {
          const i = getCurrentInstance();
          if (true && !i) {
            warn(`useContext() called without active instance.`);
          }
          return i.setupContext || (i.setupContext = createSetupContext(i));
        }
        /**
         * Runtime helper for merging default declarations. Imported by compiled code
         * only.
         * @internal
         */
        function mergeDefaults(raw, defaults) {
          const props = (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(
            raw
          )
            ? raw.reduce(
                (normalized, p) => ((normalized[p] = {}), normalized),
                {}
              )
            : raw;
          for (const key in defaults) {
            const opt = props[key];
            if (opt) {
              if (
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opt) ||
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt)
              ) {
                props[key] = { type: opt, default: defaults[key] };
              } else {
                opt.default = defaults[key];
              }
            } else if (opt === null) {
              props[key] = { default: defaults[key] };
            } else if (true) {
              warn(
                `props default key "${key}" has no corresponding declaration.`
              );
            }
          }
          return props;
        }
        /**
         * Used to create a proxy for the rest element when destructuring props with
         * defineProps().
         * @internal
         */
        function createPropsRestProxy(props, excludedKeys) {
          const ret = {};
          for (const key in props) {
            if (!excludedKeys.includes(key)) {
              Object.defineProperty(ret, key, {
                enumerable: true,
                get: () => props[key],
              });
            }
          }
          return ret;
        }
        /**
         * `<script setup>` helper for persisting the current instance context over
         * async/await flows.
         *
         * `@vue/compiler-sfc` converts the following:
         *
         * ```ts
         * const x = await foo()
         * ```
         *
         * into:
         *
         * ```ts
         * let __temp, __restore
         * const x = (([__temp, __restore] = withAsyncContext(() => foo())),__temp=await __temp,__restore(),__temp)
         * ```
         * @internal
         */
        function withAsyncContext(getAwaitable) {
          const ctx = getCurrentInstance();
          if (true && !ctx) {
            warn(
              `withAsyncContext called without active current instance. ` +
                `This is likely a bug.`
            );
          }
          let awaitable = getAwaitable();
          unsetCurrentInstance();
          if (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(awaitable)
          ) {
            awaitable = awaitable.catch((e) => {
              setCurrentInstance(ctx);
              throw e;
            });
          }
          return [awaitable, () => setCurrentInstance(ctx)];
        }

        // Actual implementation
        function h(type, propsOrChildren, children) {
          const l = arguments.length;
          if (l === 2) {
            if (
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(
                propsOrChildren
              ) &&
              !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(
                propsOrChildren
              )
            ) {
              // single vnode without props
              if (isVNode(propsOrChildren)) {
                return createVNode(type, null, [propsOrChildren]);
              }
              // props without children
              return createVNode(type, propsOrChildren);
            } else {
              // omit props
              return createVNode(type, null, propsOrChildren);
            }
          } else {
            if (l > 3) {
              children = Array.prototype.slice.call(arguments, 2);
            } else if (l === 3 && isVNode(children)) {
              children = [children];
            }
            return createVNode(type, propsOrChildren, children);
          }
        }

        const ssrContextKey = Symbol(true ? `ssrContext` : 0);
        const useSSRContext = () => {
          {
            const ctx = inject(ssrContextKey);
            if (!ctx) {
              warn(
                `Server rendering context not provided. Make sure to only call ` +
                  `useSSRContext() conditionally in the server build.`
              );
            }
            return ctx;
          }
        };

        function isShallow(value) {
          return !!(value && value['__v_isShallow' /* IS_SHALLOW */]);
        }

        function initCustomFormatter() {
          /* eslint-disable no-restricted-globals */
          if (false || typeof window === 'undefined') {
            return;
          }
          const vueStyle = { style: 'color:#3ba776' };
          const numberStyle = { style: 'color:#0b1bc9' };
          const stringStyle = { style: 'color:#b62e24' };
          const keywordStyle = { style: 'color:#9d288c' };
          // custom formatter for Chrome
          // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html
          const formatter = {
            header(obj) {
              // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup
              if (
                !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)
              ) {
                return null;
              }
              if (obj.__isVue) {
                return ['div', vueStyle, `VueInstance`];
              } else if (
                (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(obj)
              ) {
                return [
                  'div',
                  {},
                  ['span', vueStyle, genRefFlag(obj)],
                  '<',
                  formatValue(obj.value),
                  `>`,
                ];
              } else if (
                (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(
                  obj
                )
              ) {
                return [
                  'div',
                  {},
                  [
                    'span',
                    vueStyle,
                    isShallow(obj) ? 'ShallowReactive' : 'Reactive',
                  ],
                  '<',
                  formatValue(obj),
                  `>${
                    (0,
                    _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(
                      obj
                    )
                      ? ` (readonly)`
                      : ``
                  }`,
                ];
              } else if (
                (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(
                  obj
                )
              ) {
                return [
                  'div',
                  {},
                  [
                    'span',
                    vueStyle,
                    isShallow(obj) ? 'ShallowReadonly' : 'Readonly',
                  ],
                  '<',
                  formatValue(obj),
                  '>',
                ];
              }
              return null;
            },
            hasBody(obj) {
              return obj && obj.__isVue;
            },
            body(obj) {
              if (obj && obj.__isVue) {
                return ['div', {}, ...formatInstance(obj.$)];
              }
            },
          };
          function formatInstance(instance) {
            const blocks = [];
            if (instance.type.props && instance.props) {
              blocks.push(
                createInstanceBlock(
                  'props',
                  (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(
                    instance.props
                  )
                )
              );
            }
            if (
              instance.setupState !==
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ
            ) {
              blocks.push(createInstanceBlock('setup', instance.setupState));
            }
            if (
              instance.data !==
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ
            ) {
              blocks.push(
                createInstanceBlock(
                  'data',
                  (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(
                    instance.data
                  )
                )
              );
            }
            const computed = extractKeys(instance, 'computed');
            if (computed) {
              blocks.push(createInstanceBlock('computed', computed));
            }
            const injected = extractKeys(instance, 'inject');
            if (injected) {
              blocks.push(createInstanceBlock('injected', injected));
            }
            blocks.push([
              'div',
              {},
              [
                'span',
                {
                  style: keywordStyle.style + ';opacity:0.66',
                },
                '$ (internal): ',
              ],
              ['object', { object: instance }],
            ]);
            return blocks;
          }
          function createInstanceBlock(type, target) {
            target = (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(
              {},
              target
            );
            if (!Object.keys(target).length) {
              return ['span', {}];
            }
            return [
              'div',
              { style: 'line-height:1.25em;margin-bottom:0.6em' },
              [
                'div',
                {
                  style: 'color:#476582',
                },
                type,
              ],
              [
                'div',
                {
                  style: 'padding-left:1.25em',
                },
                ...Object.keys(target).map((key) => {
                  return [
                    'div',
                    {},
                    ['span', keywordStyle, key + ': '],
                    formatValue(target[key], false),
                  ];
                }),
              ],
            ];
          }
          function formatValue(v, asRaw = true) {
            if (typeof v === 'number') {
              return ['span', numberStyle, v];
            } else if (typeof v === 'string') {
              return ['span', stringStyle, JSON.stringify(v)];
            } else if (typeof v === 'boolean') {
              return ['span', keywordStyle, v];
            } else if (
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(v)
            ) {
              return [
                'object',
                {
                  object: asRaw
                    ? (0, _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(v)
                    : v,
                },
              ];
            } else {
              return ['span', stringStyle, String(v)];
            }
          }
          function extractKeys(instance, type) {
            const Comp = instance.type;
            if (
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(Comp)
            ) {
              return;
            }
            const extracted = {};
            for (const key in instance.ctx) {
              if (isKeyOfType(Comp, key, type)) {
                extracted[key] = instance.ctx[key];
              }
            }
            return extracted;
          }
          function isKeyOfType(Comp, key, type) {
            const opts = Comp[type];
            if (
              ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opts) &&
                opts.includes(key)) ||
              ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opts) &&
                key in opts)
            ) {
              return true;
            }
            if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
              return true;
            }
            if (
              Comp.mixins &&
              Comp.mixins.some((m) => isKeyOfType(m, key, type))
            ) {
              return true;
            }
          }
          function genRefFlag(v) {
            if (isShallow(v)) {
              return `ShallowRef`;
            }
            if (v.effect) {
              return `ComputedRef`;
            }
            return `Ref`;
          }
          if (window.devtoolsFormatters) {
            window.devtoolsFormatters.push(formatter);
          } else {
            window.devtoolsFormatters = [formatter];
          }
        }

        function withMemo(memo, render, cache, index) {
          const cached = cache[index];
          if (cached && isMemoSame(cached, memo)) {
            return cached;
          }
          const ret = render();
          // shallow clone
          ret.memo = memo.slice();
          return (cache[index] = ret);
        }
        function isMemoSame(cached, memo) {
          const prev = cached.memo;
          if (prev.length != memo.length) {
            return false;
          }
          for (let i = 0; i < prev.length; i++) {
            if (prev[i] !== memo[i]) {
              return false;
            }
          }
          // make sure to let parent block track it when returning cached
          if (isBlockTreeEnabled > 0 && currentBlock) {
            currentBlock.push(cached);
          }
          return true;
        }

        // Core API ------------------------------------------------------------------
        const version = '3.2.31';
        const _ssrUtils = {
          createComponentInstance,
          setupComponent,
          renderComponentRoot,
          setCurrentRenderingInstance,
          isVNode,
          normalizeVNode,
        };
        /**
         * SSR utils for \@vue/server-renderer. Only exposed in cjs builds.
         * @internal
         */
        const ssrUtils = _ssrUtils;
        /**
         * @internal only exposed in compat builds
         */
        const resolveFilter = null;
        /**
         * @internal only exposed in compat builds.
         */
        const compatUtils = null;

        /***/
      },

    /***/ './node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js':
      /*!***********************************************************************!*\
  !*** ./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js ***!
  \***********************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ BaseTransition: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition,
          /* harmony export */ Comment: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Comment,
          /* harmony export */ EffectScope: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.EffectScope,
          /* harmony export */ Fragment: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment,
          /* harmony export */ KeepAlive: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.KeepAlive,
          /* harmony export */ ReactiveEffect: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect,
          /* harmony export */ Static: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Static,
          /* harmony export */ Suspense: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Suspense,
          /* harmony export */ Teleport: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Teleport,
          /* harmony export */ Text: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Text,
          /* harmony export */ callWithAsyncErrorHandling: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling,
          /* harmony export */ callWithErrorHandling: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling,
          /* harmony export */ camelize: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.camelize,
          /* harmony export */ capitalize: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.capitalize,
          /* harmony export */ cloneVNode: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.cloneVNode,
          /* harmony export */ compatUtils: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.compatUtils,
          /* harmony export */ computed: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.computed,
          /* harmony export */ createBlock: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createBlock,
          /* harmony export */ createCommentVNode: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode,
          /* harmony export */ createElementBlock: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createElementBlock,
          /* harmony export */ createElementVNode: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createElementVNode,
          /* harmony export */ createHydrationRenderer: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer,
          /* harmony export */ createPropsRestProxy: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createPropsRestProxy,
          /* harmony export */ createRenderer: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createRenderer,
          /* harmony export */ createSlots: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createSlots,
          /* harmony export */ createStaticVNode: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode,
          /* harmony export */ createTextVNode: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createTextVNode,
          /* harmony export */ createVNode: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode,
          /* harmony export */ customRef: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.customRef,
          /* harmony export */ defineAsyncComponent: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent,
          /* harmony export */ defineComponent: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineComponent,
          /* harmony export */ defineEmits: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineEmits,
          /* harmony export */ defineExpose: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineExpose,
          /* harmony export */ defineProps: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineProps,
          /* harmony export */ devtools: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.devtools,
          /* harmony export */ effect: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.effect,
          /* harmony export */ effectScope: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.effectScope,
          /* harmony export */ getCurrentInstance: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance,
          /* harmony export */ getCurrentScope: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope,
          /* harmony export */ getTransitionRawChildren: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren,
          /* harmony export */ guardReactiveProps: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.guardReactiveProps,
          /* harmony export */ h: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h,
          /* harmony export */ handleError: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.handleError,
          /* harmony export */ initCustomFormatter: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter,
          /* harmony export */ inject: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.inject,
          /* harmony export */ isMemoSame: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isMemoSame,
          /* harmony export */ isProxy: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isProxy,
          /* harmony export */ isReactive: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isReactive,
          /* harmony export */ isReadonly: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isReadonly,
          /* harmony export */ isRef: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRef,
          /* harmony export */ isRuntimeOnly: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly,
          /* harmony export */ isShallow: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isShallow,
          /* harmony export */ isVNode: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isVNode,
          /* harmony export */ markRaw: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.markRaw,
          /* harmony export */ mergeDefaults: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.mergeDefaults,
          /* harmony export */ mergeProps: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.mergeProps,
          /* harmony export */ nextTick: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nextTick,
          /* harmony export */ normalizeClass: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.normalizeClass,
          /* harmony export */ normalizeProps: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.normalizeProps,
          /* harmony export */ normalizeStyle: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle,
          /* harmony export */ onActivated: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onActivated,
          /* harmony export */ onBeforeMount: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount,
          /* harmony export */ onBeforeUnmount: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount,
          /* harmony export */ onBeforeUpdate: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate,
          /* harmony export */ onDeactivated: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onDeactivated,
          /* harmony export */ onErrorCaptured: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured,
          /* harmony export */ onMounted: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onMounted,
          /* harmony export */ onRenderTracked: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked,
          /* harmony export */ onRenderTriggered: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered,
          /* harmony export */ onScopeDispose: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose,
          /* harmony export */ onServerPrefetch: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch,
          /* harmony export */ onUnmounted: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUnmounted,
          /* harmony export */ onUpdated: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated,
          /* harmony export */ openBlock: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.openBlock,
          /* harmony export */ popScopeId: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.popScopeId,
          /* harmony export */ provide: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.provide,
          /* harmony export */ proxyRefs: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.proxyRefs,
          /* harmony export */ pushScopeId: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.pushScopeId,
          /* harmony export */ queuePostFlushCb: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb,
          /* harmony export */ reactive: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.reactive,
          /* harmony export */ readonly: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.readonly,
          /* harmony export */ ref: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ref,
          /* harmony export */ registerRuntimeCompiler: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler,
          /* harmony export */ renderList: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.renderList,
          /* harmony export */ renderSlot: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.renderSlot,
          /* harmony export */ resolveComponent: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveComponent,
          /* harmony export */ resolveDirective: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveDirective,
          /* harmony export */ resolveDynamicComponent: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent,
          /* harmony export */ resolveFilter: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveFilter,
          /* harmony export */ resolveTransitionHooks: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks,
          /* harmony export */ setBlockTracking: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking,
          /* harmony export */ setDevtoolsHook: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook,
          /* harmony export */ setTransitionHooks: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks,
          /* harmony export */ shallowReactive: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowReactive,
          /* harmony export */ shallowReadonly: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly,
          /* harmony export */ shallowRef: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowRef,
          /* harmony export */ ssrContextKey: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey,
          /* harmony export */ ssrUtils: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ssrUtils,
          /* harmony export */ stop: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.stop,
          /* harmony export */ toDisplayString: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toDisplayString,
          /* harmony export */ toHandlerKey: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey,
          /* harmony export */ toHandlers: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toHandlers,
          /* harmony export */ toRaw: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRaw,
          /* harmony export */ toRef: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRef,
          /* harmony export */ toRefs: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRefs,
          /* harmony export */ transformVNodeArgs: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs,
          /* harmony export */ triggerRef: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.triggerRef,
          /* harmony export */ unref: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.unref,
          /* harmony export */ useAttrs: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useAttrs,
          /* harmony export */ useSSRContext: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useSSRContext,
          /* harmony export */ useSlots: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useSlots,
          /* harmony export */ useTransitionState: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTransitionState,
          /* harmony export */ version: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.version,
          /* harmony export */ warn: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn,
          /* harmony export */ watch: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watch,
          /* harmony export */ watchEffect: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchEffect,
          /* harmony export */ watchPostEffect: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect,
          /* harmony export */ watchSyncEffect: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchSyncEffect,
          /* harmony export */ withAsyncContext: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withAsyncContext,
          /* harmony export */ withCtx: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withCtx,
          /* harmony export */ withDefaults: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withDefaults,
          /* harmony export */ withDirectives: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withDirectives,
          /* harmony export */ withMemo: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withMemo,
          /* harmony export */ withScopeId: () =>
            /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withScopeId,
          /* harmony export */ Transition: () => /* binding */ Transition,
          /* harmony export */ TransitionGroup: () =>
            /* binding */ TransitionGroup,
          /* harmony export */ VueElement: () => /* binding */ VueElement,
          /* harmony export */ createApp: () => /* binding */ createApp,
          /* harmony export */ createSSRApp: () => /* binding */ createSSRApp,
          /* harmony export */ defineCustomElement: () =>
            /* binding */ defineCustomElement,
          /* harmony export */ defineSSRCustomElement: () =>
            /* binding */ defineSSRCustomElement,
          /* harmony export */ hydrate: () => /* binding */ hydrate,
          /* harmony export */ initDirectivesForSSR: () =>
            /* binding */ initDirectivesForSSR,
          /* harmony export */ render: () => /* binding */ render,
          /* harmony export */ useCssModule: () => /* binding */ useCssModule,
          /* harmony export */ useCssVars: () => /* binding */ useCssVars,
          /* harmony export */ vModelCheckbox: () =>
            /* binding */ vModelCheckbox,
          /* harmony export */ vModelDynamic: () => /* binding */ vModelDynamic,
          /* harmony export */ vModelRadio: () => /* binding */ vModelRadio,
          /* harmony export */ vModelSelect: () => /* binding */ vModelSelect,
          /* harmony export */ vModelText: () => /* binding */ vModelText,
          /* harmony export */ vShow: () => /* binding */ vShow,
          /* harmony export */ withKeys: () => /* binding */ withKeys,
          /* harmony export */ withModifiers: () => /* binding */ withModifiers,
          /* harmony export */
        });
        /* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! @vue/shared */ './node_modules/@vue/shared/dist/shared.esm-bundler.js'
          );
        /* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! @vue/runtime-core */ './node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js'
          );
        /* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! @vue/runtime-core */ './node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js'
          );

        const svgNS = 'http://www.w3.org/2000/svg';
        const doc = typeof document !== 'undefined' ? document : null;
        const templateContainer = doc && doc.createElement('template');
        const nodeOps = {
          insert: (child, parent, anchor) => {
            parent.insertBefore(child, anchor || null);
          },
          remove: (child) => {
            const parent = child.parentNode;
            if (parent) {
              parent.removeChild(child);
            }
          },
          createElement: (tag, isSVG, is, props) => {
            const el = isSVG
              ? doc.createElementNS(svgNS, tag)
              : doc.createElement(tag, is ? { is } : undefined);
            if (tag === 'select' && props && props.multiple != null) {
              el.setAttribute('multiple', props.multiple);
            }
            return el;
          },
          createText: (text) => doc.createTextNode(text),
          createComment: (text) => doc.createComment(text),
          setText: (node, text) => {
            node.nodeValue = text;
          },
          setElementText: (el, text) => {
            el.textContent = text;
          },
          parentNode: (node) => node.parentNode,
          nextSibling: (node) => node.nextSibling,
          querySelector: (selector) => doc.querySelector(selector),
          setScopeId(el, id) {
            el.setAttribute(id, '');
          },
          cloneNode(el) {
            const cloned = el.cloneNode(true);
            // #3072
            // - in `patchDOMProp`, we store the actual value in the `el._value` property.
            // - normally, elements using `:value` bindings will not be hoisted, but if
            //   the bound value is a constant, e.g. `:value="true"` - they do get
            //   hoisted.
            // - in production, hoisted nodes are cloned when subsequent inserts, but
            //   cloneNode() does not copy the custom property we attached.
            // - This may need to account for other custom DOM properties we attach to
            //   elements in addition to `_value` in the future.
            if (`_value` in el) {
              cloned._value = el._value;
            }
            return cloned;
          },
          // __UNSAFE__
          // Reason: innerHTML.
          // Static content here can only come from compiled templates.
          // As long as the user only uses trusted templates, this is safe.
          insertStaticContent(content, parent, anchor, isSVG, start, end) {
            // <parent> before | first ... last | anchor </parent>
            const before = anchor ? anchor.previousSibling : parent.lastChild;
            // #5308 can only take cached path if:
            // - has a single root node
            // - nextSibling info is still available
            if (start && (start === end || start.nextSibling)) {
              // cached
              while (true) {
                parent.insertBefore(start.cloneNode(true), anchor);
                if (start === end || !(start = start.nextSibling)) break;
              }
            } else {
              // fresh insert
              templateContainer.innerHTML = isSVG
                ? `<svg>${content}</svg>`
                : content;
              const template = templateContainer.content;
              if (isSVG) {
                // remove outer svg wrapper
                const wrapper = template.firstChild;
                while (wrapper.firstChild) {
                  template.appendChild(wrapper.firstChild);
                }
                template.removeChild(wrapper);
              }
              parent.insertBefore(template, anchor);
            }
            return [
              // first
              before ? before.nextSibling : parent.firstChild,
              // last
              anchor ? anchor.previousSibling : parent.lastChild,
            ];
          },
        };

        // compiler should normalize class + :class bindings on the same element
        // into a single binding ['staticClass', dynamic]
        function patchClass(el, value, isSVG) {
          // directly setting className should be faster than setAttribute in theory
          // if this is an element during a transition, take the temporary transition
          // classes into account.
          const transitionClasses = el._vtc;
          if (transitionClasses) {
            value = (
              value ? [value, ...transitionClasses] : [...transitionClasses]
            ).join(' ');
          }
          if (value == null) {
            el.removeAttribute('class');
          } else if (isSVG) {
            el.setAttribute('class', value);
          } else {
            el.className = value;
          }
        }

        function patchStyle(el, prev, next) {
          const style = el.style;
          const isCssString = (0,
          _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(next);
          if (next && !isCssString) {
            for (const key in next) {
              setStyle(style, key, next[key]);
            }
            if (
              prev &&
              !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(prev)
            ) {
              for (const key in prev) {
                if (next[key] == null) {
                  setStyle(style, key, '');
                }
              }
            }
          } else {
            const currentDisplay = style.display;
            if (isCssString) {
              if (prev !== next) {
                style.cssText = next;
              }
            } else if (prev) {
              el.removeAttribute('style');
            }
            // indicates that the `display` of the element is controlled by `v-show`,
            // so we always keep the current `display` value regardless of the `style`
            // value, thus handing over control to `v-show`.
            if ('_vod' in el) {
              style.display = currentDisplay;
            }
          }
        }
        const importantRE = /\s*!important$/;
        function setStyle(style, name, val) {
          if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(val)) {
            val.forEach((v) => setStyle(style, name, v));
          } else {
            if (name.startsWith('--')) {
              // custom property definition
              style.setProperty(name, val);
            } else {
              const prefixed = autoPrefix(style, name);
              if (importantRE.test(val)) {
                // !important
                style.setProperty(
                  (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(
                    prefixed
                  ),
                  val.replace(importantRE, ''),
                  'important'
                );
              } else {
                style[prefixed] = val;
              }
            }
          }
        }
        const prefixes = ['Webkit', 'Moz', 'ms'];
        const prefixCache = {};
        function autoPrefix(style, rawName) {
          const cached = prefixCache[rawName];
          if (cached) {
            return cached;
          }
          let name = (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(
            rawName
          );
          if (name !== 'filter' && name in style) {
            return (prefixCache[rawName] = name);
          }
          name = (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(name);
          for (let i = 0; i < prefixes.length; i++) {
            const prefixed = prefixes[i] + name;
            if (prefixed in style) {
              return (prefixCache[rawName] = prefixed);
            }
          }
          return rawName;
        }

        const xlinkNS = 'http://www.w3.org/1999/xlink';
        function patchAttr(el, key, value, isSVG, instance) {
          if (isSVG && key.startsWith('xlink:')) {
            if (value == null) {
              el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
            } else {
              el.setAttributeNS(xlinkNS, key, value);
            }
          } else {
            // note we are only checking boolean attributes that don't have a
            // corresponding dom prop of the same name here.
            const isBoolean = (0,
            _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSpecialBooleanAttr)(key);
            if (
              value == null ||
              (isBoolean &&
                !(0,
                _vue_shared__WEBPACK_IMPORTED_MODULE_1__.includeBooleanAttr)(
                  value
                ))
            ) {
              el.removeAttribute(key);
            } else {
              el.setAttribute(key, isBoolean ? '' : value);
            }
          }
        }

        // __UNSAFE__
        // functions. The user is responsible for using them with only trusted content.
        function patchDOMProp(
          el,
          key,
          value,
          // the following args are passed only due to potential innerHTML/textContent
          // overriding existing VNodes, in which case the old tree must be properly
          // unmounted.
          prevChildren,
          parentComponent,
          parentSuspense,
          unmountChildren
        ) {
          if (key === 'innerHTML' || key === 'textContent') {
            if (prevChildren) {
              unmountChildren(prevChildren, parentComponent, parentSuspense);
            }
            el[key] = value == null ? '' : value;
            return;
          }
          if (
            key === 'value' &&
            el.tagName !== 'PROGRESS' &&
            // custom elements may use _value internally
            !el.tagName.includes('-')
          ) {
            // store value as _value as well since
            // non-string values will be stringified.
            el._value = value;
            const newValue = value == null ? '' : value;
            if (
              el.value !== newValue ||
              // #4956: always set for OPTION elements because its value falls back to
              // textContent if no value attribute is present. And setting .value for
              // OPTION has no side effect
              el.tagName === 'OPTION'
            ) {
              el.value = newValue;
            }
            if (value == null) {
              el.removeAttribute(key);
            }
            return;
          }
          if (value === '' || value == null) {
            const type = typeof el[key];
            if (type === 'boolean') {
              // e.g. <select multiple> compiles to { multiple: '' }
              el[key] = (0,
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__.includeBooleanAttr)(
                value
              );
              return;
            } else if (value == null && type === 'string') {
              // e.g. <div :id="null">
              el[key] = '';
              el.removeAttribute(key);
              return;
            } else if (type === 'number') {
              // e.g. <img :width="null">
              // the value of some IDL attr must be greater than 0, e.g. input.size = 0 -> error
              try {
                el[key] = 0;
              } catch (_a) {}
              el.removeAttribute(key);
              return;
            }
          }
          // some properties perform value validation and throw
          try {
            el[key] = value;
          } catch (e) {
            if (true) {
              (0, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
                `Failed setting prop "${key}" on <${el.tagName.toLowerCase()}>: ` +
                  `value ${value} is invalid.`,
                e
              );
            }
          }
        }

        // Async edge case fix requires storing an event listener's attach timestamp.
        let _getNow = Date.now;
        let skipTimestampCheck = false;
        if (typeof window !== 'undefined') {
          // Determine what event timestamp the browser is using. Annoyingly, the
          // timestamp can either be hi-res (relative to page load) or low-res
          // (relative to UNIX epoch), so in order to compare time we have to use the
          // same timestamp type when saving the flush timestamp.
          if (_getNow() > document.createEvent('Event').timeStamp) {
            // if the low-res timestamp which is bigger than the event timestamp
            // (which is evaluated AFTER) it means the event is using a hi-res timestamp,
            // and we need to use the hi-res version for event listeners as well.
            _getNow = () => performance.now();
          }
          // #3485: Firefox <= 53 has incorrect Event.timeStamp implementation
          // and does not fire microtasks in between event propagation, so safe to exclude.
          const ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
          skipTimestampCheck = !!(ffMatch && Number(ffMatch[1]) <= 53);
        }
        // To avoid the overhead of repeatedly calling performance.now(), we cache
        // and use the same timestamp for all event listeners attached in the same tick.
        let cachedNow = 0;
        const p = Promise.resolve();
        const reset = () => {
          cachedNow = 0;
        };
        const getNow = () =>
          cachedNow || (p.then(reset), (cachedNow = _getNow()));
        function addEventListener(el, event, handler, options) {
          el.addEventListener(event, handler, options);
        }
        function removeEventListener(el, event, handler, options) {
          el.removeEventListener(event, handler, options);
        }
        function patchEvent(
          el,
          rawName,
          prevValue,
          nextValue,
          instance = null
        ) {
          // vei = vue event invokers
          const invokers = el._vei || (el._vei = {});
          const existingInvoker = invokers[rawName];
          if (nextValue && existingInvoker) {
            // patch
            existingInvoker.value = nextValue;
          } else {
            const [name, options] = parseName(rawName);
            if (nextValue) {
              // add
              const invoker = (invokers[rawName] = createInvoker(
                nextValue,
                instance
              ));
              addEventListener(el, name, invoker, options);
            } else if (existingInvoker) {
              // remove
              removeEventListener(el, name, existingInvoker, options);
              invokers[rawName] = undefined;
            }
          }
        }
        const optionsModifierRE = /(?:Once|Passive|Capture)$/;
        function parseName(name) {
          let options;
          if (optionsModifierRE.test(name)) {
            options = {};
            let m;
            while ((m = name.match(optionsModifierRE))) {
              name = name.slice(0, name.length - m[0].length);
              options[m[0].toLowerCase()] = true;
            }
          }
          return [
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(
              name.slice(2)
            ),
            options,
          ];
        }
        function createInvoker(initialValue, instance) {
          const invoker = (e) => {
            // async edge case #6566: inner click event triggers patch, event handler
            // attached to outer element during patch, and triggered again. This
            // happens because browsers fire microtask ticks between event propagation.
            // the solution is simple: we save the timestamp when a handler is attached,
            // and the handler would only fire if the event passed to it was fired
            // AFTER it was attached.
            const timeStamp = e.timeStamp || _getNow();
            if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {
              (0,
              _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling)(
                patchStopImmediatePropagation(e, invoker.value),
                instance,
                5 /* NATIVE_EVENT_HANDLER */,
                [e]
              );
            }
          };
          invoker.value = initialValue;
          invoker.attached = getNow();
          return invoker;
        }
        function patchStopImmediatePropagation(e, value) {
          if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
            const originalStop = e.stopImmediatePropagation;
            e.stopImmediatePropagation = () => {
              originalStop.call(e);
              e._stopped = true;
            };
            return value.map((fn) => (e) => !e._stopped && fn && fn(e));
          } else {
            return value;
          }
        }

        const nativeOnRE = /^on[a-z]/;
        const patchProp = (
          el,
          key,
          prevValue,
          nextValue,
          isSVG = false,
          prevChildren,
          parentComponent,
          parentSuspense,
          unmountChildren
        ) => {
          if (key === 'class') {
            patchClass(el, nextValue, isSVG);
          } else if (key === 'style') {
            patchStyle(el, prevValue, nextValue);
          } else if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
            // ignore v-model listeners
            if (
              !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(
                key
              )
            ) {
              patchEvent(el, key, prevValue, nextValue, parentComponent);
            }
          } else if (
            key[0] === '.'
              ? ((key = key.slice(1)), true)
              : key[0] === '^'
              ? ((key = key.slice(1)), false)
              : shouldSetAsProp(el, key, nextValue, isSVG)
          ) {
            patchDOMProp(
              el,
              key,
              nextValue,
              prevChildren,
              parentComponent,
              parentSuspense,
              unmountChildren
            );
          } else {
            // special case for <input v-model type="checkbox"> with
            // :true-value & :false-value
            // store value as dom properties since non-string values will be
            // stringified.
            if (key === 'true-value') {
              el._trueValue = nextValue;
            } else if (key === 'false-value') {
              el._falseValue = nextValue;
            }
            patchAttr(el, key, nextValue, isSVG);
          }
        };
        function shouldSetAsProp(el, key, value, isSVG) {
          if (isSVG) {
            // most keys must be set as attribute on svg elements to work
            // ...except innerHTML & textContent
            if (key === 'innerHTML' || key === 'textContent') {
              return true;
            }
            // or native onclick with function values
            if (
              key in el &&
              nativeOnRE.test(key) &&
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)
            ) {
              return true;
            }
            return false;
          }
          // spellcheck and draggable are numerated attrs, however their
          // corresponding DOM properties are actually booleans - this leads to
          // setting it with a string "false" value leading it to be coerced to
          // `true`, so we need to always treat them as attributes.
          // Note that `contentEditable` doesn't have this problem: its DOM
          // property is also enumerated string values.
          if (key === 'spellcheck' || key === 'draggable') {
            return false;
          }
          // #1787, #2840 form property on form elements is readonly and must be set as
          // attribute.
          if (key === 'form') {
            return false;
          }
          // #1526 <input list> must be set as attribute
          if (key === 'list' && el.tagName === 'INPUT') {
            return false;
          }
          // #2766 <textarea type> must be set as attribute
          if (key === 'type' && el.tagName === 'TEXTAREA') {
            return false;
          }
          // native onclick with string value, must be set as attribute
          if (
            nativeOnRE.test(key) &&
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(value)
          ) {
            return false;
          }
          return key in el;
        }

        function defineCustomElement(options, hydate) {
          const Comp = (0,
          _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineComponent)(
            options
          );
          class VueCustomElement extends VueElement {
            constructor(initialProps) {
              super(Comp, initialProps, hydate);
            }
          }
          VueCustomElement.def = Comp;
          return VueCustomElement;
        }
        const defineSSRCustomElement = (options) => {
          // @ts-ignore
          return defineCustomElement(options, hydrate);
        };
        const BaseClass =
          typeof HTMLElement !== 'undefined' ? HTMLElement : class {};
        class VueElement extends BaseClass {
          constructor(_def, _props = {}, hydrate) {
            super();
            this._def = _def;
            this._props = _props;
            /**
             * @internal
             */
            this._instance = null;
            this._connected = false;
            this._resolved = false;
            this._numberProps = null;
            if (this.shadowRoot && hydrate) {
              hydrate(this._createVNode(), this.shadowRoot);
            } else {
              if (true && this.shadowRoot) {
                (0, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
                  `Custom element has pre-rendered declarative shadow root but is not ` +
                    `defined as hydratable. Use \`defineSSRCustomElement\`.`
                );
              }
              this.attachShadow({ mode: 'open' });
            }
          }
          connectedCallback() {
            this._connected = true;
            if (!this._instance) {
              this._resolveDef();
            }
          }
          disconnectedCallback() {
            this._connected = false;
            (0, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => {
              if (!this._connected) {
                render(null, this.shadowRoot);
                this._instance = null;
              }
            });
          }
          /**
           * resolve inner component definition (handle possible async component)
           */
          _resolveDef() {
            if (this._resolved) {
              return;
            }
            this._resolved = true;
            // set initial attrs
            for (let i = 0; i < this.attributes.length; i++) {
              this._setAttr(this.attributes[i].name);
            }
            // watch future attr changes
            new MutationObserver((mutations) => {
              for (const m of mutations) {
                this._setAttr(m.attributeName);
              }
            }).observe(this, { attributes: true });
            const resolve = (def) => {
              const { props, styles } = def;
              const hasOptions = !(0,
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(props);
              const rawKeys = props
                ? hasOptions
                  ? Object.keys(props)
                  : props
                : [];
              // cast Number-type props set before resolve
              let numberProps;
              if (hasOptions) {
                for (const key in this._props) {
                  const opt = props[key];
                  if (opt === Number || (opt && opt.type === Number)) {
                    this._props[key] = (0,
                    _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(
                      this._props[key]
                    );
                    (numberProps || (numberProps = Object.create(null)))[
                      key
                    ] = true;
                  }
                }
              }
              this._numberProps = numberProps;
              // check if there are props set pre-upgrade or connect
              for (const key of Object.keys(this)) {
                if (key[0] !== '_') {
                  this._setProp(key, this[key], true, false);
                }
              }
              // defining getter/setters on prototype
              for (const key of rawKeys.map(
                _vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize
              )) {
                Object.defineProperty(this, key, {
                  get() {
                    return this._getProp(key);
                  },
                  set(val) {
                    this._setProp(key, val);
                  },
                });
              }
              // apply CSS
              this._applyStyles(styles);
              // initial render
              this._update();
            };
            const asyncDef = this._def.__asyncLoader;
            if (asyncDef) {
              asyncDef().then(resolve);
            } else {
              resolve(this._def);
            }
          }
          _setAttr(key) {
            let value = this.getAttribute(key);
            if (this._numberProps && this._numberProps[key]) {
              value = (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(
                value
              );
            }
            this._setProp(
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key),
              value,
              false
            );
          }
          /**
           * @internal
           */
          _getProp(key) {
            return this._props[key];
          }
          /**
           * @internal
           */
          _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
            if (val !== this._props[key]) {
              this._props[key] = val;
              if (shouldUpdate && this._instance) {
                this._update();
              }
              // reflect
              if (shouldReflect) {
                if (val === true) {
                  this.setAttribute(
                    (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(
                      key
                    ),
                    ''
                  );
                } else if (typeof val === 'string' || typeof val === 'number') {
                  this.setAttribute(
                    (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(
                      key
                    ),
                    val + ''
                  );
                } else if (!val) {
                  this.removeAttribute(
                    (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)
                  );
                }
              }
            }
          }
          _update() {
            render(this._createVNode(), this.shadowRoot);
          }
          _createVNode() {
            const vnode = (0,
            _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode)(
              this._def,
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(
                {},
                this._props
              )
            );
            if (!this._instance) {
              vnode.ce = (instance) => {
                this._instance = instance;
                instance.isCE = true;
                // HMR
                if (true) {
                  instance.ceReload = (newStyles) => {
                    // always reset styles
                    if (this._styles) {
                      this._styles.forEach((s) =>
                        this.shadowRoot.removeChild(s)
                      );
                      this._styles.length = 0;
                    }
                    this._applyStyles(newStyles);
                    // if this is an async component, ceReload is called from the inner
                    // component so no need to reload the async wrapper
                    if (!this._def.__asyncLoader) {
                      // reload
                      this._instance = null;
                      this._update();
                    }
                  };
                }
                // intercept emit
                instance.emit = (event, ...args) => {
                  this.dispatchEvent(
                    new CustomEvent(event, {
                      detail: args,
                    })
                  );
                };
                // locate nearest Vue custom element parent for provide/inject
                let parent = this;
                while (
                  (parent = parent && (parent.parentNode || parent.host))
                ) {
                  if (parent instanceof VueElement) {
                    instance.parent = parent._instance;
                    break;
                  }
                }
              };
            }
            return vnode;
          }
          _applyStyles(styles) {
            if (styles) {
              styles.forEach((css) => {
                const s = document.createElement('style');
                s.textContent = css;
                this.shadowRoot.appendChild(s);
                // record for HMR
                if (true) {
                  (this._styles || (this._styles = [])).push(s);
                }
              });
            }
          }
        }

        function useCssModule(name = '$style') {
          /* istanbul ignore else */
          {
            const instance = (0,
            _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
            if (!instance) {
              true &&
                (0, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
                  `useCssModule must be called inside setup()`
                );
              return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
            }
            const modules = instance.type.__cssModules;
            if (!modules) {
              true &&
                (0, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
                  `Current instance does not have CSS modules injected.`
                );
              return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
            }
            const mod = modules[name];
            if (!mod) {
              true &&
                (0, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
                  `Current instance does not have CSS module named "${name}".`
                );
              return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
            }
            return mod;
          }
        }

        /**
         * Runtime helper for SFC's CSS variable injection feature.
         * @private
         */
        function useCssVars(getter) {
          const instance = (0,
          _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
          /* istanbul ignore next */
          if (!instance) {
            true &&
              (0, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
                `useCssVars is called without current active component instance.`
              );
            return;
          }
          const setVars = () =>
            setVarsOnVNode(instance.subTree, getter(instance.proxy));
          (0, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect)(
            setVars
          );
          (0, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
            const ob = new MutationObserver(setVars);
            ob.observe(instance.subTree.el.parentNode, { childList: true });
            (0, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(
              () => ob.disconnect()
            );
          });
        }
        function setVarsOnVNode(vnode, vars) {
          if (vnode.shapeFlag & 128 /* SUSPENSE */) {
            const suspense = vnode.suspense;
            vnode = suspense.activeBranch;
            if (suspense.pendingBranch && !suspense.isHydrating) {
              suspense.effects.push(() => {
                setVarsOnVNode(suspense.activeBranch, vars);
              });
            }
          }
          // drill down HOCs until it's a non-component vnode
          while (vnode.component) {
            vnode = vnode.component.subTree;
          }
          if (vnode.shapeFlag & 1 /* ELEMENT */ && vnode.el) {
            setVarsOnNode(vnode.el, vars);
          } else if (
            vnode.type ===
            _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment
          ) {
            vnode.children.forEach((c) => setVarsOnVNode(c, vars));
          } else if (
            vnode.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Static
          ) {
            let { el, anchor } = vnode;
            while (el) {
              setVarsOnNode(el, vars);
              if (el === anchor) break;
              el = el.nextSibling;
            }
          }
        }
        function setVarsOnNode(el, vars) {
          if (el.nodeType === 1) {
            const style = el.style;
            for (const key in vars) {
              style.setProperty(`--${key}`, vars[key]);
            }
          }
        }

        const TRANSITION = 'transition';
        const ANIMATION = 'animation';
        // DOM Transition is a higher-order-component based on the platform-agnostic
        // base Transition component, with DOM-specific logic.
        const Transition = (props, { slots }) =>
          (0, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h)(
            _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition,
            resolveTransitionProps(props),
            slots
          );
        Transition.displayName = 'Transition';
        const DOMTransitionPropsValidators = {
          name: String,
          type: String,
          css: {
            type: Boolean,
            default: true,
          },
          duration: [String, Number, Object],
          enterFromClass: String,
          enterActiveClass: String,
          enterToClass: String,
          appearFromClass: String,
          appearActiveClass: String,
          appearToClass: String,
          leaveFromClass: String,
          leaveActiveClass: String,
          leaveToClass: String,
        };
        const TransitionPropsValidators = (Transition.props = /*#__PURE__*/ (0,
        _vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(
          {},
          _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition.props,
          DOMTransitionPropsValidators
        ));
        /**
         * #3227 Incoming hooks may be merged into arrays when wrapping Transition
         * with custom HOCs.
         */
        const callHook = (hook, args = []) => {
          if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {
            hook.forEach((h) => h(...args));
          } else if (hook) {
            hook(...args);
          }
        };
        /**
         * Check if a hook expects a callback (2nd arg), which means the user
         * intends to explicitly control the end of the transition.
         */
        const hasExplicitCallback = (hook) => {
          return hook
            ? (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)
              ? hook.some((h) => h.length > 1)
              : hook.length > 1
            : false;
        };
        function resolveTransitionProps(rawProps) {
          const baseProps = {};
          for (const key in rawProps) {
            if (!(key in DOMTransitionPropsValidators)) {
              baseProps[key] = rawProps[key];
            }
          }
          if (rawProps.css === false) {
            return baseProps;
          }
          const {
            name = 'v',
            type,
            duration,
            enterFromClass = `${name}-enter-from`,
            enterActiveClass = `${name}-enter-active`,
            enterToClass = `${name}-enter-to`,
            appearFromClass = enterFromClass,
            appearActiveClass = enterActiveClass,
            appearToClass = enterToClass,
            leaveFromClass = `${name}-leave-from`,
            leaveActiveClass = `${name}-leave-active`,
            leaveToClass = `${name}-leave-to`,
          } = rawProps;
          const durations = normalizeDuration(duration);
          const enterDuration = durations && durations[0];
          const leaveDuration = durations && durations[1];
          const {
            onBeforeEnter,
            onEnter,
            onEnterCancelled,
            onLeave,
            onLeaveCancelled,
            onBeforeAppear = onBeforeEnter,
            onAppear = onEnter,
            onAppearCancelled = onEnterCancelled,
          } = baseProps;
          const finishEnter = (el, isAppear, done) => {
            removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
            removeTransitionClass(
              el,
              isAppear ? appearActiveClass : enterActiveClass
            );
            done && done();
          };
          const finishLeave = (el, done) => {
            removeTransitionClass(el, leaveToClass);
            removeTransitionClass(el, leaveActiveClass);
            done && done();
          };
          const makeEnterHook = (isAppear) => {
            return (el, done) => {
              const hook = isAppear ? onAppear : onEnter;
              const resolve = () => finishEnter(el, isAppear, done);
              callHook(hook, [el, resolve]);
              nextFrame(() => {
                removeTransitionClass(
                  el,
                  isAppear ? appearFromClass : enterFromClass
                );
                addTransitionClass(el, isAppear ? appearToClass : enterToClass);
                if (!hasExplicitCallback(hook)) {
                  whenTransitionEnds(el, type, enterDuration, resolve);
                }
              });
            };
          };
          return (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(
            baseProps,
            {
              onBeforeEnter(el) {
                callHook(onBeforeEnter, [el]);
                addTransitionClass(el, enterFromClass);
                addTransitionClass(el, enterActiveClass);
              },
              onBeforeAppear(el) {
                callHook(onBeforeAppear, [el]);
                addTransitionClass(el, appearFromClass);
                addTransitionClass(el, appearActiveClass);
              },
              onEnter: makeEnterHook(false),
              onAppear: makeEnterHook(true),
              onLeave(el, done) {
                const resolve = () => finishLeave(el, done);
                addTransitionClass(el, leaveFromClass);
                // force reflow so *-leave-from classes immediately take effect (#2593)
                forceReflow();
                addTransitionClass(el, leaveActiveClass);
                nextFrame(() => {
                  removeTransitionClass(el, leaveFromClass);
                  addTransitionClass(el, leaveToClass);
                  if (!hasExplicitCallback(onLeave)) {
                    whenTransitionEnds(el, type, leaveDuration, resolve);
                  }
                });
                callHook(onLeave, [el, resolve]);
              },
              onEnterCancelled(el) {
                finishEnter(el, false);
                callHook(onEnterCancelled, [el]);
              },
              onAppearCancelled(el) {
                finishEnter(el, true);
                callHook(onAppearCancelled, [el]);
              },
              onLeaveCancelled(el) {
                finishLeave(el);
                callHook(onLeaveCancelled, [el]);
              },
            }
          );
        }
        function normalizeDuration(duration) {
          if (duration == null) {
            return null;
          } else if (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(duration)
          ) {
            return [NumberOf(duration.enter), NumberOf(duration.leave)];
          } else {
            const n = NumberOf(duration);
            return [n, n];
          }
        }
        function NumberOf(val) {
          const res = (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(
            val
          );
          if (true) validateDuration(res);
          return res;
        }
        function validateDuration(val) {
          if (typeof val !== 'number') {
            (0, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
              `<transition> explicit duration is not a valid number - ` +
                `got ${JSON.stringify(val)}.`
            );
          } else if (isNaN(val)) {
            (0, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
              `<transition> explicit duration is NaN - ` +
                'the duration expression might be incorrect.'
            );
          }
        }
        function addTransitionClass(el, cls) {
          cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
          (el._vtc || (el._vtc = new Set())).add(cls);
        }
        function removeTransitionClass(el, cls) {
          cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
          const { _vtc } = el;
          if (_vtc) {
            _vtc.delete(cls);
            if (!_vtc.size) {
              el._vtc = undefined;
            }
          }
        }
        function nextFrame(cb) {
          requestAnimationFrame(() => {
            requestAnimationFrame(cb);
          });
        }
        let endId = 0;
        function whenTransitionEnds(
          el,
          expectedType,
          explicitTimeout,
          resolve
        ) {
          const id = (el._endId = ++endId);
          const resolveIfNotStale = () => {
            if (id === el._endId) {
              resolve();
            }
          };
          if (explicitTimeout) {
            return setTimeout(resolveIfNotStale, explicitTimeout);
          }
          const { type, timeout, propCount } = getTransitionInfo(
            el,
            expectedType
          );
          if (!type) {
            return resolve();
          }
          const endEvent = type + 'end';
          let ended = 0;
          const end = () => {
            el.removeEventListener(endEvent, onEnd);
            resolveIfNotStale();
          };
          const onEnd = (e) => {
            if (e.target === el && ++ended >= propCount) {
              end();
            }
          };
          setTimeout(() => {
            if (ended < propCount) {
              end();
            }
          }, timeout + 1);
          el.addEventListener(endEvent, onEnd);
        }
        function getTransitionInfo(el, expectedType) {
          const styles = window.getComputedStyle(el);
          // JSDOM may return undefined for transition properties
          const getStyleProperties = (key) => (styles[key] || '').split(', ');
          const transitionDelays = getStyleProperties(TRANSITION + 'Delay');
          const transitionDurations = getStyleProperties(
            TRANSITION + 'Duration'
          );
          const transitionTimeout = getTimeout(
            transitionDelays,
            transitionDurations
          );
          const animationDelays = getStyleProperties(ANIMATION + 'Delay');
          const animationDurations = getStyleProperties(ANIMATION + 'Duration');
          const animationTimeout = getTimeout(
            animationDelays,
            animationDurations
          );
          let type = null;
          let timeout = 0;
          let propCount = 0;
          /* istanbul ignore if */
          if (expectedType === TRANSITION) {
            if (transitionTimeout > 0) {
              type = TRANSITION;
              timeout = transitionTimeout;
              propCount = transitionDurations.length;
            }
          } else if (expectedType === ANIMATION) {
            if (animationTimeout > 0) {
              type = ANIMATION;
              timeout = animationTimeout;
              propCount = animationDurations.length;
            }
          } else {
            timeout = Math.max(transitionTimeout, animationTimeout);
            type =
              timeout > 0
                ? transitionTimeout > animationTimeout
                  ? TRANSITION
                  : ANIMATION
                : null;
            propCount = type
              ? type === TRANSITION
                ? transitionDurations.length
                : animationDurations.length
              : 0;
          }
          const hasTransform =
            type === TRANSITION &&
            /\b(transform|all)(,|$)/.test(styles[TRANSITION + 'Property']);
          return {
            type,
            timeout,
            propCount,
            hasTransform,
          };
        }
        function getTimeout(delays, durations) {
          while (delays.length < durations.length) {
            delays = delays.concat(delays);
          }
          return Math.max(
            ...durations.map((d, i) => toMs(d) + toMs(delays[i]))
          );
        }
        // Old versions of Chromium (below 61.0.3163.100) formats floating pointer
        // numbers in a locale-dependent way, using a comma instead of a dot.
        // If comma is not replaced with a dot, the input will be rounded down
        // (i.e. acting as a floor function) causing unexpected behaviors
        function toMs(s) {
          return Number(s.slice(0, -1).replace(',', '.')) * 1000;
        }
        // synchronously force layout to put elements into a certain state
        function forceReflow() {
          return document.body.offsetHeight;
        }

        const positionMap = new WeakMap();
        const newPositionMap = new WeakMap();
        const TransitionGroupImpl = {
          name: 'TransitionGroup',
          props: /*#__PURE__*/ (0,
          _vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(
            {},
            TransitionPropsValidators,
            {
              tag: String,
              moveClass: String,
            }
          ),
          setup(props, { slots }) {
            const instance = (0,
            _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
            const state = (0,
            _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTransitionState)();
            let prevChildren;
            let children;
            (0, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated)(
              () => {
                // children is guaranteed to exist after initial render
                if (!prevChildren.length) {
                  return;
                }
                const moveClass =
                  props.moveClass || `${props.name || 'v'}-move`;
                if (
                  !hasCSSTransform(
                    prevChildren[0].el,
                    instance.vnode.el,
                    moveClass
                  )
                ) {
                  return;
                }
                // we divide the work into three loops to avoid mixing DOM reads and writes
                // in each iteration - which helps prevent layout thrashing.
                prevChildren.forEach(callPendingCbs);
                prevChildren.forEach(recordPosition);
                const movedChildren = prevChildren.filter(applyTranslation);
                // force reflow to put everything in position
                forceReflow();
                movedChildren.forEach((c) => {
                  const el = c.el;
                  const style = el.style;
                  addTransitionClass(el, moveClass);
                  style.transform =
                    style.webkitTransform =
                    style.transitionDuration =
                      '';
                  const cb = (el._moveCb = (e) => {
                    if (e && e.target !== el) {
                      return;
                    }
                    if (!e || /transform$/.test(e.propertyName)) {
                      el.removeEventListener('transitionend', cb);
                      el._moveCb = null;
                      removeTransitionClass(el, moveClass);
                    }
                  });
                  el.addEventListener('transitionend', cb);
                });
              }
            );
            return () => {
              const rawProps = (0,
              _vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.toRaw)(props);
              const cssTransitionProps = resolveTransitionProps(rawProps);
              let tag =
                rawProps.tag ||
                _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment;
              prevChildren = children;
              children = slots.default
                ? (0,
                  _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren)(
                    slots.default()
                  )
                : [];
              for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (child.key != null) {
                  (0,
                  _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(
                    child,
                    (0,
                    _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(
                      child,
                      cssTransitionProps,
                      state,
                      instance
                    )
                  );
                } else if (true) {
                  (0, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
                    `<TransitionGroup> children must be keyed.`
                  );
                }
              }
              if (prevChildren) {
                for (let i = 0; i < prevChildren.length; i++) {
                  const child = prevChildren[i];
                  (0,
                  _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(
                    child,
                    (0,
                    _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(
                      child,
                      cssTransitionProps,
                      state,
                      instance
                    )
                  );
                  positionMap.set(child, child.el.getBoundingClientRect());
                }
              }
              return (0,
              _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode)(
                tag,
                null,
                children
              );
            };
          },
        };
        const TransitionGroup = TransitionGroupImpl;
        function callPendingCbs(c) {
          const el = c.el;
          if (el._moveCb) {
            el._moveCb();
          }
          if (el._enterCb) {
            el._enterCb();
          }
        }
        function recordPosition(c) {
          newPositionMap.set(c, c.el.getBoundingClientRect());
        }
        function applyTranslation(c) {
          const oldPos = positionMap.get(c);
          const newPos = newPositionMap.get(c);
          const dx = oldPos.left - newPos.left;
          const dy = oldPos.top - newPos.top;
          if (dx || dy) {
            const s = c.el.style;
            s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
            s.transitionDuration = '0s';
            return c;
          }
        }
        function hasCSSTransform(el, root, moveClass) {
          // Detect whether an element with the move class applied has
          // CSS transitions. Since the element may be inside an entering
          // transition at this very moment, we make a clone of it and remove
          // all other transition classes applied to ensure only the move class
          // is applied.
          const clone = el.cloneNode();
          if (el._vtc) {
            el._vtc.forEach((cls) => {
              cls.split(/\s+/).forEach((c) => c && clone.classList.remove(c));
            });
          }
          moveClass.split(/\s+/).forEach((c) => c && clone.classList.add(c));
          clone.style.display = 'none';
          const container = root.nodeType === 1 ? root : root.parentNode;
          container.appendChild(clone);
          const { hasTransform } = getTransitionInfo(clone);
          container.removeChild(clone);
          return hasTransform;
        }

        const getModelAssigner = (vnode) => {
          const fn = vnode.props['onUpdate:modelValue'];
          return (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn)
            ? (value) =>
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(
                  fn,
                  value
                )
            : fn;
        };
        function onCompositionStart(e) {
          e.target.composing = true;
        }
        function onCompositionEnd(e) {
          const target = e.target;
          if (target.composing) {
            target.composing = false;
            trigger(target, 'input');
          }
        }
        function trigger(el, type) {
          const e = document.createEvent('HTMLEvents');
          e.initEvent(type, true, true);
          el.dispatchEvent(e);
        }
        // We are exporting the v-model runtime directly as vnode hooks so that it can
        // be tree-shaken in case v-model is never used.
        const vModelText = {
          created(el, { modifiers: { lazy, trim, number } }, vnode) {
            el._assign = getModelAssigner(vnode);
            const castToNumber =
              number || (vnode.props && vnode.props.type === 'number');
            addEventListener(el, lazy ? 'change' : 'input', (e) => {
              if (e.target.composing) return;
              let domValue = el.value;
              if (trim) {
                domValue = domValue.trim();
              } else if (castToNumber) {
                domValue = (0,
                _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(domValue);
              }
              el._assign(domValue);
            });
            if (trim) {
              addEventListener(el, 'change', () => {
                el.value = el.value.trim();
              });
            }
            if (!lazy) {
              addEventListener(el, 'compositionstart', onCompositionStart);
              addEventListener(el, 'compositionend', onCompositionEnd);
              // Safari < 10.2 & UIWebView doesn't fire compositionend when
              // switching focus before confirming composition choice
              // this also fixes the issue where some browsers e.g. iOS Chrome
              // fires "change" instead of "input" on autocomplete.
              addEventListener(el, 'change', onCompositionEnd);
            }
          },
          // set value on mounted so it's after min/max for type="range"
          mounted(el, { value }) {
            el.value = value == null ? '' : value;
          },
          beforeUpdate(
            el,
            { value, modifiers: { lazy, trim, number } },
            vnode
          ) {
            el._assign = getModelAssigner(vnode);
            // avoid clearing unresolved text. #2302
            if (el.composing) return;
            if (document.activeElement === el) {
              if (lazy) {
                return;
              }
              if (trim && el.value.trim() === value) {
                return;
              }
              if (
                (number || el.type === 'number') &&
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(
                  el.value
                ) === value
              ) {
                return;
              }
            }
            const newValue = value == null ? '' : value;
            if (el.value !== newValue) {
              el.value = newValue;
            }
          },
        };
        const vModelCheckbox = {
          // #4096 array checkboxes need to be deep traversed
          deep: true,
          created(el, _, vnode) {
            el._assign = getModelAssigner(vnode);
            addEventListener(el, 'change', () => {
              const modelValue = el._modelValue;
              const elementValue = getValue(el);
              const checked = el.checked;
              const assign = el._assign;
              if (
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(
                  modelValue
                )
              ) {
                const index = (0,
                _vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(
                  modelValue,
                  elementValue
                );
                const found = index !== -1;
                if (checked && !found) {
                  assign(modelValue.concat(elementValue));
                } else if (!checked && found) {
                  const filtered = [...modelValue];
                  filtered.splice(index, 1);
                  assign(filtered);
                }
              } else if (
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(modelValue)
              ) {
                const cloned = new Set(modelValue);
                if (checked) {
                  cloned.add(elementValue);
                } else {
                  cloned.delete(elementValue);
                }
                assign(cloned);
              } else {
                assign(getCheckboxValue(el, checked));
              }
            });
          },
          // set initial checked on mount to wait for true-value/false-value
          mounted: setChecked,
          beforeUpdate(el, binding, vnode) {
            el._assign = getModelAssigner(vnode);
            setChecked(el, binding, vnode);
          },
        };
        function setChecked(el, { value, oldValue }, vnode) {
          el._modelValue = value;
          if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
            el.checked =
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(
                value,
                vnode.props.value
              ) > -1;
          } else if (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)
          ) {
            el.checked = value.has(vnode.props.value);
          } else if (value !== oldValue) {
            el.checked = (0,
            _vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(
              value,
              getCheckboxValue(el, true)
            );
          }
        }
        const vModelRadio = {
          created(el, { value }, vnode) {
            el.checked = (0,
            _vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(
              value,
              vnode.props.value
            );
            el._assign = getModelAssigner(vnode);
            addEventListener(el, 'change', () => {
              el._assign(getValue(el));
            });
          },
          beforeUpdate(el, { value, oldValue }, vnode) {
            el._assign = getModelAssigner(vnode);
            if (value !== oldValue) {
              el.checked = (0,
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(
                value,
                vnode.props.value
              );
            }
          },
        };
        const vModelSelect = {
          // <select multiple> value need to be deep traversed
          deep: true,
          created(el, { value, modifiers: { number } }, vnode) {
            const isSetModel = (0,
            _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value);
            addEventListener(el, 'change', () => {
              const selectedVal = Array.prototype.filter
                .call(el.options, (o) => o.selected)
                .map((o) =>
                  number
                    ? (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(
                        getValue(o)
                      )
                    : getValue(o)
                );
              el._assign(
                el.multiple
                  ? isSetModel
                    ? new Set(selectedVal)
                    : selectedVal
                  : selectedVal[0]
              );
            });
            el._assign = getModelAssigner(vnode);
          },
          // set value in mounted & updated because <select> relies on its children
          // <option>s.
          mounted(el, { value }) {
            setSelected(el, value);
          },
          beforeUpdate(el, _binding, vnode) {
            el._assign = getModelAssigner(vnode);
          },
          updated(el, { value }) {
            setSelected(el, value);
          },
        };
        function setSelected(el, value) {
          const isMultiple = el.multiple;
          if (
            isMultiple &&
            !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value) &&
            !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)
          ) {
            true &&
              (0, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
                `<select multiple v-model> expects an Array or Set value for its binding, ` +
                  `but got ${Object.prototype.toString
                    .call(value)
                    .slice(8, -1)}.`
              );
            return;
          }
          for (let i = 0, l = el.options.length; i < l; i++) {
            const option = el.options[i];
            const optionValue = getValue(option);
            if (isMultiple) {
              if (
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)
              ) {
                option.selected =
                  (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(
                    value,
                    optionValue
                  ) > -1;
              } else {
                option.selected = value.has(optionValue);
              }
            } else {
              if (
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(
                  getValue(option),
                  value
                )
              ) {
                if (el.selectedIndex !== i) el.selectedIndex = i;
                return;
              }
            }
          }
          if (!isMultiple && el.selectedIndex !== -1) {
            el.selectedIndex = -1;
          }
        }
        // retrieve raw value set via :value bindings
        function getValue(el) {
          return '_value' in el ? el._value : el.value;
        }
        // retrieve raw value for true-value and false-value set via :true-value or :false-value bindings
        function getCheckboxValue(el, checked) {
          const key = checked ? '_trueValue' : '_falseValue';
          return key in el ? el[key] : checked;
        }
        const vModelDynamic = {
          created(el, binding, vnode) {
            callModelHook(el, binding, vnode, null, 'created');
          },
          mounted(el, binding, vnode) {
            callModelHook(el, binding, vnode, null, 'mounted');
          },
          beforeUpdate(el, binding, vnode, prevVNode) {
            callModelHook(el, binding, vnode, prevVNode, 'beforeUpdate');
          },
          updated(el, binding, vnode, prevVNode) {
            callModelHook(el, binding, vnode, prevVNode, 'updated');
          },
        };
        function callModelHook(el, binding, vnode, prevVNode, hook) {
          let modelToUse;
          switch (el.tagName) {
            case 'SELECT':
              modelToUse = vModelSelect;
              break;
            case 'TEXTAREA':
              modelToUse = vModelText;
              break;
            default:
              switch (vnode.props && vnode.props.type) {
                case 'checkbox':
                  modelToUse = vModelCheckbox;
                  break;
                case 'radio':
                  modelToUse = vModelRadio;
                  break;
                default:
                  modelToUse = vModelText;
              }
          }
          const fn = modelToUse[hook];
          fn && fn(el, binding, vnode, prevVNode);
        }
        // SSR vnode transforms, only used when user includes client-oriented render
        // function in SSR
        function initVModelForSSR() {
          vModelText.getSSRProps = ({ value }) => ({ value });
          vModelRadio.getSSRProps = ({ value }, vnode) => {
            if (
              vnode.props &&
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(
                vnode.props.value,
                value
              )
            ) {
              return { checked: true };
            }
          };
          vModelCheckbox.getSSRProps = ({ value }, vnode) => {
            if ((0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
              if (
                vnode.props &&
                (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(
                  value,
                  vnode.props.value
                ) > -1
              ) {
                return { checked: true };
              }
            } else if (
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)
            ) {
              if (vnode.props && value.has(vnode.props.value)) {
                return { checked: true };
              }
            } else if (value) {
              return { checked: true };
            }
          };
        }

        const systemModifiers = ['ctrl', 'shift', 'alt', 'meta'];
        const modifierGuards = {
          stop: (e) => e.stopPropagation(),
          prevent: (e) => e.preventDefault(),
          self: (e) => e.target !== e.currentTarget,
          ctrl: (e) => !e.ctrlKey,
          shift: (e) => !e.shiftKey,
          alt: (e) => !e.altKey,
          meta: (e) => !e.metaKey,
          left: (e) => 'button' in e && e.button !== 0,
          middle: (e) => 'button' in e && e.button !== 1,
          right: (e) => 'button' in e && e.button !== 2,
          exact: (e, modifiers) =>
            systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m)),
        };
        /**
         * @private
         */
        const withModifiers = (fn, modifiers) => {
          return (event, ...args) => {
            for (let i = 0; i < modifiers.length; i++) {
              const guard = modifierGuards[modifiers[i]];
              if (guard && guard(event, modifiers)) return;
            }
            return fn(event, ...args);
          };
        };
        // Kept for 2.x compat.
        // Note: IE11 compat for `spacebar` and `del` is removed for now.
        const keyNames = {
          esc: 'escape',
          space: ' ',
          up: 'arrow-up',
          left: 'arrow-left',
          right: 'arrow-right',
          down: 'arrow-down',
          delete: 'backspace',
        };
        /**
         * @private
         */
        const withKeys = (fn, modifiers) => {
          return (event) => {
            if (!('key' in event)) {
              return;
            }
            const eventKey = (0,
            _vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event.key);
            if (
              modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)
            ) {
              return fn(event);
            }
          };
        };

        const vShow = {
          beforeMount(el, { value }, { transition }) {
            el._vod = el.style.display === 'none' ? '' : el.style.display;
            if (transition && value) {
              transition.beforeEnter(el);
            } else {
              setDisplay(el, value);
            }
          },
          mounted(el, { value }, { transition }) {
            if (transition && value) {
              transition.enter(el);
            }
          },
          updated(el, { value, oldValue }, { transition }) {
            if (!value === !oldValue) return;
            if (transition) {
              if (value) {
                transition.beforeEnter(el);
                setDisplay(el, true);
                transition.enter(el);
              } else {
                transition.leave(el, () => {
                  setDisplay(el, false);
                });
              }
            } else {
              setDisplay(el, value);
            }
          },
          beforeUnmount(el, { value }) {
            setDisplay(el, value);
          },
        };
        function setDisplay(el, value) {
          el.style.display = value ? el._vod : 'none';
        }
        // SSR vnode transforms, only used when user includes client-oriented render
        // function in SSR
        function initVShowForSSR() {
          vShow.getSSRProps = ({ value }) => {
            if (!value) {
              return { style: { display: 'none' } };
            }
          };
        }

        const rendererOptions = (0,
        _vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(
          { patchProp },
          nodeOps
        );
        // lazy create the renderer - this makes core renderer logic tree-shakable
        // in case the user only imports reactivity utilities from Vue.
        let renderer;
        let enabledHydration = false;
        function ensureRenderer() {
          return (
            renderer ||
            (renderer = (0,
            _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createRenderer)(
              rendererOptions
            ))
          );
        }
        function ensureHydrationRenderer() {
          renderer = enabledHydration
            ? renderer
            : (0,
              _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer)(
                rendererOptions
              );
          enabledHydration = true;
          return renderer;
        }
        // use explicit type casts here to avoid import() calls in rolled-up d.ts
        const render = (...args) => {
          ensureRenderer().render(...args);
        };
        const hydrate = (...args) => {
          ensureHydrationRenderer().hydrate(...args);
        };
        const createApp = (...args) => {
          const app = ensureRenderer().createApp(...args);
          if (true) {
            injectNativeTagCheck(app);
            injectCompilerOptionsCheck(app);
          }
          const { mount } = app;
          app.mount = (containerOrSelector) => {
            const container = normalizeContainer(containerOrSelector);
            if (!container) return;
            const component = app._component;
            if (
              !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(
                component
              ) &&
              !component.render &&
              !component.template
            ) {
              // __UNSAFE__
              // Reason: potential execution of JS expressions in in-DOM template.
              // The user must make sure the in-DOM template is trusted. If it's
              // rendered by the server, the template should not contain any user data.
              component.template = container.innerHTML;
            }
            // clear content before mounting
            container.innerHTML = '';
            const proxy = mount(
              container,
              false,
              container instanceof SVGElement
            );
            if (container instanceof Element) {
              container.removeAttribute('v-cloak');
              container.setAttribute('data-v-app', '');
            }
            return proxy;
          };
          return app;
        };
        const createSSRApp = (...args) => {
          const app = ensureHydrationRenderer().createApp(...args);
          if (true) {
            injectNativeTagCheck(app);
            injectCompilerOptionsCheck(app);
          }
          const { mount } = app;
          app.mount = (containerOrSelector) => {
            const container = normalizeContainer(containerOrSelector);
            if (container) {
              return mount(container, true, container instanceof SVGElement);
            }
          };
          return app;
        };
        function injectNativeTagCheck(app) {
          // Inject `isNativeTag`
          // this is used for component name validation (dev only)
          Object.defineProperty(app.config, 'isNativeTag', {
            value: (tag) =>
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isHTMLTag)(tag) ||
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSVGTag)(tag),
            writable: false,
          });
        }
        // dev only
        function injectCompilerOptionsCheck(app) {
          if (
            (0, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly)()
          ) {
            const isCustomElement = app.config.isCustomElement;
            Object.defineProperty(app.config, 'isCustomElement', {
              get() {
                return isCustomElement;
              },
              set() {
                (0, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
                  `The \`isCustomElement\` config option is deprecated. Use ` +
                    `\`compilerOptions.isCustomElement\` instead.`
                );
              },
            });
            const compilerOptions = app.config.compilerOptions;
            const msg =
              `The \`compilerOptions\` config option is only respected when using ` +
              `a build of Vue.js that includes the runtime compiler (aka "full build"). ` +
              `Since you are using the runtime-only build, \`compilerOptions\` ` +
              `must be passed to \`@vue/compiler-dom\` in the build setup instead.\n` +
              `- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.\n` +
              `- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n` +
              `- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`;
            Object.defineProperty(app.config, 'compilerOptions', {
              get() {
                (0, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(msg);
                return compilerOptions;
              },
              set() {
                (0, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(msg);
              },
            });
          }
        }
        function normalizeContainer(container) {
          if (
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(container)
          ) {
            const res = document.querySelector(container);
            if (true && !res) {
              (0, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
                `Failed to mount app: mount target selector "${container}" returned null.`
              );
            }
            return res;
          }
          if (
            true &&
            window.ShadowRoot &&
            container instanceof window.ShadowRoot &&
            container.mode === 'closed'
          ) {
            (0, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
              `mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`
            );
          }
          return container;
        }
        let ssrDirectiveInitialized = false;
        /**
         * @internal
         */
        const initDirectivesForSSR = () => {
          if (!ssrDirectiveInitialized) {
            ssrDirectiveInitialized = true;
            initVModelForSSR();
            initVShowForSSR();
          }
        };

        /***/
      },

    /***/ './node_modules/@vue/shared/dist/shared.esm-bundler.js':
      /*!*************************************************************!*\
  !*** ./node_modules/@vue/shared/dist/shared.esm-bundler.js ***!
  \*************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ EMPTY_ARR: () => /* binding */ EMPTY_ARR,
          /* harmony export */ EMPTY_OBJ: () => /* binding */ EMPTY_OBJ,
          /* harmony export */ NO: () => /* binding */ NO,
          /* harmony export */ NOOP: () => /* binding */ NOOP,
          /* harmony export */ PatchFlagNames: () =>
            /* binding */ PatchFlagNames,
          /* harmony export */ camelize: () => /* binding */ camelize,
          /* harmony export */ capitalize: () => /* binding */ capitalize,
          /* harmony export */ def: () => /* binding */ def,
          /* harmony export */ escapeHtml: () => /* binding */ escapeHtml,
          /* harmony export */ escapeHtmlComment: () =>
            /* binding */ escapeHtmlComment,
          /* harmony export */ extend: () => /* binding */ extend,
          /* harmony export */ generateCodeFrame: () =>
            /* binding */ generateCodeFrame,
          /* harmony export */ getGlobalThis: () => /* binding */ getGlobalThis,
          /* harmony export */ hasChanged: () => /* binding */ hasChanged,
          /* harmony export */ hasOwn: () => /* binding */ hasOwn,
          /* harmony export */ hyphenate: () => /* binding */ hyphenate,
          /* harmony export */ includeBooleanAttr: () =>
            /* binding */ includeBooleanAttr,
          /* harmony export */ invokeArrayFns: () =>
            /* binding */ invokeArrayFns,
          /* harmony export */ isArray: () => /* binding */ isArray,
          /* harmony export */ isBooleanAttr: () => /* binding */ isBooleanAttr,
          /* harmony export */ isBuiltInDirective: () =>
            /* binding */ isBuiltInDirective,
          /* harmony export */ isDate: () => /* binding */ isDate,
          /* harmony export */ isFunction: () => /* binding */ isFunction,
          /* harmony export */ isGloballyWhitelisted: () =>
            /* binding */ isGloballyWhitelisted,
          /* harmony export */ isHTMLTag: () => /* binding */ isHTMLTag,
          /* harmony export */ isIntegerKey: () => /* binding */ isIntegerKey,
          /* harmony export */ isKnownHtmlAttr: () =>
            /* binding */ isKnownHtmlAttr,
          /* harmony export */ isKnownSvgAttr: () =>
            /* binding */ isKnownSvgAttr,
          /* harmony export */ isMap: () => /* binding */ isMap,
          /* harmony export */ isModelListener: () =>
            /* binding */ isModelListener,
          /* harmony export */ isNoUnitNumericStyleProp: () =>
            /* binding */ isNoUnitNumericStyleProp,
          /* harmony export */ isObject: () => /* binding */ isObject,
          /* harmony export */ isOn: () => /* binding */ isOn,
          /* harmony export */ isPlainObject: () => /* binding */ isPlainObject,
          /* harmony export */ isPromise: () => /* binding */ isPromise,
          /* harmony export */ isReservedProp: () =>
            /* binding */ isReservedProp,
          /* harmony export */ isSSRSafeAttrName: () =>
            /* binding */ isSSRSafeAttrName,
          /* harmony export */ isSVGTag: () => /* binding */ isSVGTag,
          /* harmony export */ isSet: () => /* binding */ isSet,
          /* harmony export */ isSpecialBooleanAttr: () =>
            /* binding */ isSpecialBooleanAttr,
          /* harmony export */ isString: () => /* binding */ isString,
          /* harmony export */ isSymbol: () => /* binding */ isSymbol,
          /* harmony export */ isVoidTag: () => /* binding */ isVoidTag,
          /* harmony export */ looseEqual: () => /* binding */ looseEqual,
          /* harmony export */ looseIndexOf: () => /* binding */ looseIndexOf,
          /* harmony export */ makeMap: () => /* binding */ makeMap,
          /* harmony export */ normalizeClass: () =>
            /* binding */ normalizeClass,
          /* harmony export */ normalizeProps: () =>
            /* binding */ normalizeProps,
          /* harmony export */ normalizeStyle: () =>
            /* binding */ normalizeStyle,
          /* harmony export */ objectToString: () =>
            /* binding */ objectToString,
          /* harmony export */ parseStringStyle: () =>
            /* binding */ parseStringStyle,
          /* harmony export */ propsToAttrMap: () =>
            /* binding */ propsToAttrMap,
          /* harmony export */ remove: () => /* binding */ remove,
          /* harmony export */ slotFlagsText: () => /* binding */ slotFlagsText,
          /* harmony export */ stringifyStyle: () =>
            /* binding */ stringifyStyle,
          /* harmony export */ toDisplayString: () =>
            /* binding */ toDisplayString,
          /* harmony export */ toHandlerKey: () => /* binding */ toHandlerKey,
          /* harmony export */ toNumber: () => /* binding */ toNumber,
          /* harmony export */ toRawType: () => /* binding */ toRawType,
          /* harmony export */ toTypeString: () => /* binding */ toTypeString,
          /* harmony export */
        });
        /**
         * Make a map and return a function for checking if a key
         * is in that map.
         * IMPORTANT: all calls of this function must be prefixed with
         * \/\*#\_\_PURE\_\_\*\/
         * So that rollup can tree-shake them if necessary.
         */
        function makeMap(str, expectsLowerCase) {
          const map = Object.create(null);
          const list = str.split(',');
          for (let i = 0; i < list.length; i++) {
            map[list[i]] = true;
          }
          return expectsLowerCase
            ? (val) => !!map[val.toLowerCase()]
            : (val) => !!map[val];
        }

        /**
         * dev only flag -> name mapping
         */
        const PatchFlagNames = {
          [1 /* TEXT */]: `TEXT`,
          [2 /* CLASS */]: `CLASS`,
          [4 /* STYLE */]: `STYLE`,
          [8 /* PROPS */]: `PROPS`,
          [16 /* FULL_PROPS */]: `FULL_PROPS`,
          [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,
          [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,
          [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,
          [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,
          [512 /* NEED_PATCH */]: `NEED_PATCH`,
          [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,
          [2048 /* DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,
          [-1 /* HOISTED */]: `HOISTED`,
          [-2 /* BAIL */]: `BAIL`,
        };

        /**
         * Dev only
         */
        const slotFlagsText = {
          [1 /* STABLE */]: 'STABLE',
          [2 /* DYNAMIC */]: 'DYNAMIC',
          [3 /* FORWARDED */]: 'FORWARDED',
        };

        const GLOBALS_WHITE_LISTED =
          'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +
          'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +
          'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';
        const isGloballyWhitelisted =
          /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);

        const range = 2;
        function generateCodeFrame(source, start = 0, end = source.length) {
          // Split the content into individual lines but capture the newline sequence
          // that separated each line. This is important because the actual sequence is
          // needed to properly take into account the full line length for offset
          // comparison
          let lines = source.split(/(\r?\n)/);
          // Separate the lines and newline sequences into separate arrays for easier referencing
          const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
          lines = lines.filter((_, idx) => idx % 2 === 0);
          let count = 0;
          const res = [];
          for (let i = 0; i < lines.length; i++) {
            count +=
              lines[i].length +
              ((newlineSequences[i] && newlineSequences[i].length) || 0);
            if (count >= start) {
              for (let j = i - range; j <= i + range || end > count; j++) {
                if (j < 0 || j >= lines.length) continue;
                const line = j + 1;
                res.push(
                  `${line}${' '.repeat(
                    Math.max(3 - String(line).length, 0)
                  )}|  ${lines[j]}`
                );
                const lineLength = lines[j].length;
                const newLineSeqLength =
                  (newlineSequences[j] && newlineSequences[j].length) || 0;
                if (j === i) {
                  // push underline
                  const pad = start - (count - (lineLength + newLineSeqLength));
                  const length = Math.max(
                    1,
                    end > count ? lineLength - pad : end - start
                  );
                  res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));
                } else if (j > i) {
                  if (end > count) {
                    const length = Math.max(
                      Math.min(end - count, lineLength),
                      1
                    );
                    res.push(`   |  ` + '^'.repeat(length));
                  }
                  count += lineLength + newLineSeqLength;
                }
              }
              break;
            }
          }
          return res.join('\n');
        }

        /**
         * On the client we only need to offer special cases for boolean attributes that
         * have different names from their corresponding dom properties:
         * - itemscope -> N/A
         * - allowfullscreen -> allowFullscreen
         * - formnovalidate -> formNoValidate
         * - ismap -> isMap
         * - nomodule -> noModule
         * - novalidate -> noValidate
         * - readonly -> readOnly
         */
        const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
        const isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);
        /**
         * The full list is needed during SSR to produce the correct initial markup.
         */
        const isBooleanAttr = /*#__PURE__*/ makeMap(
          specialBooleanAttrs +
            `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +
            `loop,open,required,reversed,scoped,seamless,` +
            `checked,muted,multiple,selected`
        );
        /**
         * Boolean attributes should be included if the value is truthy or ''.
         * e.g. `<select multiple>` compiles to `{ multiple: '' }`
         */
        function includeBooleanAttr(value) {
          return !!value || value === '';
        }
        const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
        const attrValidationCache = {};
        function isSSRSafeAttrName(name) {
          if (attrValidationCache.hasOwnProperty(name)) {
            return attrValidationCache[name];
          }
          const isUnsafe = unsafeAttrCharRE.test(name);
          if (isUnsafe) {
            console.error(`unsafe attribute name: ${name}`);
          }
          return (attrValidationCache[name] = !isUnsafe);
        }
        const propsToAttrMap = {
          acceptCharset: 'accept-charset',
          className: 'class',
          htmlFor: 'for',
          httpEquiv: 'http-equiv',
        };
        /**
         * CSS properties that accept plain numbers
         */
        const isNoUnitNumericStyleProp = /*#__PURE__*/ makeMap(
          `animation-iteration-count,border-image-outset,border-image-slice,` +
            `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +
            `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +
            `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +
            `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +
            `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +
            // SVG
            `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +
            `stroke-miterlimit,stroke-opacity,stroke-width`
        );
        /**
         * Known attributes, this is used for stringification of runtime static nodes
         * so that we don't stringify bindings that cannot be set from HTML.
         * Don't also forget to allow `data-*` and `aria-*`!
         * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
         */
        const isKnownHtmlAttr = /*#__PURE__*/ makeMap(
          `accept,accept-charset,accesskey,action,align,allow,alt,async,` +
            `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +
            `border,buffered,capture,challenge,charset,checked,cite,class,code,` +
            `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +
            `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +
            `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +
            `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +
            `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +
            `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +
            `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +
            `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +
            `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +
            `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +
            `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +
            `value,width,wrap`
        );
        /**
         * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute
         */
        const isKnownSvgAttr = /*#__PURE__*/ makeMap(
          `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` +
            `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` +
            `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` +
            `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` +
            `color-interpolation-filters,color-profile,color-rendering,` +
            `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` +
            `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` +
            `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` +
            `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` +
            `font-family,font-size,font-size-adjust,font-stretch,font-style,` +
            `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` +
            `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` +
            `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` +
            `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` +
            `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` +
            `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` +
            `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` +
            `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` +
            `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` +
            `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` +
            `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` +
            `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` +
            `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` +
            `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` +
            `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` +
            `specularConstant,specularExponent,speed,spreadMethod,startOffset,` +
            `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` +
            `strikethrough-position,strikethrough-thickness,string,stroke,` +
            `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` +
            `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` +
            `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` +
            `text-decoration,text-rendering,textLength,to,transform,transform-origin,` +
            `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` +
            `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` +
            `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` +
            `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` +
            `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` +
            `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` +
            `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`
        );

        function normalizeStyle(value) {
          if (isArray(value)) {
            const res = {};
            for (let i = 0; i < value.length; i++) {
              const item = value[i];
              const normalized = isString(item)
                ? parseStringStyle(item)
                : normalizeStyle(item);
              if (normalized) {
                for (const key in normalized) {
                  res[key] = normalized[key];
                }
              }
            }
            return res;
          } else if (isString(value)) {
            return value;
          } else if (isObject(value)) {
            return value;
          }
        }
        const listDelimiterRE = /;(?![^(]*\))/g;
        const propertyDelimiterRE = /:(.+)/;
        function parseStringStyle(cssText) {
          const ret = {};
          cssText.split(listDelimiterRE).forEach((item) => {
            if (item) {
              const tmp = item.split(propertyDelimiterRE);
              tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
            }
          });
          return ret;
        }
        function stringifyStyle(styles) {
          let ret = '';
          if (!styles || isString(styles)) {
            return ret;
          }
          for (const key in styles) {
            const value = styles[key];
            const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
            if (
              isString(value) ||
              (typeof value === 'number' &&
                isNoUnitNumericStyleProp(normalizedKey))
            ) {
              // only render valid values
              ret += `${normalizedKey}:${value};`;
            }
          }
          return ret;
        }
        function normalizeClass(value) {
          let res = '';
          if (isString(value)) {
            res = value;
          } else if (isArray(value)) {
            for (let i = 0; i < value.length; i++) {
              const normalized = normalizeClass(value[i]);
              if (normalized) {
                res += normalized + ' ';
              }
            }
          } else if (isObject(value)) {
            for (const name in value) {
              if (value[name]) {
                res += name + ' ';
              }
            }
          }
          return res.trim();
        }
        function normalizeProps(props) {
          if (!props) return null;
          let { class: klass, style } = props;
          if (klass && !isString(klass)) {
            props.class = normalizeClass(klass);
          }
          if (style) {
            props.style = normalizeStyle(style);
          }
          return props;
        }

        // These tag configs are shared between compiler-dom and runtime-dom, so they
        // https://developer.mozilla.org/en-US/docs/Web/HTML/Element
        const HTML_TAGS =
          'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +
          'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +
          'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +
          'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +
          'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +
          'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +
          'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +
          'option,output,progress,select,textarea,details,dialog,menu,' +
          'summary,template,blockquote,iframe,tfoot';
        // https://developer.mozilla.org/en-US/docs/Web/SVG/Element
        const SVG_TAGS =
          'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +
          'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +
          'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +
          'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +
          'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +
          'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +
          'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +
          'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +
          'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +
          'text,textPath,title,tspan,unknown,use,view';
        const VOID_TAGS =
          'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';
        /**
         * Compiler only.
         * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
         */
        const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);
        /**
         * Compiler only.
         * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
         */
        const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);
        /**
         * Compiler only.
         * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
         */
        const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);

        const escapeRE = /["'&<>]/;
        function escapeHtml(string) {
          const str = '' + string;
          const match = escapeRE.exec(str);
          if (!match) {
            return str;
          }
          let html = '';
          let escaped;
          let index;
          let lastIndex = 0;
          for (index = match.index; index < str.length; index++) {
            switch (str.charCodeAt(index)) {
              case 34: // "
                escaped = '&quot;';
                break;
              case 38: // &
                escaped = '&amp;';
                break;
              case 39: // '
                escaped = '&#39;';
                break;
              case 60: // <
                escaped = '&lt;';
                break;
              case 62: // >
                escaped = '&gt;';
                break;
              default:
                continue;
            }
            if (lastIndex !== index) {
              html += str.slice(lastIndex, index);
            }
            lastIndex = index + 1;
            html += escaped;
          }
          return lastIndex !== index
            ? html + str.slice(lastIndex, index)
            : html;
        }
        // https://www.w3.org/TR/html52/syntax.html#comments
        const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
        function escapeHtmlComment(src) {
          return src.replace(commentStripRE, '');
        }

        function looseCompareArrays(a, b) {
          if (a.length !== b.length) return false;
          let equal = true;
          for (let i = 0; equal && i < a.length; i++) {
            equal = looseEqual(a[i], b[i]);
          }
          return equal;
        }
        function looseEqual(a, b) {
          if (a === b) return true;
          let aValidType = isDate(a);
          let bValidType = isDate(b);
          if (aValidType || bValidType) {
            return aValidType && bValidType
              ? a.getTime() === b.getTime()
              : false;
          }
          aValidType = isArray(a);
          bValidType = isArray(b);
          if (aValidType || bValidType) {
            return aValidType && bValidType ? looseCompareArrays(a, b) : false;
          }
          aValidType = isObject(a);
          bValidType = isObject(b);
          if (aValidType || bValidType) {
            /* istanbul ignore if: this if will probably never be called */
            if (!aValidType || !bValidType) {
              return false;
            }
            const aKeysCount = Object.keys(a).length;
            const bKeysCount = Object.keys(b).length;
            if (aKeysCount !== bKeysCount) {
              return false;
            }
            for (const key in a) {
              const aHasKey = a.hasOwnProperty(key);
              const bHasKey = b.hasOwnProperty(key);
              if (
                (aHasKey && !bHasKey) ||
                (!aHasKey && bHasKey) ||
                !looseEqual(a[key], b[key])
              ) {
                return false;
              }
            }
          }
          return String(a) === String(b);
        }
        function looseIndexOf(arr, val) {
          return arr.findIndex((item) => looseEqual(item, val));
        }

        /**
         * For converting {{ interpolation }} values to displayed strings.
         * @private
         */
        const toDisplayString = (val) => {
          return isString(val)
            ? val
            : val == null
            ? ''
            : isArray(val) ||
              (isObject(val) &&
                (val.toString === objectToString || !isFunction(val.toString)))
            ? JSON.stringify(val, replacer, 2)
            : String(val);
        };
        const replacer = (_key, val) => {
          // can't use isRef here since @vue/shared has no deps
          if (val && val.__v_isRef) {
            return replacer(_key, val.value);
          } else if (isMap(val)) {
            return {
              [`Map(${val.size})`]: [...val.entries()].reduce(
                (entries, [key, val]) => {
                  entries[`${key} =>`] = val;
                  return entries;
                },
                {}
              ),
            };
          } else if (isSet(val)) {
            return {
              [`Set(${val.size})`]: [...val.values()],
            };
          } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
            return String(val);
          }
          return val;
        };

        const EMPTY_OBJ = true ? Object.freeze({}) : 0;
        const EMPTY_ARR = true ? Object.freeze([]) : 0;
        const NOOP = () => {};
        /**
         * Always return false.
         */
        const NO = () => false;
        const onRE = /^on[^a-z]/;
        const isOn = (key) => onRE.test(key);
        const isModelListener = (key) => key.startsWith('onUpdate:');
        const extend = Object.assign;
        const remove = (arr, el) => {
          const i = arr.indexOf(el);
          if (i > -1) {
            arr.splice(i, 1);
          }
        };
        const hasOwnProperty = Object.prototype.hasOwnProperty;
        const hasOwn = (val, key) => hasOwnProperty.call(val, key);
        const isArray = Array.isArray;
        const isMap = (val) => toTypeString(val) === '[object Map]';
        const isSet = (val) => toTypeString(val) === '[object Set]';
        const isDate = (val) => val instanceof Date;
        const isFunction = (val) => typeof val === 'function';
        const isString = (val) => typeof val === 'string';
        const isSymbol = (val) => typeof val === 'symbol';
        const isObject = (val) => val !== null && typeof val === 'object';
        const isPromise = (val) => {
          return isObject(val) && isFunction(val.then) && isFunction(val.catch);
        };
        const objectToString = Object.prototype.toString;
        const toTypeString = (value) => objectToString.call(value);
        const toRawType = (value) => {
          // extract "RawType" from strings like "[object RawType]"
          return toTypeString(value).slice(8, -1);
        };
        const isPlainObject = (val) => toTypeString(val) === '[object Object]';
        const isIntegerKey = (key) =>
          isString(key) &&
          key !== 'NaN' &&
          key[0] !== '-' &&
          '' + parseInt(key, 10) === key;
        const isReservedProp = /*#__PURE__*/ makeMap(
          // the leading comma is intentional so empty string "" is also included
          ',key,ref,ref_for,ref_key,' +
            'onVnodeBeforeMount,onVnodeMounted,' +
            'onVnodeBeforeUpdate,onVnodeUpdated,' +
            'onVnodeBeforeUnmount,onVnodeUnmounted'
        );
        const isBuiltInDirective = /*#__PURE__*/ makeMap(
          'bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo'
        );
        const cacheStringFunction = (fn) => {
          const cache = Object.create(null);
          return (str) => {
            const hit = cache[str];
            return hit || (cache[str] = fn(str));
          };
        };
        const camelizeRE = /-(\w)/g;
        /**
         * @private
         */
        const camelize = cacheStringFunction((str) => {
          return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
        });
        const hyphenateRE = /\B([A-Z])/g;
        /**
         * @private
         */
        const hyphenate = cacheStringFunction((str) =>
          str.replace(hyphenateRE, '-$1').toLowerCase()
        );
        /**
         * @private
         */
        const capitalize = cacheStringFunction(
          (str) => str.charAt(0).toUpperCase() + str.slice(1)
        );
        /**
         * @private
         */
        const toHandlerKey = cacheStringFunction((str) =>
          str ? `on${capitalize(str)}` : ``
        );
        // compare whether a value has changed, accounting for NaN.
        const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
        const invokeArrayFns = (fns, arg) => {
          for (let i = 0; i < fns.length; i++) {
            fns[i](arg);
          }
        };
        const def = (obj, key, value) => {
          Object.defineProperty(obj, key, {
            configurable: true,
            enumerable: false,
            value,
          });
        };
        const toNumber = (val) => {
          const n = parseFloat(val);
          return isNaN(n) ? val : n;
        };
        let _globalThis;
        const getGlobalThis = () => {
          return (
            _globalThis ||
            (_globalThis =
              typeof globalThis !== 'undefined'
                ? globalThis
                : typeof self !== 'undefined'
                ? self
                : typeof window !== 'undefined'
                ? window
                : typeof __webpack_require__.g !== 'undefined'
                ? __webpack_require__.g
                : {})
          );
        };

        /***/
      },

    /***/ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/AdminHeader.vue?vue&type=script&lang=ts':
      /*!********************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/AdminHeader.vue?vue&type=script&lang=ts ***!
  \********************************************************************************************************************************************************************************************************************************************************************************************************************************/
      /***/ (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });

        var vue_1 = __webpack_require__(
          /*! vue */ './node_modules/vue/dist/vue.esm-bundler.js'
        );

        exports['default'] = (0, vue_1.defineComponent)({
          name: 'header-component',
          components: {},
          setup: function setup() {
            var data = {
              languageNavLiClasses: 'flex',
              languageNavAnchorClasses:
                'flex text-white items-center uppercase nav__pointer-hover px-1.5',
              menuNavLiClasses: 'flex px-4',
              menuNavAnchorClasses:
                'flex text-white items-center uppercase nav__pointer-hover',
              languages: [
                {
                  language: 'EN',
                  permalink: '#',
                  active: true,
                },
                {
                  language: 'FR',
                  permalink: '#',
                  active: false,
                },
                {
                  language: 'ES',
                  permalink: '#',
                  active: false,
                },
              ],
              menus: [
                {
                  name: 'Activity DATA',
                  permalink: '#',
                  active: true,
                },
                {
                  name: 'Organisation DATA',
                  permalink: '#',
                  active: false,
                },
                {
                  name: 'Settings',
                  permalink: '#',
                  active: false,
                },
              ],
            };
            return {
              data: data,
            };
          },
        });

        /***/
      },

    /***/ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/AlertMessage.vue?vue&type=script&lang=ts':
      /*!*********************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/AlertMessage.vue?vue&type=script&lang=ts ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************************/
      /***/ (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });

        var vue_1 = __webpack_require__(
          /*! vue */ './node_modules/vue/dist/vue.esm-bundler.js'
        );

        exports['default'] = (0, vue_1.defineComponent)({
          name: 'alert-message',
          components: {},
          props: {
            type: String,
          },
          setup: function setup(props) {
            var icon = 'tick';

            if (props.type === 'failure') {
              icon = 'close';
            }

            return {
              icon: icon,
            };
          },
        });

        /***/
      },

    /***/ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/Pagination.vue?vue&type=script&lang=ts':
      /*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/Pagination.vue?vue&type=script&lang=ts ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************/
      /***/ (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });

        var vue_1 = __webpack_require__(
          /*! vue */ './node_modules/vue/dist/vue.esm-bundler.js'
        );

        exports['default'] = (0, vue_1.defineComponent)({
          name: 'pagination-component',
          components: {},
        });

        /***/
      },

    /***/ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/PopupModal.vue?vue&type=script&lang=ts':
      /*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/PopupModal.vue?vue&type=script&lang=ts ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************/
      /***/ (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });

        var vue_1 = __webpack_require__(
          /*! vue */ './node_modules/vue/dist/vue.esm-bundler.js'
        );

        exports['default'] = (0, vue_1.defineComponent)({
          name: 'popup-modal',
          props: ['modalActive'],
          emits: ['close'],
          setup: function setup(props, _a) {
            var emit = _a.emit;

            var close = function close() {
              emit('close');
            };

            return {
              close: close,
            };
          },
        });

        /***/
      },

    /***/ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/ToastMessage.vue?vue&type=script&lang=ts':
      /*!*********************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/ToastMessage.vue?vue&type=script&lang=ts ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************************/
      /***/ (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });

        var vue_1 = __webpack_require__(
          /*! vue */ './node_modules/vue/dist/vue.esm-bundler.js'
        );

        exports['default'] = (0, vue_1.defineComponent)({
          name: 'toast-message',
          components: {},
          setup: function setup() {
            return {};
          },
        });

        /***/
      },

    /***/ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/views/activity/ActivityList.vue?vue&type=script&lang=ts':
      /*!*************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/views/activity/ActivityList.vue?vue&type=script&lang=ts ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************************************************************/
      /***/ function (__unused_webpack_module, exports, __webpack_require__) {
        'use strict';

        var __importDefault =
          (this && this.__importDefault) ||
          function (mod) {
            return mod && mod.__esModule
              ? mod
              : {
                  default: mod,
                };
          };

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });

        var vue_1 = __webpack_require__(
          /*! vue */ './node_modules/vue/dist/vue.esm-bundler.js'
        );

        var EmptyActivity_vue_1 = __importDefault(
          __webpack_require__(
            /*! ./partials/EmptyActivity.vue */ './resources/assets/js/views/activity/partials/EmptyActivity.vue'
          )
        );

        var TableLayout_vue_1 = __importDefault(
          __webpack_require__(
            /*! ./partials/TableLayout.vue */ './resources/assets/js/views/activity/partials/TableLayout.vue'
          )
        );

        var Pagination_vue_1 = __importDefault(
          __webpack_require__(
            /*! ../../components/Pagination.vue */ './resources/assets/js/components/Pagination.vue'
          )
        );

        var PageTitle_vue_1 = __importDefault(
          __webpack_require__(
            /*! ./partials/PageTitle.vue */ './resources/assets/js/views/activity/partials/PageTitle.vue'
          )
        );

        var ToastMessage_vue_1 = __importDefault(
          __webpack_require__(
            /*! ../../components/ToastMessage.vue */ './resources/assets/js/components/ToastMessage.vue'
          )
        );

        exports['default'] = (0, vue_1.defineComponent)({
          name: 'activity-component',
          components: {
            EmptyActivity: EmptyActivity_vue_1['default'],
            PageTitle: PageTitle_vue_1['default'],
            Pagination: Pagination_vue_1['default'],
            ToastMessage: ToastMessage_vue_1['default'],
            TableLayout: TableLayout_vue_1['default'],
          },
          setup: function setup() {
            var state = (0, vue_1.reactive)({
              showButtons: false,
            });

            var showOrHide = function showOrHide(data) {
              if (data === void 0) {
                data = Array;
              }

              if (data.length > 0) {
                state.showButtons = true;
              } else {
                state.showButtons = false;
              }
            };

            return {
              state: state,
              showOrHide: showOrHide,
            };
          },
        });

        /***/
      },

    /***/ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/views/activity/partials/AddActivityButton.vue?vue&type=script&lang=ts':
      /*!***************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/views/activity/partials/AddActivityButton.vue?vue&type=script&lang=ts ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
      /***/ (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });

        var vue_1 = __webpack_require__(
          /*! vue */ './node_modules/vue/dist/vue.esm-bundler.js'
        );

        exports['default'] = (0, vue_1.defineComponent)({
          name: 'add-activity-button',
          components: {},
          setup: function setup() {
            var state = (0, vue_1.reactive)({
              isVisible: false,
            });
            var liClass =
              'block p-2.5 text-n-40 text-tiny leading-[1.5] font-bold hover:text-n-50 hover:bg-n-10';

            var toggle = function toggle() {
              state.isVisible = !state.isVisible;
            };

            return {
              state: state,
              liClass: liClass,
              toggle: toggle,
            };
          },
        });

        /***/
      },

    /***/ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/views/activity/partials/EmptyActivity.vue?vue&type=script&lang=ts':
      /*!***********************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/views/activity/partials/EmptyActivity.vue?vue&type=script&lang=ts ***!
  \***********************************************************************************************************************************************************************************************************************************************************************************************************************************************/
      /***/ function (__unused_webpack_module, exports, __webpack_require__) {
        'use strict';

        var __importDefault =
          (this && this.__importDefault) ||
          function (mod) {
            return mod && mod.__esModule
              ? mod
              : {
                  default: mod,
                };
          };

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });

        var vue_1 = __webpack_require__(
          /*! vue */ './node_modules/vue/dist/vue.esm-bundler.js'
        );

        var AddActivityButton_vue_1 = __importDefault(
          __webpack_require__(
            /*! ./AddActivityButton.vue */ './resources/assets/js/views/activity/partials/AddActivityButton.vue'
          )
        );

        exports['default'] = (0, vue_1.defineComponent)({
          name: 'empty-activity',
          components: {
            ActivityButton: AddActivityButton_vue_1['default'],
          },
          setup: function setup() {
            var state = (0, vue_1.reactive)({
              dismiss: true,
            });
            return {
              state: state,
            };
          },
        });

        /***/
      },

    /***/ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/views/activity/partials/PageTitle.vue?vue&type=script&lang=ts':
      /*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/views/activity/partials/PageTitle.vue?vue&type=script&lang=ts ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************************/
      /***/ function (__unused_webpack_module, exports, __webpack_require__) {
        'use strict';

        var __importDefault =
          (this && this.__importDefault) ||
          function (mod) {
            return mod && mod.__esModule
              ? mod
              : {
                  default: mod,
                };
          };

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });

        var vue_1 = __webpack_require__(
          /*! vue */ './node_modules/vue/dist/vue.esm-bundler.js'
        );

        var AddActivityButton_vue_1 = __importDefault(
          __webpack_require__(
            /*! ./AddActivityButton.vue */ './resources/assets/js/views/activity/partials/AddActivityButton.vue'
          )
        );

        var PopupModal_vue_1 = __importDefault(
          __webpack_require__(
            /*! ../../../components/PopupModal.vue */ './resources/assets/js/components/PopupModal.vue'
          )
        );

        var AlertMessage_vue_1 = __importDefault(
          __webpack_require__(
            /*! ../../../components/AlertMessage.vue */ './resources/assets/js/components/AlertMessage.vue'
          )
        );

        exports['default'] = (0, vue_1.defineComponent)({
          name: 'page-title',
          components: {
            AddActivityButton: AddActivityButton_vue_1['default'],
            Modal: PopupModal_vue_1['default'],
            Alert: AlertMessage_vue_1['default'],
          },
          props: {
            showButtons: Boolean,
          },
          setup: function setup() {
            var state = (0, vue_1.reactive)({
              modalActive: false,
            });
            var data = {
              activityList: [
                {
                  title: 'EU-Angola Dialogue Facility',
                  permalink: '#',
                  canBePublished: true,
                },
                {
                  title:
                    'Programme in support of Higher Education Agro-PRODESI: Acceleration of inclusive & sustainable agribusiness investment in economic corridors',
                  permalink: '#',
                  canBePublished: false,
                },
                {
                  title:
                    'UNFPA Angola Improved national population data systems to map and address inequalities; to advance achievement of the Sustainable Development Goals and the commitments of the Programme of Action of the International Cference on Population and Development; and to strengthen interventions in humanitarian crises activities',
                  permalink: '#',
                  canBePublished: false,
                },
                {
                  title: 'Programme in support of Higher Education',
                  permalink: '#',
                  canBePublished: true,
                },
                {
                  title:
                    'AGO.S1 Leadership, advocacy and communication to fast track the AIDS response',
                  permalink: '#',
                  canBePublished: true,
                },
              ],
            };
            var list = (0, vue_1.reactive)({
              publishable: [],
              nonPublishable: [],
            }); // computed function
            // const selectedItems = computed({
            //
            // });
            // toggle function

            var toggleModal = function toggleModal() {
              state.modalActive = false;
            };

            return {
              state: state,
              data: data,
              list: list,
              toggleModal: toggleModal,
            };
          },
        });

        /***/
      },

    /***/ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/views/activity/partials/TableLayout.vue?vue&type=script&lang=ts':
      /*!*********************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/views/activity/partials/TableLayout.vue?vue&type=script&lang=ts ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************************************/
      /***/ (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });

        var vue_1 = __webpack_require__(
          /*! vue */ './node_modules/vue/dist/vue.esm-bundler.js'
        );

        exports['default'] = (0, vue_1.defineComponent)({
          name: 'table-layout',
          components: {},
          emits: ['showOrHide'],
          setup: function setup(props, _a) {
            var emit = _a.emit;
            var state = (0, vue_1.reactive)({
              selected: [],
            });

            var emitShowOrHide = function emitShowOrHide() {
              emit('showOrHide', state.selected);
            };

            return {
              state: state,
              emitShowOrHide: emitShowOrHide,
            };
          },
        });

        /***/
      },

    /***/ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/AdminHeader.vue?vue&type=template&id=6fe59055&ts=true':
      /*!********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/AdminHeader.vue?vue&type=template&id=6fe59055&ts=true ***!
  \********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
      /***/ (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.render = void 0;

        var vue_1 = __webpack_require__(
          /*! vue */ './node_modules/vue/dist/vue.esm-bundler.js'
        );

        var _hoisted_1 = {
          class:
            'flex min-h-[60px] max-w-full gap-10 bg-bluecoral px-10 text-xs leading-normal text-white',
        };
        var _hoisted_2 = {
          class: 'flex grow-0 items-center',
        };
        var _hoisted_3 = {
          href: '/',
        };
        var _hoisted_4 = {
          class: 'flex grow-0',
        };
        var _hoisted_5 = {
          class: 'flex flex-wrap',
        };
        var _hoisted_6 = ['href'];
        var _hoisted_7 = {
          class: '',
        };
        var _hoisted_8 = {
          class: 'flex grow justify-end',
        };
        var _hoisted_9 = {
          class: '-mx-4 flex flex-wrap',
        };
        var _hoisted_10 = ['href'];
        var _hoisted_11 = {
          class: '',
        };
        var _hoisted_12 = {
          class: 'flex grow-0 items-center',
        };
        var _hoisted_13 = {
          class: 'flex',
        };
        var _hoisted_14 = {
          class: 'button secondary-btn mr-3.5 font-bold',
        };
        var _hoisted_15 = {
          class: 'button secondary-btn font-bold',
        };

        function render(_ctx, _cache, $props, $setup, $data, $options) {
          var _component_svg_vue = (0, vue_1.resolveComponent)('svg-vue');

          return (
            (0, vue_1.openBlock)(),
            (0, vue_1.createElementBlock)('header', _hoisted_1, [
              (0, vue_1.createElementVNode)('figure', _hoisted_2, [
                (0, vue_1.createElementVNode)('a', _hoisted_3, [
                  (0, vue_1.createVNode)(_component_svg_vue, {
                    icon: 'logo',
                    class: 'text-4xl',
                  }),
                ]),
              ]),
              (0, vue_1.createElementVNode)('nav', _hoisted_4, [
                (0, vue_1.createElementVNode)('ul', _hoisted_5, [
                  ((0, vue_1.openBlock)(true),
                  (0, vue_1.createElementBlock)(
                    vue_1.Fragment,
                    null,
                    (0, vue_1.renderList)(
                      _ctx.data.languages,
                      function (language, index) {
                        return (
                          (0, vue_1.openBlock)(),
                          (0, vue_1.createElementBlock)(
                            'li',
                            {
                              class: (0, vue_1.normalizeClass)(
                                _ctx.data.languageNavLiClasses
                              ),
                              key: index,
                            },
                            [
                              (0, vue_1.createElementVNode)(
                                'a',
                                {
                                  class: (0, vue_1.normalizeClass)([
                                    {
                                      nav__pointer: language.active,
                                    },
                                    _ctx.data.languageNavAnchorClasses,
                                  ]),
                                  href: language.permalink,
                                },
                                [
                                  (0, vue_1.createElementVNode)(
                                    'span',
                                    _hoisted_7,
                                    (0, vue_1.toDisplayString)(
                                      language.language
                                    ),
                                    1
                                    /* TEXT */
                                  ),
                                ],
                                10,
                                /* CLASS, PROPS */
                                _hoisted_6
                              ),
                            ],
                            2
                            /* CLASS */
                          )
                        );
                      }
                    ),
                    128
                    /* KEYED_FRAGMENT */
                  )),
                ]),
              ]),
              (0, vue_1.createElementVNode)('nav', _hoisted_8, [
                (0, vue_1.createElementVNode)('ul', _hoisted_9, [
                  ((0, vue_1.openBlock)(true),
                  (0, vue_1.createElementBlock)(
                    vue_1.Fragment,
                    null,
                    (0, vue_1.renderList)(
                      _ctx.data.menus,
                      function (menu, index) {
                        return (
                          (0, vue_1.openBlock)(),
                          (0, vue_1.createElementBlock)(
                            'li',
                            {
                              key: index,
                              class: (0, vue_1.normalizeClass)(
                                _ctx.data.menuNavLiClasses
                              ),
                            },
                            [
                              (0, vue_1.createElementVNode)(
                                'a',
                                {
                                  class: (0, vue_1.normalizeClass)([
                                    {
                                      nav__pointer: menu.active,
                                    },
                                    _ctx.data.menuNavAnchorClasses,
                                  ]),
                                  href: menu.permalink,
                                },
                                [
                                  (0, vue_1.createElementVNode)(
                                    'span',
                                    _hoisted_11,
                                    (0, vue_1.toDisplayString)(menu.name),
                                    1
                                    /* TEXT */
                                  ),
                                ],
                                10,
                                /* CLASS, PROPS */
                                _hoisted_10
                              ),
                            ],
                            2
                            /* CLASS */
                          )
                        );
                      }
                    ),
                    128
                    /* KEYED_FRAGMENT */
                  )),
                ]),
              ]),
              (0, vue_1.createElementVNode)('div', _hoisted_12, [
                (0, vue_1.createElementVNode)('div', _hoisted_13, [
                  (0, vue_1.createCommentVNode)(
                    '        <input type="text" v-model="keyword">'
                  ),
                  (0, vue_1.createElementVNode)('button', _hoisted_14, [
                    (0, vue_1.createVNode)(_component_svg_vue, {
                      icon: 'plus',
                    }),
                  ]),
                  (0, vue_1.createElementVNode)('button', _hoisted_15, [
                    (0, vue_1.createVNode)(_component_svg_vue, {
                      icon: 'user-profile',
                    }),
                  ]),
                ]),
              ]),
            ])
          );
        }

        exports.render = render;

        /***/
      },

    /***/ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/AlertMessage.vue?vue&type=template&id=657fa342&scoped=true&ts=true':
      /*!*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/AlertMessage.vue?vue&type=template&id=657fa342&scoped=true&ts=true ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
      /***/ (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.render = void 0;

        var vue_1 = __webpack_require__(
          /*! vue */ './node_modules/vue/dist/vue.esm-bundler.js'
        );

        function render(_ctx, _cache, $props, $setup, $data, $options) {
          var _component_svg_vue = (0, vue_1.resolveComponent)('svg-vue');

          return (
            (0, vue_1.openBlock)(),
            (0, vue_1.createElementBlock)(
              'div',
              {
                class: (0, vue_1.normalizeClass)([
                  'flex border-l-2 px-3 py-2.5 text-sm leading-relaxed',
                  _ctx.type,
                ]),
              },
              [
                (0, vue_1.createVNode)(
                  _component_svg_vue,
                  {
                    icon: _ctx.icon,
                    class: 'mr-2 mt-0.5 text-lg',
                  },
                  null,
                  8,
                  /* PROPS */
                  ['icon']
                ),
                (0, vue_1.createElementVNode)('b', null, [
                  (0, vue_1.renderSlot)(
                    _ctx.$slots,
                    'default',
                    {},
                    undefined,
                    true
                  ),
                ]),
              ],
              2
              /* CLASS */
            )
          );
        }

        exports.render = render;

        /***/
      },

    /***/ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/Pagination.vue?vue&type=template&id=3895afde&ts=true':
      /*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/Pagination.vue?vue&type=template&id=3895afde&ts=true ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
      /***/ (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.render = void 0;

        var vue_1 = __webpack_require__(
          /*! vue */ './node_modules/vue/dist/vue.esm-bundler.js'
        );

        var _hoisted_1 = {
          class: 'pagination',
          'aria-label': 'Pagination',
        };
        var _hoisted_2 = {
          href: '#',
          class: 'prev-btn',
        };

        var _hoisted_3 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'span',
          {
            class: '',
          },
          'Prev',
          -1
          /* HOISTED */
        );

        var _hoisted_4 = /*#__PURE__*/ (0, vue_1.createStaticVNode)(
          '<a href="#" aria-current="page" class="current"> 1 </a><a href="#" class=""> 2 </a><a href="#" class=""> 3 </a><span class=""> ... </span><a href="#" class=""> 8 </a><a href="#" class=""> 9 </a><a href="#" class=""> 10 </a>',
          7
        );

        var _hoisted_11 = {
          href: '#',
          class: 'next-btn',
        };

        var _hoisted_12 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'span',
          {
            class: '',
          },
          'Next',
          -1
          /* HOISTED */
        );

        function render(_ctx, _cache, $props, $setup, $data, $options) {
          var _component_svg_vue = (0, vue_1.resolveComponent)('svg-vue');

          return (
            (0, vue_1.openBlock)(),
            (0, vue_1.createElementBlock)('nav', _hoisted_1, [
              (0, vue_1.createElementVNode)('a', _hoisted_2, [
                (0, vue_1.createVNode)(_component_svg_vue, {
                  icon: 'arrow-left',
                }),
                _hoisted_3,
              ]),
              _hoisted_4,
              (0, vue_1.createElementVNode)('a', _hoisted_11, [
                _hoisted_12,
                (0, vue_1.createVNode)(_component_svg_vue, {
                  icon: 'arrow-right',
                }),
              ]),
            ])
          );
        }

        exports.render = render;

        /***/
      },

    /***/ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/PopupModal.vue?vue&type=template&id=5a2bda58&scoped=true&ts=true':
      /*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/PopupModal.vue?vue&type=template&id=5a2bda58&scoped=true&ts=true ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
      /***/ (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.render = void 0;

        var vue_1 = __webpack_require__(
          /*! vue */ './node_modules/vue/dist/vue.esm-bundler.js'
        );

        var _withScopeId = function _withScopeId(n) {
          return (
            (0, vue_1.pushScopeId)('data-v-5a2bda58'),
            (n = n()),
            (0, vue_1.popScopeId)(),
            n
          );
        };

        var _hoisted_1 = {
          class:
            'modal fixed top-0 left-0 flex h-screen w-screen items-center justify-center p-8',
        };
        var _hoisted_2 = {
          class: 'flex h-full w-full items-center justify-center',
        };
        var _hoisted_3 = {
          class:
            'modal-inner relative max-h-full w-full max-w-[809px] overflow-x-hidden rounded-lg bg-white p-8',
        };

        function render(_ctx, _cache, $props, $setup, $data, $options) {
          return (
            (0, vue_1.openBlock)(),
            (0, vue_1.createBlock)(
              vue_1.Teleport,
              {
                to: 'body',
              },
              [
                (0, vue_1.createVNode)(
                  vue_1.Transition,
                  {
                    name: 'modal-animation',
                  },
                  {
                    default: (0, vue_1.withCtx)(function () {
                      return [
                        (0, vue_1.withDirectives)(
                          (0, vue_1.createElementVNode)(
                            'div',
                            _hoisted_1,
                            [
                              (0, vue_1.createVNode)(
                                vue_1.Transition,
                                {
                                  name: 'modal-animation-inner',
                                },
                                {
                                  default: (0, vue_1.withCtx)(function () {
                                    return [
                                      (0, vue_1.createElementVNode)(
                                        'div',
                                        _hoisted_2,
                                        [
                                          (0, vue_1.createElementVNode)('div', {
                                            class:
                                              'modal-backdrop absolute left-0 top-0 h-full w-full bg-n-50 opacity-50',
                                            onClick:
                                              _cache[0] ||
                                              (_cache[0] = function () { //@ts-ignore
                                                var args = [];

                                                for (
                                                  var _i = 0;
                                                  _i < arguments.length;
                                                  _i++
                                                ) {
                                                  args[_i] = arguments[_i];
                                                }

                                                return (
                                                  _ctx.close &&
                                                  _ctx.close.apply(_ctx, args)
                                                );
                                              }),
                                          }),
                                          (0, vue_1.withDirectives)(
                                            (0, vue_1.createElementVNode)(
                                              'div',
                                              _hoisted_3,
                                              [
                                                (0, vue_1.renderSlot)(
                                                  _ctx.$slots,
                                                  'default',
                                                  {},
                                                  undefined,
                                                  true
                                                ),
                                              ],
                                              512
                                              /* NEED_PATCH */
                                            ),
                                            [[vue_1.vShow, _ctx.modalActive]]
                                          ),
                                        ]
                                      ),
                                    ];
                                  }),
                                  _: 3,
                                  /* FORWARDED */
                                }
                              ),
                            ],
                            512
                            /* NEED_PATCH */
                          ),
                          [[vue_1.vShow, _ctx.modalActive]]
                        ),
                      ];
                    }),
                    _: 3,
                    /* FORWARDED */
                  }
                ),
              ]
            )
          );
        }

        exports.render = render;

        /***/
      },

    /***/ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/ToastMessage.vue?vue&type=template&id=d01d8cd2&ts=true':
      /*!*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/ToastMessage.vue?vue&type=template&id=d01d8cd2&ts=true ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
      /***/ (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.render = void 0;

        var vue_1 = __webpack_require__(
          /*! vue */ './node_modules/vue/dist/vue.esm-bundler.js'
        );

        var _hoisted_1 = {
          class:
            'fixed right-10 bottom-0 inline-flex rounded-t-lg bg-eggshell py-4 px-8 text-sm leading-normal text-n-50',
        };

        var _hoisted_2 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'span',
          null,
          '5 activities ready to publish',
          -1
          /* HOISTED */
        );

        var _hoisted_3 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'span',
          {
            class: 'ml-2.5 cursor-pointer font-bold text-spring-50',
          },
          'Publish all',
          -1
          /* HOISTED */
        );

        var _hoisted_4 = [_hoisted_2, _hoisted_3];

        function render(_ctx, _cache, $props, $setup, $data, $options) {
          return (
            (0, vue_1.openBlock)(),
            (0, vue_1.createElementBlock)('div', _hoisted_1, _hoisted_4)
          );
        }

        exports.render = render;

        /***/
      },

    /***/ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/views/activity/ActivityList.vue?vue&type=template&id=2222ed6c&ts=true':
      /*!*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/views/activity/ActivityList.vue?vue&type=template&id=2222ed6c&ts=true ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
      /***/ (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.render = void 0;

        var vue_1 = __webpack_require__(
          /*! vue */ './node_modules/vue/dist/vue.esm-bundler.js'
        );

        var _hoisted_1 = {
          id: 'activity-listing-page',
          class: 'bg-paper px-10 pt-4 pb-[71px]',
        };
        var _hoisted_2 = {
          id: 'activity',
        };
        var _hoisted_3 = {
          class: 'mt-6',
        };

        function render(_ctx, _cache, $props, $setup, $data, $options) {
          var _component_PageTitle = (0, vue_1.resolveComponent)('PageTitle');

          var _component_TableLayout = (0, vue_1.resolveComponent)(
            'TableLayout'
          );

          var _component_Pagination = (0, vue_1.resolveComponent)('Pagination');

          var _component_ToastMessage = (0, vue_1.resolveComponent)(
            'ToastMessage'
          );

          return (
            (0, vue_1.openBlock)(),
            (0, vue_1.createElementBlock)('div', _hoisted_1, [
              (0, vue_1.createElementVNode)('div', _hoisted_2, [
                (0, vue_1.createVNode)(
                  _component_PageTitle,
                  {
                    showButtons: _ctx.state.showButtons,
                  },
                  null,
                  8,
                  /* PROPS */
                  ['showButtons']
                ),
                (0, vue_1.createCommentVNode)(
                  '  If no data then show empty state   '
                ),
                (0, vue_1.createCommentVNode)('      <EmptyActivity/>'),
                (0, vue_1.createCommentVNode)('   Else listing view   '),
                (0, vue_1.createVNode)(
                  _component_TableLayout,
                  {
                    onShowOrHide: _ctx.showOrHide,
                  },
                  null,
                  8,
                  /* PROPS */
                  ['onShowOrHide']
                ),
                (0, vue_1.createElementVNode)('div', _hoisted_3, [
                  (0, vue_1.createVNode)(_component_Pagination),
                ]),
                (0, vue_1.createVNode)(_component_ToastMessage),
              ]),
            ])
          );
        }

        exports.render = render;

        /***/
      },

    /***/ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/views/activity/partials/AddActivityButton.vue?vue&type=template&id=050e173c&ts=true':
      /*!***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/views/activity/partials/AddActivityButton.vue?vue&type=template&id=050e173c&ts=true ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
      /***/ (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.render = void 0;

        var vue_1 = __webpack_require__(
          /*! vue */ './node_modules/vue/dist/vue.esm-bundler.js'
        );

        var _hoisted_1 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'span',
          null,
          'Add Activity',
          -1
          /* HOISTED */
        );

        var _hoisted_2 = {
          key: 0,
          class:
            'button__dropdown absolute right-0 top-full z-10 w-48 bg-white p-2 text-left shadow-dropdown',
        };

        function render(_ctx, _cache, $props, $setup, $data, $options) {
          var _component_svg_vue = (0, vue_1.resolveComponent)('svg-vue');

          return (
            (0, vue_1.openBlock)(),
            (0, vue_1.createElementBlock)(
              'button',
              {
                class: 'button primary-btn relative font-bold',
                onClick:
                  _cache[0] ||
                  (_cache[0] = function () { //@ts-ignore
                    var args = [];

                    for (var _i = 0; _i < arguments.length; _i++) {
                      args[_i] = arguments[_i];
                    }

                    return _ctx.toggle && _ctx.toggle.apply(_ctx, args);
                  }),
              },
              [
                (0, vue_1.createVNode)(_component_svg_vue, {
                  icon: 'plus',
                }),
                _hoisted_1,
                _ctx.state.isVisible
                  ? ((0, vue_1.openBlock)(),
                    (0, vue_1.createElementBlock)('div', _hoisted_2, [
                      (0, vue_1.createElementVNode)('ul', null, [
                        (0, vue_1.createElementVNode)('li', null, [
                          (0, vue_1.createElementVNode)(
                            'a',
                            {
                              href: '#',
                              class: (0, vue_1.normalizeClass)(_ctx.liClass),
                            },
                            'Add activity manually',
                            2
                            /* CLASS */
                          ),
                        ]),
                        (0, vue_1.createElementVNode)('li', null, [
                          (0, vue_1.createElementVNode)(
                            'a',
                            {
                              href: '#',
                              class: (0, vue_1.normalizeClass)(_ctx.liClass),
                            },
                            'Upload activities from .xml',
                            2
                            /* CLASS */
                          ),
                        ]),
                        (0, vue_1.createElementVNode)('li', null, [
                          (0, vue_1.createElementVNode)(
                            'a',
                            {
                              href: '#',
                              class: (0, vue_1.normalizeClass)(_ctx.liClass),
                            },
                            'Upload activities from .csv',
                            2
                            /* CLASS */
                          ),
                        ]),
                      ]),
                    ]))
                  : (0, vue_1.createCommentVNode)('v-if', true),
              ]
            )
          );
        }

        exports.render = render;

        /***/
      },

    /***/ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/views/activity/partials/EmptyActivity.vue?vue&type=template&id=9aef9688&ts=true':
      /*!***********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/views/activity/partials/EmptyActivity.vue?vue&type=template&id=9aef9688&ts=true ***!
  \***********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
      /***/ (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.render = void 0;

        var vue_1 = __webpack_require__(
          /*! vue */ './node_modules/vue/dist/vue.esm-bundler.js'
        );

        var _hoisted_1 = {
          id: 'empty-state',
          class:
            'relative flex min-h-[647px] flex-col items-center justify-center bg-white p-10',
        };
        var _hoisted_2 = {
          key: 0,
          class:
            'absolute left-0 top-0 flex w-full rounded-bl rounded-br bg-rose py-4 px-5 text-sm leading-relaxed text-n-50',
        };
        var _hoisted_3 = {
          class: 'grow',
        };
        var _hoisted_4 = {
          class: 'flex items-center',
        };

        var _hoisted_5 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'p',
          {
            class: 'grow',
          },
          [
            /*#__PURE__*/ (0, vue_1.createTextVNode)(' Please '),
            /*#__PURE__*/ (0, vue_1.createElementVNode)(
              'a',
              {
                href: '#',
                class: 'font-bold',
              },
              'complete your setup'
            ),
            /*#__PURE__*/ (0, vue_1.createTextVNode)(
              ' in order to enable complete features of IATI publisher tool. '
            ),
          ],
          -1
          /* HOISTED */
        );

        var _hoisted_6 = {
          class: 'grow-0',
        };
        var _hoisted_7 = {
          class:
            'mb-6 flex h-[150px] w-[150px] items-center justify-center rounded-full',
          style: {
            background: 'linear-gradient(180deg, #e3ecfa 0%, #dae7ff 100%)',
          },
        };

        var _hoisted_8 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'h5',
          {
            class: 'mb-[5px] text-heading-5 font-bold leading-9',
          },
          ' No activity has been added yet. ',
          -1
          /* HOISTED */
        );

        var _hoisted_9 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'div',
          {
            class: 'mb-[17px] text-caption-c1 leading-5 text-n-50',
          },
          ' Click on the button below to add a new activity ',
          -1
          /* HOISTED */
        );

        function render(_ctx, _cache, $props, $setup, $data, $options) {
          var _component_svg_vue = (0, vue_1.resolveComponent)('svg-vue');

          var _component_ActivityButton = (0, vue_1.resolveComponent)(
            'ActivityButton'
          );

          return (
            (0, vue_1.openBlock)(),
            (0, vue_1.createElementBlock)('div', _hoisted_1, [
              _ctx.state.dismiss
                ? ((0, vue_1.openBlock)(),
                  (0, vue_1.createElementBlock)('div', _hoisted_2, [
                    (0, vue_1.createElementVNode)('div', _hoisted_3, [
                      (0, vue_1.createElementVNode)('div', _hoisted_4, [
                        (0, vue_1.createVNode)(_component_svg_vue, {
                          icon: 'alert',
                          class: 'mr-1 grow-0 text-base text-crimson-50',
                        }),
                        _hoisted_5,
                      ]),
                    ]),
                    (0, vue_1.createElementVNode)('div', _hoisted_6, [
                      (0, vue_1.createElementVNode)(
                        'button',
                        {
                          class: 'text-sm leading-relaxed text-bluecoral',
                          onClick:
                            _cache[0] ||
                            (_cache[0] = function ($event) {
                              return (_ctx.state.dismiss = false);
                            }),
                        },
                        ' Dismiss '
                      ),
                    ]),
                  ]))
                : (0, vue_1.createCommentVNode)('v-if', true),
              (0, vue_1.createElementVNode)('div', _hoisted_7, [
                (0, vue_1.createVNode)(_component_svg_vue, {
                  icon: 'folder',
                  class: 'text-[94px]',
                }),
              ]),
              _hoisted_8,
              _hoisted_9,
              (0, vue_1.createVNode)(_component_ActivityButton),
            ])
          );
        }

        exports.render = render;

        /***/
      },

    /***/ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/views/activity/partials/PageTitle.vue?vue&type=template&id=7589e86e&ts=true':
      /*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/views/activity/partials/PageTitle.vue?vue&type=template&id=7589e86e&ts=true ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
      /***/ (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.render = void 0;

        var vue_1 = __webpack_require__(
          /*! vue */ './node_modules/vue/dist/vue.esm-bundler.js'
        );

        var _hoisted_1 = {
          class: 'page-title mb-4',
        };
        var _hoisted_2 = {
          class: 'flex items-end gap-4',
        };
        var _hoisted_3 = {
          class: 'title grow-0',
        };

        var _hoisted_4 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'div',
          {
            class: 'mb-4 text-caption-c1 font-bold text-n-40',
          },
          ' Your Activities ',
          -1
          /* HOISTED */
        );

        var _hoisted_5 = {
          class: 'inline-flex items-center',
        };

        var _hoisted_6 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'h4',
          {
            class: 'mr-4 font-bold',
          },
          'Your Activities',
          -1
          /* HOISTED */
        );

        var _hoisted_7 = {
          class: 'tooltip-btn',
        };
        var _hoisted_8 = {
          class: '',
        };

        var _hoisted_9 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'span',
          null,
          'What is activity?',
          -1
          /* HOISTED */
        );

        var _hoisted_10 = /*#__PURE__*/ (0, vue_1.createStaticVNode)(
          '<div class="tooltip-btn__content z-[1]"><div class="content"><div class="mb-1.5 text-caption-c1 font-bold text-bluecoral"> What is an activity? </div><p> Organisations need to publish data on their activities. An ‘activity’ is an individual project or piece of development and humanitarian work. The unit of work described by an ‘activity’ is determined by the organisation that is publishing the data. </p><p> For example, an activity could be a donor government providing US$ 100 million to a recipient country’s state bank to implement basic education over 8 years. </p><p class="text-n-40"> To know more about how to publish data on activities according to the IATI read the <a href="#" class="text-bluecoral"><b>full guidance</b></a>. </p></div></div>',
          1
        );

        var _hoisted_11 = {
          class: 'actions flex grow justify-end',
        };
        var _hoisted_12 = {
          class: 'inline-flex justify-center',
        };
        var _hoisted_13 = {
          class: 'button secondary-btn mr-3.5 font-bold',
        };

        var _hoisted_14 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'span',
          null,
          'Download Selected',
          -1
          /* HOISTED */
        );

        var _hoisted_15 = /*#__PURE__*/ (0, vue_1.createTextVNode)(
          'The following activities are eligible for publishing'
        );

        var _hoisted_16 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'div',
          {
            class: 'checked-list',
          },
          [
            /*#__PURE__*/ (0, vue_1.createElementVNode)(
              'div',
              {
                class: 'list px-6',
              },
              [
                /*#__PURE__*/ (0, vue_1.createElementVNode)(
                  'a',
                  {
                    href: '#',
                    class: 'block border-b border-n-20 py-4',
                  },
                  'EU-Angola Dialogue Facility'
                ),
              ]
            ),
          ],
          -1
          /* HOISTED */
        );

        var _hoisted_17 = /*#__PURE__*/ (0, vue_1.createTextVNode)(
          'The following activities are not eligible for publishing'
        );

        var _hoisted_18 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'div',
          {
            class: 'checked-list',
          },
          [
            /*#__PURE__*/ (0, vue_1.createElementVNode)(
              'div',
              {
                class: 'list px-6',
              },
              [
                /*#__PURE__*/ (0, vue_1.createElementVNode)(
                  'a',
                  {
                    href: '#',
                    class: 'block border-b border-n-20 py-4',
                  },
                  'Programme in support of Higher Education Agro-PRODESI: Acceleration of inclusive & sustainable agribusiness investment in economic corridors'
                ),
              ]
            ),
          ],
          -1
          /* HOISTED */
        );

        var _hoisted_19 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'span',
          null,
          'Publish Selected',
          -1
          /* HOISTED */
        );

        var _hoisted_20 = {
          class: 'button secondary-btn mr-3.5 font-bold',
        };

        var _hoisted_21 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'span',
          null,
          'Delete Selected',
          -1
          /* HOISTED */
        );

        var _hoisted_22 = {
          class: 'button secondary-btn mr-3.5 font-bold',
        };

        var _hoisted_23 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'span',
          null,
          'Download All',
          -1
          /* HOISTED */
        );

        var _hoisted_24 = {
          class: 'button secondary-btn mr-3.5 font-bold',
        };

        var _hoisted_25 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'span',
          null,
          'Publish',
          -1
          /* HOISTED */
        );

        function render(_ctx, _cache, $props, $setup, $data, $options) {
          var _component_svg_vue = (0, vue_1.resolveComponent)('svg-vue');

          var _component_alert = (0, vue_1.resolveComponent)('alert');

          var _component_Modal = (0, vue_1.resolveComponent)('Modal');

          var _component_AddActivityButton = (0, vue_1.resolveComponent)(
            'AddActivityButton'
          );

          return (
            (0, vue_1.openBlock)(),
            (0, vue_1.createElementBlock)('div', _hoisted_1, [
              (0, vue_1.createElementVNode)('div', _hoisted_2, [
                (0, vue_1.createElementVNode)('div', _hoisted_3, [
                  _hoisted_4,
                  (0, vue_1.createElementVNode)('div', _hoisted_5, [
                    _hoisted_6,
                    (0, vue_1.createElementVNode)('div', _hoisted_7, [
                      (0, vue_1.createElementVNode)('button', _hoisted_8, [
                        (0, vue_1.createVNode)(_component_svg_vue, {
                          icon: 'question-mark',
                        }),
                        _hoisted_9,
                      ]),
                      _hoisted_10,
                    ]),
                  ]),
                ]),
                (0, vue_1.createElementVNode)('div', _hoisted_11, [
                  (0, vue_1.createElementVNode)('div', _hoisted_12, [
                    (0, vue_1.withDirectives)(
                      (0, vue_1.createElementVNode)(
                        'button',
                        _hoisted_13,
                        [
                          (0, vue_1.createVNode)(_component_svg_vue, {
                            icon: 'download-file',
                          }),
                          _hoisted_14,
                        ],
                        512
                        /* NEED_PATCH */
                      ),
                      [[vue_1.vShow, _ctx.showButtons]]
                    ),
                    (0, vue_1.createCommentVNode)('    Toggle modal      '),
                    (0, vue_1.createVNode)(
                      _component_Modal,
                      {
                        onClose: _ctx.toggleModal,
                        modalActive: _ctx.state.modalActive,
                      },
                      {
                        default: (0, vue_1.withCtx)(function () {
                          return [
                            (0, vue_1.createVNode)(
                              _component_alert,
                              {
                                type: 'success',
                                class: 'mb-1',
                              },
                              {
                                default: (0, vue_1.withCtx)(function () {
                                  return [_hoisted_15];
                                }),
                                _: 1,
                                /* STABLE */
                              }
                            ),
                            _hoisted_16,
                            (0, vue_1.createVNode)(
                              _component_alert,
                              {
                                type: 'failure',
                                class: 'mt-1 mb-1',
                              },
                              {
                                default: (0, vue_1.withCtx)(function () {
                                  return [_hoisted_17];
                                }),
                                _: 1,
                                /* STABLE */
                              }
                            ),
                            _hoisted_18,
                          ];
                        }),
                        _: 1,
                        /* STABLE */
                      },
                      8,
                      /* PROPS */
                      ['onClose', 'modalActive']
                    ),
                    (0, vue_1.withDirectives)(
                      (0, vue_1.createElementVNode)(
                        'button',
                        {
                          class: 'button secondary-btn mr-3.5 font-bold',
                          onClick:
                            _cache[0] ||
                            (_cache[0] = function ($event) {
                              return (_ctx.state.modalActive = true);
                            }),
                        },
                        [
                          (0, vue_1.createVNode)(_component_svg_vue, {
                            icon: 'approved-cloud',
                          }),
                          _hoisted_19,
                        ],
                        512
                        /* NEED_PATCH */
                      ),
                      [[vue_1.vShow, _ctx.showButtons]]
                    ),
                    (0, vue_1.withDirectives)(
                      (0, vue_1.createElementVNode)(
                        'button',
                        _hoisted_20,
                        [
                          (0, vue_1.createVNode)(_component_svg_vue, {
                            icon: 'delete',
                          }),
                          _hoisted_21,
                        ],
                        512
                        /* NEED_PATCH */
                      ),
                      [[vue_1.vShow, _ctx.showButtons]]
                    ),
                    (0, vue_1.createElementVNode)('button', _hoisted_22, [
                      (0, vue_1.createVNode)(_component_svg_vue, {
                        icon: 'download-file',
                      }),
                      _hoisted_23,
                    ]),
                    (0, vue_1.createElementVNode)('button', _hoisted_24, [
                      (0, vue_1.createVNode)(_component_svg_vue, {
                        icon: 'publish',
                      }),
                      _hoisted_25,
                    ]),
                    (0, vue_1.createVNode)(_component_AddActivityButton),
                  ]),
                ]),
              ]),
            ])
          );
        }

        exports.render = render;

        /***/
      },

    /***/ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/views/activity/partials/TableLayout.vue?vue&type=template&id=5d84a1d8&ts=true':
      /*!*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/views/activity/partials/TableLayout.vue?vue&type=template&id=5d84a1d8&ts=true ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
      /***/ (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.render = void 0;

        var vue_1 = __webpack_require__(
          /*! vue */ './node_modules/vue/dist/vue.esm-bundler.js'
        );

        var _hoisted_1 = {
          class: 'iati-list-table overflow-auto',
        };
        var _hoisted_2 = {
          class: '',
        };
        var _hoisted_3 = {
          class: 'bg-n-10',
        };
        var _hoisted_4 = {
          scope: 'col',
          id: 'title',
        };
        var _hoisted_5 = {
          href: '#',
          class: 'text-n-50 transition duration-500 hover:text-spring-50',
        };
        var _hoisted_6 = {
          class: 'sorting-indicator descending',
        };

        var _hoisted_7 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'span',
          null,
          'Activity Title',
          -1
          /* HOISTED */
        );

        var _hoisted_8 = {
          scope: 'col',
          id: 'date',
        };
        var _hoisted_9 = {
          href: '#',
          class: 'text-n-50 transition duration-500 hover:text-spring-50',
        };
        var _hoisted_10 = {
          class: 'sorting-indicator ascending',
        };

        var _hoisted_11 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'span',
          null,
          'Updated On',
          -1
          /* HOISTED */
        );

        var _hoisted_12 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'th',
          {
            scope: 'col',
            id: 'status',
          },
          [
            /*#__PURE__*/ (0, vue_1.createElementVNode)(
              'span',
              {
                class: 'hidden',
              },
              'Status'
            ),
          ],
          -1
          /* HOISTED */
        );

        var _hoisted_13 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'th',
          {
            scope: 'col',
            id: 'publish',
          },
          [
            /*#__PURE__*/ (0, vue_1.createElementVNode)(
              'span',
              {
                class: 'hidden',
              },
              'Status'
            ),
          ],
          -1
          /* HOISTED */
        );

        var _hoisted_14 = {
          scope: 'col',
          id: 'cb',
        };
        var _hoisted_15 = {
          class: '',
        };
        var _hoisted_16 = {
          class: 'title',
        };
        var _hoisted_17 = {
          href: '#',
          class:
            'hover:text-sp50 inline-flex items-start text-n-50 transition duration-500',
        };

        var _hoisted_18 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'span',
          null,
          'EU-Angola Dialogue Facility',
          -1
          /* HOISTED */
        );

        var _hoisted_19 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'td',
          {
            class: 'text-n-40',
          },
          '2 days ago',
          -1
          /* HOISTED */
        );

        var _hoisted_20 = {
          class:
            'inline-flex items-center text-n-40 transition duration-500 hover:text-spring-50',
        };
        var _hoisted_21 = {
          class: 'mr-1 text-base',
        };

        var _hoisted_22 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'span',
          {
            class: 'text-sm leading-relaxed',
          },
          'Draft',
          -1
          /* HOISTED */
        );

        var _hoisted_23 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'td',
          null,
          null,
          -1
          /* HOISTED */
        );

        var _hoisted_24 = {
          class: 'check-column',
        };

        var _hoisted_25 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'label',
          {
            class: 'sr-only',
            for: '',
          },
          ' Select "EU-Angola Dialogue Facility" ',
          -1
          /* HOISTED */
        );

        var _hoisted_26 = {
          class: 'checkbox',
        };

        var _hoisted_27 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'span',
          {
            class: 'checkmark',
          },
          null,
          -1
          /* HOISTED */
        );

        var _hoisted_28 = {
          class: 'text-n-50',
        };
        var _hoisted_29 = {
          href: '#',
          class:
            'hover:text-sp50 inline-flex items-start text-n-50 transition duration-500',
        };

        var _hoisted_30 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'span',
          null,
          'Support Program on Public Finance Management and Financial Sector reform',
          -1
          /* HOISTED */
        );

        var _hoisted_31 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'td',
          {
            class: 'text-n-40',
          },
          '2 days ago',
          -1
          /* HOISTED */
        );

        var _hoisted_32 = {
          class:
            'inline-flex items-center text-n-40 transition duration-500 hover:text-spring-50',
        };
        var _hoisted_33 = {
          class: 'mr-1 text-base',
        };

        var _hoisted_34 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'span',
          {
            class: 'text-sm leading-relaxed',
          },
          'Ready to publish',
          -1
          /* HOISTED */
        );

        var _hoisted_35 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'td',
          null,
          [
            /*#__PURE__*/ (0, vue_1.createElementVNode)(
              'button',
              {
                class: 'button primary-outline-btn w-20',
              },
              'Publish'
            ),
          ],
          -1
          /* HOISTED */
        );

        var _hoisted_36 = {
          class: 'check-column',
        };

        var _hoisted_37 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'label',
          {
            class: 'sr-only',
            for: '',
          },
          ' Select "Support Program on Public Finance Management and Financial Sector reform" ',
          -1
          /* HOISTED */
        );

        var _hoisted_38 = {
          class: 'checkbox',
        };

        var _hoisted_39 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'span',
          {
            class: 'checkmark',
          },
          null,
          -1
          /* HOISTED */
        );

        var _hoisted_40 = {
          class: 'text-n-50',
        };
        var _hoisted_41 = {
          href: '#',
          class:
            'hover:text-sp50 inline-flex items-start text-n-50 transition duration-500',
        };

        var _hoisted_42 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'span',
          null,
          'UNFPA Angola Improved national population data systems to map and address inequalities; to advance the achievement of the Sustainable Development Goals and the commitments of the Programme of Action of the International Conference on Population and Development; and to strengthen interventions in humanitarian crises activities',
          -1
          /* HOISTED */
        );

        var _hoisted_43 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'td',
          {
            class: 'text-n-40',
          },
          '2 days ago',
          -1
          /* HOISTED */
        );

        var _hoisted_44 = {
          class:
            'inline-flex items-center text-n-40 transition duration-500 hover:text-spring-50',
        };
        var _hoisted_45 = {
          class: 'mr-1 text-base text-spring-50',
        };

        var _hoisted_46 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'span',
          {
            class: 'text-sm leading-relaxed',
          },
          'Published',
          -1
          /* HOISTED */
        );

        var _hoisted_47 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'td',
          null,
          null,
          -1
          /* HOISTED */
        );

        var _hoisted_48 = {
          class: 'check-column',
        };

        var _hoisted_49 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'label',
          {
            class: 'sr-only',
            for: '',
          },
          ' Select "UNFPA Angola Improved national population data systems to map and address inequalities; to advance the achievement of the Sustainable Development Goals and the commitments of the Programme of Action of the International Conference on Population and Development; and to strengthen interventions in humanitarian crises activities" ',
          -1
          /* HOISTED */
        );

        var _hoisted_50 = {
          class: 'checkbox',
        };

        var _hoisted_51 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'span',
          {
            class: 'checkmark',
          },
          null,
          -1
          /* HOISTED */
        );

        var _hoisted_52 = {
          class: 'text-n-50',
        };
        var _hoisted_53 = {
          href: '#',
          class:
            'hover:text-sp50 inline-flex items-start text-n-50 transition duration-500',
        };

        var _hoisted_54 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'span',
          null,
          'Programme in support of Higher Education',
          -1
          /* HOISTED */
        );

        var _hoisted_55 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'td',
          {
            class: 'text-n-40',
          },
          '2 days ago',
          -1
          /* HOISTED */
        );

        var _hoisted_56 = {
          class:
            'inline-flex items-center text-n-40 transition duration-500 hover:text-spring-50',
        };
        var _hoisted_57 = {
          class: 'mr-1 text-base',
        };

        var _hoisted_58 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'span',
          {
            class: 'text-sm leading-relaxed',
          },
          'Changes made',
          -1
          /* HOISTED */
        );

        var _hoisted_59 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'td',
          null,
          [
            /*#__PURE__*/ (0, vue_1.createElementVNode)(
              'button',
              {
                class: 'button primary-outline-btn w-20',
              },
              'RePublish'
            ),
          ],
          -1
          /* HOISTED */
        );

        var _hoisted_60 = {
          class: 'check-column',
        };

        var _hoisted_61 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'label',
          {
            class: 'sr-only',
            for: '',
          },
          ' Select "Programme in support of Higher Education" ',
          -1
          /* HOISTED */
        );

        var _hoisted_62 = {
          class: 'checkbox',
        };

        var _hoisted_63 = /*#__PURE__*/ (0, vue_1.createElementVNode)(
          'span',
          {
            class: 'checkmark',
          },
          null,
          -1
          /* HOISTED */
        );

        function render(_ctx, _cache, $props, $setup, $data, $options) {
          var _component_svg_vue = (0, vue_1.resolveComponent)('svg-vue');

          return (
            (0, vue_1.openBlock)(),
            (0, vue_1.createElementBlock)('div', _hoisted_1, [
              (0, vue_1.createElementVNode)('table', _hoisted_2, [
                (0, vue_1.createElementVNode)('thead', null, [
                  (0, vue_1.createElementVNode)('tr', _hoisted_3, [
                    (0, vue_1.createElementVNode)('th', _hoisted_4, [
                      (0, vue_1.createElementVNode)('a', _hoisted_5, [
                        (0, vue_1.createElementVNode)('span', _hoisted_6, [
                          (0, vue_1.createVNode)(_component_svg_vue, {
                            icon: 'descending-arrow',
                          }),
                        ]),
                        _hoisted_7,
                      ]),
                    ]),
                    (0, vue_1.createElementVNode)('th', _hoisted_8, [
                      (0, vue_1.createElementVNode)('a', _hoisted_9, [
                        (0, vue_1.createElementVNode)('span', _hoisted_10, [
                          (0, vue_1.createVNode)(_component_svg_vue, {
                            icon: 'ascending-arrow',
                          }),
                        ]),
                        _hoisted_11,
                      ]),
                    ]),
                    _hoisted_12,
                    _hoisted_13,
                    (0, vue_1.createElementVNode)('th', _hoisted_14, [
                      (0, vue_1.createElementVNode)('span', _hoisted_15, [
                        (0, vue_1.createVNode)(_component_svg_vue, {
                          icon: 'checkbox',
                        }),
                      ]),
                    ]),
                  ]),
                ]),
                (0, vue_1.createElementVNode)('tbody', null, [
                  (0, vue_1.createCommentVNode)('      Loop starts here'),
                  (0, vue_1.createCommentVNode)(
                    '      ==================================='
                  ),
                  (0, vue_1.createCommentVNode)(
                    '      First item with "Draft" status'
                  ),
                  (0, vue_1.createCommentVNode)(
                    '      ======================================='
                  ),
                  (0, vue_1.createElementVNode)('tr', null, [
                    (0, vue_1.createElementVNode)('td', _hoisted_16, [
                      (0, vue_1.createElementVNode)('a', _hoisted_17, [
                        (0, vue_1.createVNode)(_component_svg_vue, {
                          icon: 'approved-cloud',
                          class: 'mr-3 mt-1 shrink-0 text-base text-spring-50',
                        }),
                        _hoisted_18,
                      ]),
                    ]),
                    _hoisted_19,
                    (0, vue_1.createElementVNode)('td', null, [
                      (0, vue_1.createElementVNode)('button', _hoisted_20, [
                        (0, vue_1.createElementVNode)('span', _hoisted_21, [
                          (0, vue_1.createVNode)(_component_svg_vue, {
                            icon: 'document-write',
                          }),
                        ]),
                        _hoisted_22,
                      ]),
                    ]),
                    _hoisted_23,
                    (0, vue_1.createElementVNode)('th', _hoisted_24, [
                      _hoisted_25,
                      (0, vue_1.createElementVNode)('label', _hoisted_26, [
                        (0, vue_1.withDirectives)(
                          (0, vue_1.createElementVNode)(
                            'input',
                            {
                              type: 'checkbox',
                              value: 1,
                              'onUpdate:modelValue':
                                _cache[0] ||
                                (_cache[0] = function ($event) {
                                  return (_ctx.state.selected = $event);
                                }),
                              onChange:
                                _cache[1] ||
                                (_cache[1] = function () { //@ts-ignore
                                  var args = [];

                                  for (
                                    var _i = 0;
                                    _i < arguments.length;
                                    _i++
                                  ) {
                                    args[_i] = arguments[_i];
                                  }

                                  return (
                                    _ctx.emitShowOrHide &&
                                    _ctx.emitShowOrHide.apply(_ctx, args)
                                  );
                                }),
                            },
                            null,
                            544
                            /* HYDRATE_EVENTS, NEED_PATCH */
                          ),
                          [[vue_1.vModelCheckbox, _ctx.state.selected]]
                        ),
                        _hoisted_27,
                      ]),
                    ]),
                  ]),
                  (0, vue_1.createCommentVNode)(
                    '      ========================================    '
                  ),
                  (0, vue_1.createCommentVNode)(
                    '      Second item with "Ready to Publish" button  '
                  ),
                  (0, vue_1.createCommentVNode)(
                    '      ============================================'
                  ),
                  (0, vue_1.createElementVNode)('tr', null, [
                    (0, vue_1.createElementVNode)('td', _hoisted_28, [
                      (0, vue_1.createElementVNode)('a', _hoisted_29, [
                        (0, vue_1.createVNode)(_component_svg_vue, {
                          icon: 'approved-cloud',
                          class: 'mr-3 mt-1 shrink-0 text-base text-spring-50',
                        }),
                        _hoisted_30,
                      ]),
                    ]),
                    _hoisted_31,
                    (0, vue_1.createElementVNode)('td', null, [
                      (0, vue_1.createElementVNode)('button', _hoisted_32, [
                        (0, vue_1.createElementVNode)('span', _hoisted_33, [
                          (0, vue_1.createVNode)(_component_svg_vue, {
                            icon: 'tick',
                          }),
                        ]),
                        _hoisted_34,
                      ]),
                    ]),
                    _hoisted_35,
                    (0, vue_1.createElementVNode)('th', _hoisted_36, [
                      _hoisted_37,
                      (0, vue_1.createElementVNode)('label', _hoisted_38, [
                        (0, vue_1.withDirectives)(
                          (0, vue_1.createElementVNode)(
                            'input',
                            {
                              type: 'checkbox',
                              value: 2,
                              'onUpdate:modelValue':
                                _cache[2] ||
                                (_cache[2] = function ($event) {
                                  return (_ctx.state.selected = $event);
                                }),
                              onChange:
                                _cache[3] ||
                                (_cache[3] = function () { //@ts-ignore
                                  var args = [];

                                  for (
                                    var _i = 0;
                                    _i < arguments.length;
                                    _i++
                                  ) {
                                    args[_i] = arguments[_i];
                                  }

                                  return (
                                    _ctx.emitShowOrHide &&
                                    _ctx.emitShowOrHide.apply(_ctx, args)
                                  );
                                }),
                            },
                            null,
                            544
                            /* HYDRATE_EVENTS, NEED_PATCH */
                          ),
                          [[vue_1.vModelCheckbox, _ctx.state.selected]]
                        ),
                        _hoisted_39,
                      ]),
                    ]),
                  ]),
                  (0, vue_1.createCommentVNode)(
                    '      ========================================'
                  ),
                  (0, vue_1.createCommentVNode)(
                    '        Third item with "Published" Status'
                  ),
                  (0, vue_1.createCommentVNode)(
                    '      ============================================'
                  ),
                  (0, vue_1.createElementVNode)('tr', null, [
                    (0, vue_1.createElementVNode)('td', _hoisted_40, [
                      (0, vue_1.createElementVNode)('a', _hoisted_41, [
                        (0, vue_1.createVNode)(_component_svg_vue, {
                          icon: 'tick',
                          class: 'mr-3 mt-1 shrink-0 text-base text-spring-50',
                        }),
                        _hoisted_42,
                      ]),
                    ]),
                    _hoisted_43,
                    (0, vue_1.createElementVNode)('td', null, [
                      (0, vue_1.createElementVNode)('button', _hoisted_44, [
                        (0, vue_1.createElementVNode)('span', _hoisted_45, [
                          (0, vue_1.createVNode)(_component_svg_vue, {
                            icon: 'tick',
                          }),
                        ]),
                        _hoisted_46,
                      ]),
                    ]),
                    _hoisted_47,
                    (0, vue_1.createElementVNode)('th', _hoisted_48, [
                      _hoisted_49,
                      (0, vue_1.createElementVNode)('label', _hoisted_50, [
                        (0, vue_1.withDirectives)(
                          (0, vue_1.createElementVNode)(
                            'input',
                            {
                              type: 'checkbox',
                              value: 3,
                              'onUpdate:modelValue':
                                _cache[4] ||
                                (_cache[4] = function ($event) {
                                  return (_ctx.state.selected = $event);
                                }),
                              onChange:
                                _cache[5] ||
                                (_cache[5] = function () { //@ts-ignore
                                  var args = [];

                                  for (
                                    var _i = 0;
                                    _i < arguments.length;
                                    _i++
                                  ) {
                                    args[_i] = arguments[_i];
                                  }

                                  return (
                                    _ctx.emitShowOrHide &&
                                    _ctx.emitShowOrHide.apply(_ctx, args)
                                  );
                                }),
                            },
                            null,
                            544
                            /* HYDRATE_EVENTS, NEED_PATCH */
                          ),
                          [[vue_1.vModelCheckbox, _ctx.state.selected]]
                        ),
                        _hoisted_51,
                      ]),
                    ]),
                  ]),
                  (0, vue_1.createCommentVNode)(
                    '      ========================================'
                  ),
                  (0, vue_1.createCommentVNode)(
                    '        Fourth item with "Changes made" Status'
                  ),
                  (0, vue_1.createCommentVNode)(
                    '      ============================================'
                  ),
                  (0, vue_1.createElementVNode)('tr', null, [
                    (0, vue_1.createElementVNode)('td', _hoisted_52, [
                      (0, vue_1.createElementVNode)('a', _hoisted_53, [
                        (0, vue_1.createVNode)(_component_svg_vue, {
                          icon: 'approved-cloud',
                          class: 'mr-3 mt-1 text-base text-spring-50',
                        }),
                        _hoisted_54,
                      ]),
                    ]),
                    _hoisted_55,
                    (0, vue_1.createElementVNode)('td', null, [
                      (0, vue_1.createElementVNode)('button', _hoisted_56, [
                        (0, vue_1.createElementVNode)('span', _hoisted_57, [
                          (0, vue_1.createVNode)(_component_svg_vue, {
                            icon: 'history',
                          }),
                        ]),
                        _hoisted_58,
                      ]),
                    ]),
                    _hoisted_59,
                    (0, vue_1.createElementVNode)('th', _hoisted_60, [
                      _hoisted_61,
                      (0, vue_1.createElementVNode)('label', _hoisted_62, [
                        (0, vue_1.withDirectives)(
                          (0, vue_1.createElementVNode)(
                            'input',
                            {
                              type: 'checkbox',
                              value: 4,
                              'onUpdate:modelValue':
                                _cache[6] ||
                                (_cache[6] = function ($event) {
                                  return (_ctx.state.selected = $event);
                                }),
                              onChange:
                                _cache[7] ||
                                (_cache[7] = function () { //@ts-ignore
                                  var args = [];

                                  for (
                                    var _i = 0;
                                    _i < arguments.length;
                                    _i++
                                  ) {
                                    args[_i] = arguments[_i];
                                  }

                                  return (
                                    _ctx.emitShowOrHide &&
                                    _ctx.emitShowOrHide.apply(_ctx, args)
                                  );
                                }),
                            },
                            null,
                            544
                            /* HYDRATE_EVENTS, NEED_PATCH */
                          ),
                          [[vue_1.vModelCheckbox, _ctx.state.selected]]
                        ),
                        _hoisted_63,
                      ]),
                    ]),
                  ]),
                  (0, vue_1.createCommentVNode)('  Loop ends here  '),
                ]),
              ]),
            ])
          );
        }

        exports.render = render;

        /***/
      },

    /***/ './resources/assets/js/app.ts':
      /*!************************************!*\
  !*** ./resources/assets/js/app.ts ***!
  \************************************/
      /***/ function (__unused_webpack_module, exports, __webpack_require__) {
        'use strict';

        var __importDefault =
          (this && this.__importDefault) ||
          function (mod) {
            return mod && mod.__esModule
              ? mod
              : {
                  default: mod,
                };
          };

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        /**
         * First we will load all of this project's JavaScript dependencies which
         * includes Vue and other libraries. It is a great starting point when
         * building robust, powerful web applications using Vue and Laravel.
         */

        var vue_1 = __webpack_require__(
          /*! vue */ './node_modules/vue/dist/vue.esm-bundler.js'
        );

        var svg_vue3_1 = __importDefault(
          __webpack_require__(
            /*! svg-vue3 */ './node_modules/svg-vue3/dist/svg-vue.esm.js'
          )
        );
        /**
         * Vue components for Activities Listing
         *
         */

        var ActivityList_vue_1 = __importDefault(
          __webpack_require__(
            /*! ./views/activity/ActivityList.vue */ './resources/assets/js/views/activity/ActivityList.vue'
          )
        );

        var AdminHeader_vue_1 = __importDefault(
          __webpack_require__(
            /*! ./components/AdminHeader.vue */ './resources/assets/js/components/AdminHeader.vue'
          )
        );

        var app = (0, vue_1.createApp)({});
        /**
         * Registering vue component for activity listing
         */

        app.component('activity-template', ActivityList_vue_1['default']);
        app.component('loggedin-header', AdminHeader_vue_1['default']);
        /**
         * Extension to inline SVG files with Vue.js and optimize them automatically with SVGO
         */

        app.use(svg_vue3_1['default']);
        /**
         * Next, we will create a fresh Vue application instance and attach it to
         * the page. Then, you may begin adding components to this application
         * or customize the JavaScript scaffolding to fit your unique needs.
         */

        app.mount('#app');

        /***/
      },

    /***/ './node_modules/css-loader/dist/cjs.js??clonedRuleSet-14.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-14.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-14.use[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/AlertMessage.vue?vue&type=style&index=0&id=657fa342&lang=scss&scoped=true':
      /*!*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??clonedRuleSet-14.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-14.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-14.use[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/AlertMessage.vue?vue&type=style&index=0&id=657fa342&lang=scss&scoped=true ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
      /***/ (module, __webpack_exports__, __webpack_require__) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ../../../../node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ './node_modules/css-loader/dist/runtime/cssWithMappingToString.js'
          );
        /* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default =
          /*#__PURE__*/ __webpack_require__.n(
            _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__
          );
        /* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ../../../../node_modules/css-loader/dist/runtime/api.js */ './node_modules/css-loader/dist/runtime/api.js'
          );
        /* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default =
          /*#__PURE__*/ __webpack_require__.n(
            _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__
          );
        // Imports

        var ___CSS_LOADER_EXPORT___ =
          _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(
            _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()
          );
        // Module
        ___CSS_LOADER_EXPORT___.push([
          module.id,
          '.success[data-v-657fa342] {\n    --tw-border-opacity: 1;\n    border-color: rgba(var(--spring-50), var(--tw-border-opacity));\n    --tw-bg-opacity: 1;\n    background-color: rgba(var(--mint), var(--tw-bg-opacity))\n}\n.success svg[data-v-657fa342] {\n    --tw-text-opacity: 1;\n    color: rgba(var(--spring-50), var(--tw-text-opacity))\n}\n.failure[data-v-657fa342] {\n    --tw-bg-opacity: 1;\n    background-color: rgba(var(--rose), var(--tw-bg-opacity));\n    --tw-text-opacity: 1;\n    color: rgba(var(--crimson-40), var(--tw-text-opacity))\n}\n.failure svg[data-v-657fa342] {\n    --tw-text-opacity: 1;\n    color: rgba(var(--crimson-40), var(--tw-text-opacity))\n}',
          '',
          {
            version: 3,
            sources: ['<no source>', 'webpack://./AlertMessage.vue'],
            names: [],
            mappings:
              'AAAA;IAAA,sBAAA;IAAA,8DAAA;IAAA,kBAAA;IAAA;ACKA;ADLA;IAAA,oBAAA;IAAA;ACSA;ADTA;IAAA,kBAAA;IAAA,yDAAA;IAAA,oBAAA;IAAA;ACgBA;ADhBA;IAAA,oBAAA;IAAA;ACoBA',
            sourceRoot: '',
          },
        ]);
        // Exports
        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          ___CSS_LOADER_EXPORT___;

        /***/
      },

    /***/ './node_modules/css-loader/dist/cjs.js??clonedRuleSet-14.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-14.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-14.use[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/PopupModal.vue?vue&type=style&index=0&id=5a2bda58&lang=scss&scoped=true':
      /*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??clonedRuleSet-14.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-14.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-14.use[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/PopupModal.vue?vue&type=style&index=0&id=5a2bda58&lang=scss&scoped=true ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
      /***/ (module, __webpack_exports__, __webpack_require__) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ../../../../node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ './node_modules/css-loader/dist/runtime/cssWithMappingToString.js'
          );
        /* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default =
          /*#__PURE__*/ __webpack_require__.n(
            _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__
          );
        /* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ../../../../node_modules/css-loader/dist/runtime/api.js */ './node_modules/css-loader/dist/runtime/api.js'
          );
        /* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default =
          /*#__PURE__*/ __webpack_require__.n(
            _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__
          );
        // Imports

        var ___CSS_LOADER_EXPORT___ =
          _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(
            _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()
          );
        // Module
        ___CSS_LOADER_EXPORT___.push([
          module.id,
          '.modal-animation-enter-active[data-v-5a2bda58],\n.modal-animation-leave-active[data-v-5a2bda58] {\n  transition: opacity 0.5s cubic-bezier(0.52, 0.02, 0.19, 1.02);\n}\n.modal-animation-enter-from[data-v-5a2bda58],\n.modal-animation-leave-to[data-v-5a2bda58] {\n  opacity: 0;\n}\n.modal-animation-inner-enter-active[data-v-5a2bda58] {\n  transition: all 0.5s cubic-bezier(0.52, 0.02, 0.19, 1.02) 0.15s;\n}\n.modal-animation-inner-leave-active[data-v-5a2bda58] {\n  transition: all 0.5s cubic-bezier(0.52, 0.02, 0.19, 1.02);\n}\n.modal-animation-inner-enter-from[data-v-5a2bda58] {\n  opacity: 0;\n  transform: scale(0.8);\n}\n.modal-animation-inner-leave-to[data-v-5a2bda58] {\n  transform: scale(0.8);\n}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./resources/assets/js/components/PopupModal.vue',
            ],
            names: [],
            mappings:
              'AACA;;EAEE,6DAAA;AAAF;AAEA;;EAEE,UAAA;AACF;AACA;EACE,+DAAA;AAEF;AAAA;EACE,yDAAA;AAGF;AADA;EACE,UAAA;EACA,qBAAA;AAIF;AAFA;EACE,qBAAA;AAKF',
            sourcesContent: [
              '\n.modal-animation-enter-active,\n.modal-animation-leave-active {\n  transition: opacity 0.5s cubic-bezier(0.52, 0.02, 0.19, 1.02);\n}\n.modal-animation-enter-from,\n.modal-animation-leave-to {\n  opacity: 0;\n}\n.modal-animation-inner-enter-active {\n  transition: all 0.5s cubic-bezier(0.52, 0.02, 0.19, 1.02) 0.15s;\n}\n.modal-animation-inner-leave-active {\n  transition: all 0.5s cubic-bezier(0.52, 0.02, 0.19, 1.02);\n}\n.modal-animation-inner-enter-from {\n  opacity: 0;\n  transform: scale(0.8);\n}\n.modal-animation-inner-leave-to {\n  transform: scale(0.8);\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        // Exports
        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          ___CSS_LOADER_EXPORT___;

        /***/
      },

    /***/ './node_modules/css-loader/dist/runtime/api.js':
      /*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
      /***/ (module) => {
        'use strict';

        /*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
        // css base code, injected by the css-loader
        // eslint-disable-next-line func-names
        module.exports = function (cssWithMappingToString) {
          var list = []; // return the list of modules as css string

          list.toString = function toString() {
            return this.map(function (item) {
              var content = cssWithMappingToString(item);

              if (item[2]) {
                return '@media '.concat(item[2], ' {').concat(content, '}');
              }

              return content;
            }).join('');
          }; // import a list of modules into the list
          // eslint-disable-next-line func-names

          list.i = function (modules, mediaQuery, dedupe) {
            if (typeof modules === 'string') {
              // eslint-disable-next-line no-param-reassign
              modules = [[null, modules, '']];
            }

            var alreadyImportedModules = {};

            if (dedupe) {
              for (var i = 0; i < this.length; i++) {
                // eslint-disable-next-line prefer-destructuring
                var id = this[i][0];

                if (id != null) {
                  alreadyImportedModules[id] = true;
                }
              }
            }

            for (var _i = 0; _i < modules.length; _i++) {
              var item = [].concat(modules[_i]);

              if (dedupe && alreadyImportedModules[item[0]]) {
                // eslint-disable-next-line no-continue
                continue;
              }

              if (mediaQuery) {
                if (!item[2]) {
                  item[2] = mediaQuery;
                } else {
                  item[2] = ''.concat(mediaQuery, ' and ').concat(item[2]);
                }
              }

              list.push(item);
            }
          };

          return list;
        };

        /***/
      },

    /***/ './node_modules/css-loader/dist/runtime/cssWithMappingToString.js':
      /*!************************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/cssWithMappingToString.js ***!
  \************************************************************************/
      /***/ (module) => {
        'use strict';

        function _slicedToArray(arr, i) {
          return (
            _arrayWithHoles(arr) ||
            _iterableToArrayLimit(arr, i) ||
            _unsupportedIterableToArray(arr, i) ||
            _nonIterableRest()
          );
        }

        function _nonIterableRest() {
          throw new TypeError(
            'Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
          );
        }

        function _unsupportedIterableToArray(o, minLen) {
          if (!o) return;
          if (typeof o === 'string') return _arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === 'Object' && o.constructor) n = o.constructor.name;
          if (n === 'Map' || n === 'Set') return Array.from(o);
          if (
            n === 'Arguments' ||
            /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
          )
            return _arrayLikeToArray(o, minLen);
        }

        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        }

        function _iterableToArrayLimit(arr, i) {
          var _i =
            arr &&
            ((typeof Symbol !== 'undefined' && arr[Symbol.iterator]) ||
              arr['@@iterator']);
          if (_i == null) return;
          var _arr = [];
          var _n = true;
          var _d = false;
          var _s, _e;
          try {
            for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i['return'] != null) _i['return']();
            } finally {
              if (_d) throw _e;
            }
          }
          return _arr;
        }

        function _arrayWithHoles(arr) {
          if (Array.isArray(arr)) return arr;
        }

        module.exports = function cssWithMappingToString(item) {
          var _item = _slicedToArray(item, 4),
            content = _item[1],
            cssMapping = _item[3];

          if (!cssMapping) {
            return content;
          }

          if (typeof btoa === 'function') {
            // eslint-disable-next-line no-undef
            var base64 = btoa(
              unescape(encodeURIComponent(JSON.stringify(cssMapping)))
            );
            var data =
              'sourceMappingURL=data:application/json;charset=utf-8;base64,'.concat(
                base64
              );
            var sourceMapping = '/*# '.concat(data, ' */');
            var sourceURLs = cssMapping.sources.map(function (source) {
              return '/*# sourceURL='
                .concat(cssMapping.sourceRoot || '')
                .concat(source, ' */');
            });
            return [content]
              .concat(sourceURLs)
              .concat([sourceMapping])
              .join('\n');
          }

          return [content].join('\n');
        };

        /***/
      },

    /***/ './resources/assets/images/svg/alert.svg':
      /*!***********************************************!*\
  !*** ./resources/assets/images/svg/alert.svg ***!
  \***********************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          '<svg viewBox="0 0 21 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.464 1.667C5.88 1.667 2.13 5.417 2.13 10c0 4.584 3.75 8.334 8.333 8.334s8.333-3.75 8.333-8.334c0-4.583-3.75-8.333-8.333-8.333Zm0 12.5c-.5 0-.833-.333-.833-.833 0-.5.333-.834.833-.834.5 0 .833.334.833.834 0 .5-.333.833-.833.833ZM11.297 10c0 .5-.333.834-.833.834-.5 0-.833-.334-.833-.834V6.667c0-.5.333-.833.833-.833.5 0 .833.333.833.833V10Z" fill="currentColor"/></svg>';

        /***/
      },

    /***/ './resources/assets/images/svg/approved-cloud.svg':
      /*!********************************************************!*\
  !*** ./resources/assets/images/svg/approved-cloud.svg ***!
  \********************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 16 16"><path fill="currentColor" d="m9.527 9.46-2.194 2.194-.86-.86a.668.668 0 1 0-.946.94l1.333 1.333a.666.666 0 0 0 .947 0l2.666-2.667a.667.667 0 1 0-.946-.94Zm2.753-3.913a4.667 4.667 0 0 0-8.907 1.267 2.667 2.667 0 0 0-.253 5.1.668.668 0 1 0 .427-1.247 1.333 1.333 0 0 1-.88-1.267A1.333 1.333 0 0 1 4 8.067a.667.667 0 0 0 .667-.667 3.333 3.333 0 0 1 6.486-1.066.668.668 0 0 0 .52.44 2 2 0 0 1 .16 3.893A.672.672 0 1 0 12 12h.167a3.333 3.333 0 0 0 .113-6.413v-.04Z"/></svg>';

        /***/
      },

    /***/ './resources/assets/images/svg/arrow-left.svg':
      /*!****************************************************!*\
  !*** ./resources/assets/images/svg/arrow-left.svg ***!
  \****************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          '<svg viewBox="0 0 8 12" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 1.054 6.805 0 0 6l6.805 6L8 10.947 2.39 6 8 1.054Z" fill="currentColor"/></svg>';

        /***/
      },

    /***/ './resources/assets/images/svg/arrow-right.svg':
      /*!*****************************************************!*\
  !*** ./resources/assets/images/svg/arrow-right.svg ***!
  \*****************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          '<svg viewBox="0 0 8 12" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0 1.054 1.195 0 8 6l-6.805 6L0 10.947 5.61 6 0 1.054Z" fill="currentColor"/></svg>';

        /***/
      },

    /***/ './resources/assets/images/svg/ascending-arrow.svg':
      /*!*********************************************************!*\
  !*** ./resources/assets/images/svg/ascending-arrow.svg ***!
  \*********************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 17 16"><path fill="currentColor" d="M5.955 10.333h4.67l-2.336 2.253-2.334-2.253Zm1.844 3.194c.27.26.704.26.974 0l3.17-3.06c.436-.414.132-1.134-.483-1.134H5.126c-.615 0-.926.72-.49 1.14l3.163 3.053Zm-2.68-6.86h6.341c.615 0 .926-.72.49-1.14l-3.17-3.06a.706.706 0 0 0-.974 0l-3.17 3.06c-.436.42-.132 1.14.483 1.14Z"/></svg>';

        /***/
      },

    /***/ './resources/assets/images/svg/checkbox.svg':
      /*!**************************************************!*\
  !*** ./resources/assets/images/svg/checkbox.svg ***!
  \**************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 20 20"><path fill="currentColor" stroke="currentColor" d="M17.167 3.334v-.5h-11v11h11v-10.5ZM8.204 8.75l.463-.466 1.37 1.376.355.357.354-.357 3.92-3.95.463.465-4.737 4.78L8.204 8.75Zm-5.37 7.916v.5H14.5v.667H3.333c-.64 0-1.166-.526-1.166-1.167V5.5h.666v11.167Zm3.833-14.5h10c.64 0 1.166.526 1.166 1.167v10c0 .64-.526 1.166-1.166 1.166h-10c-.64 0-1.167-.526-1.167-1.166v-10c0-.64.526-1.167 1.167-1.167Z"/></svg>';

        /***/
      },

    /***/ './resources/assets/images/svg/close.svg':
      /*!***********************************************!*\
  !*** ./resources/assets/images/svg/close.svg ***!
  \***********************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          '<svg viewBox="0 0 18 19" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9 2.434c-4.125 0-7.5 3.375-7.5 7.5s3.375 7.5 7.5 7.5 7.5-3.375 7.5-7.5-3.375-7.5-7.5-7.5Zm2.775 9.225c.3.3.3.75 0 1.05-.3.3-.75.3-1.05 0L9 10.984l-1.725 1.725c-.3.3-.75.3-1.05 0-.3-.3-.3-.75 0-1.05L7.95 9.934 6.225 8.209c-.3-.3-.3-.75 0-1.05.3-.3.75-.3 1.05 0L9 8.884l1.725-1.725c.3-.3.75-.3 1.05 0 .3.3.3.75 0 1.05L10.05 9.934l1.725 1.725Z" fill="#E34D5B"/></svg>';

        /***/
      },

    /***/ './resources/assets/images/svg/delete.svg':
      /*!************************************************!*\
  !*** ./resources/assets/images/svg/delete.svg ***!
  \************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 12 14"><path fill="currentColor" stroke="currentColor" d="M8.167 3v.5h3.166a.167.167 0 0 1 0 .333h-1.166v7.833a1.5 1.5 0 0 1-1.5 1.5H3.333a1.5 1.5 0 0 1-1.06-.439l-.354.354.354-.354a1.5 1.5 0 0 1-.44-1.06V3.832H.667a.167.167 0 1 1 0-.333h3.166V2.333a1.5 1.5 0 0 1 1.5-1.5h1.334a1.5 1.5 0 0 1 1.5 1.5V3Zm-.834.5h.5V2.333a1.167 1.167 0 0 0-1.166-1.167H5.333a1.167 1.167 0 0 0-1.166 1.167V3.5h3.166Zm-4.666.333h-.5v7.833a1.167 1.167 0 0 0 1.166 1.167h5.334a1.167 1.167 0 0 0 1.166-1.167V3.833H2.667Zm2.118 6.618a.167.167 0 0 1-.285-.118v-4a.167.167 0 1 1 .333 0v4a.167.167 0 0 1-.048.118Zm2.666 0a.167.167 0 0 1-.284-.118v-4a.167.167 0 0 1 .333 0v4a.167.167 0 0 1-.049.118Z"/></svg>';

        /***/
      },

    /***/ './resources/assets/images/svg/descending-arrow.svg':
      /*!**********************************************************!*\
  !*** ./resources/assets/images/svg/descending-arrow.svg ***!
  \**********************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 17 16"><path fill="currentColor" d="M10.624 5.667h-4.67L8.29 3.414l2.335 2.253ZM8.78 2.474a.706.706 0 0 0-.974 0l-3.17 3.06c-.436.413-.132 1.133.483 1.133h6.334c.615 0 .926-.72.49-1.14L8.78 2.474Zm2.68 6.86H5.119c-.615 0-.926.72-.49 1.14l3.17 3.06c.27.26.704.26.974 0l3.17-3.06c.436-.42.132-1.14-.483-1.14Z"/></svg>';

        /***/
      },

    /***/ './resources/assets/images/svg/document-write.svg':
      /*!********************************************************!*\
  !*** ./resources/assets/images/svg/document-write.svg ***!
  \********************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 16 16"><path fill="currentColor" d="m13.807 11.14-1.614-1.614a.666.666 0 0 0-.946 0L8.86 11.913a.667.667 0 0 0-.193.473V14a.667.667 0 0 0 .666.666h1.614a.668.668 0 0 0 .473-.193l2.387-2.387a.667.667 0 0 0 0-.946Zm-3.14 2.193H10v-.667l1.72-1.72.667.667-1.72 1.72Zm-4 0H4a.666.666 0 0 1-.667-.667V3.333A.667.667 0 0 1 4 2.666h3.333v2a2 2 0 0 0 2 2h2v.667a.667.667 0 0 0 1.334 0V5.96a.88.88 0 0 0-.04-.18v-.06a.714.714 0 0 0-.127-.187l-4-4a.713.713 0 0 0-.187-.127.213.213 0 0 0-.06 0l-.213-.073H4a2 2 0 0 0-2 2v9.333a2 2 0 0 0 2 2h2.667a.667.667 0 1 0 0-1.333Zm2-9.727 1.726 1.727h-1.06a.667.667 0 0 1-.666-.667v-1.06ZM5.333 9.333h4a.667.667 0 0 0 0-1.333h-4a.667.667 0 1 0 0 1.333Zm0-2.667H6a.667.667 0 0 0 0-1.333h-.667a.667.667 0 0 0 0 1.333Zm1.334 4H5.333a.667.667 0 0 0 0 1.334h1.334a.667.667 0 0 0 0-1.334Z"/></svg>';

        /***/
      },

    /***/ './resources/assets/images/svg/download-file.svg':
      /*!*******************************************************!*\
  !*** ./resources/assets/images/svg/download-file.svg ***!
  \*******************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 16 16"><path fill="currentColor" stroke="currentColor" d="m12.796 5.87.023.07a.305.305 0 0 1 .014.054v6.672a1.5 1.5 0 0 1-1.5 1.5H4.667a1.5 1.5 0 0 1-1.5-1.5V3.333a1.5 1.5 0 0 1 1.5-1.5h3.978a.233.233 0 0 1 .033.014l.11.06h.045l3.963 3.962Zm-3.11-2.617-.853-.854v2.267A1.167 1.167 0 0 0 10 5.833h2.267l-.853-.854-1.727-1.726ZM8.5 2.666v-.5H4.667A1.167 1.167 0 0 0 3.5 3.333v9.333a1.167 1.167 0 0 0 1.167 1.167h6.666a1.167 1.167 0 0 0 1.167-1.167v-6.5H10a1.5 1.5 0 0 1-1.5-1.5v-2Zm-.333 7.06v1.237l.86-.89.189-.195a.17.17 0 0 1 .237.242l-1.328 1.328a.167.167 0 0 1-.052.032l-.011.004-.01.005a.127.127 0 0 1-.103 0l-.01-.005-.012-.004a.167.167 0 0 1-.052-.032l-1.328-1.329a.17.17 0 0 1 .237-.241l.19.196.86.889V8a.167.167 0 0 1 .333 0v1.726Z"/></svg>';

        /***/
      },

    /***/ './resources/assets/images/svg/folder.svg':
      /*!************************************************!*\
  !*** ./resources/assets/images/svg/folder.svg ***!
  \************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 94 94"><path fill="url(#a)" d="M17.603 26.274c0-2.379 0-3.569.47-4.474a4.177 4.177 0 0 1 1.782-1.782c.905-.47 2.095-.47 4.474-.47h17.557c1.013 0 1.519 0 1.996.114.406.096.795.253 1.154.465.423.249.787.6 1.516 1.302l.432.416c.729.702 1.093 1.053 1.516 1.302.36.212.748.369 1.154.465.477.114.983.114 1.995.114h17.718c2.38 0 3.57 0 4.475.47a4.177 4.177 0 0 1 1.781 1.782c.47.905.47 2.095.47 4.474v40.046c0 1.19 0 1.784-.234 2.237-.199.381-.51.692-.891.89-.453.236-1.048.236-2.237.236H23.657c-2.142 0-3.212 0-4.027-.424a3.76 3.76 0 0 1-1.604-1.603c-.423-.815-.423-1.886-.423-4.027V26.274Z"/><g filter="url(#b)"><path fill="#B9DDFF" fill-opacity=".6" d="M33.09 38.39c.59-2.032.886-3.048 1.666-3.633.78-.586 1.838-.586 3.954-.586h38.531c3.332 0 4.998 0 5.876 1.082.878 1.082.534 2.712-.152 5.972l-5.893 27.992c-.468 2.225-.703 3.337-1.508 3.99-.805.654-1.942.654-4.216.654H21.781c2.161-2.35 2.161-4.7 4.322-11.75 1.55-5.058 5.103-17.24 6.987-23.72Z"/><path stroke="url(#c)" stroke-width=".39" d="M38.71 34.366h38.531c1.672 0 2.905 0 3.83.133.92.132 1.5.39 1.894.877.395.486.528 1.105.468 2.033-.06.933-.314 2.14-.659 3.776l-5.893 27.992c-.235 1.117-.408 1.938-.621 2.561-.211.62-.455 1.023-.819 1.318-.364.295-.809.45-1.458.53-.654.08-1.493.08-2.635.08H22.212c.92-1.1 1.421-2.244 1.917-3.86.224-.734.45-1.569.711-2.542l.168-.623a134.82 134.82 0 0 1 1.282-4.473c1.55-5.06 5.104-17.243 6.987-23.723.297-1.02.515-1.77.755-2.338.238-.564.49-.93.842-1.194.352-.265.774-.404 1.381-.475.613-.072 1.393-.072 2.455-.072Z"/></g><path fill="url(#d)" fill-opacity=".9" stroke="url(#e)" stroke-width=".312" d="M28.048 23.883h8.356a1.933 1.933 0 1 1 0 3.866h-8.356a1.933 1.933 0 0 1 0-3.866Z"/><defs><linearGradient id="a" x1="34.475" x2="78.609" y1="31.429" y2="47.774" gradientUnits="userSpaceOnUse"><stop stop-color="#7FC0FB"/><stop offset="1" stop-color="#4088F4"/></linearGradient><linearGradient id="c" x1="18.648" x2="40.8" y1="37.006" y2="90.426" gradientUnits="userSpaceOnUse"><stop stop-color="#fff"/><stop offset=".766" stop-color="#fff" stop-opacity="0"/></linearGradient><linearGradient id="d" x1="25.006" x2="42.161" y1="23.447" y2="28.516" gradientUnits="userSpaceOnUse"><stop stop-color="#fff"/><stop offset="1" stop-color="#fff" stop-opacity="0"/></linearGradient><linearGradient id="e" x1="23.837" x2="32.226" y1="24.617" y2="27.904" gradientUnits="userSpaceOnUse"><stop stop-color="#fff"/><stop offset="1" stop-color="#fff" stop-opacity="0"/></linearGradient><filter id="b" width="78.572" height="56.402" x="13.425" y="25.815" color-interpolation-filters="sRGB" filterUnits="userSpaceOnUse"><feFlood flood-opacity="0" result="BackgroundImageFix"/><feGaussianBlur in="BackgroundImage" stdDeviation="4.178"/><feComposite in2="SourceAlpha" operator="in" result="effect1_backgroundBlur_1426_16551"/><feBlend in="SourceGraphic" in2="effect1_backgroundBlur_1426_16551" result="shape"/></filter></defs></svg>';

        /***/
      },

    /***/ './resources/assets/images/svg/history.svg':
      /*!*************************************************!*\
  !*** ./resources/assets/images/svg/history.svg ***!
  \*************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 16 16"><path fill="currentColor" d="M11.333 2.2c-2.6-1.467-5.8-1-7.933 1V2c0-.4-.267-.667-.667-.667S2.067 1.6 2.067 2v3c0 .4.266.666.666.666h3c.4 0 .667-.266.667-.666s-.267-.667-.667-.667h-1.6c1-1.067 2.4-1.667 3.867-1.667 2.933 0 5.333 2.4 5.333 5.334 0 2.933-2.4 5.333-5.333 5.333-2.933 0-5.333-2.4-5.333-5.333 0-.4-.267-.667-.667-.667S1.333 7.6 1.333 8c0 3.666 3 6.666 6.667 6.666 2.4 0 4.6-1.266 5.8-3.333 1.8-3.2.733-7.267-2.467-9.133ZM8 5.333c-.4 0-.667.267-.667.667v2c0 .4.267.666.667.666h1.333c.4 0 .667-.266.667-.666s-.267-.667-.667-.667h-.666V6c0-.4-.267-.667-.667-.667Z"/></svg>';

        /***/
      },

    /***/ './resources/assets/images/svg/logo.svg':
      /*!**********************************************!*\
  !*** ./resources/assets/images/svg/logo.svg ***!
  \**********************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          '<svg viewBox="0 0 122 36" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M44.019 27V16.979h3.247c1.23 0 2.032.05 2.406.15.574.15 1.055.478 1.442.984.388.502.581 1.151.581 1.948 0 .616-.111 1.133-.335 1.552-.223.42-.508.75-.854.992-.342.236-.69.394-1.046.471-.483.096-1.183.144-2.099.144h-1.319V27h-2.023Zm2.023-8.326v2.844h1.107c.798 0 1.331-.053 1.6-.158a1.333 1.333 0 0 0 .861-1.271c0-.365-.107-.665-.32-.902a1.399 1.399 0 0 0-.814-.445c-.242-.045-.727-.068-1.456-.068h-.978Zm7.02-1.695h2.024v5.427c0 .862.025 1.42.075 1.675.087.41.292.74.616.991.328.246.774.37 1.34.37.574 0 1.007-.117 1.298-.35.292-.236.467-.526.527-.867.059-.342.089-.91.089-1.703V16.98h2.023v5.263c0 1.203-.055 2.053-.164 2.55-.11.497-.312.916-.608 1.258-.292.342-.684.615-1.176.82-.492.2-1.135.3-1.928.3-.957 0-1.684-.109-2.18-.327-.493-.224-.883-.51-1.17-.862a2.788 2.788 0 0 1-.567-1.114c-.132-.574-.198-1.422-.198-2.543v-5.346Zm9.858 0h4.006c.793 0 1.383.034 1.77.102.393.064.741.2 1.047.41.31.21.567.49.772.841.205.346.308.736.308 1.169 0 .47-.128.9-.383 1.292a2.33 2.33 0 0 1-1.025.882c.61.177 1.08.48 1.408.909.328.428.492.932.492 1.51 0 .456-.107.9-.321 1.334-.21.428-.5.772-.868 1.032-.365.255-.816.412-1.354.472-.337.036-1.15.059-2.44.068H62.92V16.979Zm2.024 1.668v2.317h1.326c.788 0 1.278-.011 1.47-.034.346-.041.617-.16.813-.356.2-.2.301-.462.301-.786 0-.31-.087-.56-.26-.752-.168-.196-.421-.314-.758-.355-.201-.023-.778-.035-1.73-.035h-1.162Zm0 3.985v2.68h1.873c.73 0 1.192-.021 1.388-.062.3-.055.544-.187.731-.396.191-.215.287-.5.287-.855 0-.3-.073-.556-.219-.766a1.237 1.237 0 0 0-.635-.458c-.274-.095-.87-.143-1.791-.143h-1.634ZM72.805 27v-9.94h2.024v8.252h5.031V27h-7.055Zm8.163 0V16.979h2.023V27h-2.023Zm3.165-3.26 1.969-.192c.118.66.358 1.146.718 1.456.364.31.854.465 1.47.465.651 0 1.141-.137 1.47-.41.332-.278.498-.602.498-.971a.89.89 0 0 0-.212-.602c-.136-.168-.378-.314-.724-.437-.237-.082-.777-.228-1.62-.438-1.085-.269-1.846-.599-2.284-.99-.615-.552-.922-1.224-.922-2.017 0-.51.143-.987.43-1.43.292-.446.709-.785 1.251-1.018.547-.232 1.206-.348 1.976-.348 1.257 0 2.203.275 2.837.827.638.551.973 1.287 1.005 2.208l-2.024.089c-.087-.515-.273-.884-.56-1.108-.283-.228-.71-.342-1.279-.342-.588 0-1.048.121-1.38.363a.73.73 0 0 0-.322.622c0 .237.1.44.3.608.256.214.876.438 1.86.67.985.232 1.712.474 2.18.725.475.246.844.585 1.108 1.018.27.429.404.96.404 1.593 0 .574-.16 1.112-.479 1.613-.319.502-.77.875-1.353 1.121-.584.242-1.31.363-2.181.363-1.267 0-2.24-.292-2.919-.875-.679-.588-1.085-1.443-1.217-2.564ZM93.711 27V16.979h2.023v3.944H99.7v-3.944h2.023V27h-2.023v-4.382h-3.965V27h-2.023Zm9.83 0V16.979h7.431v1.695h-5.408v2.221h5.032v1.689h-5.032v2.727h5.599V27h-7.622Zm9.065 0V16.979h4.258c1.071 0 1.848.09 2.332.273a2.28 2.28 0 0 1 1.168.957c.292.46.438.987.438 1.58 0 .751-.221 1.373-.663 1.865-.442.488-1.103.796-1.983.923.438.255.798.536 1.081.841.287.305.672.848 1.155 1.627L121.615 27h-2.419l-1.463-2.18c-.52-.78-.875-1.27-1.067-1.47a1.503 1.503 0 0 0-.608-.417c-.214-.078-.554-.117-1.019-.117h-.41V27h-2.023Zm2.023-5.783h1.497c.971 0 1.577-.041 1.819-.123.241-.082.43-.224.567-.424.137-.2.205-.451.205-.752 0-.337-.091-.608-.273-.813-.178-.21-.431-.342-.759-.397-.164-.023-.656-.034-1.477-.034h-1.579v2.543Z" fill="#fff"/><path fill="url(#a)" d="M0 0h41v36H0z"/><defs><pattern id="a" patternContentUnits="objectBoundingBox" width="1" height="1"><use xlink:href="#b" transform="matrix(.00093 0 0 .00106 -.122 -.007)"/></pattern><image id="b" width="2235" height="959" xlink:href="data:image/png;base64,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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcHr+A3LBd4aw8UyLAAAAAElFTkSuQmCC"/></defs></svg>';

        /***/
      },

    /***/ './resources/assets/images/svg/plus.svg':
      /*!**********************************************!*\
  !*** ./resources/assets/images/svg/plus.svg ***!
  \**********************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 16 16"><path fill="currentColor" stroke="currentColor" stroke-width=".667" d="M8.333 7.333v.333h2.334a.333.333 0 1 1 0 .667H8.333v2.333a.333.333 0 1 1-.666 0V8.333H5.333a.333.333 0 0 1 0-.667h2.334V5.333a.333.333 0 1 1 .666 0v2Zm-3.852-4.6a6.333 6.333 0 1 1 7.038 10.533A6.333 6.333 0 0 1 4.48 2.734Zm.37 9.978a5.666 5.666 0 1 0 6.297-9.422 5.666 5.666 0 0 0-6.296 9.422Z"/></svg>';

        /***/
      },

    /***/ './resources/assets/images/svg/publish.svg':
      /*!*************************************************!*\
  !*** ./resources/assets/images/svg/publish.svg ***!
  \*************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 17 16"><path fill="currentColor" stroke="currentColor" stroke-width=".667" d="M8.167 3.6v-.805l-.57.569-.866.867a.312.312 0 0 1-.462 0 .312.312 0 0 1 0-.462l2-2-.234-.235.234.235a.312.312 0 0 1 .462 0l.233-.234-.233.234 2 2a.312.312 0 0 1 0 .462.368.368 0 0 1-.108.08.292.292 0 0 1-.123.022.292.292 0 0 1-.123-.021.368.368 0 0 1-.108-.081l-.867-.867-.569-.57v8.539c0 .124-.04.202-.085.248-.046.045-.124.085-.248.085s-.202-.04-.248-.085c-.045-.046-.085-.124-.085-.248V3.6Zm3 2.733H12.5c.95 0 1.667.717 1.667 1.667v4.666c0 .95-.718 1.667-1.667 1.667h-8c-.95 0-1.667-.717-1.667-1.667V8c0-.95.718-1.667 1.667-1.667h1.333c.125 0 .202.04.248.086.046.045.086.123.086.247 0 .125-.04.202-.086.248-.046.046-.123.086-.248.086H4.5a1 1 0 0 0-.719.28A1 1 0 0 0 3.5 8v4.666a1 1 0 0 0 .281.72 1 1 0 0 0 .719.28h8a1 1 0 0 0 .719-.28 1 1 0 0 0 .281-.72V8a1 1 0 0 0-.281-.72A1 1 0 0 0 12.5 7h-1.333c-.125 0-.202-.04-.248-.086-.046-.046-.086-.123-.086-.248 0-.124.04-.202.086-.247.046-.046.123-.086.248-.086Z"/></svg>';

        /***/
      },

    /***/ './resources/assets/images/svg/question-mark.svg':
      /*!*******************************************************!*\
  !*** ./resources/assets/images/svg/question-mark.svg ***!
  \*******************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 15 14"><path fill="currentColor" stroke="currentColor" stroke-width=".667" d="M7.5 4.666a1 1 0 0 0-.869.5l-.006.012a.333.333 0 0 1-.203.166l.093.32-.093-.32a.333.333 0 0 1-.36-.12l-.266.2.267-.2a.333.333 0 0 1-.015-.379l.004-.006.003-.006A1.667 1.667 0 0 1 7.5 4a1.667 1.667 0 0 1 .554 3.233l-.22.08v.353a.333.333 0 1 1-.666 0V7a.333.333 0 0 1 .333-.334 1 1 0 0 0 0-2Zm0 0V5l.001-.334Zm-.316 4.898.01-.02.008-.023a.173.173 0 0 1 .02-.039 1.2 1.2 0 0 1 .046-.06.333.333 0 0 1 .104-.067l-.128-.308.128.308a.333.333 0 0 1 .365.073.333.333 0 0 1 .096.236v.015a.333.333 0 0 1-.02.126v.001a.267.267 0 0 1-.062.098l.236.236-.236-.236a.267.267 0 0 1-.098.062l-.01.004-.011.005a.293.293 0 0 1-.237 0l-.01-.005-.012-.004a.267.267 0 0 1-.097-.062l-.236.236.236-.236a.267.267 0 0 1-.063-.098l-.005-.014-.007-.015a.227.227 0 0 1-.021-.102v-.033a.573.573 0 0 1-.002-.064.094.094 0 0 1 .006-.014ZM3.98 1.734a6.333 6.333 0 1 1 7.038 10.532A6.333 6.333 0 0 1 3.98 1.734Zm.37 9.977a5.666 5.666 0 1 0 6.297-9.422 5.666 5.666 0 0 0-6.296 9.422Z"/></svg>';

        /***/
      },

    /***/ './resources/assets/images/svg/tick.svg':
      /*!**********************************************!*\
  !*** ./resources/assets/images/svg/tick.svg ***!
  \**********************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 16 16"><path fill="#fff" d="M6.875 10.729a.665.665 0 0 1-.471-.196L4.529 8.658a.667.667 0 0 1 .942-.942l1.404 1.403 3.654-3.653a.667.667 0 0 1 .942.942l-4.125 4.125a.664.664 0 0 1-.471.196Z" opacity=".99"/><path fill="currentColor" d="M8 1.333A6.667 6.667 0 1 0 14.667 8 6.674 6.674 0 0 0 8 1.333Zm3.471 5.076-4.125 4.125a.667.667 0 0 1-.942 0L4.529 8.659a.667.667 0 0 1 .942-.943l1.404 1.403 3.654-3.653a.667.667 0 0 1 .942.943Z"/></svg>';

        /***/
      },

    /***/ './resources/assets/images/svg/user-profile.svg':
      /*!******************************************************!*\
  !*** ./resources/assets/images/svg/user-profile.svg ***!
  \******************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          '<svg viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="m3.837 11.643-.128.314.243.235A5.833 5.833 0 0 0 8 13.833h.002a5.833 5.833 0 0 0 4.047-1.64l.243-.236-.129-.314a4.5 4.5 0 0 0-8.325 0Zm8.338-.724.43.736.433-.736A5.78 5.78 0 0 0 13.833 8 5.833 5.833 0 0 0 2.167 8a5.78 5.78 0 0 0 .795 2.92l.432.736.43-.737a4.833 4.833 0 0 1 2.363-2.042l.655-.265-.467-.53a2.167 2.167 0 1 1 3.25 0l-.467.53.655.265a4.833 4.833 0 0 1 2.362 2.042ZM4.635 2.84c1-.655 2.17-1.005 3.365-1.007a6.166 6.166 0 0 1 4.532 10.335 6.167 6.167 0 0 1-9.064 0A6.167 6.167 0 0 1 4.635 2.84Zm1.84 2.808a1.833 1.833 0 1 0 3.05 2.037 1.833 1.833 0 0 0-3.05-2.037Z" fill="transparent" stroke="currentColor"/></svg>';

        /***/
      },

    /***/ './node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-14.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-14.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-14.use[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/AlertMessage.vue?vue&type=style&index=0&id=657fa342&lang=scss&scoped=true':
      /*!*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-14.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-14.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-14.use[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/AlertMessage.vue?vue&type=style&index=0&id=657fa342&lang=scss&scoped=true ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! !../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ './node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js'
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default =
          /*#__PURE__*/ __webpack_require__.n(
            _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__
          );
        /* harmony import */ var _node_modules_css_loader_dist_cjs_js_clonedRuleSet_14_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_14_use_2_node_modules_sass_loader_dist_cjs_js_clonedRuleSet_14_use_3_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_AlertMessage_vue_vue_type_style_index_0_id_657fa342_lang_scss_scoped_true__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! !!../../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-14.use[1]!../../../../node_modules/vue-loader/dist/stylePostLoader.js!../../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-14.use[2]!../../../../node_modules/sass-loader/dist/cjs.js??clonedRuleSet-14.use[3]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./AlertMessage.vue?vue&type=style&index=0&id=657fa342&lang=scss&scoped=true */ './node_modules/css-loader/dist/cjs.js??clonedRuleSet-14.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-14.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-14.use[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/AlertMessage.vue?vue&type=style&index=0&id=657fa342&lang=scss&scoped=true'
          );

        var options = {};

        options.insert = 'head';
        options.singleton = false;

        var update =
          _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(
            _node_modules_css_loader_dist_cjs_js_clonedRuleSet_14_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_14_use_2_node_modules_sass_loader_dist_cjs_js_clonedRuleSet_14_use_3_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_AlertMessage_vue_vue_type_style_index_0_id_657fa342_lang_scss_scoped_true__WEBPACK_IMPORTED_MODULE_1__[
              'default'
            ],
            options
          );

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          _node_modules_css_loader_dist_cjs_js_clonedRuleSet_14_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_14_use_2_node_modules_sass_loader_dist_cjs_js_clonedRuleSet_14_use_3_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_AlertMessage_vue_vue_type_style_index_0_id_657fa342_lang_scss_scoped_true__WEBPACK_IMPORTED_MODULE_1__[
            'default'
          ].locals || {};

        /***/
      },

    /***/ './node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-14.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-14.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-14.use[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/PopupModal.vue?vue&type=style&index=0&id=5a2bda58&lang=scss&scoped=true':
      /*!***********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-14.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-14.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-14.use[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/PopupModal.vue?vue&type=style&index=0&id=5a2bda58&lang=scss&scoped=true ***!
  \***********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! !../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ './node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js'
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default =
          /*#__PURE__*/ __webpack_require__.n(
            _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__
          );
        /* harmony import */ var _node_modules_css_loader_dist_cjs_js_clonedRuleSet_14_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_14_use_2_node_modules_sass_loader_dist_cjs_js_clonedRuleSet_14_use_3_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_PopupModal_vue_vue_type_style_index_0_id_5a2bda58_lang_scss_scoped_true__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! !!../../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-14.use[1]!../../../../node_modules/vue-loader/dist/stylePostLoader.js!../../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-14.use[2]!../../../../node_modules/sass-loader/dist/cjs.js??clonedRuleSet-14.use[3]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./PopupModal.vue?vue&type=style&index=0&id=5a2bda58&lang=scss&scoped=true */ './node_modules/css-loader/dist/cjs.js??clonedRuleSet-14.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-14.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-14.use[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/PopupModal.vue?vue&type=style&index=0&id=5a2bda58&lang=scss&scoped=true'
          );

        var options = {};

        options.insert = 'head';
        options.singleton = false;

        var update =
          _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(
            _node_modules_css_loader_dist_cjs_js_clonedRuleSet_14_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_14_use_2_node_modules_sass_loader_dist_cjs_js_clonedRuleSet_14_use_3_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_PopupModal_vue_vue_type_style_index_0_id_5a2bda58_lang_scss_scoped_true__WEBPACK_IMPORTED_MODULE_1__[
              'default'
            ],
            options
          );

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          _node_modules_css_loader_dist_cjs_js_clonedRuleSet_14_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_14_use_2_node_modules_sass_loader_dist_cjs_js_clonedRuleSet_14_use_3_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_PopupModal_vue_vue_type_style_index_0_id_5a2bda58_lang_scss_scoped_true__WEBPACK_IMPORTED_MODULE_1__[
            'default'
          ].locals || {};

        /***/
      },

    /***/ './node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js':
      /*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
      /***/ (module, __unused_webpack_exports, __webpack_require__) => {
        'use strict';

        var isOldIE = (function isOldIE() {
          var memo;
          return function memorize() {
            if (typeof memo === 'undefined') {
              // Test for IE <= 9 as proposed by Browserhacks
              // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
              // Tests for existence of standard globals is to allow style-loader
              // to operate correctly into non-standard environments
              // @see https://github.com/webpack-contrib/style-loader/issues/177
              memo = Boolean(
                window && document && document.all && !window.atob
              );
            }

            return memo;
          };
        })();

        var getTarget = (function getTarget() {
          var memo = {};
          return function memorize(target) {
            if (typeof memo[target] === 'undefined') {
              var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

              if (
                window.HTMLIFrameElement &&
                styleTarget instanceof window.HTMLIFrameElement
              ) {
                try {
                  // This will throw an exception if access to iframe is blocked
                  // due to cross-origin restrictions
                  styleTarget = styleTarget.contentDocument.head;
                } catch (e) {
                  // istanbul ignore next
                  styleTarget = null;
                }
              }

              memo[target] = styleTarget;
            }

            return memo[target];
          };
        })();

        var stylesInDom = [];

        function getIndexByIdentifier(identifier) {
          var result = -1;

          for (var i = 0; i < stylesInDom.length; i++) {
            if (stylesInDom[i].identifier === identifier) {
              result = i;
              break;
            }
          }

          return result;
        }

        function modulesToDom(list, options) {
          var idCountMap = {};
          var identifiers = [];

          for (var i = 0; i < list.length; i++) {
            var item = list[i];
            var id = options.base ? item[0] + options.base : item[0];
            var count = idCountMap[id] || 0;
            var identifier = ''.concat(id, ' ').concat(count);
            idCountMap[id] = count + 1;
            var index = getIndexByIdentifier(identifier);
            var obj = {
              css: item[1],
              media: item[2],
              sourceMap: item[3],
            };

            if (index !== -1) {
              stylesInDom[index].references++;
              stylesInDom[index].updater(obj);
            } else {
              stylesInDom.push({
                identifier: identifier,
                updater: addStyle(obj, options),
                references: 1,
              });
            }

            identifiers.push(identifier);
          }

          return identifiers;
        }

        function insertStyleElement(options) {
          var style = document.createElement('style');
          var attributes = options.attributes || {};

          if (typeof attributes.nonce === 'undefined') {
            var nonce = true ? __webpack_require__.nc : 0;

            if (nonce) {
              attributes.nonce = nonce;
            }
          }

          Object.keys(attributes).forEach(function (key) {
            style.setAttribute(key, attributes[key]);
          });

          if (typeof options.insert === 'function') {
            options.insert(style);
          } else {
            var target = getTarget(options.insert || 'head');

            if (!target) {
              throw new Error(
                "Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid."
              );
            }

            target.appendChild(style);
          }

          return style;
        }

        function removeStyleElement(style) {
          // istanbul ignore if
          if (style.parentNode === null) {
            return false;
          }

          style.parentNode.removeChild(style);
        }
        /* istanbul ignore next  */

        var replaceText = (function replaceText() {
          var textStore = [];
          return function replace(index, replacement) {
            textStore[index] = replacement;
            return textStore.filter(Boolean).join('\n');
          };
        })();

        function applyToSingletonTag(style, index, remove, obj) {
          var css = remove
            ? ''
            : obj.media
            ? '@media '.concat(obj.media, ' {').concat(obj.css, '}')
            : obj.css; // For old IE

          /* istanbul ignore if  */

          if (style.styleSheet) {
            style.styleSheet.cssText = replaceText(index, css);
          } else {
            var cssNode = document.createTextNode(css);
            var childNodes = style.childNodes;

            if (childNodes[index]) {
              style.removeChild(childNodes[index]);
            }

            if (childNodes.length) {
              style.insertBefore(cssNode, childNodes[index]);
            } else {
              style.appendChild(cssNode);
            }
          }
        }

        function applyToTag(style, options, obj) {
          var css = obj.css;
          var media = obj.media;
          var sourceMap = obj.sourceMap;

          if (media) {
            style.setAttribute('media', media);
          } else {
            style.removeAttribute('media');
          }

          if (sourceMap && typeof btoa !== 'undefined') {
            css +=
              '\n/*# sourceMappingURL=data:application/json;base64,'.concat(
                btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))),
                ' */'
              );
          } // For old IE

          /* istanbul ignore if  */

          if (style.styleSheet) {
            style.styleSheet.cssText = css;
          } else {
            while (style.firstChild) {
              style.removeChild(style.firstChild);
            }

            style.appendChild(document.createTextNode(css));
          }
        }

        var singleton = null;
        var singletonCounter = 0;

        function addStyle(obj, options) {
          var style;
          var update;
          var remove;

          if (options.singleton) {
            var styleIndex = singletonCounter++;
            style = singleton || (singleton = insertStyleElement(options));
            update = applyToSingletonTag.bind(null, style, styleIndex, false);
            remove = applyToSingletonTag.bind(null, style, styleIndex, true);
          } else {
            style = insertStyleElement(options);
            update = applyToTag.bind(null, style, options);

            remove = function remove() {
              removeStyleElement(style);
            };
          }

          update(obj);
          return function updateStyle(newObj) {
            if (newObj) {
              if (
                newObj.css === obj.css &&
                newObj.media === obj.media &&
                newObj.sourceMap === obj.sourceMap
              ) {
                return;
              }

              update((obj = newObj));
            } else {
              remove();
            }
          };
        }

        module.exports = function (list, options) {
          options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
          // tags it will allow on a page

          if (!options.singleton && typeof options.singleton !== 'boolean') {
            options.singleton = isOldIE();
          }

          list = list || [];
          var lastIdentifiers = modulesToDom(list, options);
          return function update(newList) {
            newList = newList || [];

            if (Object.prototype.toString.call(newList) !== '[object Array]') {
              return;
            }

            for (var i = 0; i < lastIdentifiers.length; i++) {
              var identifier = lastIdentifiers[i];
              var index = getIndexByIdentifier(identifier);
              stylesInDom[index].references--;
            }

            var newLastIdentifiers = modulesToDom(newList, options);

            for (var _i = 0; _i < lastIdentifiers.length; _i++) {
              var _identifier = lastIdentifiers[_i];

              var _index = getIndexByIdentifier(_identifier);

              if (stylesInDom[_index].references === 0) {
                stylesInDom[_index].updater();

                stylesInDom.splice(_index, 1);
              }
            }

            lastIdentifiers = newLastIdentifiers;
          };
        };

        /***/
      },

    /***/ './node_modules/svg-vue3/dist/svg-vue.esm.js':
      /*!***************************************************!*\
  !*** ./node_modules/svg-vue3/dist/svg-vue.esm.js ***!
  \***************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! vue */ './node_modules/vue/dist/vue.esm-bundler.js'
          );

        var script = {
          name: 'SvgVue',
          props: {
            icon: String,
          },

          setup(props) {
            const iconPath = (0, vue__WEBPACK_IMPORTED_MODULE_0__.computed)(
              () =>
                props.icon.replace(
                  new RegExp(
                    '.'.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, '\\$1'),
                    'g'
                  ),
                  '/'
                ) + '.svg'
            );
            const svgString = (0, vue__WEBPACK_IMPORTED_MODULE_0__.computed)(
              () =>
                __webpack_require__(
                  './resources/assets/images/svg sync recursive ^\\.\\/.*$'
                )(`./${iconPath.value}`).default
            );
            const svgAttributes = (0,
            vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
              if (!svgString) return {};
              let wrapper = document.createElement('div');
              wrapper.innerHTML = svgString.value;
              let attributesList = wrapper.firstElementChild.attributes;
              let attributes = {};
              Object.keys(attributesList).map(
                (i) =>
                  (attributes[attributesList[i].name] = attributesList[i].value)
              );
              return attributes;
            });
            const svgContent = (0, vue__WEBPACK_IMPORTED_MODULE_0__.computed)(
              () =>
                svgString
                  ? svgString.value.replace(/^<svg[^>]*>|<\/svg>$/g, '')
                  : null
            );
            return {
              svgAttributes,
              svgContent,
            };
          },
        };

        function render(_ctx, _cache, $props, $setup, $data, $options) {
          return (
            (0, vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),
            (0, vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(
              'svg',
              (0, vue__WEBPACK_IMPORTED_MODULE_0__.mergeProps)(
                $setup.svgAttributes,
                {
                  innerHTML: $setup.svgContent,
                }
              ),
              null,
              16,
              ['innerHTML']
            )
          );
        }

        script.render = render;

        // Import vue component
        // IIFE injects install function into component, allowing component
        // to be registered via Vue.use() as well as Vue.component(),

        var entry_esm = /*#__PURE__*/ (() => {
          // Get component instance
          const installable = script; // Attach install function executed by Vue.use()

          installable.install = (app) => {
            app.component('SvgVue', installable);
          };

          return installable;
        })(); // It's possible to expose named exports when writing components that can
        // also be used as directives, etc. - eg. import { RollupDemoDirective } from 'rollup-demo';
        // export const RollupDemoDirective = directive;

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          entry_esm;

        /***/
      },

    /***/ './node_modules/vue-loader/dist/exportHelper.js':
      /*!******************************************************!*\
  !*** ./node_modules/vue-loader/dist/exportHelper.js ***!
  \******************************************************/
      /***/ (__unused_webpack_module, exports) => {
        'use strict';

        Object.defineProperty(exports, '__esModule', { value: true });
        // runtime helper for setting properties on components
        // in a tree-shakable way
        exports['default'] = (sfc, props) => {
          const target = sfc.__vccOpts || sfc;
          for (const [key, val] of props) {
            target[key] = val;
          }
          return target;
        };

        /***/
      },

    /***/ './resources/assets/js/components/AdminHeader.vue':
      /*!********************************************************!*\
  !*** ./resources/assets/js/components/AdminHeader.vue ***!
  \********************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ __esModule: () =>
            /* reexport safe */ _AdminHeader_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__.__esModule,
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony import */ var _AdminHeader_vue_vue_type_template_id_6fe59055_ts_true__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ./AdminHeader.vue?vue&type=template&id=6fe59055&ts=true */ './resources/assets/js/components/AdminHeader.vue?vue&type=template&id=6fe59055&ts=true'
          );
        /* harmony import */ var _AdminHeader_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ./AdminHeader.vue?vue&type=script&lang=ts */ './resources/assets/js/components/AdminHeader.vue?vue&type=script&lang=ts'
          );
        /* harmony import */ var _Users_titungdup_projects_iatipublisher_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! ./node_modules/vue-loader/dist/exportHelper.js */ './node_modules/vue-loader/dist/exportHelper.js'
          );

        const __exports__ = /*#__PURE__*/ (0,
        _Users_titungdup_projects_iatipublisher_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__[
          'default'
        ])(
          _AdminHeader_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__[
            'default'
          ],
          [
            [
              'render',
              _AdminHeader_vue_vue_type_template_id_6fe59055_ts_true__WEBPACK_IMPORTED_MODULE_0__.render,
            ],
            ['__file', 'resources/assets/js/components/AdminHeader.vue'],
          ]
        );
        /* hot reload */
        if (false) {
        }

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          __exports__;

        /***/
      },

    /***/ './resources/assets/js/components/AlertMessage.vue':
      /*!*********************************************************!*\
  !*** ./resources/assets/js/components/AlertMessage.vue ***!
  \*********************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ __esModule: () =>
            /* reexport safe */ _AlertMessage_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__.__esModule,
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony import */ var _AlertMessage_vue_vue_type_template_id_657fa342_scoped_true_ts_true__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ./AlertMessage.vue?vue&type=template&id=657fa342&scoped=true&ts=true */ './resources/assets/js/components/AlertMessage.vue?vue&type=template&id=657fa342&scoped=true&ts=true'
          );
        /* harmony import */ var _AlertMessage_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ./AlertMessage.vue?vue&type=script&lang=ts */ './resources/assets/js/components/AlertMessage.vue?vue&type=script&lang=ts'
          );
        /* harmony import */ var _AlertMessage_vue_vue_type_style_index_0_id_657fa342_lang_scss_scoped_true__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! ./AlertMessage.vue?vue&type=style&index=0&id=657fa342&lang=scss&scoped=true */ './resources/assets/js/components/AlertMessage.vue?vue&type=style&index=0&id=657fa342&lang=scss&scoped=true'
          );
        /* harmony import */ var _Users_titungdup_projects_iatipublisher_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_3__ =
          __webpack_require__(
            /*! ./node_modules/vue-loader/dist/exportHelper.js */ './node_modules/vue-loader/dist/exportHelper.js'
          );

        const __exports__ = /*#__PURE__*/ (0,
        _Users_titungdup_projects_iatipublisher_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_3__[
          'default'
        ])(
          _AlertMessage_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__[
            'default'
          ],
          [
            [
              'render',
              _AlertMessage_vue_vue_type_template_id_657fa342_scoped_true_ts_true__WEBPACK_IMPORTED_MODULE_0__.render,
            ],
            ['__scopeId', 'data-v-657fa342'],
            ['__file', 'resources/assets/js/components/AlertMessage.vue'],
          ]
        );
        /* hot reload */
        if (false) {
        }

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          __exports__;

        /***/
      },

    /***/ './resources/assets/js/components/Pagination.vue':
      /*!*******************************************************!*\
  !*** ./resources/assets/js/components/Pagination.vue ***!
  \*******************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ __esModule: () =>
            /* reexport safe */ _Pagination_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__.__esModule,
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony import */ var _Pagination_vue_vue_type_template_id_3895afde_ts_true__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ./Pagination.vue?vue&type=template&id=3895afde&ts=true */ './resources/assets/js/components/Pagination.vue?vue&type=template&id=3895afde&ts=true'
          );
        /* harmony import */ var _Pagination_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ./Pagination.vue?vue&type=script&lang=ts */ './resources/assets/js/components/Pagination.vue?vue&type=script&lang=ts'
          );
        /* harmony import */ var _Users_titungdup_projects_iatipublisher_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! ./node_modules/vue-loader/dist/exportHelper.js */ './node_modules/vue-loader/dist/exportHelper.js'
          );

        const __exports__ = /*#__PURE__*/ (0,
        _Users_titungdup_projects_iatipublisher_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__[
          'default'
        ])(
          _Pagination_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__[
            'default'
          ],
          [
            [
              'render',
              _Pagination_vue_vue_type_template_id_3895afde_ts_true__WEBPACK_IMPORTED_MODULE_0__.render,
            ],
            ['__file', 'resources/assets/js/components/Pagination.vue'],
          ]
        );
        /* hot reload */
        if (false) {
        }

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          __exports__;

        /***/
      },

    /***/ './resources/assets/js/components/PopupModal.vue':
      /*!*******************************************************!*\
  !*** ./resources/assets/js/components/PopupModal.vue ***!
  \*******************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ __esModule: () =>
            /* reexport safe */ _PopupModal_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__.__esModule,
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony import */ var _PopupModal_vue_vue_type_template_id_5a2bda58_scoped_true_ts_true__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ./PopupModal.vue?vue&type=template&id=5a2bda58&scoped=true&ts=true */ './resources/assets/js/components/PopupModal.vue?vue&type=template&id=5a2bda58&scoped=true&ts=true'
          );
        /* harmony import */ var _PopupModal_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ./PopupModal.vue?vue&type=script&lang=ts */ './resources/assets/js/components/PopupModal.vue?vue&type=script&lang=ts'
          );
        /* harmony import */ var _PopupModal_vue_vue_type_style_index_0_id_5a2bda58_lang_scss_scoped_true__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! ./PopupModal.vue?vue&type=style&index=0&id=5a2bda58&lang=scss&scoped=true */ './resources/assets/js/components/PopupModal.vue?vue&type=style&index=0&id=5a2bda58&lang=scss&scoped=true'
          );
        /* harmony import */ var _Users_titungdup_projects_iatipublisher_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_3__ =
          __webpack_require__(
            /*! ./node_modules/vue-loader/dist/exportHelper.js */ './node_modules/vue-loader/dist/exportHelper.js'
          );

        const __exports__ = /*#__PURE__*/ (0,
        _Users_titungdup_projects_iatipublisher_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_3__[
          'default'
        ])(
          _PopupModal_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__[
            'default'
          ],
          [
            [
              'render',
              _PopupModal_vue_vue_type_template_id_5a2bda58_scoped_true_ts_true__WEBPACK_IMPORTED_MODULE_0__.render,
            ],
            ['__scopeId', 'data-v-5a2bda58'],
            ['__file', 'resources/assets/js/components/PopupModal.vue'],
          ]
        );
        /* hot reload */
        if (false) {
        }

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          __exports__;

        /***/
      },

    /***/ './resources/assets/js/components/ToastMessage.vue':
      /*!*********************************************************!*\
  !*** ./resources/assets/js/components/ToastMessage.vue ***!
  \*********************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ __esModule: () =>
            /* reexport safe */ _ToastMessage_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__.__esModule,
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony import */ var _ToastMessage_vue_vue_type_template_id_d01d8cd2_ts_true__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ./ToastMessage.vue?vue&type=template&id=d01d8cd2&ts=true */ './resources/assets/js/components/ToastMessage.vue?vue&type=template&id=d01d8cd2&ts=true'
          );
        /* harmony import */ var _ToastMessage_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ./ToastMessage.vue?vue&type=script&lang=ts */ './resources/assets/js/components/ToastMessage.vue?vue&type=script&lang=ts'
          );
        /* harmony import */ var _Users_titungdup_projects_iatipublisher_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! ./node_modules/vue-loader/dist/exportHelper.js */ './node_modules/vue-loader/dist/exportHelper.js'
          );

        const __exports__ = /*#__PURE__*/ (0,
        _Users_titungdup_projects_iatipublisher_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__[
          'default'
        ])(
          _ToastMessage_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__[
            'default'
          ],
          [
            [
              'render',
              _ToastMessage_vue_vue_type_template_id_d01d8cd2_ts_true__WEBPACK_IMPORTED_MODULE_0__.render,
            ],
            ['__file', 'resources/assets/js/components/ToastMessage.vue'],
          ]
        );
        /* hot reload */
        if (false) {
        }

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          __exports__;

        /***/
      },

    /***/ './resources/assets/js/views/activity/ActivityList.vue':
      /*!*************************************************************!*\
  !*** ./resources/assets/js/views/activity/ActivityList.vue ***!
  \*************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony import */ var _ActivityList_vue_vue_type_template_id_2222ed6c_ts_true__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ./ActivityList.vue?vue&type=template&id=2222ed6c&ts=true */ './resources/assets/js/views/activity/ActivityList.vue?vue&type=template&id=2222ed6c&ts=true'
          );
        /* harmony import */ var _ActivityList_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ./ActivityList.vue?vue&type=script&lang=ts */ './resources/assets/js/views/activity/ActivityList.vue?vue&type=script&lang=ts'
          );
        /* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
        /* harmony reexport (unknown) */ for (const __WEBPACK_IMPORT_KEY__ in _ActivityList_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__)
          if (__WEBPACK_IMPORT_KEY__ !== 'default')
            __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () =>
              _ActivityList_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__[
                __WEBPACK_IMPORT_KEY__
              ];
        /* harmony reexport (unknown) */ __webpack_require__.d(
          __webpack_exports__,
          __WEBPACK_REEXPORT_OBJECT__
        );
        /* harmony import */ var _Users_titungdup_projects_iatipublisher_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! ./node_modules/vue-loader/dist/exportHelper.js */ './node_modules/vue-loader/dist/exportHelper.js'
          );

        const __exports__ = /*#__PURE__*/ (0,
        _Users_titungdup_projects_iatipublisher_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__[
          'default'
        ])(
          _ActivityList_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__[
            'default'
          ],
          [
            [
              'render',
              _ActivityList_vue_vue_type_template_id_2222ed6c_ts_true__WEBPACK_IMPORTED_MODULE_0__.render,
            ],
            ['__file', 'resources/assets/js/views/activity/ActivityList.vue'],
          ]
        );
        /* hot reload */
        if (false) {
        }

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          __exports__;

        /***/
      },

    /***/ './resources/assets/js/views/activity/partials/AddActivityButton.vue':
      /*!***************************************************************************!*\
  !*** ./resources/assets/js/views/activity/partials/AddActivityButton.vue ***!
  \***************************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ __esModule: () =>
            /* reexport safe */ _AddActivityButton_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__.__esModule,
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony import */ var _AddActivityButton_vue_vue_type_template_id_050e173c_ts_true__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ./AddActivityButton.vue?vue&type=template&id=050e173c&ts=true */ './resources/assets/js/views/activity/partials/AddActivityButton.vue?vue&type=template&id=050e173c&ts=true'
          );
        /* harmony import */ var _AddActivityButton_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ./AddActivityButton.vue?vue&type=script&lang=ts */ './resources/assets/js/views/activity/partials/AddActivityButton.vue?vue&type=script&lang=ts'
          );
        /* harmony import */ var _Users_titungdup_projects_iatipublisher_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! ./node_modules/vue-loader/dist/exportHelper.js */ './node_modules/vue-loader/dist/exportHelper.js'
          );

        const __exports__ = /*#__PURE__*/ (0,
        _Users_titungdup_projects_iatipublisher_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__[
          'default'
        ])(
          _AddActivityButton_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__[
            'default'
          ],
          [
            [
              'render',
              _AddActivityButton_vue_vue_type_template_id_050e173c_ts_true__WEBPACK_IMPORTED_MODULE_0__.render,
            ],
            [
              '__file',
              'resources/assets/js/views/activity/partials/AddActivityButton.vue',
            ],
          ]
        );
        /* hot reload */
        if (false) {
        }

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          __exports__;

        /***/
      },

    /***/ './resources/assets/js/views/activity/partials/EmptyActivity.vue':
      /*!***********************************************************************!*\
  !*** ./resources/assets/js/views/activity/partials/EmptyActivity.vue ***!
  \***********************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony import */ var _EmptyActivity_vue_vue_type_template_id_9aef9688_ts_true__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ./EmptyActivity.vue?vue&type=template&id=9aef9688&ts=true */ './resources/assets/js/views/activity/partials/EmptyActivity.vue?vue&type=template&id=9aef9688&ts=true'
          );
        /* harmony import */ var _EmptyActivity_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ./EmptyActivity.vue?vue&type=script&lang=ts */ './resources/assets/js/views/activity/partials/EmptyActivity.vue?vue&type=script&lang=ts'
          );
        /* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
        /* harmony reexport (unknown) */ for (const __WEBPACK_IMPORT_KEY__ in _EmptyActivity_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__)
          if (__WEBPACK_IMPORT_KEY__ !== 'default')
            __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () =>
              _EmptyActivity_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__[
                __WEBPACK_IMPORT_KEY__
              ];
        /* harmony reexport (unknown) */ __webpack_require__.d(
          __webpack_exports__,
          __WEBPACK_REEXPORT_OBJECT__
        );
        /* harmony import */ var _Users_titungdup_projects_iatipublisher_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! ./node_modules/vue-loader/dist/exportHelper.js */ './node_modules/vue-loader/dist/exportHelper.js'
          );

        const __exports__ = /*#__PURE__*/ (0,
        _Users_titungdup_projects_iatipublisher_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__[
          'default'
        ])(
          _EmptyActivity_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__[
            'default'
          ],
          [
            [
              'render',
              _EmptyActivity_vue_vue_type_template_id_9aef9688_ts_true__WEBPACK_IMPORTED_MODULE_0__.render,
            ],
            [
              '__file',
              'resources/assets/js/views/activity/partials/EmptyActivity.vue',
            ],
          ]
        );
        /* hot reload */
        if (false) {
        }

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          __exports__;

        /***/
      },

    /***/ './resources/assets/js/views/activity/partials/PageTitle.vue':
      /*!*******************************************************************!*\
  !*** ./resources/assets/js/views/activity/partials/PageTitle.vue ***!
  \*******************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony import */ var _PageTitle_vue_vue_type_template_id_7589e86e_ts_true__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ./PageTitle.vue?vue&type=template&id=7589e86e&ts=true */ './resources/assets/js/views/activity/partials/PageTitle.vue?vue&type=template&id=7589e86e&ts=true'
          );
        /* harmony import */ var _PageTitle_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ./PageTitle.vue?vue&type=script&lang=ts */ './resources/assets/js/views/activity/partials/PageTitle.vue?vue&type=script&lang=ts'
          );
        /* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
        /* harmony reexport (unknown) */ for (const __WEBPACK_IMPORT_KEY__ in _PageTitle_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__)
          if (__WEBPACK_IMPORT_KEY__ !== 'default')
            __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () =>
              _PageTitle_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__[
                __WEBPACK_IMPORT_KEY__
              ];
        /* harmony reexport (unknown) */ __webpack_require__.d(
          __webpack_exports__,
          __WEBPACK_REEXPORT_OBJECT__
        );
        /* harmony import */ var _Users_titungdup_projects_iatipublisher_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! ./node_modules/vue-loader/dist/exportHelper.js */ './node_modules/vue-loader/dist/exportHelper.js'
          );

        const __exports__ = /*#__PURE__*/ (0,
        _Users_titungdup_projects_iatipublisher_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__[
          'default'
        ])(
          _PageTitle_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__[
            'default'
          ],
          [
            [
              'render',
              _PageTitle_vue_vue_type_template_id_7589e86e_ts_true__WEBPACK_IMPORTED_MODULE_0__.render,
            ],
            [
              '__file',
              'resources/assets/js/views/activity/partials/PageTitle.vue',
            ],
          ]
        );
        /* hot reload */
        if (false) {
        }

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          __exports__;

        /***/
      },

    /***/ './resources/assets/js/views/activity/partials/TableLayout.vue':
      /*!*********************************************************************!*\
  !*** ./resources/assets/js/views/activity/partials/TableLayout.vue ***!
  \*********************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ __esModule: () =>
            /* reexport safe */ _TableLayout_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__.__esModule,
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony import */ var _TableLayout_vue_vue_type_template_id_5d84a1d8_ts_true__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ./TableLayout.vue?vue&type=template&id=5d84a1d8&ts=true */ './resources/assets/js/views/activity/partials/TableLayout.vue?vue&type=template&id=5d84a1d8&ts=true'
          );
        /* harmony import */ var _TableLayout_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ./TableLayout.vue?vue&type=script&lang=ts */ './resources/assets/js/views/activity/partials/TableLayout.vue?vue&type=script&lang=ts'
          );
        /* harmony import */ var _Users_titungdup_projects_iatipublisher_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! ./node_modules/vue-loader/dist/exportHelper.js */ './node_modules/vue-loader/dist/exportHelper.js'
          );

        const __exports__ = /*#__PURE__*/ (0,
        _Users_titungdup_projects_iatipublisher_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__[
          'default'
        ])(
          _TableLayout_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__[
            'default'
          ],
          [
            [
              'render',
              _TableLayout_vue_vue_type_template_id_5d84a1d8_ts_true__WEBPACK_IMPORTED_MODULE_0__.render,
            ],
            [
              '__file',
              'resources/assets/js/views/activity/partials/TableLayout.vue',
            ],
          ]
        );
        /* hot reload */
        if (false) {
        }

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          __exports__;

        /***/
      },

    /***/ './resources/assets/js/components/AdminHeader.vue?vue&type=script&lang=ts':
      /*!********************************************************************************!*\
  !*** ./resources/assets/js/components/AdminHeader.vue?vue&type=script&lang=ts ***!
  \********************************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_AdminHeader_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__[
              'default'
            ],
          /* harmony export */ __esModule: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_AdminHeader_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__.__esModule,
          /* harmony export */
        });
        /* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_AdminHeader_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!../../../../node_modules/ts-loader/index.js??clonedRuleSet-7!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./AdminHeader.vue?vue&type=script&lang=ts */ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/AdminHeader.vue?vue&type=script&lang=ts'
          );

        /***/
      },

    /***/ './resources/assets/js/components/AlertMessage.vue?vue&type=script&lang=ts':
      /*!*********************************************************************************!*\
  !*** ./resources/assets/js/components/AlertMessage.vue?vue&type=script&lang=ts ***!
  \*********************************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_AlertMessage_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__[
              'default'
            ],
          /* harmony export */ __esModule: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_AlertMessage_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__.__esModule,
          /* harmony export */
        });
        /* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_AlertMessage_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!../../../../node_modules/ts-loader/index.js??clonedRuleSet-7!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./AlertMessage.vue?vue&type=script&lang=ts */ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/AlertMessage.vue?vue&type=script&lang=ts'
          );

        /***/
      },

    /***/ './resources/assets/js/components/Pagination.vue?vue&type=script&lang=ts':
      /*!*******************************************************************************!*\
  !*** ./resources/assets/js/components/Pagination.vue?vue&type=script&lang=ts ***!
  \*******************************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Pagination_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__[
              'default'
            ],
          /* harmony export */ __esModule: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Pagination_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__.__esModule,
          /* harmony export */
        });
        /* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Pagination_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!../../../../node_modules/ts-loader/index.js??clonedRuleSet-7!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Pagination.vue?vue&type=script&lang=ts */ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/Pagination.vue?vue&type=script&lang=ts'
          );

        /***/
      },

    /***/ './resources/assets/js/components/PopupModal.vue?vue&type=script&lang=ts':
      /*!*******************************************************************************!*\
  !*** ./resources/assets/js/components/PopupModal.vue?vue&type=script&lang=ts ***!
  \*******************************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_PopupModal_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__[
              'default'
            ],
          /* harmony export */ __esModule: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_PopupModal_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__.__esModule,
          /* harmony export */
        });
        /* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_PopupModal_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!../../../../node_modules/ts-loader/index.js??clonedRuleSet-7!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./PopupModal.vue?vue&type=script&lang=ts */ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/PopupModal.vue?vue&type=script&lang=ts'
          );

        /***/
      },

    /***/ './resources/assets/js/components/ToastMessage.vue?vue&type=script&lang=ts':
      /*!*********************************************************************************!*\
  !*** ./resources/assets/js/components/ToastMessage.vue?vue&type=script&lang=ts ***!
  \*********************************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_ToastMessage_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__[
              'default'
            ],
          /* harmony export */ __esModule: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_ToastMessage_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__.__esModule,
          /* harmony export */
        });
        /* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_ToastMessage_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!../../../../node_modules/ts-loader/index.js??clonedRuleSet-7!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./ToastMessage.vue?vue&type=script&lang=ts */ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/ToastMessage.vue?vue&type=script&lang=ts'
          );

        /***/
      },

    /***/ './resources/assets/js/views/activity/ActivityList.vue?vue&type=script&lang=ts':
      /*!*************************************************************************************!*\
  !*** ./resources/assets/js/views/activity/ActivityList.vue?vue&type=script&lang=ts ***!
  \*************************************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () =>
            /* reexport default from dynamic */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_ActivityList_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0___default.a,
          /* harmony export */
        });
        /* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_ActivityList_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! -!../../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!../../../../../node_modules/ts-loader/index.js??clonedRuleSet-7!../../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./ActivityList.vue?vue&type=script&lang=ts */ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/views/activity/ActivityList.vue?vue&type=script&lang=ts'
          );
        /* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_ActivityList_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0___default =
          /*#__PURE__*/ __webpack_require__.n(
            _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_ActivityList_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__
          );
        /* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
        /* harmony reexport (unknown) */ for (const __WEBPACK_IMPORT_KEY__ in _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_ActivityList_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__)
          if (__WEBPACK_IMPORT_KEY__ !== 'default')
            __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () =>
              _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_ActivityList_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__[
                __WEBPACK_IMPORT_KEY__
              ];
        /* harmony reexport (unknown) */ __webpack_require__.d(
          __webpack_exports__,
          __WEBPACK_REEXPORT_OBJECT__
        );

        /***/
      },

    /***/ './resources/assets/js/views/activity/partials/AddActivityButton.vue?vue&type=script&lang=ts':
      /*!***************************************************************************************************!*\
  !*** ./resources/assets/js/views/activity/partials/AddActivityButton.vue?vue&type=script&lang=ts ***!
  \***************************************************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_AddActivityButton_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__[
              'default'
            ],
          /* harmony export */ __esModule: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_AddActivityButton_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__.__esModule,
          /* harmony export */
        });
        /* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_AddActivityButton_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! -!../../../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!../../../../../../node_modules/ts-loader/index.js??clonedRuleSet-7!../../../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./AddActivityButton.vue?vue&type=script&lang=ts */ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/views/activity/partials/AddActivityButton.vue?vue&type=script&lang=ts'
          );

        /***/
      },

    /***/ './resources/assets/js/views/activity/partials/EmptyActivity.vue?vue&type=script&lang=ts':
      /*!***********************************************************************************************!*\
  !*** ./resources/assets/js/views/activity/partials/EmptyActivity.vue?vue&type=script&lang=ts ***!
  \***********************************************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () =>
            /* reexport default from dynamic */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_EmptyActivity_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0___default.a,
          /* harmony export */
        });
        /* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_EmptyActivity_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! -!../../../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!../../../../../../node_modules/ts-loader/index.js??clonedRuleSet-7!../../../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./EmptyActivity.vue?vue&type=script&lang=ts */ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/views/activity/partials/EmptyActivity.vue?vue&type=script&lang=ts'
          );
        /* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_EmptyActivity_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0___default =
          /*#__PURE__*/ __webpack_require__.n(
            _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_EmptyActivity_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__
          );
        /* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
        /* harmony reexport (unknown) */ for (const __WEBPACK_IMPORT_KEY__ in _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_EmptyActivity_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__)
          if (__WEBPACK_IMPORT_KEY__ !== 'default')
            __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () =>
              _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_EmptyActivity_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__[
                __WEBPACK_IMPORT_KEY__
              ];
        /* harmony reexport (unknown) */ __webpack_require__.d(
          __webpack_exports__,
          __WEBPACK_REEXPORT_OBJECT__
        );

        /***/
      },

    /***/ './resources/assets/js/views/activity/partials/PageTitle.vue?vue&type=script&lang=ts':
      /*!*******************************************************************************************!*\
  !*** ./resources/assets/js/views/activity/partials/PageTitle.vue?vue&type=script&lang=ts ***!
  \*******************************************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () =>
            /* reexport default from dynamic */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_PageTitle_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0___default.a,
          /* harmony export */
        });
        /* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_PageTitle_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! -!../../../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!../../../../../../node_modules/ts-loader/index.js??clonedRuleSet-7!../../../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./PageTitle.vue?vue&type=script&lang=ts */ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/views/activity/partials/PageTitle.vue?vue&type=script&lang=ts'
          );
        /* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_PageTitle_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0___default =
          /*#__PURE__*/ __webpack_require__.n(
            _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_PageTitle_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__
          );
        /* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
        /* harmony reexport (unknown) */ for (const __WEBPACK_IMPORT_KEY__ in _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_PageTitle_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__)
          if (__WEBPACK_IMPORT_KEY__ !== 'default')
            __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () =>
              _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_PageTitle_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__[
                __WEBPACK_IMPORT_KEY__
              ];
        /* harmony reexport (unknown) */ __webpack_require__.d(
          __webpack_exports__,
          __WEBPACK_REEXPORT_OBJECT__
        );

        /***/
      },

    /***/ './resources/assets/js/views/activity/partials/TableLayout.vue?vue&type=script&lang=ts':
      /*!*********************************************************************************************!*\
  !*** ./resources/assets/js/views/activity/partials/TableLayout.vue?vue&type=script&lang=ts ***!
  \*********************************************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_TableLayout_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__[
              'default'
            ],
          /* harmony export */ __esModule: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_TableLayout_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__.__esModule,
          /* harmony export */
        });
        /* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_TableLayout_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! -!../../../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!../../../../../../node_modules/ts-loader/index.js??clonedRuleSet-7!../../../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./TableLayout.vue?vue&type=script&lang=ts */ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/views/activity/partials/TableLayout.vue?vue&type=script&lang=ts'
          );

        /***/
      },

    /***/ './resources/assets/js/components/AdminHeader.vue?vue&type=template&id=6fe59055&ts=true':
      /*!**********************************************************************************************!*\
  !*** ./resources/assets/js/components/AdminHeader.vue?vue&type=template&id=6fe59055&ts=true ***!
  \**********************************************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ __esModule: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_4_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_AdminHeader_vue_vue_type_template_id_6fe59055_ts_true__WEBPACK_IMPORTED_MODULE_0__.__esModule,
          /* harmony export */ render: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_4_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_AdminHeader_vue_vue_type_template_id_6fe59055_ts_true__WEBPACK_IMPORTED_MODULE_0__.render,
          /* harmony export */
        });
        /* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_4_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_AdminHeader_vue_vue_type_template_id_6fe59055_ts_true__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!../../../../node_modules/ts-loader/index.js??clonedRuleSet-7!../../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./AdminHeader.vue?vue&type=template&id=6fe59055&ts=true */ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/AdminHeader.vue?vue&type=template&id=6fe59055&ts=true'
          );

        /***/
      },

    /***/ './resources/assets/js/components/AlertMessage.vue?vue&type=template&id=657fa342&scoped=true&ts=true':
      /*!***********************************************************************************************************!*\
  !*** ./resources/assets/js/components/AlertMessage.vue?vue&type=template&id=657fa342&scoped=true&ts=true ***!
  \***********************************************************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ __esModule: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_4_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_AlertMessage_vue_vue_type_template_id_657fa342_scoped_true_ts_true__WEBPACK_IMPORTED_MODULE_0__.__esModule,
          /* harmony export */ render: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_4_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_AlertMessage_vue_vue_type_template_id_657fa342_scoped_true_ts_true__WEBPACK_IMPORTED_MODULE_0__.render,
          /* harmony export */
        });
        /* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_4_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_AlertMessage_vue_vue_type_template_id_657fa342_scoped_true_ts_true__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!../../../../node_modules/ts-loader/index.js??clonedRuleSet-7!../../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./AlertMessage.vue?vue&type=template&id=657fa342&scoped=true&ts=true */ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/AlertMessage.vue?vue&type=template&id=657fa342&scoped=true&ts=true'
          );

        /***/
      },

    /***/ './resources/assets/js/components/Pagination.vue?vue&type=template&id=3895afde&ts=true':
      /*!*********************************************************************************************!*\
  !*** ./resources/assets/js/components/Pagination.vue?vue&type=template&id=3895afde&ts=true ***!
  \*********************************************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ __esModule: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_4_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Pagination_vue_vue_type_template_id_3895afde_ts_true__WEBPACK_IMPORTED_MODULE_0__.__esModule,
          /* harmony export */ render: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_4_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Pagination_vue_vue_type_template_id_3895afde_ts_true__WEBPACK_IMPORTED_MODULE_0__.render,
          /* harmony export */
        });
        /* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_4_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Pagination_vue_vue_type_template_id_3895afde_ts_true__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!../../../../node_modules/ts-loader/index.js??clonedRuleSet-7!../../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Pagination.vue?vue&type=template&id=3895afde&ts=true */ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/Pagination.vue?vue&type=template&id=3895afde&ts=true'
          );

        /***/
      },

    /***/ './resources/assets/js/components/PopupModal.vue?vue&type=template&id=5a2bda58&scoped=true&ts=true':
      /*!*********************************************************************************************************!*\
  !*** ./resources/assets/js/components/PopupModal.vue?vue&type=template&id=5a2bda58&scoped=true&ts=true ***!
  \*********************************************************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ __esModule: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_4_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_PopupModal_vue_vue_type_template_id_5a2bda58_scoped_true_ts_true__WEBPACK_IMPORTED_MODULE_0__.__esModule,
          /* harmony export */ render: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_4_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_PopupModal_vue_vue_type_template_id_5a2bda58_scoped_true_ts_true__WEBPACK_IMPORTED_MODULE_0__.render,
          /* harmony export */
        });
        /* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_4_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_PopupModal_vue_vue_type_template_id_5a2bda58_scoped_true_ts_true__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!../../../../node_modules/ts-loader/index.js??clonedRuleSet-7!../../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./PopupModal.vue?vue&type=template&id=5a2bda58&scoped=true&ts=true */ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/PopupModal.vue?vue&type=template&id=5a2bda58&scoped=true&ts=true'
          );

        /***/
      },

    /***/ './resources/assets/js/components/ToastMessage.vue?vue&type=template&id=d01d8cd2&ts=true':
      /*!***********************************************************************************************!*\
  !*** ./resources/assets/js/components/ToastMessage.vue?vue&type=template&id=d01d8cd2&ts=true ***!
  \***********************************************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ __esModule: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_4_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_ToastMessage_vue_vue_type_template_id_d01d8cd2_ts_true__WEBPACK_IMPORTED_MODULE_0__.__esModule,
          /* harmony export */ render: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_4_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_ToastMessage_vue_vue_type_template_id_d01d8cd2_ts_true__WEBPACK_IMPORTED_MODULE_0__.render,
          /* harmony export */
        });
        /* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_4_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_ToastMessage_vue_vue_type_template_id_d01d8cd2_ts_true__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!../../../../node_modules/ts-loader/index.js??clonedRuleSet-7!../../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./ToastMessage.vue?vue&type=template&id=d01d8cd2&ts=true */ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/ToastMessage.vue?vue&type=template&id=d01d8cd2&ts=true'
          );

        /***/
      },

    /***/ './resources/assets/js/views/activity/ActivityList.vue?vue&type=template&id=2222ed6c&ts=true':
      /*!***************************************************************************************************!*\
  !*** ./resources/assets/js/views/activity/ActivityList.vue?vue&type=template&id=2222ed6c&ts=true ***!
  \***************************************************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ __esModule: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_4_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_ActivityList_vue_vue_type_template_id_2222ed6c_ts_true__WEBPACK_IMPORTED_MODULE_0__.__esModule,
          /* harmony export */ render: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_4_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_ActivityList_vue_vue_type_template_id_2222ed6c_ts_true__WEBPACK_IMPORTED_MODULE_0__.render,
          /* harmony export */
        });
        /* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_4_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_ActivityList_vue_vue_type_template_id_2222ed6c_ts_true__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! -!../../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!../../../../../node_modules/ts-loader/index.js??clonedRuleSet-7!../../../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!../../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./ActivityList.vue?vue&type=template&id=2222ed6c&ts=true */ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/views/activity/ActivityList.vue?vue&type=template&id=2222ed6c&ts=true'
          );

        /***/
      },

    /***/ './resources/assets/js/views/activity/partials/AddActivityButton.vue?vue&type=template&id=050e173c&ts=true':
      /*!*****************************************************************************************************************!*\
  !*** ./resources/assets/js/views/activity/partials/AddActivityButton.vue?vue&type=template&id=050e173c&ts=true ***!
  \*****************************************************************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ __esModule: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_4_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_AddActivityButton_vue_vue_type_template_id_050e173c_ts_true__WEBPACK_IMPORTED_MODULE_0__.__esModule,
          /* harmony export */ render: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_4_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_AddActivityButton_vue_vue_type_template_id_050e173c_ts_true__WEBPACK_IMPORTED_MODULE_0__.render,
          /* harmony export */
        });
        /* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_4_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_AddActivityButton_vue_vue_type_template_id_050e173c_ts_true__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! -!../../../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!../../../../../../node_modules/ts-loader/index.js??clonedRuleSet-7!../../../../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!../../../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./AddActivityButton.vue?vue&type=template&id=050e173c&ts=true */ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/views/activity/partials/AddActivityButton.vue?vue&type=template&id=050e173c&ts=true'
          );

        /***/
      },

    /***/ './resources/assets/js/views/activity/partials/EmptyActivity.vue?vue&type=template&id=9aef9688&ts=true':
      /*!*************************************************************************************************************!*\
  !*** ./resources/assets/js/views/activity/partials/EmptyActivity.vue?vue&type=template&id=9aef9688&ts=true ***!
  \*************************************************************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ __esModule: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_4_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_EmptyActivity_vue_vue_type_template_id_9aef9688_ts_true__WEBPACK_IMPORTED_MODULE_0__.__esModule,
          /* harmony export */ render: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_4_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_EmptyActivity_vue_vue_type_template_id_9aef9688_ts_true__WEBPACK_IMPORTED_MODULE_0__.render,
          /* harmony export */
        });
        /* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_4_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_EmptyActivity_vue_vue_type_template_id_9aef9688_ts_true__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! -!../../../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!../../../../../../node_modules/ts-loader/index.js??clonedRuleSet-7!../../../../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!../../../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./EmptyActivity.vue?vue&type=template&id=9aef9688&ts=true */ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/views/activity/partials/EmptyActivity.vue?vue&type=template&id=9aef9688&ts=true'
          );

        /***/
      },

    /***/ './resources/assets/js/views/activity/partials/PageTitle.vue?vue&type=template&id=7589e86e&ts=true':
      /*!*********************************************************************************************************!*\
  !*** ./resources/assets/js/views/activity/partials/PageTitle.vue?vue&type=template&id=7589e86e&ts=true ***!
  \*********************************************************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ __esModule: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_4_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_PageTitle_vue_vue_type_template_id_7589e86e_ts_true__WEBPACK_IMPORTED_MODULE_0__.__esModule,
          /* harmony export */ render: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_4_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_PageTitle_vue_vue_type_template_id_7589e86e_ts_true__WEBPACK_IMPORTED_MODULE_0__.render,
          /* harmony export */
        });
        /* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_4_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_PageTitle_vue_vue_type_template_id_7589e86e_ts_true__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! -!../../../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!../../../../../../node_modules/ts-loader/index.js??clonedRuleSet-7!../../../../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!../../../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./PageTitle.vue?vue&type=template&id=7589e86e&ts=true */ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/views/activity/partials/PageTitle.vue?vue&type=template&id=7589e86e&ts=true'
          );

        /***/
      },

    /***/ './resources/assets/js/views/activity/partials/TableLayout.vue?vue&type=template&id=5d84a1d8&ts=true':
      /*!***********************************************************************************************************!*\
  !*** ./resources/assets/js/views/activity/partials/TableLayout.vue?vue&type=template&id=5d84a1d8&ts=true ***!
  \***********************************************************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ __esModule: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_4_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_TableLayout_vue_vue_type_template_id_5d84a1d8_ts_true__WEBPACK_IMPORTED_MODULE_0__.__esModule,
          /* harmony export */ render: () =>
            /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_4_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_TableLayout_vue_vue_type_template_id_5d84a1d8_ts_true__WEBPACK_IMPORTED_MODULE_0__.render,
          /* harmony export */
        });
        /* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_babel_loader_lib_index_js_clonedRuleSet_6_use_0_node_modules_ts_loader_index_js_clonedRuleSet_7_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_4_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_TableLayout_vue_vue_type_template_id_5d84a1d8_ts_true__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! -!../../../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!../../../../../../node_modules/ts-loader/index.js??clonedRuleSet-7!../../../../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!../../../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./TableLayout.vue?vue&type=template&id=5d84a1d8&ts=true */ './node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/babel-loader/lib/index.js??clonedRuleSet-6.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-7!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/views/activity/partials/TableLayout.vue?vue&type=template&id=5d84a1d8&ts=true'
          );

        /***/
      },

    /***/ './resources/assets/js/components/AlertMessage.vue?vue&type=style&index=0&id=657fa342&lang=scss&scoped=true':
      /*!******************************************************************************************************************!*\
  !*** ./resources/assets/js/components/AlertMessage.vue?vue&type=style&index=0&id=657fa342&lang=scss&scoped=true ***!
  \******************************************************************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_14_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_14_use_2_node_modules_sass_loader_dist_cjs_js_clonedRuleSet_14_use_3_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_AlertMessage_vue_vue_type_style_index_0_id_657fa342_lang_scss_scoped_true__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! -!../../../../node_modules/style-loader/dist/cjs.js!../../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-14.use[1]!../../../../node_modules/vue-loader/dist/stylePostLoader.js!../../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-14.use[2]!../../../../node_modules/sass-loader/dist/cjs.js??clonedRuleSet-14.use[3]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./AlertMessage.vue?vue&type=style&index=0&id=657fa342&lang=scss&scoped=true */ './node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-14.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-14.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-14.use[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/AlertMessage.vue?vue&type=style&index=0&id=657fa342&lang=scss&scoped=true'
          );

        /***/
      },

    /***/ './resources/assets/js/components/PopupModal.vue?vue&type=style&index=0&id=5a2bda58&lang=scss&scoped=true':
      /*!****************************************************************************************************************!*\
  !*** ./resources/assets/js/components/PopupModal.vue?vue&type=style&index=0&id=5a2bda58&lang=scss&scoped=true ***!
  \****************************************************************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_14_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_14_use_2_node_modules_sass_loader_dist_cjs_js_clonedRuleSet_14_use_3_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_PopupModal_vue_vue_type_style_index_0_id_5a2bda58_lang_scss_scoped_true__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! -!../../../../node_modules/style-loader/dist/cjs.js!../../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-14.use[1]!../../../../node_modules/vue-loader/dist/stylePostLoader.js!../../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-14.use[2]!../../../../node_modules/sass-loader/dist/cjs.js??clonedRuleSet-14.use[3]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./PopupModal.vue?vue&type=style&index=0&id=5a2bda58&lang=scss&scoped=true */ './node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-14.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-14.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-14.use[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/components/PopupModal.vue?vue&type=style&index=0&id=5a2bda58&lang=scss&scoped=true'
          );

        /***/
      },

    /***/ './node_modules/vue/dist/vue.esm-bundler.js':
      /*!**************************************************!*\
  !*** ./node_modules/vue/dist/vue.esm-bundler.js ***!
  \**************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ BaseTransition: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.BaseTransition,
          /* harmony export */ Comment: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Comment,
          /* harmony export */ EffectScope: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.EffectScope,
          /* harmony export */ Fragment: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Fragment,
          /* harmony export */ KeepAlive: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.KeepAlive,
          /* harmony export */ ReactiveEffect: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect,
          /* harmony export */ Static: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Static,
          /* harmony export */ Suspense: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Suspense,
          /* harmony export */ Teleport: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Teleport,
          /* harmony export */ Text: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Text,
          /* harmony export */ Transition: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Transition,
          /* harmony export */ TransitionGroup: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.TransitionGroup,
          /* harmony export */ VueElement: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.VueElement,
          /* harmony export */ callWithAsyncErrorHandling: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling,
          /* harmony export */ callWithErrorHandling: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling,
          /* harmony export */ camelize: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.camelize,
          /* harmony export */ capitalize: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.capitalize,
          /* harmony export */ cloneVNode: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.cloneVNode,
          /* harmony export */ compatUtils: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.compatUtils,
          /* harmony export */ computed: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.computed,
          /* harmony export */ createApp: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createApp,
          /* harmony export */ createBlock: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createBlock,
          /* harmony export */ createCommentVNode: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode,
          /* harmony export */ createElementBlock: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createElementBlock,
          /* harmony export */ createElementVNode: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createElementVNode,
          /* harmony export */ createHydrationRenderer: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer,
          /* harmony export */ createPropsRestProxy: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createPropsRestProxy,
          /* harmony export */ createRenderer: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createRenderer,
          /* harmony export */ createSSRApp: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSSRApp,
          /* harmony export */ createSlots: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSlots,
          /* harmony export */ createStaticVNode: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode,
          /* harmony export */ createTextVNode: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createTextVNode,
          /* harmony export */ createVNode: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createVNode,
          /* harmony export */ customRef: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.customRef,
          /* harmony export */ defineAsyncComponent: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent,
          /* harmony export */ defineComponent: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineComponent,
          /* harmony export */ defineCustomElement: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineCustomElement,
          /* harmony export */ defineEmits: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineEmits,
          /* harmony export */ defineExpose: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineExpose,
          /* harmony export */ defineProps: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineProps,
          /* harmony export */ defineSSRCustomElement: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineSSRCustomElement,
          /* harmony export */ devtools: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.devtools,
          /* harmony export */ effect: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.effect,
          /* harmony export */ effectScope: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.effectScope,
          /* harmony export */ getCurrentInstance: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance,
          /* harmony export */ getCurrentScope: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope,
          /* harmony export */ getTransitionRawChildren: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren,
          /* harmony export */ guardReactiveProps: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.guardReactiveProps,
          /* harmony export */ h: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.h,
          /* harmony export */ handleError: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.handleError,
          /* harmony export */ hydrate: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.hydrate,
          /* harmony export */ initCustomFormatter: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter,
          /* harmony export */ initDirectivesForSSR: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.initDirectivesForSSR,
          /* harmony export */ inject: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.inject,
          /* harmony export */ isMemoSame: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isMemoSame,
          /* harmony export */ isProxy: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isProxy,
          /* harmony export */ isReactive: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReactive,
          /* harmony export */ isReadonly: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReadonly,
          /* harmony export */ isRef: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRef,
          /* harmony export */ isRuntimeOnly: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly,
          /* harmony export */ isShallow: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isShallow,
          /* harmony export */ isVNode: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isVNode,
          /* harmony export */ markRaw: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.markRaw,
          /* harmony export */ mergeDefaults: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeDefaults,
          /* harmony export */ mergeProps: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeProps,
          /* harmony export */ nextTick: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.nextTick,
          /* harmony export */ normalizeClass: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeClass,
          /* harmony export */ normalizeProps: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeProps,
          /* harmony export */ normalizeStyle: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle,
          /* harmony export */ onActivated: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onActivated,
          /* harmony export */ onBeforeMount: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount,
          /* harmony export */ onBeforeUnmount: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount,
          /* harmony export */ onBeforeUpdate: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate,
          /* harmony export */ onDeactivated: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onDeactivated,
          /* harmony export */ onErrorCaptured: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured,
          /* harmony export */ onMounted: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onMounted,
          /* harmony export */ onRenderTracked: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked,
          /* harmony export */ onRenderTriggered: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered,
          /* harmony export */ onScopeDispose: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose,
          /* harmony export */ onServerPrefetch: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch,
          /* harmony export */ onUnmounted: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUnmounted,
          /* harmony export */ onUpdated: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUpdated,
          /* harmony export */ openBlock: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.openBlock,
          /* harmony export */ popScopeId: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.popScopeId,
          /* harmony export */ provide: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.provide,
          /* harmony export */ proxyRefs: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.proxyRefs,
          /* harmony export */ pushScopeId: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.pushScopeId,
          /* harmony export */ queuePostFlushCb: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb,
          /* harmony export */ reactive: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.reactive,
          /* harmony export */ readonly: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.readonly,
          /* harmony export */ ref: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ref,
          /* harmony export */ registerRuntimeCompiler: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler,
          /* harmony export */ render: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.render,
          /* harmony export */ renderList: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderList,
          /* harmony export */ renderSlot: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderSlot,
          /* harmony export */ resolveComponent: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveComponent,
          /* harmony export */ resolveDirective: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDirective,
          /* harmony export */ resolveDynamicComponent: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent,
          /* harmony export */ resolveFilter: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveFilter,
          /* harmony export */ resolveTransitionHooks: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks,
          /* harmony export */ setBlockTracking: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking,
          /* harmony export */ setDevtoolsHook: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook,
          /* harmony export */ setTransitionHooks: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks,
          /* harmony export */ shallowReactive: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReactive,
          /* harmony export */ shallowReadonly: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly,
          /* harmony export */ shallowRef: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowRef,
          /* harmony export */ ssrContextKey: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey,
          /* harmony export */ ssrUtils: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrUtils,
          /* harmony export */ stop: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.stop,
          /* harmony export */ toDisplayString: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toDisplayString,
          /* harmony export */ toHandlerKey: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey,
          /* harmony export */ toHandlers: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlers,
          /* harmony export */ toRaw: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRaw,
          /* harmony export */ toRef: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRef,
          /* harmony export */ toRefs: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRefs,
          /* harmony export */ transformVNodeArgs: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs,
          /* harmony export */ triggerRef: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.triggerRef,
          /* harmony export */ unref: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.unref,
          /* harmony export */ useAttrs: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useAttrs,
          /* harmony export */ useCssModule: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssModule,
          /* harmony export */ useCssVars: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssVars,
          /* harmony export */ useSSRContext: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useSSRContext,
          /* harmony export */ useSlots: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useSlots,
          /* harmony export */ useTransitionState: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useTransitionState,
          /* harmony export */ vModelCheckbox: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelCheckbox,
          /* harmony export */ vModelDynamic: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelDynamic,
          /* harmony export */ vModelRadio: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelRadio,
          /* harmony export */ vModelSelect: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelSelect,
          /* harmony export */ vModelText: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelText,
          /* harmony export */ vShow: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vShow,
          /* harmony export */ version: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.version,
          /* harmony export */ warn: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.warn,
          /* harmony export */ watch: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watch,
          /* harmony export */ watchEffect: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchEffect,
          /* harmony export */ watchPostEffect: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect,
          /* harmony export */ watchSyncEffect: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchSyncEffect,
          /* harmony export */ withAsyncContext: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withAsyncContext,
          /* harmony export */ withCtx: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withCtx,
          /* harmony export */ withDefaults: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withDefaults,
          /* harmony export */ withDirectives: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withDirectives,
          /* harmony export */ withKeys: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withKeys,
          /* harmony export */ withMemo: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withMemo,
          /* harmony export */ withModifiers: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withModifiers,
          /* harmony export */ withScopeId: () =>
            /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withScopeId,
          /* harmony export */ compile: () => /* binding */ compileToFunction,
          /* harmony export */
        });
        /* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! @vue/runtime-dom */ './node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js'
          );
        /* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! @vue/runtime-dom */ './node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js'
          );
        /* harmony import */ var _vue_compiler_dom__WEBPACK_IMPORTED_MODULE_3__ =
          __webpack_require__(
            /*! @vue/compiler-dom */ './node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js'
          );
        /* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! @vue/shared */ './node_modules/@vue/shared/dist/shared.esm-bundler.js'
          );

        function initDev() {
          {
            (0,
            _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__.initCustomFormatter)();
          }
        }

        // This entry is the "full-build" that includes both the runtime
        if (true) {
          initDev();
        }
        const compileCache = Object.create(null);
        function compileToFunction(template, options) {
          if (
            !(0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(template)
          ) {
            if (template.nodeType) {
              template = template.innerHTML;
            } else {
              true &&
                (0, _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__.warn)(
                  `invalid template option: `,
                  template
                );
              return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
            }
          }
          const key = template;
          const cached = compileCache[key];
          if (cached) {
            return cached;
          }
          if (template[0] === '#') {
            const el = document.querySelector(template);
            if (true && !el) {
              (0, _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__.warn)(
                `Template element not found or is empty: ${template}`
              );
            }
            // __UNSAFE__
            // Reason: potential execution of JS expressions in in-DOM template.
            // The user must make sure the in-DOM template is trusted. If it's rendered
            // by the server, the template should not contain any user data.
            template = el ? el.innerHTML : ``;
          }
          const { code } = (0,
          _vue_compiler_dom__WEBPACK_IMPORTED_MODULE_3__.compile)(
            template,
            (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(
              {
                hoistStatic: true,
                onError: true ? onError : 0,
                onWarn: true ? (e) => onError(e, true) : 0,
              },
              options
            )
          );
          function onError(err, asWarning = false) {
            const message = asWarning
              ? err.message
              : `Template compilation error: ${err.message}`;
            const codeFrame =
              err.loc &&
              (0, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.generateCodeFrame)(
                template,
                err.loc.start.offset,
                err.loc.end.offset
              );
            (0, _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__.warn)(
              codeFrame ? `${message}\n${codeFrame}` : message
            );
          }
          // The wildcard import results in a huge object with every export
          // with keys that cannot be mangled, and can be quite heavy size-wise.
          // In the global build we know `Vue` is available globally so we can avoid
          // the wildcard object.
          const render = new Function('Vue', code)(
            _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__
          );
          render._rc = true;
          return (compileCache[key] = render);
        }
        (0,
        _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__.registerRuntimeCompiler)(
          compileToFunction
        );

        /***/
      },

    /***/ './resources/assets/images/svg sync recursive ^\\.\\/.*$':
      /*!****************************************************!*\
  !*** ./resources/assets/images/svg/ sync ^\.\/.*$ ***!
  \****************************************************/
      /***/ (module, __unused_webpack_exports, __webpack_require__) => {
        var map = {
          './alert.svg': './resources/assets/images/svg/alert.svg',
          './approved-cloud.svg':
            './resources/assets/images/svg/approved-cloud.svg',
          './arrow-left.svg': './resources/assets/images/svg/arrow-left.svg',
          './arrow-right.svg': './resources/assets/images/svg/arrow-right.svg',
          './ascending-arrow.svg':
            './resources/assets/images/svg/ascending-arrow.svg',
          './checkbox.svg': './resources/assets/images/svg/checkbox.svg',
          './close.svg': './resources/assets/images/svg/close.svg',
          './delete.svg': './resources/assets/images/svg/delete.svg',
          './descending-arrow.svg':
            './resources/assets/images/svg/descending-arrow.svg',
          './document-write.svg':
            './resources/assets/images/svg/document-write.svg',
          './download-file.svg':
            './resources/assets/images/svg/download-file.svg',
          './folder.svg': './resources/assets/images/svg/folder.svg',
          './history.svg': './resources/assets/images/svg/history.svg',
          './logo.svg': './resources/assets/images/svg/logo.svg',
          './plus.svg': './resources/assets/images/svg/plus.svg',
          './publish.svg': './resources/assets/images/svg/publish.svg',
          './question-mark.svg':
            './resources/assets/images/svg/question-mark.svg',
          './tick.svg': './resources/assets/images/svg/tick.svg',
          './user-profile.svg':
            './resources/assets/images/svg/user-profile.svg',
        };

        function webpackContext(req) {
          var id = webpackContextResolve(req);
          return __webpack_require__(id);
        }
        function webpackContextResolve(req) {
          if (!__webpack_require__.o(map, req)) {
            var e = new Error("Cannot find module '" + req + "'");
            e.code = 'MODULE_NOT_FOUND';
            throw e;
          }
          return map[req];
        }
        webpackContext.keys = function webpackContextKeys() {
          return Object.keys(map);
        };
        webpackContext.resolve = webpackContextResolve;
        module.exports = webpackContext;
        webpackContext.id =
          './resources/assets/images/svg sync recursive ^\\.\\/.*$';

        /***/
      },

    /******/
  };
  /************************************************************************/
  /******/ // The module cache
  /******/ var __webpack_module_cache__ = {};
  /******/
  /******/ // The require function
  /******/ function __webpack_require__(moduleId) {
    /******/ // Check if module is in cache
    /******/ var cachedModule = __webpack_module_cache__[moduleId];
    /******/ if (cachedModule !== undefined) {
      /******/ return cachedModule.exports;
      /******/
    }
    /******/ // Create a new module (and put it into the cache)
    /******/ var module = (__webpack_module_cache__[moduleId] = {
      /******/ id: moduleId,
      /******/ // no module.loaded needed
      /******/ exports: {},
      /******/
    });
    /******/
    /******/ // Execute the module function
    /******/ __webpack_modules__[moduleId].call(
      module.exports,
      module,
      module.exports,
      __webpack_require__
    );
    /******/
    /******/ // Return the exports of the module
    /******/ return module.exports;
    /******/
  }
  /******/
  /************************************************************************/
  /******/ /* webpack/runtime/compat get default export */
  /******/ (() => {
    /******/ // getDefaultExport function for compatibility with non-harmony modules
    /******/ __webpack_require__.n = (module) => {
      /******/ var getter =
        module && module.__esModule
          ? /******/ () => module['default']
          : /******/ () => module;
      /******/ __webpack_require__.d(getter, { a: getter });
      /******/ return getter;
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/define property getters */
  /******/ (() => {
    /******/ // define getter functions for harmony exports
    /******/ __webpack_require__.d = (exports, definition) => {
      /******/ for (var key in definition) {
        /******/ if (
          __webpack_require__.o(definition, key) &&
          !__webpack_require__.o(exports, key)
        ) {
          /******/ Object.defineProperty(exports, key, {
            enumerable: true,
            get: definition[key],
          });
          /******/
        }
        /******/
      }
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/global */
  /******/ (() => {
    /******/ __webpack_require__.g = (function () {
      /******/ if (typeof globalThis === 'object') return globalThis;
      /******/ try {
        /******/ return this || new Function('return this')();
        /******/
      } catch (e) {
        /******/ if (typeof window === 'object') return window;
        /******/
      }
      /******/
    })();
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/hasOwnProperty shorthand */
  /******/ (() => {
    /******/ __webpack_require__.o = (obj, prop) =>
      Object.prototype.hasOwnProperty.call(obj, prop);
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/make namespace object */
  /******/ (() => {
    /******/ // define __esModule on exports
    /******/ __webpack_require__.r = (exports) => {
      /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
        /******/ Object.defineProperty(exports, Symbol.toStringTag, {
          value: 'Module',
        });
        /******/
      }
      /******/ Object.defineProperty(exports, '__esModule', { value: true });
      /******/
    };
    /******/
  })();
  /******/
  /************************************************************************/
  /******/
  /******/ // startup
  /******/ // Load entry module and return exports
  /******/ // This entry module is referenced by other modules so it can't be inlined
  /******/ var __webpack_exports__ = __webpack_require__(
    './resources/assets/js/app.ts'
  );
  /******/
  /******/
})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxRUFBcUUsc0RBQVM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2Q0FBSTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixLQUFxQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0RBQU87QUFDbkIsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsb0RBQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbURBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxLQUFxQztBQUM5QztBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQXFDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1Q0FBdUM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsaURBQUk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxLQUFxQztBQUN0QyxzQkFBc0I7QUFDdEIsTUFBTSxDQUFFO0FBQ1Is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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsa0NBQWtDLGNBQWMsUUFBUTtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQXFDO0FBQzFDLElBQUksMERBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSSxtREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOE1BQThNO0FBQzFOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWcyQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMWpQbitCO0FBQzNWO0FBQ3VQOztBQUV6UjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsS0FBSztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsUUFBUTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjLEdBQUcsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxzQkFBc0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztVQ3hDQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3RCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsaUNBQWlDLFdBQVc7V0FDNUM7V0FDQTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsR0FBRztXQUNIO1dBQ0E7V0FDQSxDQUFDOzs7OztXQ1BEOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7VUVOQTtVQUNBO1VBQ0E7VUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdnVlL2NvbXBpbGVyLWNvcmUvZGlzdC9jb21waWxlci1jb3JlLmVzbS1idW5kbGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdnVlL2NvbXBpbGVyLWRvbS9kaXN0L2NvbXBpbGVyLWRvbS5lc20tYnVuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHZ1ZS9yZWFjdGl2aXR5L2Rpc3QvcmVhY3Rpdml0eS5lc20tYnVuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHZ1ZS9ydW50aW1lLWNvcmUvZGlzdC9ydW50aW1lLWNvcmUuZXNtLWJ1bmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B2dWUvcnVudGltZS1kb20vZGlzdC9ydW50aW1lLWRvbS5lc20tYnVuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHZ1ZS9zaGFyZWQvZGlzdC9zaGFyZWQuZXNtLWJ1bmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnRzL0FkbWluSGVhZGVyLnZ1ZSIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBvbmVudHMvQWxlcnRNZXNzYWdlLnZ1ZSIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBvbmVudHMvUGFnaW5hdGlvbi52dWUiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnRzL1BvcHVwTW9kYWwudnVlIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvY29tcG9uZW50cy9Ub2FzdE1lc3NhZ2UudnVlIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvdmlld3MvYWN0aXZpdHkvQWN0aXZpdHlMaXN0LnZ1ZSIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL3ZpZXdzL2FjdGl2aXR5L3BhcnRpYWxzL0FkZEFjdGl2aXR5QnV0dG9uLnZ1ZSIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL3ZpZXdzL2FjdGl2aXR5L3BhcnRpYWxzL0VtcHR5QWN0aXZpdHkudnVlIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvdmlld3MvYWN0aXZpdHkvcGFydGlhbHMvUGFnZVRpdGxlLnZ1ZSIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL3ZpZXdzL2FjdGl2aXR5L3BhcnRpYWxzL1RhYmxlTGF5b3V0LnZ1ZSIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2FwcC50cyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBvbmVudHMvQWxlcnRNZXNzYWdlLnZ1ZT8zMGY3Iiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvY29tcG9uZW50cy9Qb3B1cE1vZGFsLnZ1ZT8xZjA4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2Nzc1dpdGhNYXBwaW5nVG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9pbWFnZXMvc3ZnL2FsZXJ0LnN2ZyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2ltYWdlcy9zdmcvYXBwcm92ZWQtY2xvdWQuc3ZnIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvaW1hZ2VzL3N2Zy9hcnJvdy1sZWZ0LnN2ZyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2ltYWdlcy9zdmcvYXJyb3ctcmlnaHQuc3ZnIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvaW1hZ2VzL3N2Zy9hc2NlbmRpbmctYXJyb3cuc3ZnIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvaW1hZ2VzL3N2Zy9jaGVja2JveC5zdmciLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9pbWFnZXMvc3ZnL2Nsb3NlLnN2ZyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2ltYWdlcy9zdmcvZGVsZXRlLnN2ZyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2ltYWdlcy9zdmcvZGVzY2VuZGluZy1hcnJvdy5zdmciLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9pbWFnZXMvc3ZnL2RvY3VtZW50LXdyaXRlLnN2ZyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2ltYWdlcy9zdmcvZG93bmxvYWQtZmlsZS5zdmciLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9pbWFnZXMvc3ZnL2ZvbGRlci5zdmciLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9pbWFnZXMvc3ZnL2hpc3Rvcnkuc3ZnIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvaW1hZ2VzL3N2Zy9sb2dvLnN2ZyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2ltYWdlcy9zdmcvcGx1cy5zdmciLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9pbWFnZXMvc3ZnL3B1Ymxpc2guc3ZnIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvaW1hZ2VzL3N2Zy9xdWVzdGlvbi1tYXJrLnN2ZyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2ltYWdlcy9zdmcvdGljay5zdmciLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9pbWFnZXMvc3ZnL3VzZXItcHJvZmlsZS5zdmciLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnRzL0FsZXJ0TWVzc2FnZS52dWU/NmI5NiIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBvbmVudHMvUG9wdXBNb2RhbC52dWU/ZmQ4NiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N2Zy12dWUzL2Rpc3Qvc3ZnLXZ1ZS5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9leHBvcnRIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnRzL0FkbWluSGVhZGVyLnZ1ZT8zYzJkIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvY29tcG9uZW50cy9BbGVydE1lc3NhZ2UudnVlPzAxMGQiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnRzL1BhZ2luYXRpb24udnVlPzE3MDMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnRzL1BvcHVwTW9kYWwudnVlP2VkMzAiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnRzL1RvYXN0TWVzc2FnZS52dWU/MzkxZCIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL3ZpZXdzL2FjdGl2aXR5L0FjdGl2aXR5TGlzdC52dWU/MTRlOSIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL3ZpZXdzL2FjdGl2aXR5L3BhcnRpYWxzL0FkZEFjdGl2aXR5QnV0dG9uLnZ1ZT80NzQzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvdmlld3MvYWN0aXZpdHkvcGFydGlhbHMvRW1wdHlBY3Rpdml0eS52dWU/NTQxZiIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL3ZpZXdzL2FjdGl2aXR5L3BhcnRpYWxzL1BhZ2VUaXRsZS52dWU/MjExYSIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL3ZpZXdzL2FjdGl2aXR5L3BhcnRpYWxzL1RhYmxlTGF5b3V0LnZ1ZT83MDQ2Iiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvY29tcG9uZW50cy9BZG1pbkhlYWRlci52dWU/MjI3YSIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBvbmVudHMvQWxlcnRNZXNzYWdlLnZ1ZT9hNmJiIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvY29tcG9uZW50cy9QYWdpbmF0aW9uLnZ1ZT9iYTVhIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvY29tcG9uZW50cy9Qb3B1cE1vZGFsLnZ1ZT85NDBkIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvY29tcG9uZW50cy9Ub2FzdE1lc3NhZ2UudnVlP2U5YTciLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy92aWV3cy9hY3Rpdml0eS9BY3Rpdml0eUxpc3QudnVlPzYzNGMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy92aWV3cy9hY3Rpdml0eS9wYXJ0aWFscy9BZGRBY3Rpdml0eUJ1dHRvbi52dWU/ZWNlZSIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL3ZpZXdzL2FjdGl2aXR5L3BhcnRpYWxzL0VtcHR5QWN0aXZpdHkudnVlPzNlMWYiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy92aWV3cy9hY3Rpdml0eS9wYXJ0aWFscy9QYWdlVGl0bGUudnVlPzAzMGYiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy92aWV3cy9hY3Rpdml0eS9wYXJ0aWFscy9UYWJsZUxheW91dC52dWU/ZjU1YyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBvbmVudHMvQWRtaW5IZWFkZXIudnVlP2ZlMzQiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnRzL0FsZXJ0TWVzc2FnZS52dWU/N2QzMSIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBvbmVudHMvUGFnaW5hdGlvbi52dWU/NGFlZiIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBvbmVudHMvUG9wdXBNb2RhbC52dWU/ZWVjZCIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBvbmVudHMvVG9hc3RNZXNzYWdlLnZ1ZT83NjVkIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvdmlld3MvYWN0aXZpdHkvQWN0aXZpdHlMaXN0LnZ1ZT9hNTFmIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvdmlld3MvYWN0aXZpdHkvcGFydGlhbHMvQWRkQWN0aXZpdHlCdXR0b24udnVlPzU4ZWYiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy92aWV3cy9hY3Rpdml0eS9wYXJ0aWFscy9FbXB0eUFjdGl2aXR5LnZ1ZT9mM2ZjIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvdmlld3MvYWN0aXZpdHkvcGFydGlhbHMvUGFnZVRpdGxlLnZ1ZT80MDAxIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvdmlld3MvYWN0aXZpdHkvcGFydGlhbHMvVGFibGVMYXlvdXQudnVlP2I4OGUiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnRzL0FsZXJ0TWVzc2FnZS52dWU/M2MxZSIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBvbmVudHMvUG9wdXBNb2RhbC52dWU/ODZiMSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmVzbS1idW5kbGVyLmpzIiwid2VicGFjazovLy8vVXNlcnMvdGl0dW5nZHVwL3Byb2plY3RzL2lhdGlwdWJsaXNoZXIvcmVzb3VyY2VzL2Fzc2V0cy9pbWFnZXMvc3ZnfHN5bmN8L15cXC5cXC8uKiQvIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly8vd2VicGFjay9iZWZvcmUtc3RhcnR1cCIsIndlYnBhY2s6Ly8vd2VicGFjay9zdGFydHVwIiwid2VicGFjazovLy93ZWJwYWNrL2FmdGVyLXN0YXJ0dXAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNTdHJpbmcsIGh5cGhlbmF0ZSwgTk9PUCwgZXh0ZW5kLCBpc09iamVjdCwgTk8sIGlzQXJyYXksIG1ha2VNYXAsIGlzU3ltYm9sLCBFTVBUWV9PQkosIGNhcGl0YWxpemUsIGNhbWVsaXplIGFzIGNhbWVsaXplJDEsIFBhdGNoRmxhZ05hbWVzLCBzbG90RmxhZ3NUZXh0LCBpc09uLCBpc0J1aWx0SW5EaXJlY3RpdmUsIGlzUmVzZXJ2ZWRQcm9wLCB0b0hhbmRsZXJLZXkgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5leHBvcnQgeyBnZW5lcmF0ZUNvZGVGcmFtZSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuZnVuY3Rpb24gZGVmYXVsdE9uRXJyb3IoZXJyb3IpIHtcclxuICAgIHRocm93IGVycm9yO1xyXG59XHJcbmZ1bmN0aW9uIGRlZmF1bHRPbldhcm4obXNnKSB7XHJcbiAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY29uc29sZS53YXJuKGBbVnVlIHdhcm5dICR7bXNnLm1lc3NhZ2V9YCk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXJFcnJvcihjb2RlLCBsb2MsIG1lc3NhZ2VzLCBhZGRpdGlvbmFsTWVzc2FnZSkge1xyXG4gICAgY29uc3QgbXNnID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICF0cnVlXHJcbiAgICAgICAgPyAobWVzc2FnZXMgfHwgZXJyb3JNZXNzYWdlcylbY29kZV0gKyAoYWRkaXRpb25hbE1lc3NhZ2UgfHwgYGApXHJcbiAgICAgICAgOiBjb2RlO1xyXG4gICAgY29uc3QgZXJyb3IgPSBuZXcgU3ludGF4RXJyb3IoU3RyaW5nKG1zZykpO1xyXG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XHJcbiAgICBlcnJvci5sb2MgPSBsb2M7XHJcbiAgICByZXR1cm4gZXJyb3I7XHJcbn1cclxuY29uc3QgZXJyb3JNZXNzYWdlcyA9IHtcclxuICAgIC8vIHBhcnNlIGVycm9yc1xyXG4gICAgWzAgLyogQUJSVVBUX0NMT1NJTkdfT0ZfRU1QVFlfQ09NTUVOVCAqL106ICdJbGxlZ2FsIGNvbW1lbnQuJyxcclxuICAgIFsxIC8qIENEQVRBX0lOX0hUTUxfQ09OVEVOVCAqL106ICdDREFUQSBzZWN0aW9uIGlzIGFsbG93ZWQgb25seSBpbiBYTUwgY29udGV4dC4nLFxyXG4gICAgWzIgLyogRFVQTElDQVRFX0FUVFJJQlVURSAqL106ICdEdXBsaWNhdGUgYXR0cmlidXRlLicsXHJcbiAgICBbMyAvKiBFTkRfVEFHX1dJVEhfQVRUUklCVVRFUyAqL106ICdFbmQgdGFnIGNhbm5vdCBoYXZlIGF0dHJpYnV0ZXMuJyxcclxuICAgIFs0IC8qIEVORF9UQUdfV0lUSF9UUkFJTElOR19TT0xJRFVTICovXTogXCJJbGxlZ2FsICcvJyBpbiB0YWdzLlwiLFxyXG4gICAgWzUgLyogRU9GX0JFRk9SRV9UQUdfTkFNRSAqL106ICdVbmV4cGVjdGVkIEVPRiBpbiB0YWcuJyxcclxuICAgIFs2IC8qIEVPRl9JTl9DREFUQSAqL106ICdVbmV4cGVjdGVkIEVPRiBpbiBDREFUQSBzZWN0aW9uLicsXHJcbiAgICBbNyAvKiBFT0ZfSU5fQ09NTUVOVCAqL106ICdVbmV4cGVjdGVkIEVPRiBpbiBjb21tZW50LicsXHJcbiAgICBbOCAvKiBFT0ZfSU5fU0NSSVBUX0hUTUxfQ09NTUVOVF9MSUtFX1RFWFQgKi9dOiAnVW5leHBlY3RlZCBFT0YgaW4gc2NyaXB0LicsXHJcbiAgICBbOSAvKiBFT0ZfSU5fVEFHICovXTogJ1VuZXhwZWN0ZWQgRU9GIGluIHRhZy4nLFxyXG4gICAgWzEwIC8qIElOQ09SUkVDVExZX0NMT1NFRF9DT01NRU5UICovXTogJ0luY29ycmVjdGx5IGNsb3NlZCBjb21tZW50LicsXHJcbiAgICBbMTEgLyogSU5DT1JSRUNUTFlfT1BFTkVEX0NPTU1FTlQgKi9dOiAnSW5jb3JyZWN0bHkgb3BlbmVkIGNvbW1lbnQuJyxcclxuICAgIFsxMiAvKiBJTlZBTElEX0ZJUlNUX0NIQVJBQ1RFUl9PRl9UQUdfTkFNRSAqL106IFwiSWxsZWdhbCB0YWcgbmFtZS4gVXNlICcmbHQ7JyB0byBwcmludCAnPCcuXCIsXHJcbiAgICBbMTMgLyogTUlTU0lOR19BVFRSSUJVVEVfVkFMVUUgKi9dOiAnQXR0cmlidXRlIHZhbHVlIHdhcyBleHBlY3RlZC4nLFxyXG4gICAgWzE0IC8qIE1JU1NJTkdfRU5EX1RBR19OQU1FICovXTogJ0VuZCB0YWcgbmFtZSB3YXMgZXhwZWN0ZWQuJyxcclxuICAgIFsxNSAvKiBNSVNTSU5HX1dISVRFU1BBQ0VfQkVUV0VFTl9BVFRSSUJVVEVTICovXTogJ1doaXRlc3BhY2Ugd2FzIGV4cGVjdGVkLicsXHJcbiAgICBbMTYgLyogTkVTVEVEX0NPTU1FTlQgKi9dOiBcIlVuZXhwZWN0ZWQgJzwhLS0nIGluIGNvbW1lbnQuXCIsXHJcbiAgICBbMTcgLyogVU5FWFBFQ1RFRF9DSEFSQUNURVJfSU5fQVRUUklCVVRFX05BTUUgKi9dOiAnQXR0cmlidXRlIG5hbWUgY2Fubm90IGNvbnRhaW4gVSswMDIyIChcIiksIFUrMDAyNyAoXFwnKSwgYW5kIFUrMDAzQyAoPCkuJyxcclxuICAgIFsxOCAvKiBVTkVYUEVDVEVEX0NIQVJBQ1RFUl9JTl9VTlFVT1RFRF9BVFRSSUJVVEVfVkFMVUUgKi9dOiAnVW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlIGNhbm5vdCBjb250YWluIFUrMDAyMiAoXCIpLCBVKzAwMjcgKFxcJyksIFUrMDAzQyAoPCksIFUrMDAzRCAoPSksIGFuZCBVKzAwNjAgKGApLicsXHJcbiAgICBbMTkgLyogVU5FWFBFQ1RFRF9FUVVBTFNfU0lHTl9CRUZPUkVfQVRUUklCVVRFX05BTUUgKi9dOiBcIkF0dHJpYnV0ZSBuYW1lIGNhbm5vdCBzdGFydCB3aXRoICc9Jy5cIixcclxuICAgIFsyMSAvKiBVTkVYUEVDVEVEX1FVRVNUSU9OX01BUktfSU5TVEVBRF9PRl9UQUdfTkFNRSAqL106IFwiJzw/JyBpcyBhbGxvd2VkIG9ubHkgaW4gWE1MIGNvbnRleHQuXCIsXHJcbiAgICBbMjAgLyogVU5FWFBFQ1RFRF9OVUxMX0NIQVJBQ1RFUiAqL106IGBVbmV4cGVjdGVkIG51bGwgY2hhcmFjdGVyLmAsXHJcbiAgICBbMjIgLyogVU5FWFBFQ1RFRF9TT0xJRFVTX0lOX1RBRyAqL106IFwiSWxsZWdhbCAnLycgaW4gdGFncy5cIixcclxuICAgIC8vIFZ1ZS1zcGVjaWZpYyBwYXJzZSBlcnJvcnNcclxuICAgIFsyMyAvKiBYX0lOVkFMSURfRU5EX1RBRyAqL106ICdJbnZhbGlkIGVuZCB0YWcuJyxcclxuICAgIFsyNCAvKiBYX01JU1NJTkdfRU5EX1RBRyAqL106ICdFbGVtZW50IGlzIG1pc3NpbmcgZW5kIHRhZy4nLFxyXG4gICAgWzI1IC8qIFhfTUlTU0lOR19JTlRFUlBPTEFUSU9OX0VORCAqL106ICdJbnRlcnBvbGF0aW9uIGVuZCBzaWduIHdhcyBub3QgZm91bmQuJyxcclxuICAgIFsyNyAvKiBYX01JU1NJTkdfRFlOQU1JQ19ESVJFQ1RJVkVfQVJHVU1FTlRfRU5EICovXTogJ0VuZCBicmFja2V0IGZvciBkeW5hbWljIGRpcmVjdGl2ZSBhcmd1bWVudCB3YXMgbm90IGZvdW5kLiAnICtcclxuICAgICAgICAnTm90ZSB0aGF0IGR5bmFtaWMgZGlyZWN0aXZlIGFyZ3VtZW50IGNhbm5vdCBjb250YWluIHNwYWNlcy4nLFxyXG4gICAgWzI2IC8qIFhfTUlTU0lOR19ESVJFQ1RJVkVfTkFNRSAqL106ICdMZWdhbCBkaXJlY3RpdmUgbmFtZSB3YXMgZXhwZWN0ZWQuJyxcclxuICAgIC8vIHRyYW5zZm9ybSBlcnJvcnNcclxuICAgIFsyOCAvKiBYX1ZfSUZfTk9fRVhQUkVTU0lPTiAqL106IGB2LWlmL3YtZWxzZS1pZiBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcclxuICAgIFsyOSAvKiBYX1ZfSUZfU0FNRV9LRVkgKi9dOiBgdi1pZi9lbHNlIGJyYW5jaGVzIG11c3QgdXNlIHVuaXF1ZSBrZXlzLmAsXHJcbiAgICBbMzAgLyogWF9WX0VMU0VfTk9fQURKQUNFTlRfSUYgKi9dOiBgdi1lbHNlL3YtZWxzZS1pZiBoYXMgbm8gYWRqYWNlbnQgdi1pZiBvciB2LWVsc2UtaWYuYCxcclxuICAgIFszMSAvKiBYX1ZfRk9SX05PX0VYUFJFU1NJT04gKi9dOiBgdi1mb3IgaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXHJcbiAgICBbMzIgLyogWF9WX0ZPUl9NQUxGT1JNRURfRVhQUkVTU0lPTiAqL106IGB2LWZvciBoYXMgaW52YWxpZCBleHByZXNzaW9uLmAsXHJcbiAgICBbMzMgLyogWF9WX0ZPUl9URU1QTEFURV9LRVlfUExBQ0VNRU5UICovXTogYDx0ZW1wbGF0ZSB2LWZvcj4ga2V5IHNob3VsZCBiZSBwbGFjZWQgb24gdGhlIDx0ZW1wbGF0ZT4gdGFnLmAsXHJcbiAgICBbMzQgLyogWF9WX0JJTkRfTk9fRVhQUkVTU0lPTiAqL106IGB2LWJpbmQgaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXHJcbiAgICBbMzUgLyogWF9WX09OX05PX0VYUFJFU1NJT04gKi9dOiBgdi1vbiBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcclxuICAgIFszNiAvKiBYX1ZfU0xPVF9VTkVYUEVDVEVEX0RJUkVDVElWRV9PTl9TTE9UX09VVExFVCAqL106IGBVbmV4cGVjdGVkIGN1c3RvbSBkaXJlY3RpdmUgb24gPHNsb3Q+IG91dGxldC5gLFxyXG4gICAgWzM3IC8qIFhfVl9TTE9UX01JWEVEX1NMT1RfVVNBR0UgKi9dOiBgTWl4ZWQgdi1zbG90IHVzYWdlIG9uIGJvdGggdGhlIGNvbXBvbmVudCBhbmQgbmVzdGVkIDx0ZW1wbGF0ZT4uYCArXHJcbiAgICAgICAgYFdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIG5hbWVkIHNsb3RzLCBhbGwgc2xvdHMgc2hvdWxkIHVzZSA8dGVtcGxhdGU+IGAgK1xyXG4gICAgICAgIGBzeW50YXggdG8gYXZvaWQgc2NvcGUgYW1iaWd1aXR5LmAsXHJcbiAgICBbMzggLyogWF9WX1NMT1RfRFVQTElDQVRFX1NMT1RfTkFNRVMgKi9dOiBgRHVwbGljYXRlIHNsb3QgbmFtZXMgZm91bmQuIGAsXHJcbiAgICBbMzkgLyogWF9WX1NMT1RfRVhUUkFORU9VU19ERUZBVUxUX1NMT1RfQ0hJTERSRU4gKi9dOiBgRXh0cmFuZW91cyBjaGlsZHJlbiBmb3VuZCB3aGVuIGNvbXBvbmVudCBhbHJlYWR5IGhhcyBleHBsaWNpdGx5IG5hbWVkIGAgK1xyXG4gICAgICAgIGBkZWZhdWx0IHNsb3QuIFRoZXNlIGNoaWxkcmVuIHdpbGwgYmUgaWdub3JlZC5gLFxyXG4gICAgWzQwIC8qIFhfVl9TTE9UX01JU1BMQUNFRCAqL106IGB2LXNsb3QgY2FuIG9ubHkgYmUgdXNlZCBvbiBjb21wb25lbnRzIG9yIDx0ZW1wbGF0ZT4gdGFncy5gLFxyXG4gICAgWzQxIC8qIFhfVl9NT0RFTF9OT19FWFBSRVNTSU9OICovXTogYHYtbW9kZWwgaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXHJcbiAgICBbNDIgLyogWF9WX01PREVMX01BTEZPUk1FRF9FWFBSRVNTSU9OICovXTogYHYtbW9kZWwgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIEphdmFTY3JpcHQgbWVtYmVyIGV4cHJlc3Npb24uYCxcclxuICAgIFs0MyAvKiBYX1ZfTU9ERUxfT05fU0NPUEVfVkFSSUFCTEUgKi9dOiBgdi1tb2RlbCBjYW5ub3QgYmUgdXNlZCBvbiB2LWZvciBvciB2LXNsb3Qgc2NvcGUgdmFyaWFibGVzIGJlY2F1c2UgdGhleSBhcmUgbm90IHdyaXRhYmxlLmAsXHJcbiAgICBbNDQgLyogWF9JTlZBTElEX0VYUFJFU1NJT04gKi9dOiBgRXJyb3IgcGFyc2luZyBKYXZhU2NyaXB0IGV4cHJlc3Npb246IGAsXHJcbiAgICBbNDUgLyogWF9LRUVQX0FMSVZFX0lOVkFMSURfQ0hJTERSRU4gKi9dOiBgPEtlZXBBbGl2ZT4gZXhwZWN0cyBleGFjdGx5IG9uZSBjaGlsZCBjb21wb25lbnQuYCxcclxuICAgIC8vIGdlbmVyaWMgZXJyb3JzXHJcbiAgICBbNDYgLyogWF9QUkVGSVhfSURfTk9UX1NVUFBPUlRFRCAqL106IGBcInByZWZpeElkZW50aWZpZXJzXCIgb3B0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBidWlsZCBvZiBjb21waWxlci5gLFxyXG4gICAgWzQ3IC8qIFhfTU9EVUxFX01PREVfTk9UX1NVUFBPUlRFRCAqL106IGBFUyBtb2R1bGUgbW9kZSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnVpbGQgb2YgY29tcGlsZXIuYCxcclxuICAgIFs0OCAvKiBYX0NBQ0hFX0hBTkRMRVJfTk9UX1NVUFBPUlRFRCAqL106IGBcImNhY2hlSGFuZGxlcnNcIiBvcHRpb24gaXMgb25seSBzdXBwb3J0ZWQgd2hlbiB0aGUgXCJwcmVmaXhJZGVudGlmaWVyc1wiIG9wdGlvbiBpcyBlbmFibGVkLmAsXHJcbiAgICBbNDkgLyogWF9TQ09QRV9JRF9OT1RfU1VQUE9SVEVEICovXTogYFwic2NvcGVJZFwiIG9wdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCBpbiBtb2R1bGUgbW9kZS5gLFxyXG4gICAgLy8ganVzdCB0byBmdWxmaWxsIHR5cGVzXHJcbiAgICBbNTAgLyogX19FWFRFTkRfUE9JTlRfXyAqL106IGBgXHJcbn07XG5cbmNvbnN0IEZSQUdNRU5UID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBGcmFnbWVudGAgOiBgYCk7XHJcbmNvbnN0IFRFTEVQT1JUID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBUZWxlcG9ydGAgOiBgYCk7XHJcbmNvbnN0IFNVU1BFTlNFID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBTdXNwZW5zZWAgOiBgYCk7XHJcbmNvbnN0IEtFRVBfQUxJVkUgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYEtlZXBBbGl2ZWAgOiBgYCk7XHJcbmNvbnN0IEJBU0VfVFJBTlNJVElPTiA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgQmFzZVRyYW5zaXRpb25gIDogYGApO1xyXG5jb25zdCBPUEVOX0JMT0NLID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBvcGVuQmxvY2tgIDogYGApO1xyXG5jb25zdCBDUkVBVEVfQkxPQ0sgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNyZWF0ZUJsb2NrYCA6IGBgKTtcclxuY29uc3QgQ1JFQVRFX0VMRU1FTlRfQkxPQ0sgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNyZWF0ZUVsZW1lbnRCbG9ja2AgOiBgYCk7XHJcbmNvbnN0IENSRUFURV9WTk9ERSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY3JlYXRlVk5vZGVgIDogYGApO1xyXG5jb25zdCBDUkVBVEVfRUxFTUVOVF9WTk9ERSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY3JlYXRlRWxlbWVudFZOb2RlYCA6IGBgKTtcclxuY29uc3QgQ1JFQVRFX0NPTU1FTlQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNyZWF0ZUNvbW1lbnRWTm9kZWAgOiBgYCk7XHJcbmNvbnN0IENSRUFURV9URVhUID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBjcmVhdGVUZXh0Vk5vZGVgIDogYGApO1xyXG5jb25zdCBDUkVBVEVfU1RBVElDID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBjcmVhdGVTdGF0aWNWTm9kZWAgOiBgYCk7XHJcbmNvbnN0IFJFU09MVkVfQ09NUE9ORU5UID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGByZXNvbHZlQ29tcG9uZW50YCA6IGBgKTtcclxuY29uc3QgUkVTT0xWRV9EWU5BTUlDX0NPTVBPTkVOVCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgcmVzb2x2ZUR5bmFtaWNDb21wb25lbnRgIDogYGApO1xyXG5jb25zdCBSRVNPTFZFX0RJUkVDVElWRSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgcmVzb2x2ZURpcmVjdGl2ZWAgOiBgYCk7XHJcbmNvbnN0IFJFU09MVkVfRklMVEVSID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGByZXNvbHZlRmlsdGVyYCA6IGBgKTtcclxuY29uc3QgV0lUSF9ESVJFQ1RJVkVTID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB3aXRoRGlyZWN0aXZlc2AgOiBgYCk7XHJcbmNvbnN0IFJFTkRFUl9MSVNUID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGByZW5kZXJMaXN0YCA6IGBgKTtcclxuY29uc3QgUkVOREVSX1NMT1QgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHJlbmRlclNsb3RgIDogYGApO1xyXG5jb25zdCBDUkVBVEVfU0xPVFMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNyZWF0ZVNsb3RzYCA6IGBgKTtcclxuY29uc3QgVE9fRElTUExBWV9TVFJJTkcgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHRvRGlzcGxheVN0cmluZ2AgOiBgYCk7XHJcbmNvbnN0IE1FUkdFX1BST1BTID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBtZXJnZVByb3BzYCA6IGBgKTtcclxuY29uc3QgTk9STUFMSVpFX0NMQVNTID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBub3JtYWxpemVDbGFzc2AgOiBgYCk7XHJcbmNvbnN0IE5PUk1BTElaRV9TVFlMRSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgbm9ybWFsaXplU3R5bGVgIDogYGApO1xyXG5jb25zdCBOT1JNQUxJWkVfUFJPUFMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYG5vcm1hbGl6ZVByb3BzYCA6IGBgKTtcclxuY29uc3QgR1VBUkRfUkVBQ1RJVkVfUFJPUFMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGd1YXJkUmVhY3RpdmVQcm9wc2AgOiBgYCk7XHJcbmNvbnN0IFRPX0hBTkRMRVJTID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB0b0hhbmRsZXJzYCA6IGBgKTtcclxuY29uc3QgQ0FNRUxJWkUgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNhbWVsaXplYCA6IGBgKTtcclxuY29uc3QgQ0FQSVRBTElaRSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY2FwaXRhbGl6ZWAgOiBgYCk7XHJcbmNvbnN0IFRPX0hBTkRMRVJfS0VZID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB0b0hhbmRsZXJLZXlgIDogYGApO1xyXG5jb25zdCBTRVRfQkxPQ0tfVFJBQ0tJTkcgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHNldEJsb2NrVHJhY2tpbmdgIDogYGApO1xyXG5jb25zdCBQVVNIX1NDT1BFX0lEID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBwdXNoU2NvcGVJZGAgOiBgYCk7XHJcbmNvbnN0IFBPUF9TQ09QRV9JRCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgcG9wU2NvcGVJZGAgOiBgYCk7XHJcbmNvbnN0IFdJVEhfQ1RYID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB3aXRoQ3R4YCA6IGBgKTtcclxuY29uc3QgVU5SRUYgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHVucmVmYCA6IGBgKTtcclxuY29uc3QgSVNfUkVGID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBpc1JlZmAgOiBgYCk7XHJcbmNvbnN0IFdJVEhfTUVNTyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgd2l0aE1lbW9gIDogYGApO1xyXG5jb25zdCBJU19NRU1PX1NBTUUgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGlzTWVtb1NhbWVgIDogYGApO1xyXG4vLyBOYW1lIG1hcHBpbmcgZm9yIHJ1bnRpbWUgaGVscGVycyB0aGF0IG5lZWQgdG8gYmUgaW1wb3J0ZWQgZnJvbSAndnVlJyBpblxyXG4vLyBnZW5lcmF0ZWQgY29kZS4gTWFrZSBzdXJlIHRoZXNlIGFyZSBjb3JyZWN0bHkgZXhwb3J0ZWQgaW4gdGhlIHJ1bnRpbWUhXHJcbi8vIFVzaW5nIGBhbnlgIGhlcmUgYmVjYXVzZSBUUyBkb2Vzbid0IGFsbG93IHN5bWJvbHMgYXMgaW5kZXggdHlwZS5cclxuY29uc3QgaGVscGVyTmFtZU1hcCA9IHtcclxuICAgIFtGUkFHTUVOVF06IGBGcmFnbWVudGAsXHJcbiAgICBbVEVMRVBPUlRdOiBgVGVsZXBvcnRgLFxyXG4gICAgW1NVU1BFTlNFXTogYFN1c3BlbnNlYCxcclxuICAgIFtLRUVQX0FMSVZFXTogYEtlZXBBbGl2ZWAsXHJcbiAgICBbQkFTRV9UUkFOU0lUSU9OXTogYEJhc2VUcmFuc2l0aW9uYCxcclxuICAgIFtPUEVOX0JMT0NLXTogYG9wZW5CbG9ja2AsXHJcbiAgICBbQ1JFQVRFX0JMT0NLXTogYGNyZWF0ZUJsb2NrYCxcclxuICAgIFtDUkVBVEVfRUxFTUVOVF9CTE9DS106IGBjcmVhdGVFbGVtZW50QmxvY2tgLFxyXG4gICAgW0NSRUFURV9WTk9ERV06IGBjcmVhdGVWTm9kZWAsXHJcbiAgICBbQ1JFQVRFX0VMRU1FTlRfVk5PREVdOiBgY3JlYXRlRWxlbWVudFZOb2RlYCxcclxuICAgIFtDUkVBVEVfQ09NTUVOVF06IGBjcmVhdGVDb21tZW50Vk5vZGVgLFxyXG4gICAgW0NSRUFURV9URVhUXTogYGNyZWF0ZVRleHRWTm9kZWAsXHJcbiAgICBbQ1JFQVRFX1NUQVRJQ106IGBjcmVhdGVTdGF0aWNWTm9kZWAsXHJcbiAgICBbUkVTT0xWRV9DT01QT05FTlRdOiBgcmVzb2x2ZUNvbXBvbmVudGAsXHJcbiAgICBbUkVTT0xWRV9EWU5BTUlDX0NPTVBPTkVOVF06IGByZXNvbHZlRHluYW1pY0NvbXBvbmVudGAsXHJcbiAgICBbUkVTT0xWRV9ESVJFQ1RJVkVdOiBgcmVzb2x2ZURpcmVjdGl2ZWAsXHJcbiAgICBbUkVTT0xWRV9GSUxURVJdOiBgcmVzb2x2ZUZpbHRlcmAsXHJcbiAgICBbV0lUSF9ESVJFQ1RJVkVTXTogYHdpdGhEaXJlY3RpdmVzYCxcclxuICAgIFtSRU5ERVJfTElTVF06IGByZW5kZXJMaXN0YCxcclxuICAgIFtSRU5ERVJfU0xPVF06IGByZW5kZXJTbG90YCxcclxuICAgIFtDUkVBVEVfU0xPVFNdOiBgY3JlYXRlU2xvdHNgLFxyXG4gICAgW1RPX0RJU1BMQVlfU1RSSU5HXTogYHRvRGlzcGxheVN0cmluZ2AsXHJcbiAgICBbTUVSR0VfUFJPUFNdOiBgbWVyZ2VQcm9wc2AsXHJcbiAgICBbTk9STUFMSVpFX0NMQVNTXTogYG5vcm1hbGl6ZUNsYXNzYCxcclxuICAgIFtOT1JNQUxJWkVfU1RZTEVdOiBgbm9ybWFsaXplU3R5bGVgLFxyXG4gICAgW05PUk1BTElaRV9QUk9QU106IGBub3JtYWxpemVQcm9wc2AsXHJcbiAgICBbR1VBUkRfUkVBQ1RJVkVfUFJPUFNdOiBgZ3VhcmRSZWFjdGl2ZVByb3BzYCxcclxuICAgIFtUT19IQU5ETEVSU106IGB0b0hhbmRsZXJzYCxcclxuICAgIFtDQU1FTElaRV06IGBjYW1lbGl6ZWAsXHJcbiAgICBbQ0FQSVRBTElaRV06IGBjYXBpdGFsaXplYCxcclxuICAgIFtUT19IQU5ETEVSX0tFWV06IGB0b0hhbmRsZXJLZXlgLFxyXG4gICAgW1NFVF9CTE9DS19UUkFDS0lOR106IGBzZXRCbG9ja1RyYWNraW5nYCxcclxuICAgIFtQVVNIX1NDT1BFX0lEXTogYHB1c2hTY29wZUlkYCxcclxuICAgIFtQT1BfU0NPUEVfSURdOiBgcG9wU2NvcGVJZGAsXHJcbiAgICBbV0lUSF9DVFhdOiBgd2l0aEN0eGAsXHJcbiAgICBbVU5SRUZdOiBgdW5yZWZgLFxyXG4gICAgW0lTX1JFRl06IGBpc1JlZmAsXHJcbiAgICBbV0lUSF9NRU1PXTogYHdpdGhNZW1vYCxcclxuICAgIFtJU19NRU1PX1NBTUVdOiBgaXNNZW1vU2FtZWBcclxufTtcclxuZnVuY3Rpb24gcmVnaXN0ZXJSdW50aW1lSGVscGVycyhoZWxwZXJzKSB7XHJcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGhlbHBlcnMpLmZvckVhY2gocyA9PiB7XHJcbiAgICAgICAgaGVscGVyTmFtZU1hcFtzXSA9IGhlbHBlcnNbc107XHJcbiAgICB9KTtcclxufVxuXG4vLyBBU1QgVXRpbGl0aWVzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBTb21lIGV4cHJlc3Npb25zLCBlLmcuIHNlcXVlbmNlIGFuZCBjb25kaXRpb25hbCBleHByZXNzaW9ucywgYXJlIG5ldmVyXHJcbi8vIGFzc29jaWF0ZWQgd2l0aCB0ZW1wbGF0ZSBub2Rlcywgc28gdGhlaXIgc291cmNlIGxvY2F0aW9ucyBhcmUganVzdCBhIHN0dWIuXHJcbi8vIENvbnRhaW5lciB0eXBlcyBsaWtlIENvbXBvdW5kRXhwcmVzc2lvbiBhbHNvIGRvbid0IG5lZWQgYSByZWFsIGxvY2F0aW9uLlxyXG5jb25zdCBsb2NTdHViID0ge1xyXG4gICAgc291cmNlOiAnJyxcclxuICAgIHN0YXJ0OiB7IGxpbmU6IDEsIGNvbHVtbjogMSwgb2Zmc2V0OiAwIH0sXHJcbiAgICBlbmQ6IHsgbGluZTogMSwgY29sdW1uOiAxLCBvZmZzZXQ6IDAgfVxyXG59O1xyXG5mdW5jdGlvbiBjcmVhdGVSb290KGNoaWxkcmVuLCBsb2MgPSBsb2NTdHViKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDAgLyogUk9PVCAqLyxcclxuICAgICAgICBjaGlsZHJlbixcclxuICAgICAgICBoZWxwZXJzOiBbXSxcclxuICAgICAgICBjb21wb25lbnRzOiBbXSxcclxuICAgICAgICBkaXJlY3RpdmVzOiBbXSxcclxuICAgICAgICBob2lzdHM6IFtdLFxyXG4gICAgICAgIGltcG9ydHM6IFtdLFxyXG4gICAgICAgIGNhY2hlZDogMCxcclxuICAgICAgICB0ZW1wczogMCxcclxuICAgICAgICBjb2RlZ2VuTm9kZTogdW5kZWZpbmVkLFxyXG4gICAgICAgIGxvY1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVWTm9kZUNhbGwoY29udGV4dCwgdGFnLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzLCBkaXJlY3RpdmVzLCBpc0Jsb2NrID0gZmFsc2UsIGRpc2FibGVUcmFja2luZyA9IGZhbHNlLCBpc0NvbXBvbmVudCA9IGZhbHNlLCBsb2MgPSBsb2NTdHViKSB7XHJcbiAgICBpZiAoY29udGV4dCkge1xyXG4gICAgICAgIGlmIChpc0Jsb2NrKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKE9QRU5fQkxPQ0spO1xyXG4gICAgICAgICAgICBjb250ZXh0LmhlbHBlcihnZXRWTm9kZUJsb2NrSGVscGVyKGNvbnRleHQuaW5TU1IsIGlzQ29tcG9uZW50KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb250ZXh0LmhlbHBlcihnZXRWTm9kZUhlbHBlcihjb250ZXh0LmluU1NSLCBpc0NvbXBvbmVudCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlyZWN0aXZlcykge1xyXG4gICAgICAgICAgICBjb250ZXh0LmhlbHBlcihXSVRIX0RJUkVDVElWRVMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMTMgLyogVk5PREVfQ0FMTCAqLyxcclxuICAgICAgICB0YWcsXHJcbiAgICAgICAgcHJvcHMsXHJcbiAgICAgICAgY2hpbGRyZW4sXHJcbiAgICAgICAgcGF0Y2hGbGFnLFxyXG4gICAgICAgIGR5bmFtaWNQcm9wcyxcclxuICAgICAgICBkaXJlY3RpdmVzLFxyXG4gICAgICAgIGlzQmxvY2ssXHJcbiAgICAgICAgZGlzYWJsZVRyYWNraW5nLFxyXG4gICAgICAgIGlzQ29tcG9uZW50LFxyXG4gICAgICAgIGxvY1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVBcnJheUV4cHJlc3Npb24oZWxlbWVudHMsIGxvYyA9IGxvY1N0dWIpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMTcgLyogSlNfQVJSQVlfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICBsb2MsXHJcbiAgICAgICAgZWxlbWVudHNcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihwcm9wZXJ0aWVzLCBsb2MgPSBsb2NTdHViKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDE1IC8qIEpTX09CSkVDVF9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgIGxvYyxcclxuICAgICAgICBwcm9wZXJ0aWVzXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdFByb3BlcnR5KGtleSwgdmFsdWUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMTYgLyogSlNfUFJPUEVSVFkgKi8sXHJcbiAgICAgICAgbG9jOiBsb2NTdHViLFxyXG4gICAgICAgIGtleTogaXNTdHJpbmcoa2V5KSA/IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oa2V5LCB0cnVlKSA6IGtleSxcclxuICAgICAgICB2YWx1ZVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGNvbnRlbnQsIGlzU3RhdGljID0gZmFsc2UsIGxvYyA9IGxvY1N0dWIsIGNvbnN0VHlwZSA9IDAgLyogTk9UX0NPTlNUQU5UICovKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgbG9jLFxyXG4gICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgaXNTdGF0aWMsXHJcbiAgICAgICAgY29uc3RUeXBlOiBpc1N0YXRpYyA/IDMgLyogQ0FOX1NUUklOR0lGWSAqLyA6IGNvbnN0VHlwZVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJbnRlcnBvbGF0aW9uKGNvbnRlbnQsIGxvYykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiA1IC8qIElOVEVSUE9MQVRJT04gKi8sXHJcbiAgICAgICAgbG9jLFxyXG4gICAgICAgIGNvbnRlbnQ6IGlzU3RyaW5nKGNvbnRlbnQpXHJcbiAgICAgICAgICAgID8gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihjb250ZW50LCBmYWxzZSwgbG9jKVxyXG4gICAgICAgICAgICA6IGNvbnRlbnRcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKGNoaWxkcmVuLCBsb2MgPSBsb2NTdHViKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICBsb2MsXHJcbiAgICAgICAgY2hpbGRyZW5cclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY2FsbGVlLCBhcmdzID0gW10sIGxvYyA9IGxvY1N0dWIpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMTQgLyogSlNfQ0FMTF9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgIGxvYyxcclxuICAgICAgICBjYWxsZWUsXHJcbiAgICAgICAgYXJndW1lbnRzOiBhcmdzXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbihwYXJhbXMsIHJldHVybnMgPSB1bmRlZmluZWQsIG5ld2xpbmUgPSBmYWxzZSwgaXNTbG90ID0gZmFsc2UsIGxvYyA9IGxvY1N0dWIpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMTggLyogSlNfRlVOQ1RJT05fRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICBwYXJhbXMsXHJcbiAgICAgICAgcmV0dXJucyxcclxuICAgICAgICBuZXdsaW5lLFxyXG4gICAgICAgIGlzU2xvdCxcclxuICAgICAgICBsb2NcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQ29uZGl0aW9uYWxFeHByZXNzaW9uKHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSwgbmV3bGluZSA9IHRydWUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMTkgLyogSlNfQ09ORElUSU9OQUxfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICB0ZXN0LFxyXG4gICAgICAgIGNvbnNlcXVlbnQsXHJcbiAgICAgICAgYWx0ZXJuYXRlLFxyXG4gICAgICAgIG5ld2xpbmUsXHJcbiAgICAgICAgbG9jOiBsb2NTdHViXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlRXhwcmVzc2lvbihpbmRleCwgdmFsdWUsIGlzVk5vZGUgPSBmYWxzZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAyMCAvKiBKU19DQUNIRV9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgIGluZGV4LFxyXG4gICAgICAgIHZhbHVlLFxyXG4gICAgICAgIGlzVk5vZGUsXHJcbiAgICAgICAgbG9jOiBsb2NTdHViXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrU3RhdGVtZW50KGJvZHkpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMjEgLyogSlNfQkxPQ0tfU1RBVEVNRU5UICovLFxyXG4gICAgICAgIGJvZHksXHJcbiAgICAgICAgbG9jOiBsb2NTdHViXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVRlbXBsYXRlTGl0ZXJhbChlbGVtZW50cykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAyMiAvKiBKU19URU1QTEFURV9MSVRFUkFMICovLFxyXG4gICAgICAgIGVsZW1lbnRzLFxyXG4gICAgICAgIGxvYzogbG9jU3R1YlxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJZlN0YXRlbWVudCh0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMjMgLyogSlNfSUZfU1RBVEVNRU5UICovLFxyXG4gICAgICAgIHRlc3QsXHJcbiAgICAgICAgY29uc2VxdWVudCxcclxuICAgICAgICBhbHRlcm5hdGUsXHJcbiAgICAgICAgbG9jOiBsb2NTdHViXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbm1lbnRFeHByZXNzaW9uKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDI0IC8qIEpTX0FTU0lHTk1FTlRfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICBsZWZ0LFxyXG4gICAgICAgIHJpZ2h0LFxyXG4gICAgICAgIGxvYzogbG9jU3R1YlxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVTZXF1ZW5jZUV4cHJlc3Npb24oZXhwcmVzc2lvbnMpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMjUgLyogSlNfU0VRVUVOQ0VfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICBleHByZXNzaW9ucyxcclxuICAgICAgICBsb2M6IGxvY1N0dWJcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmV0dXJuU3RhdGVtZW50KHJldHVybnMpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMjYgLyogSlNfUkVUVVJOX1NUQVRFTUVOVCAqLyxcclxuICAgICAgICByZXR1cm5zLFxyXG4gICAgICAgIGxvYzogbG9jU3R1YlxyXG4gICAgfTtcclxufVxuXG5jb25zdCBpc1N0YXRpY0V4cCA9IChwKSA9PiBwLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gJiYgcC5pc1N0YXRpYztcclxuY29uc3QgaXNCdWlsdEluVHlwZSA9ICh0YWcsIGV4cGVjdGVkKSA9PiB0YWcgPT09IGV4cGVjdGVkIHx8IHRhZyA9PT0gaHlwaGVuYXRlKGV4cGVjdGVkKTtcclxuZnVuY3Rpb24gaXNDb3JlQ29tcG9uZW50KHRhZykge1xyXG4gICAgaWYgKGlzQnVpbHRJblR5cGUodGFnLCAnVGVsZXBvcnQnKSkge1xyXG4gICAgICAgIHJldHVybiBURUxFUE9SVDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzQnVpbHRJblR5cGUodGFnLCAnU3VzcGVuc2UnKSkge1xyXG4gICAgICAgIHJldHVybiBTVVNQRU5TRTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzQnVpbHRJblR5cGUodGFnLCAnS2VlcEFsaXZlJykpIHtcclxuICAgICAgICByZXR1cm4gS0VFUF9BTElWRTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzQnVpbHRJblR5cGUodGFnLCAnQmFzZVRyYW5zaXRpb24nKSkge1xyXG4gICAgICAgIHJldHVybiBCQVNFX1RSQU5TSVRJT047XHJcbiAgICB9XHJcbn1cclxuY29uc3Qgbm9uSWRlbnRpZmllclJFID0gL15cXGR8W15cXCRcXHddLztcclxuY29uc3QgaXNTaW1wbGVJZGVudGlmaWVyID0gKG5hbWUpID0+ICFub25JZGVudGlmaWVyUkUudGVzdChuYW1lKTtcclxuY29uc3QgdmFsaWRGaXJzdElkZW50Q2hhclJFID0gL1tBLVphLXpfJFxceEEwLVxcdUZGRkZdLztcclxuY29uc3QgdmFsaWRJZGVudENoYXJSRSA9IC9bXFwuXFw/XFx3JFxceEEwLVxcdUZGRkZdLztcclxuY29uc3Qgd2hpdGVzcGFjZVJFID0gL1xccytbLltdXFxzKnxcXHMqWy5bXVxccysvZztcclxuLyoqXHJcbiAqIFNpbXBsZSBsZXhlciB0byBjaGVjayBpZiBhbiBleHByZXNzaW9uIGlzIGEgbWVtYmVyIGV4cHJlc3Npb24uIFRoaXMgaXNcclxuICogbGF4IGFuZCBvbmx5IGNoZWNrcyB2YWxpZGl0eSBhdCB0aGUgcm9vdCBsZXZlbCAoaS5lLiBkb2VzIG5vdCB2YWxpZGF0ZSBleHBzXHJcbiAqIGluc2lkZSBzcXVhcmUgYnJhY2tldHMpLCBidXQgaXQncyBvayBzaW5jZSB0aGVzZSBhcmUgb25seSB1c2VkIG9uIHRlbXBsYXRlXHJcbiAqIGV4cHJlc3Npb25zIGFuZCBmYWxzZSBwb3NpdGl2ZXMgYXJlIGludmFsaWQgZXhwcmVzc2lvbnMgaW4gdGhlIGZpcnN0IHBsYWNlLlxyXG4gKi9cclxuY29uc3QgaXNNZW1iZXJFeHByZXNzaW9uQnJvd3NlciA9IChwYXRoKSA9PiB7XHJcbiAgICAvLyByZW1vdmUgd2hpdGVzcGFjZXMgYXJvdW5kIC4gb3IgWyBmaXJzdFxyXG4gICAgcGF0aCA9IHBhdGgudHJpbSgpLnJlcGxhY2Uod2hpdGVzcGFjZVJFLCBzID0+IHMudHJpbSgpKTtcclxuICAgIGxldCBzdGF0ZSA9IDAgLyogaW5NZW1iZXJFeHAgKi87XHJcbiAgICBsZXQgc3RhdGVTdGFjayA9IFtdO1xyXG4gICAgbGV0IGN1cnJlbnRPcGVuQnJhY2tldENvdW50ID0gMDtcclxuICAgIGxldCBjdXJyZW50T3BlblBhcmVuc0NvdW50ID0gMDtcclxuICAgIGxldCBjdXJyZW50U3RyaW5nVHlwZSA9IG51bGw7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjaGFyID0gcGF0aC5jaGFyQXQoaSk7XHJcbiAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xyXG4gICAgICAgICAgICBjYXNlIDAgLyogaW5NZW1iZXJFeHAgKi86XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gJ1snKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVTdGFjay5wdXNoKHN0YXRlKTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDEgLyogaW5CcmFja2V0cyAqLztcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50T3BlbkJyYWNrZXRDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gJygnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVTdGFjay5wdXNoKHN0YXRlKTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDIgLyogaW5QYXJlbnMgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE9wZW5QYXJlbnNDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIShpID09PSAwID8gdmFsaWRGaXJzdElkZW50Q2hhclJFIDogdmFsaWRJZGVudENoYXJSRSkudGVzdChjaGFyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDEgLyogaW5CcmFja2V0cyAqLzpcclxuICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSBgJ2AgfHwgY2hhciA9PT0gYFwiYCB8fCBjaGFyID09PSAnYCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZVN0YWNrLnB1c2goc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMyAvKiBpblN0cmluZyAqLztcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RyaW5nVHlwZSA9IGNoYXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSBgW2ApIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50T3BlbkJyYWNrZXRDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gYF1gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEtLWN1cnJlbnRPcGVuQnJhY2tldENvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gc3RhdGVTdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyIC8qIGluUGFyZW5zICovOlxyXG4gICAgICAgICAgICAgICAgaWYgKGNoYXIgPT09IGAnYCB8fCBjaGFyID09PSBgXCJgIHx8IGNoYXIgPT09ICdgJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlU3RhY2sucHVzaChzdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAzIC8qIGluU3RyaW5nICovO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdHJpbmdUeXBlID0gY2hhcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09IGAoYCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRPcGVuUGFyZW5zQ291bnQrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09IGApYCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBleHAgZW5kcyBhcyBhIGNhbGwgdGhlbiBpdCBzaG91bGQgbm90IGJlIGNvbnNpZGVyZWQgdmFsaWRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gcGF0aC5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEtLWN1cnJlbnRPcGVuUGFyZW5zQ291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZVN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDMgLyogaW5TdHJpbmcgKi86XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gY3VycmVudFN0cmluZ1R5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHN0YXRlU3RhY2sucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0cmluZ1R5cGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuICFjdXJyZW50T3BlbkJyYWNrZXRDb3VudCAmJiAhY3VycmVudE9wZW5QYXJlbnNDb3VudDtcclxufTtcclxuY29uc3QgaXNNZW1iZXJFeHByZXNzaW9uTm9kZSA9IE5PT1BcclxuICAgIDtcclxuY29uc3QgaXNNZW1iZXJFeHByZXNzaW9uID0gaXNNZW1iZXJFeHByZXNzaW9uQnJvd3NlclxyXG4gICAgO1xyXG5mdW5jdGlvbiBnZXRJbm5lclJhbmdlKGxvYywgb2Zmc2V0LCBsZW5ndGgpIHtcclxuICAgIGNvbnN0IHNvdXJjZSA9IGxvYy5zb3VyY2Uuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpO1xyXG4gICAgY29uc3QgbmV3TG9jID0ge1xyXG4gICAgICAgIHNvdXJjZSxcclxuICAgICAgICBzdGFydDogYWR2YW5jZVBvc2l0aW9uV2l0aENsb25lKGxvYy5zdGFydCwgbG9jLnNvdXJjZSwgb2Zmc2V0KSxcclxuICAgICAgICBlbmQ6IGxvYy5lbmRcclxuICAgIH07XHJcbiAgICBpZiAobGVuZ3RoICE9IG51bGwpIHtcclxuICAgICAgICBuZXdMb2MuZW5kID0gYWR2YW5jZVBvc2l0aW9uV2l0aENsb25lKGxvYy5zdGFydCwgbG9jLnNvdXJjZSwgb2Zmc2V0ICsgbGVuZ3RoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXdMb2M7XHJcbn1cclxuZnVuY3Rpb24gYWR2YW5jZVBvc2l0aW9uV2l0aENsb25lKHBvcywgc291cmNlLCBudW1iZXJPZkNoYXJhY3RlcnMgPSBzb3VyY2UubGVuZ3RoKSB7XHJcbiAgICByZXR1cm4gYWR2YW5jZVBvc2l0aW9uV2l0aE11dGF0aW9uKGV4dGVuZCh7fSwgcG9zKSwgc291cmNlLCBudW1iZXJPZkNoYXJhY3RlcnMpO1xyXG59XHJcbi8vIGFkdmFuY2UgYnkgbXV0YXRpb24gd2l0aG91dCBjbG9uaW5nIChmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyksIHNpbmNlIHRoaXNcclxuLy8gZ2V0cyBjYWxsZWQgYSBsb3QgaW4gdGhlIHBhcnNlclxyXG5mdW5jdGlvbiBhZHZhbmNlUG9zaXRpb25XaXRoTXV0YXRpb24ocG9zLCBzb3VyY2UsIG51bWJlck9mQ2hhcmFjdGVycyA9IHNvdXJjZS5sZW5ndGgpIHtcclxuICAgIGxldCBsaW5lc0NvdW50ID0gMDtcclxuICAgIGxldCBsYXN0TmV3TGluZVBvcyA9IC0xO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkNoYXJhY3RlcnM7IGkrKykge1xyXG4gICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpKSA9PT0gMTAgLyogbmV3bGluZSBjaGFyIGNvZGUgKi8pIHtcclxuICAgICAgICAgICAgbGluZXNDb3VudCsrO1xyXG4gICAgICAgICAgICBsYXN0TmV3TGluZVBvcyA9IGk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcG9zLm9mZnNldCArPSBudW1iZXJPZkNoYXJhY3RlcnM7XHJcbiAgICBwb3MubGluZSArPSBsaW5lc0NvdW50O1xyXG4gICAgcG9zLmNvbHVtbiA9XHJcbiAgICAgICAgbGFzdE5ld0xpbmVQb3MgPT09IC0xXHJcbiAgICAgICAgICAgID8gcG9zLmNvbHVtbiArIG51bWJlck9mQ2hhcmFjdGVyc1xyXG4gICAgICAgICAgICA6IG51bWJlck9mQ2hhcmFjdGVycyAtIGxhc3ROZXdMaW5lUG9zO1xyXG4gICAgcmV0dXJuIHBvcztcclxufVxyXG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtc2cpIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKCFjb25kaXRpb24pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8IGB1bmV4cGVjdGVkIGNvbXBpbGVyIGNvbmRpdGlvbmApO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGZpbmREaXIobm9kZSwgbmFtZSwgYWxsb3dFbXB0eSA9IGZhbHNlKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUucHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBwID0gbm9kZS5wcm9wc1tpXTtcclxuICAgICAgICBpZiAocC50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLyAmJlxyXG4gICAgICAgICAgICAoYWxsb3dFbXB0eSB8fCBwLmV4cCkgJiZcclxuICAgICAgICAgICAgKGlzU3RyaW5nKG5hbWUpID8gcC5uYW1lID09PSBuYW1lIDogbmFtZS50ZXN0KHAubmFtZSkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBmaW5kUHJvcChub2RlLCBuYW1lLCBkeW5hbWljT25seSA9IGZhbHNlLCBhbGxvd0VtcHR5ID0gZmFsc2UpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHAgPSBub2RlLnByb3BzW2ldO1xyXG4gICAgICAgIGlmIChwLnR5cGUgPT09IDYgLyogQVRUUklCVVRFICovKSB7XHJcbiAgICAgICAgICAgIGlmIChkeW5hbWljT25seSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBpZiAocC5uYW1lID09PSBuYW1lICYmIChwLnZhbHVlIHx8IGFsbG93RW1wdHkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwLm5hbWUgPT09ICdiaW5kJyAmJlxyXG4gICAgICAgICAgICAocC5leHAgfHwgYWxsb3dFbXB0eSkgJiZcclxuICAgICAgICAgICAgaXNTdGF0aWNBcmdPZihwLmFyZywgbmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzU3RhdGljQXJnT2YoYXJnLCBuYW1lKSB7XHJcbiAgICByZXR1cm4gISEoYXJnICYmIGlzU3RhdGljRXhwKGFyZykgJiYgYXJnLmNvbnRlbnQgPT09IG5hbWUpO1xyXG59XHJcbmZ1bmN0aW9uIGhhc0R5bmFtaWNLZXlWQmluZChub2RlKSB7XHJcbiAgICByZXR1cm4gbm9kZS5wcm9wcy5zb21lKHAgPT4gcC50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLyAmJlxyXG4gICAgICAgIHAubmFtZSA9PT0gJ2JpbmQnICYmXHJcbiAgICAgICAgKCFwLmFyZyB8fCAvLyB2LWJpbmQ9XCJvYmpcIlxyXG4gICAgICAgICAgICBwLmFyZy50eXBlICE9PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovIHx8IC8vIHYtYmluZDpbX2N0eC5mb29dXHJcbiAgICAgICAgICAgICFwLmFyZy5pc1N0YXRpYykgLy8gdi1iaW5kOltmb29dXHJcbiAgICApO1xyXG59XHJcbmZ1bmN0aW9uIGlzVGV4dChub2RlKSB7XHJcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSA1IC8qIElOVEVSUE9MQVRJT04gKi8gfHwgbm9kZS50eXBlID09PSAyIC8qIFRFWFQgKi87XHJcbn1cclxuZnVuY3Rpb24gaXNWU2xvdChwKSB7XHJcbiAgICByZXR1cm4gcC50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLyAmJiBwLm5hbWUgPT09ICdzbG90JztcclxufVxyXG5mdW5jdGlvbiBpc1RlbXBsYXRlTm9kZShub2RlKSB7XHJcbiAgICByZXR1cm4gKG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovICYmIG5vZGUudGFnVHlwZSA9PT0gMyAvKiBURU1QTEFURSAqLyk7XHJcbn1cclxuZnVuY3Rpb24gaXNTbG90T3V0bGV0KG5vZGUpIHtcclxuICAgIHJldHVybiBub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJiBub2RlLnRhZ1R5cGUgPT09IDIgLyogU0xPVCAqLztcclxufVxyXG5mdW5jdGlvbiBnZXRWTm9kZUhlbHBlcihzc3IsIGlzQ29tcG9uZW50KSB7XHJcbiAgICByZXR1cm4gc3NyIHx8IGlzQ29tcG9uZW50ID8gQ1JFQVRFX1ZOT0RFIDogQ1JFQVRFX0VMRU1FTlRfVk5PREU7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Vk5vZGVCbG9ja0hlbHBlcihzc3IsIGlzQ29tcG9uZW50KSB7XHJcbiAgICByZXR1cm4gc3NyIHx8IGlzQ29tcG9uZW50ID8gQ1JFQVRFX0JMT0NLIDogQ1JFQVRFX0VMRU1FTlRfQkxPQ0s7XHJcbn1cclxuY29uc3QgcHJvcHNIZWxwZXJTZXQgPSBuZXcgU2V0KFtOT1JNQUxJWkVfUFJPUFMsIEdVQVJEX1JFQUNUSVZFX1BST1BTXSk7XHJcbmZ1bmN0aW9uIGdldFVubm9ybWFsaXplZFByb3BzKHByb3BzLCBjYWxsUGF0aCA9IFtdKSB7XHJcbiAgICBpZiAocHJvcHMgJiZcclxuICAgICAgICAhaXNTdHJpbmcocHJvcHMpICYmXHJcbiAgICAgICAgcHJvcHMudHlwZSA9PT0gMTQgLyogSlNfQ0FMTF9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgY29uc3QgY2FsbGVlID0gcHJvcHMuY2FsbGVlO1xyXG4gICAgICAgIGlmICghaXNTdHJpbmcoY2FsbGVlKSAmJiBwcm9wc0hlbHBlclNldC5oYXMoY2FsbGVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0VW5ub3JtYWxpemVkUHJvcHMocHJvcHMuYXJndW1lbnRzWzBdLCBjYWxsUGF0aC5jb25jYXQocHJvcHMpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW3Byb3BzLCBjYWxsUGF0aF07XHJcbn1cclxuZnVuY3Rpb24gaW5qZWN0UHJvcChub2RlLCBwcm9wLCBjb250ZXh0KSB7XHJcbiAgICBsZXQgcHJvcHNXaXRoSW5qZWN0aW9uO1xyXG4gICAgLyoqXHJcbiAgICAgKiAxLiBtZXJnZVByb3BzKC4uLilcclxuICAgICAqIDIuIHRvSGFuZGxlcnMoLi4uKVxyXG4gICAgICogMy4gbm9ybWFsaXplUHJvcHMoLi4uKVxyXG4gICAgICogNC4gbm9ybWFsaXplUHJvcHMoZ3VhcmRSZWFjdGl2ZVByb3BzKC4uLikpXHJcbiAgICAgKlxyXG4gICAgICogd2UgbmVlZCB0byBnZXQgdGhlIHJlYWwgcHJvcHMgYmVmb3JlIG5vcm1hbGl6YXRpb25cclxuICAgICAqL1xyXG4gICAgbGV0IHByb3BzID0gbm9kZS50eXBlID09PSAxMyAvKiBWTk9ERV9DQUxMICovID8gbm9kZS5wcm9wcyA6IG5vZGUuYXJndW1lbnRzWzJdO1xyXG4gICAgbGV0IGNhbGxQYXRoID0gW107XHJcbiAgICBsZXQgcGFyZW50Q2FsbDtcclxuICAgIGlmIChwcm9wcyAmJlxyXG4gICAgICAgICFpc1N0cmluZyhwcm9wcykgJiZcclxuICAgICAgICBwcm9wcy50eXBlID09PSAxNCAvKiBKU19DQUxMX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICBjb25zdCByZXQgPSBnZXRVbm5vcm1hbGl6ZWRQcm9wcyhwcm9wcyk7XHJcbiAgICAgICAgcHJvcHMgPSByZXRbMF07XHJcbiAgICAgICAgY2FsbFBhdGggPSByZXRbMV07XHJcbiAgICAgICAgcGFyZW50Q2FsbCA9IGNhbGxQYXRoW2NhbGxQYXRoLmxlbmd0aCAtIDFdO1xyXG4gICAgfVxyXG4gICAgaWYgKHByb3BzID09IG51bGwgfHwgaXNTdHJpbmcocHJvcHMpKSB7XHJcbiAgICAgICAgcHJvcHNXaXRoSW5qZWN0aW9uID0gY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihbcHJvcF0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJvcHMudHlwZSA9PT0gMTQgLyogSlNfQ0FMTF9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgLy8gbWVyZ2VkIHByb3BzLi4uIGFkZCBvdXJzXHJcbiAgICAgICAgLy8gb25seSBpbmplY3Qga2V5IHRvIG9iamVjdCBsaXRlcmFsIGlmIGl0J3MgdGhlIGZpcnN0IGFyZ3VtZW50IHNvIHRoYXRcclxuICAgICAgICAvLyBpZiBkb2Vzbid0IG92ZXJyaWRlIHVzZXIgcHJvdmlkZWQga2V5c1xyXG4gICAgICAgIGNvbnN0IGZpcnN0ID0gcHJvcHMuYXJndW1lbnRzWzBdO1xyXG4gICAgICAgIGlmICghaXNTdHJpbmcoZmlyc3QpICYmIGZpcnN0LnR5cGUgPT09IDE1IC8qIEpTX09CSkVDVF9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgICAgIGZpcnN0LnByb3BlcnRpZXMudW5zaGlmdChwcm9wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9wcy5jYWxsZWUgPT09IFRPX0hBTkRMRVJTKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAjMjM2NlxyXG4gICAgICAgICAgICAgICAgcHJvcHNXaXRoSW5qZWN0aW9uID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoTUVSR0VfUFJPUFMpLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihbcHJvcF0pLFxyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHByb3BzLmFyZ3VtZW50cy51bnNoaWZ0KGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oW3Byb3BdKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgIXByb3BzV2l0aEluamVjdGlvbiAmJiAocHJvcHNXaXRoSW5qZWN0aW9uID0gcHJvcHMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJvcHMudHlwZSA9PT0gMTUgLyogSlNfT0JKRUNUX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICBsZXQgYWxyZWFkeUV4aXN0cyA9IGZhbHNlO1xyXG4gICAgICAgIC8vIGNoZWNrIGV4aXN0aW5nIGtleSB0byBhdm9pZCBvdmVycmlkaW5nIHVzZXIgcHJvdmlkZWQga2V5c1xyXG4gICAgICAgIGlmIChwcm9wLmtleS50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3BLZXlOYW1lID0gcHJvcC5rZXkuY29udGVudDtcclxuICAgICAgICAgICAgYWxyZWFkeUV4aXN0cyA9IHByb3BzLnByb3BlcnRpZXMuc29tZShwID0+IHAua2V5LnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gJiZcclxuICAgICAgICAgICAgICAgIHAua2V5LmNvbnRlbnQgPT09IHByb3BLZXlOYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFhbHJlYWR5RXhpc3RzKSB7XHJcbiAgICAgICAgICAgIHByb3BzLnByb3BlcnRpZXMudW5zaGlmdChwcm9wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvcHNXaXRoSW5qZWN0aW9uID0gcHJvcHM7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBzaW5nbGUgdi1iaW5kIHdpdGggZXhwcmVzc2lvbiwgcmV0dXJuIGEgbWVyZ2VkIHJlcGxhY2VtZW50XHJcbiAgICAgICAgcHJvcHNXaXRoSW5qZWN0aW9uID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoTUVSR0VfUFJPUFMpLCBbXHJcbiAgICAgICAgICAgIGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oW3Byb3BdKSxcclxuICAgICAgICAgICAgcHJvcHNcclxuICAgICAgICBdKTtcclxuICAgICAgICAvLyBpbiB0aGUgY2FzZSBvZiBuZXN0ZWQgaGVscGVyIGNhbGwsIGUuZy4gYG5vcm1hbGl6ZVByb3BzKGd1YXJkUmVhY3RpdmVQcm9wcyhwcm9wcykpYCxcclxuICAgICAgICAvLyBpdCB3aWxsIGJlIHJld3JpdHRlbiBhcyBgbm9ybWFsaXplUHJvcHMobWVyZ2VQcm9wcyh7IGtleTogMCB9LCBwcm9wcykpYCxcclxuICAgICAgICAvLyB0aGUgYGd1YXJkUmVhY3RpdmVQcm9wc2Agd2lsbCBubyBsb25nZXIgYmUgbmVlZGVkXHJcbiAgICAgICAgaWYgKHBhcmVudENhbGwgJiYgcGFyZW50Q2FsbC5jYWxsZWUgPT09IEdVQVJEX1JFQUNUSVZFX1BST1BTKSB7XHJcbiAgICAgICAgICAgIHBhcmVudENhbGwgPSBjYWxsUGF0aFtjYWxsUGF0aC5sZW5ndGggLSAyXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobm9kZS50eXBlID09PSAxMyAvKiBWTk9ERV9DQUxMICovKSB7XHJcbiAgICAgICAgaWYgKHBhcmVudENhbGwpIHtcclxuICAgICAgICAgICAgcGFyZW50Q2FsbC5hcmd1bWVudHNbMF0gPSBwcm9wc1dpdGhJbmplY3Rpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBub2RlLnByb3BzID0gcHJvcHNXaXRoSW5qZWN0aW9uO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChwYXJlbnRDYWxsKSB7XHJcbiAgICAgICAgICAgIHBhcmVudENhbGwuYXJndW1lbnRzWzBdID0gcHJvcHNXaXRoSW5qZWN0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbm9kZS5hcmd1bWVudHNbMl0gPSBwcm9wc1dpdGhJbmplY3Rpb247XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRvVmFsaWRBc3NldElkKG5hbWUsIHR5cGUpIHtcclxuICAgIC8vIHNlZSBpc3N1ZSM0NDIyLCB3ZSBuZWVkIGFkZGluZyBpZGVudGlmaWVyIG9uIHZhbGlkQXNzZXRJZCBpZiB2YXJpYWJsZSBgbmFtZWAgaGFzIHNwZWNpZmljIGNoYXJhY3RlclxyXG4gICAgcmV0dXJuIGBfJHt0eXBlfV8ke25hbWUucmVwbGFjZSgvW15cXHddL2csIChzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHNlYXJjaFZhbHVlID09PSAnLScgPyAnXycgOiBuYW1lLmNoYXJDb2RlQXQocmVwbGFjZVZhbHVlKS50b1N0cmluZygpO1xyXG4gICAgfSl9YDtcclxufVxyXG4vLyBDaGVjayBpZiBhIG5vZGUgY29udGFpbnMgZXhwcmVzc2lvbnMgdGhhdCByZWZlcmVuY2UgY3VycmVudCBjb250ZXh0IHNjb3BlIGlkc1xyXG5mdW5jdGlvbiBoYXNTY29wZVJlZihub2RlLCBpZHMpIHtcclxuICAgIGlmICghbm9kZSB8fCBPYmplY3Qua2V5cyhpZHMpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XHJcbiAgICAgICAgY2FzZSAxIC8qIEVMRU1FTlQgKi86XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IG5vZGUucHJvcHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAocC50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIChoYXNTY29wZVJlZihwLmFyZywgaWRzKSB8fCBoYXNTY29wZVJlZihwLmV4cCwgaWRzKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5zb21lKGMgPT4gaGFzU2NvcGVSZWYoYywgaWRzKSk7XHJcbiAgICAgICAgY2FzZSAxMSAvKiBGT1IgKi86XHJcbiAgICAgICAgICAgIGlmIChoYXNTY29wZVJlZihub2RlLnNvdXJjZSwgaWRzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4uc29tZShjID0+IGhhc1Njb3BlUmVmKGMsIGlkcykpO1xyXG4gICAgICAgIGNhc2UgOSAvKiBJRiAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuYnJhbmNoZXMuc29tZShiID0+IGhhc1Njb3BlUmVmKGIsIGlkcykpO1xyXG4gICAgICAgIGNhc2UgMTAgLyogSUZfQlJBTkNIICovOlxyXG4gICAgICAgICAgICBpZiAoaGFzU2NvcGVSZWYobm9kZS5jb25kaXRpb24sIGlkcykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLnNvbWUoYyA9PiBoYXNTY29wZVJlZihjLCBpZHMpKTtcclxuICAgICAgICBjYXNlIDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIHJldHVybiAoIW5vZGUuaXNTdGF0aWMgJiZcclxuICAgICAgICAgICAgICAgIGlzU2ltcGxlSWRlbnRpZmllcihub2RlLmNvbnRlbnQpICYmXHJcbiAgICAgICAgICAgICAgICAhIWlkc1tub2RlLmNvbnRlbnRdKTtcclxuICAgICAgICBjYXNlIDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4uc29tZShjID0+IGlzT2JqZWN0KGMpICYmIGhhc1Njb3BlUmVmKGMsIGlkcykpO1xyXG4gICAgICAgIGNhc2UgNSAvKiBJTlRFUlBPTEFUSU9OICovOlxyXG4gICAgICAgIGNhc2UgMTIgLyogVEVYVF9DQUxMICovOlxyXG4gICAgICAgICAgICByZXR1cm4gaGFzU2NvcGVSZWYobm9kZS5jb250ZW50LCBpZHMpO1xyXG4gICAgICAgIGNhc2UgMiAvKiBURVhUICovOlxyXG4gICAgICAgIGNhc2UgMyAvKiBDT01NRU5UICovOlxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkgO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0TWVtb2VkVk5vZGVDYWxsKG5vZGUpIHtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDE0IC8qIEpTX0NBTExfRVhQUkVTU0lPTiAqLyAmJiBub2RlLmNhbGxlZSA9PT0gV0lUSF9NRU1PKSB7XHJcbiAgICAgICAgcmV0dXJuIG5vZGUuYXJndW1lbnRzWzFdLnJldHVybnM7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBtYWtlQmxvY2sobm9kZSwgeyBoZWxwZXIsIHJlbW92ZUhlbHBlciwgaW5TU1IgfSkge1xyXG4gICAgaWYgKCFub2RlLmlzQmxvY2spIHtcclxuICAgICAgICBub2RlLmlzQmxvY2sgPSB0cnVlO1xyXG4gICAgICAgIHJlbW92ZUhlbHBlcihnZXRWTm9kZUhlbHBlcihpblNTUiwgbm9kZS5pc0NvbXBvbmVudCkpO1xyXG4gICAgICAgIGhlbHBlcihPUEVOX0JMT0NLKTtcclxuICAgICAgICBoZWxwZXIoZ2V0Vk5vZGVCbG9ja0hlbHBlcihpblNTUiwgbm9kZS5pc0NvbXBvbmVudCkpO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IGRlcHJlY2F0aW9uRGF0YSA9IHtcclxuICAgIFtcIkNPTVBJTEVSX0lTX09OX0VMRU1FTlRcIiAvKiBDT01QSUxFUl9JU19PTl9FTEVNRU5UICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBQbGF0Zm9ybS1uYXRpdmUgZWxlbWVudHMgd2l0aCBcImlzXCIgcHJvcCB3aWxsIG5vIGxvbmdlciBiZSBgICtcclxuICAgICAgICAgICAgYHRyZWF0ZWQgYXMgY29tcG9uZW50cyBpbiBWdWUgMyB1bmxlc3MgdGhlIFwiaXNcIiB2YWx1ZSBpcyBleHBsaWNpdGx5IGAgK1xyXG4gICAgICAgICAgICBgcHJlZml4ZWQgd2l0aCBcInZ1ZTpcIi5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy9jdXN0b20tZWxlbWVudHMtaW50ZXJvcC5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTVBJTEVSX1ZfQklORF9TWU5DXCIgLyogQ09NUElMRVJfVl9CSU5EX1NZTkMgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZToga2V5ID0+IGAuc3luYyBtb2RpZmllciBmb3Igdi1iaW5kIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2LW1vZGVsIHdpdGggYCArXHJcbiAgICAgICAgICAgIGBhcmd1bWVudCBpbnN0ZWFkLiBcXGB2LWJpbmQ6JHtrZXl9LnN5bmNcXGAgc2hvdWxkIGJlIGNoYW5nZWQgdG8gYCArXHJcbiAgICAgICAgICAgIGBcXGB2LW1vZGVsOiR7a2V5fVxcYC5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy92LW1vZGVsLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiQ09NUElMRVJfVl9CSU5EX1BST1BcIiAvKiBDT01QSUxFUl9WX0JJTkRfUFJPUCAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgLnByb3AgbW9kaWZpZXIgZm9yIHYtYmluZCBoYXMgYmVlbiByZW1vdmVkIGFuZCBubyBsb25nZXIgbmVjZXNzYXJ5LiBgICtcclxuICAgICAgICAgICAgYFZ1ZSAzIHdpbGwgYXV0b21hdGljYWxseSBzZXQgYSBiaW5kaW5nIGFzIERPTSBwcm9wZXJ0eSB3aGVuIGFwcHJvcHJpYXRlLmBcclxuICAgIH0sXHJcbiAgICBbXCJDT01QSUxFUl9WX0JJTkRfT0JKRUNUX09SREVSXCIgLyogQ09NUElMRVJfVl9CSU5EX09CSkVDVF9PUkRFUiAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgdi1iaW5kPVwib2JqXCIgdXNhZ2UgaXMgbm93IG9yZGVyIHNlbnNpdGl2ZSBhbmQgYmVoYXZlcyBsaWtlIEphdmFTY3JpcHQgYCArXHJcbiAgICAgICAgICAgIGBvYmplY3Qgc3ByZWFkOiBpdCB3aWxsIG5vdyBvdmVyd3JpdGUgYW4gZXhpc3Rpbmcgbm9uLW1lcmdlYWJsZSBhdHRyaWJ1dGUgYCArXHJcbiAgICAgICAgICAgIGB0aGF0IGFwcGVhcnMgYmVmb3JlIHYtYmluZCBpbiB0aGUgY2FzZSBvZiBjb25mbGljdC4gYCArXHJcbiAgICAgICAgICAgIGBUbyByZXRhaW4gMi54IGJlaGF2aW9yLCBtb3ZlIHYtYmluZCB0byBtYWtlIGl0IHRoZSBmaXJzdCBhdHRyaWJ1dGUuIGAgK1xyXG4gICAgICAgICAgICBgWW91IGNhbiBhbHNvIHN1cHByZXNzIHRoaXMgd2FybmluZyBpZiB0aGUgdXNhZ2UgaXMgaW50ZW5kZWQuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My1taWdyYXRpb24udnVlanMub3JnL2JyZWFraW5nLWNoYW5nZXMvdi1iaW5kLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiQ09NUElMRVJfVl9PTl9OQVRJVkVcIiAvKiBDT01QSUxFUl9WX09OX05BVElWRSAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgLm5hdGl2ZSBtb2RpZmllciBmb3Igdi1vbiBoYXMgYmVlbiByZW1vdmVkIGFzIGlzIG5vIGxvbmdlciBuZWNlc3NhcnkuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My1taWdyYXRpb24udnVlanMub3JnL2JyZWFraW5nLWNoYW5nZXMvdi1vbi1uYXRpdmUtbW9kaWZpZXItcmVtb3ZlZC5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTVBJTEVSX1ZfSUZfVl9GT1JfUFJFQ0VERU5DRVwiIC8qIENPTVBJTEVSX1ZfSUZfVl9GT1JfUFJFQ0VERU5DRSAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgdi1pZiAvIHYtZm9yIHByZWNlZGVuY2Ugd2hlbiB1c2VkIG9uIHRoZSBzYW1lIGVsZW1lbnQgaGFzIGNoYW5nZWQgYCArXHJcbiAgICAgICAgICAgIGBpbiBWdWUgMzogdi1pZiBub3cgdGFrZXMgaGlnaGVyIHByZWNlZGVuY2UgYW5kIHdpbGwgbm8gbG9uZ2VyIGhhdmUgYCArXHJcbiAgICAgICAgICAgIGBhY2Nlc3MgdG8gdi1mb3Igc2NvcGUgdmFyaWFibGVzLiBJdCBpcyBiZXN0IHRvIGF2b2lkIHRoZSBhbWJpZ3VpdHkgYCArXHJcbiAgICAgICAgICAgIGB3aXRoIDx0ZW1wbGF0ZT4gdGFncyBvciB1c2UgYSBjb21wdXRlZCBwcm9wZXJ0eSB0aGF0IGZpbHRlcnMgdi1mb3IgYCArXHJcbiAgICAgICAgICAgIGBkYXRhIHNvdXJjZS5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy92LWlmLXYtZm9yLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiQ09NUElMRVJfTkFUSVZFX1RFTVBMQVRFXCIgLyogQ09NUElMRVJfTkFUSVZFX1RFTVBMQVRFICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGA8dGVtcGxhdGU+IHdpdGggbm8gc3BlY2lhbCBkaXJlY3RpdmVzIHdpbGwgcmVuZGVyIGFzIGEgbmF0aXZlIHRlbXBsYXRlIGAgK1xyXG4gICAgICAgICAgICBgZWxlbWVudCBpbnN0ZWFkIG9mIGl0cyBpbm5lciBjb250ZW50IGluIFZ1ZSAzLmBcclxuICAgIH0sXHJcbiAgICBbXCJDT01QSUxFUl9JTkxJTkVfVEVNUExBVEVcIiAvKiBDT01QSUxFUl9JTkxJTkVfVEVNUExBVEUgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYFwiaW5saW5lLXRlbXBsYXRlXCIgaGFzIGJlZW4gcmVtb3ZlZCBpbiBWdWUgMy5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy9pbmxpbmUtdGVtcGxhdGUtYXR0cmlidXRlLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiQ09NUElMRVJfRklMVEVSXCIgLyogQ09NUElMRVJfRklMVEVSUyAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgZmlsdGVycyBoYXZlIGJlZW4gcmVtb3ZlZCBpbiBWdWUgMy4gYCArXHJcbiAgICAgICAgICAgIGBUaGUgXCJ8XCIgc3ltYm9sIHdpbGwgYmUgdHJlYXRlZCBhcyBuYXRpdmUgSmF2YVNjcmlwdCBiaXR3aXNlIE9SIG9wZXJhdG9yLiBgICtcclxuICAgICAgICAgICAgYFVzZSBtZXRob2QgY2FsbHMgb3IgY29tcHV0ZWQgcHJvcGVydGllcyBpbnN0ZWFkLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMtbWlncmF0aW9uLnZ1ZWpzLm9yZy9icmVha2luZy1jaGFuZ2VzL2ZpbHRlcnMuaHRtbGBcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gZ2V0Q29tcGF0VmFsdWUoa2V5LCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCBjb25maWcgPSBjb250ZXh0Lm9wdGlvbnNcclxuICAgICAgICA/IGNvbnRleHQub3B0aW9ucy5jb21wYXRDb25maWdcclxuICAgICAgICA6IGNvbnRleHQuY29tcGF0Q29uZmlnO1xyXG4gICAgY29uc3QgdmFsdWUgPSBjb25maWcgJiYgY29uZmlnW2tleV07XHJcbiAgICBpZiAoa2V5ID09PSAnTU9ERScpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUgfHwgMzsgLy8gY29tcGlsZXIgZGVmYXVsdHMgdG8gdjMgYmVoYXZpb3JcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc0NvbXBhdEVuYWJsZWQoa2V5LCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCBtb2RlID0gZ2V0Q29tcGF0VmFsdWUoJ01PREUnLCBjb250ZXh0KTtcclxuICAgIGNvbnN0IHZhbHVlID0gZ2V0Q29tcGF0VmFsdWUoa2V5LCBjb250ZXh0KTtcclxuICAgIC8vIGluIHYzIG1vZGUsIG9ubHkgZW5hYmxlIGlmIGV4cGxpY2l0bHkgc2V0IHRvIHRydWVcclxuICAgIC8vIG90aGVyd2lzZSBlbmFibGUgZm9yIGFueSBub24tZmFsc2UgdmFsdWVcclxuICAgIHJldHVybiBtb2RlID09PSAzID8gdmFsdWUgPT09IHRydWUgOiB2YWx1ZSAhPT0gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tDb21wYXRFbmFibGVkKGtleSwgY29udGV4dCwgbG9jLCAuLi5hcmdzKSB7XHJcbiAgICBjb25zdCBlbmFibGVkID0gaXNDb21wYXRFbmFibGVkKGtleSwgY29udGV4dCk7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGVuYWJsZWQpIHtcclxuICAgICAgICB3YXJuRGVwcmVjYXRpb24oa2V5LCBjb250ZXh0LCBsb2MsIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVuYWJsZWQ7XHJcbn1cclxuZnVuY3Rpb24gd2FybkRlcHJlY2F0aW9uKGtleSwgY29udGV4dCwgbG9jLCAuLi5hcmdzKSB7XHJcbiAgICBjb25zdCB2YWwgPSBnZXRDb21wYXRWYWx1ZShrZXksIGNvbnRleHQpO1xyXG4gICAgaWYgKHZhbCA9PT0gJ3N1cHByZXNzLXdhcm5pbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBtZXNzYWdlLCBsaW5rIH0gPSBkZXByZWNhdGlvbkRhdGFba2V5XTtcclxuICAgIGNvbnN0IG1zZyA9IGAoZGVwcmVjYXRpb24gJHtrZXl9KSAke3R5cGVvZiBtZXNzYWdlID09PSAnZnVuY3Rpb24nID8gbWVzc2FnZSguLi5hcmdzKSA6IG1lc3NhZ2V9JHtsaW5rID8gYFxcbiAgRGV0YWlsczogJHtsaW5rfWAgOiBgYH1gO1xyXG4gICAgY29uc3QgZXJyID0gbmV3IFN5bnRheEVycm9yKG1zZyk7XHJcbiAgICBlcnIuY29kZSA9IGtleTtcclxuICAgIGlmIChsb2MpXHJcbiAgICAgICAgZXJyLmxvYyA9IGxvYztcclxuICAgIGNvbnRleHQub25XYXJuKGVycik7XHJcbn1cblxuLy8gVGhlIGRlZmF1bHQgZGVjb2RlciBvbmx5IHByb3ZpZGVzIGVzY2FwZXMgZm9yIGNoYXJhY3RlcnMgcmVzZXJ2ZWQgYXMgcGFydCBvZlxyXG4vLyB0aGUgdGVtcGxhdGUgc3ludGF4LCBhbmQgaXMgb25seSB1c2VkIGlmIHRoZSBjdXN0b20gcmVuZGVyZXIgZGlkIG5vdCBwcm92aWRlXHJcbi8vIGEgcGxhdGZvcm0tc3BlY2lmaWMgZGVjb2Rlci5cclxuY29uc3QgZGVjb2RlUkUgPSAvJihndHxsdHxhbXB8YXBvc3xxdW90KTsvZztcclxuY29uc3QgZGVjb2RlTWFwID0ge1xyXG4gICAgZ3Q6ICc+JyxcclxuICAgIGx0OiAnPCcsXHJcbiAgICBhbXA6ICcmJyxcclxuICAgIGFwb3M6IFwiJ1wiLFxyXG4gICAgcXVvdDogJ1wiJ1xyXG59O1xyXG5jb25zdCBkZWZhdWx0UGFyc2VyT3B0aW9ucyA9IHtcclxuICAgIGRlbGltaXRlcnM6IFtge3tgLCBgfX1gXSxcclxuICAgIGdldE5hbWVzcGFjZTogKCkgPT4gMCAvKiBIVE1MICovLFxyXG4gICAgZ2V0VGV4dE1vZGU6ICgpID0+IDAgLyogREFUQSAqLyxcclxuICAgIGlzVm9pZFRhZzogTk8sXHJcbiAgICBpc1ByZVRhZzogTk8sXHJcbiAgICBpc0N1c3RvbUVsZW1lbnQ6IE5PLFxyXG4gICAgZGVjb2RlRW50aXRpZXM6IChyYXdUZXh0KSA9PiByYXdUZXh0LnJlcGxhY2UoZGVjb2RlUkUsIChfLCBwMSkgPT4gZGVjb2RlTWFwW3AxXSksXHJcbiAgICBvbkVycm9yOiBkZWZhdWx0T25FcnJvcixcclxuICAgIG9uV2FybjogZGVmYXVsdE9uV2FybixcclxuICAgIGNvbW1lbnRzOiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxufTtcclxuZnVuY3Rpb24gYmFzZVBhcnNlKGNvbnRlbnQsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZVBhcnNlckNvbnRleHQoY29udGVudCwgb3B0aW9ucyk7XHJcbiAgICBjb25zdCBzdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcclxuICAgIHJldHVybiBjcmVhdGVSb290KHBhcnNlQ2hpbGRyZW4oY29udGV4dCwgMCAvKiBEQVRBICovLCBbXSksIGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydCkpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVBhcnNlckNvbnRleHQoY29udGVudCwgcmF3T3B0aW9ucykge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdFBhcnNlck9wdGlvbnMpO1xyXG4gICAgbGV0IGtleTtcclxuICAgIGZvciAoa2V5IGluIHJhd09wdGlvbnMpIHtcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgb3B0aW9uc1trZXldID1cclxuICAgICAgICAgICAgcmF3T3B0aW9uc1trZXldID09PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgID8gZGVmYXVsdFBhcnNlck9wdGlvbnNba2V5XVxyXG4gICAgICAgICAgICAgICAgOiByYXdPcHRpb25zW2tleV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG9wdGlvbnMsXHJcbiAgICAgICAgY29sdW1uOiAxLFxyXG4gICAgICAgIGxpbmU6IDEsXHJcbiAgICAgICAgb2Zmc2V0OiAwLFxyXG4gICAgICAgIG9yaWdpbmFsU291cmNlOiBjb250ZW50LFxyXG4gICAgICAgIHNvdXJjZTogY29udGVudCxcclxuICAgICAgICBpblByZTogZmFsc2UsXHJcbiAgICAgICAgaW5WUHJlOiBmYWxzZSxcclxuICAgICAgICBvbldhcm46IG9wdGlvbnMub25XYXJuXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlQ2hpbGRyZW4oY29udGV4dCwgbW9kZSwgYW5jZXN0b3JzKSB7XHJcbiAgICBjb25zdCBwYXJlbnQgPSBsYXN0KGFuY2VzdG9ycyk7XHJcbiAgICBjb25zdCBucyA9IHBhcmVudCA/IHBhcmVudC5ucyA6IDAgLyogSFRNTCAqLztcclxuICAgIGNvbnN0IG5vZGVzID0gW107XHJcbiAgICB3aGlsZSAoIWlzRW5kKGNvbnRleHQsIG1vZGUsIGFuY2VzdG9ycykpIHtcclxuICAgICAgICBjb25zdCBzID0gY29udGV4dC5zb3VyY2U7XHJcbiAgICAgICAgbGV0IG5vZGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKG1vZGUgPT09IDAgLyogREFUQSAqLyB8fCBtb2RlID09PSAxIC8qIFJDREFUQSAqLykge1xyXG4gICAgICAgICAgICBpZiAoIWNvbnRleHQuaW5WUHJlICYmIHN0YXJ0c1dpdGgocywgY29udGV4dC5vcHRpb25zLmRlbGltaXRlcnNbMF0pKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAne3snXHJcbiAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VJbnRlcnBvbGF0aW9uKGNvbnRleHQsIG1vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG1vZGUgPT09IDAgLyogREFUQSAqLyAmJiBzWzBdID09PSAnPCcpIHtcclxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCN0YWctb3Blbi1zdGF0ZVxyXG4gICAgICAgICAgICAgICAgaWYgKHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDUgLyogRU9GX0JFRk9SRV9UQUdfTkFNRSAqLywgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzWzFdID09PSAnIScpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9wYXJzaW5nLmh0bWwjbWFya3VwLWRlY2xhcmF0aW9uLW9wZW4tc3RhdGVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRzV2l0aChzLCAnPCEtLScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUNvbW1lbnQoY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0c1dpdGgocywgJzwhRE9DVFlQRScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBET0NUWVBFIGJ5IGEgbGltaXRhdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcnNlQm9ndXNDb21tZW50KGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGFydHNXaXRoKHMsICc8IVtDREFUQVsnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobnMgIT09IDAgLyogSFRNTCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcnNlQ0RBVEEoY29udGV4dCwgYW5jZXN0b3JzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxIC8qIENEQVRBX0lOX0hUTUxfQ09OVEVOVCAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VCb2d1c0NvbW1lbnQoY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxMSAvKiBJTkNPUlJFQ1RMWV9PUEVORURfQ09NTUVOVCAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUJvZ3VzQ29tbWVudChjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzWzFdID09PSAnLycpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9wYXJzaW5nLmh0bWwjZW5kLXRhZy1vcGVuLXN0YXRlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCA1IC8qIEVPRl9CRUZPUkVfVEFHX05BTUUgKi8sIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzWzJdID09PSAnPicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDE0IC8qIE1JU1NJTkdfRU5EX1RBR19OQU1FICovLCAyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIDMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoL1thLXpdL2kudGVzdChzWzJdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMjMgLyogWF9JTlZBTElEX0VORF9UQUcgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZVRhZyhjb250ZXh0LCAxIC8qIEVuZCAqLywgcGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTIgLyogSU5WQUxJRF9GSVJTVF9DSEFSQUNURVJfT0ZfVEFHX05BTUUgKi8sIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VCb2d1c0NvbW1lbnQoY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoL1thLXpdL2kudGVzdChzWzFdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUVsZW1lbnQoY29udGV4dCwgYW5jZXN0b3JzKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyAyLnggPHRlbXBsYXRlPiB3aXRoIG5vIGRpcmVjdGl2ZSBjb21wYXRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNDb21wYXRFbmFibGVkKFwiQ09NUElMRVJfTkFUSVZFX1RFTVBMQVRFXCIgLyogQ09NUElMRVJfTkFUSVZFX1RFTVBMQVRFICovLCBjb250ZXh0KSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudGFnID09PSAndGVtcGxhdGUnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICFub2RlLnByb3BzLnNvbWUocCA9PiBwLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1NwZWNpYWxUZW1wbGF0ZURpcmVjdGl2ZShwLm5hbWUpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5EZXByZWNhdGlvbihcIkNPTVBJTEVSX05BVElWRV9URU1QTEFURVwiIC8qIENPTVBJTEVSX05BVElWRV9URU1QTEFURSAqLywgY29udGV4dCwgbm9kZS5sb2MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzWzFdID09PSAnPycpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMjEgLyogVU5FWFBFQ1RFRF9RVUVTVElPTl9NQVJLX0lOU1RFQURfT0ZfVEFHX05BTUUgKi8sIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUJvZ3VzQ29tbWVudChjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxMiAvKiBJTlZBTElEX0ZJUlNUX0NIQVJBQ1RFUl9PRl9UQUdfTkFNRSAqLywgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFub2RlKSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBwYXJzZVRleHQoY29udGV4dCwgbW9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0FycmF5KG5vZGUpKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcHVzaE5vZGUobm9kZXMsIG5vZGVbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwdXNoTm9kZShub2Rlcywgbm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gV2hpdGVzcGFjZSBoYW5kbGluZyBzdHJhdGVneSBsaWtlIHYyXHJcbiAgICBsZXQgcmVtb3ZlZFdoaXRlc3BhY2UgPSBmYWxzZTtcclxuICAgIGlmIChtb2RlICE9PSAyIC8qIFJBV1RFWFQgKi8gJiYgbW9kZSAhPT0gMSAvKiBSQ0RBVEEgKi8pIHtcclxuICAgICAgICBjb25zdCBzaG91bGRDb25kZW5zZSA9IGNvbnRleHQub3B0aW9ucy53aGl0ZXNwYWNlICE9PSAncHJlc2VydmUnO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xyXG4gICAgICAgICAgICBpZiAoIWNvbnRleHQuaW5QcmUgJiYgbm9kZS50eXBlID09PSAyIC8qIFRFWFQgKi8pIHtcclxuICAgICAgICAgICAgICAgIGlmICghL1teXFx0XFxyXFxuXFxmIF0vLnRlc3Qobm9kZS5jb250ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBub2Rlc1tpIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5vZGVzW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgaWY6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gLSB0aGUgd2hpdGVzcGFjZSBpcyB0aGUgZmlyc3Qgb3IgbGFzdCBub2RlLCBvcjpcclxuICAgICAgICAgICAgICAgICAgICAvLyAtIChjb25kZW5zZSBtb2RlKSB0aGUgd2hpdGVzcGFjZSBpcyBhZGphY2VudCB0byBhIGNvbW1lbnQsIG9yOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIC0gKGNvbmRlbnNlIG1vZGUpIHRoZSB3aGl0ZXNwYWNlIGlzIGJldHdlZW4gdHdvIGVsZW1lbnRzIEFORCBjb250YWlucyBuZXdsaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmV2IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICFuZXh0IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChzaG91bGRDb25kZW5zZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHByZXYudHlwZSA9PT0gMyAvKiBDT01NRU5UICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC50eXBlID09PSAzIC8qIENPTU1FTlQgKi8gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocHJldi50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgL1tcXHJcXG5dLy50ZXN0KG5vZGUuY29udGVudCkpKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZFdoaXRlc3BhY2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1tpXSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHRoZSB3aGl0ZXNwYWNlIGlzIGNvbmRlbnNlZCBpbnRvIGEgc2luZ2xlIHNwYWNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY29udGVudCA9ICcgJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaG91bGRDb25kZW5zZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGluIGNvbmRlbnNlIG1vZGUsIGNvbnNlY3V0aXZlIHdoaXRlc3BhY2VzIGluIHRleHQgYXJlIGNvbmRlbnNlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvd24gdG8gYSBzaW5nbGUgc3BhY2UuXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jb250ZW50ID0gbm9kZS5jb250ZW50LnJlcGxhY2UoL1tcXHRcXHJcXG5cXGYgXSsvZywgJyAnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBSZW1vdmUgY29tbWVudCBub2RlcyBpZiBkZXNpcmVkIGJ5IGNvbmZpZ3VyYXRpb24uXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMyAvKiBDT01NRU5UICovICYmICFjb250ZXh0Lm9wdGlvbnMuY29tbWVudHMpIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZWRXaGl0ZXNwYWNlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIG5vZGVzW2ldID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29udGV4dC5pblByZSAmJiBwYXJlbnQgJiYgY29udGV4dC5vcHRpb25zLmlzUHJlVGFnKHBhcmVudC50YWcpKSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBsZWFkaW5nIG5ld2xpbmUgcGVyIGh0bWwgc3BlY1xyXG4gICAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9ncm91cGluZy1jb250ZW50Lmh0bWwjdGhlLXByZS1lbGVtZW50XHJcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gbm9kZXNbMF07XHJcbiAgICAgICAgICAgIGlmIChmaXJzdCAmJiBmaXJzdC50eXBlID09PSAyIC8qIFRFWFQgKi8pIHtcclxuICAgICAgICAgICAgICAgIGZpcnN0LmNvbnRlbnQgPSBmaXJzdC5jb250ZW50LnJlcGxhY2UoL15cXHI/XFxuLywgJycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlbW92ZWRXaGl0ZXNwYWNlID8gbm9kZXMuZmlsdGVyKEJvb2xlYW4pIDogbm9kZXM7XHJcbn1cclxuZnVuY3Rpb24gcHVzaE5vZGUobm9kZXMsIG5vZGUpIHtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDIgLyogVEVYVCAqLykge1xyXG4gICAgICAgIGNvbnN0IHByZXYgPSBsYXN0KG5vZGVzKTtcclxuICAgICAgICAvLyBNZXJnZSBpZiBib3RoIHRoaXMgYW5kIHRoZSBwcmV2aW91cyBub2RlIGFyZSB0ZXh0IGFuZCB0aG9zZSBhcmVcclxuICAgICAgICAvLyBjb25zZWN1dGl2ZS4gVGhpcyBoYXBwZW5zIGZvciBjYXNlcyBsaWtlIFwiYSA8IGJcIi5cclxuICAgICAgICBpZiAocHJldiAmJlxyXG4gICAgICAgICAgICBwcmV2LnR5cGUgPT09IDIgLyogVEVYVCAqLyAmJlxyXG4gICAgICAgICAgICBwcmV2LmxvYy5lbmQub2Zmc2V0ID09PSBub2RlLmxvYy5zdGFydC5vZmZzZXQpIHtcclxuICAgICAgICAgICAgcHJldi5jb250ZW50ICs9IG5vZGUuY29udGVudDtcclxuICAgICAgICAgICAgcHJldi5sb2MuZW5kID0gbm9kZS5sb2MuZW5kO1xyXG4gICAgICAgICAgICBwcmV2LmxvYy5zb3VyY2UgKz0gbm9kZS5sb2Muc291cmNlO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbm9kZXMucHVzaChub2RlKTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUNEQVRBKGNvbnRleHQsIGFuY2VzdG9ycykge1xyXG4gICAgYWR2YW5jZUJ5KGNvbnRleHQsIDkpO1xyXG4gICAgY29uc3Qgbm9kZXMgPSBwYXJzZUNoaWxkcmVuKGNvbnRleHQsIDMgLyogQ0RBVEEgKi8sIGFuY2VzdG9ycyk7XHJcbiAgICBpZiAoY29udGV4dC5zb3VyY2UubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDYgLyogRU9GX0lOX0NEQVRBICovKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCAzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBub2RlcztcclxufVxyXG5mdW5jdGlvbiBwYXJzZUNvbW1lbnQoY29udGV4dCkge1xyXG4gICAgY29uc3Qgc3RhcnQgPSBnZXRDdXJzb3IoY29udGV4dCk7XHJcbiAgICBsZXQgY29udGVudDtcclxuICAgIC8vIFJlZ3VsYXIgY29tbWVudC5cclxuICAgIGNvbnN0IG1hdGNoID0gLy0tKFxcISk/Pi8uZXhlYyhjb250ZXh0LnNvdXJjZSk7XHJcbiAgICBpZiAoIW1hdGNoKSB7XHJcbiAgICAgICAgY29udGVudCA9IGNvbnRleHQuc291cmNlLnNsaWNlKDQpO1xyXG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCBjb250ZXh0LnNvdXJjZS5sZW5ndGgpO1xyXG4gICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCA3IC8qIEVPRl9JTl9DT01NRU5UICovKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChtYXRjaC5pbmRleCA8PSAzKSB7XHJcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAwIC8qIEFCUlVQVF9DTE9TSU5HX09GX0VNUFRZX0NPTU1FTlQgKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWF0Y2hbMV0pIHtcclxuICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDEwIC8qIElOQ09SUkVDVExZX0NMT1NFRF9DT01NRU5UICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGVudCA9IGNvbnRleHQuc291cmNlLnNsaWNlKDQsIG1hdGNoLmluZGV4KTtcclxuICAgICAgICAvLyBBZHZhbmNpbmcgd2l0aCByZXBvcnRpbmcgbmVzdGVkIGNvbW1lbnRzLlxyXG4gICAgICAgIGNvbnN0IHMgPSBjb250ZXh0LnNvdXJjZS5zbGljZSgwLCBtYXRjaC5pbmRleCk7XHJcbiAgICAgICAgbGV0IHByZXZJbmRleCA9IDEsIG5lc3RlZEluZGV4ID0gMDtcclxuICAgICAgICB3aGlsZSAoKG5lc3RlZEluZGV4ID0gcy5pbmRleE9mKCc8IS0tJywgcHJldkluZGV4KSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCBuZXN0ZWRJbmRleCAtIHByZXZJbmRleCArIDEpO1xyXG4gICAgICAgICAgICBpZiAobmVzdGVkSW5kZXggKyA0IDwgcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxNiAvKiBORVNURURfQ09NTUVOVCAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJldkluZGV4ID0gbmVzdGVkSW5kZXggKyAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggLSBwcmV2SW5kZXggKyAxKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMyAvKiBDT01NRU5UICovLFxyXG4gICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgbG9jOiBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQpXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlQm9ndXNDb21tZW50KGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xyXG4gICAgY29uc3QgY29udGVudFN0YXJ0ID0gY29udGV4dC5zb3VyY2VbMV0gPT09ICc/JyA/IDEgOiAyO1xyXG4gICAgbGV0IGNvbnRlbnQ7XHJcbiAgICBjb25zdCBjbG9zZUluZGV4ID0gY29udGV4dC5zb3VyY2UuaW5kZXhPZignPicpO1xyXG4gICAgaWYgKGNsb3NlSW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgY29udGVudCA9IGNvbnRleHQuc291cmNlLnNsaWNlKGNvbnRlbnRTdGFydCk7XHJcbiAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIGNvbnRleHQuc291cmNlLmxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb250ZW50ID0gY29udGV4dC5zb3VyY2Uuc2xpY2UoY29udGVudFN0YXJ0LCBjbG9zZUluZGV4KTtcclxuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgY2xvc2VJbmRleCArIDEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAzIC8qIENPTU1FTlQgKi8sXHJcbiAgICAgICAgY29udGVudCxcclxuICAgICAgICBsb2M6IGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydClcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VFbGVtZW50KGNvbnRleHQsIGFuY2VzdG9ycykge1xyXG4gICAgLy8gU3RhcnQgdGFnLlxyXG4gICAgY29uc3Qgd2FzSW5QcmUgPSBjb250ZXh0LmluUHJlO1xyXG4gICAgY29uc3Qgd2FzSW5WUHJlID0gY29udGV4dC5pblZQcmU7XHJcbiAgICBjb25zdCBwYXJlbnQgPSBsYXN0KGFuY2VzdG9ycyk7XHJcbiAgICBjb25zdCBlbGVtZW50ID0gcGFyc2VUYWcoY29udGV4dCwgMCAvKiBTdGFydCAqLywgcGFyZW50KTtcclxuICAgIGNvbnN0IGlzUHJlQm91bmRhcnkgPSBjb250ZXh0LmluUHJlICYmICF3YXNJblByZTtcclxuICAgIGNvbnN0IGlzVlByZUJvdW5kYXJ5ID0gY29udGV4dC5pblZQcmUgJiYgIXdhc0luVlByZTtcclxuICAgIGlmIChlbGVtZW50LmlzU2VsZkNsb3NpbmcgfHwgY29udGV4dC5vcHRpb25zLmlzVm9pZFRhZyhlbGVtZW50LnRhZykpIHtcclxuICAgICAgICAvLyAjNDAzMCBzZWxmLWNsb3NpbmcgPHByZT4gdGFnXHJcbiAgICAgICAgaWYgKGlzUHJlQm91bmRhcnkpIHtcclxuICAgICAgICAgICAgY29udGV4dC5pblByZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNWUHJlQm91bmRhcnkpIHtcclxuICAgICAgICAgICAgY29udGV4dC5pblZQcmUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICAvLyBDaGlsZHJlbi5cclxuICAgIGFuY2VzdG9ycy5wdXNoKGVsZW1lbnQpO1xyXG4gICAgY29uc3QgbW9kZSA9IGNvbnRleHQub3B0aW9ucy5nZXRUZXh0TW9kZShlbGVtZW50LCBwYXJlbnQpO1xyXG4gICAgY29uc3QgY2hpbGRyZW4gPSBwYXJzZUNoaWxkcmVuKGNvbnRleHQsIG1vZGUsIGFuY2VzdG9ycyk7XHJcbiAgICBhbmNlc3RvcnMucG9wKCk7XHJcbiAgICAvLyAyLnggaW5saW5lLXRlbXBsYXRlIGNvbXBhdFxyXG4gICAge1xyXG4gICAgICAgIGNvbnN0IGlubGluZVRlbXBsYXRlUHJvcCA9IGVsZW1lbnQucHJvcHMuZmluZChwID0+IHAudHlwZSA9PT0gNiAvKiBBVFRSSUJVVEUgKi8gJiYgcC5uYW1lID09PSAnaW5saW5lLXRlbXBsYXRlJyk7XHJcbiAgICAgICAgaWYgKGlubGluZVRlbXBsYXRlUHJvcCAmJlxyXG4gICAgICAgICAgICBjaGVja0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9JTkxJTkVfVEVNUExBVEVcIiAvKiBDT01QSUxFUl9JTkxJTkVfVEVNUExBVEUgKi8sIGNvbnRleHQsIGlubGluZVRlbXBsYXRlUHJvcC5sb2MpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvYyA9IGdldFNlbGVjdGlvbihjb250ZXh0LCBlbGVtZW50LmxvYy5lbmQpO1xyXG4gICAgICAgICAgICBpbmxpbmVUZW1wbGF0ZVByb3AudmFsdWUgPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAyIC8qIFRFWFQgKi8sXHJcbiAgICAgICAgICAgICAgICBjb250ZW50OiBsb2Muc291cmNlLFxyXG4gICAgICAgICAgICAgICAgbG9jXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxlbWVudC5jaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgLy8gRW5kIHRhZy5cclxuICAgIGlmIChzdGFydHNXaXRoRW5kVGFnT3Blbihjb250ZXh0LnNvdXJjZSwgZWxlbWVudC50YWcpKSB7XHJcbiAgICAgICAgcGFyc2VUYWcoY29udGV4dCwgMSAvKiBFbmQgKi8sIHBhcmVudCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMjQgLyogWF9NSVNTSU5HX0VORF9UQUcgKi8sIDAsIGVsZW1lbnQubG9jLnN0YXJ0KTtcclxuICAgICAgICBpZiAoY29udGV4dC5zb3VyY2UubGVuZ3RoID09PSAwICYmIGVsZW1lbnQudGFnLnRvTG93ZXJDYXNlKCkgPT09ICdzY3JpcHQnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gY2hpbGRyZW5bMF07XHJcbiAgICAgICAgICAgIGlmIChmaXJzdCAmJiBzdGFydHNXaXRoKGZpcnN0LmxvYy5zb3VyY2UsICc8IS0tJykpIHtcclxuICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCA4IC8qIEVPRl9JTl9TQ1JJUFRfSFRNTF9DT01NRU5UX0xJS0VfVEVYVCAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbGVtZW50LmxvYyA9IGdldFNlbGVjdGlvbihjb250ZXh0LCBlbGVtZW50LmxvYy5zdGFydCk7XHJcbiAgICBpZiAoaXNQcmVCb3VuZGFyeSkge1xyXG4gICAgICAgIGNvbnRleHQuaW5QcmUgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChpc1ZQcmVCb3VuZGFyeSkge1xyXG4gICAgICAgIGNvbnRleHQuaW5WUHJlID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZWxlbWVudDtcclxufVxyXG5jb25zdCBpc1NwZWNpYWxUZW1wbGF0ZURpcmVjdGl2ZSA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChgaWYsZWxzZSxlbHNlLWlmLGZvcixzbG90YCk7XHJcbmZ1bmN0aW9uIHBhcnNlVGFnKGNvbnRleHQsIHR5cGUsIHBhcmVudCkge1xyXG4gICAgLy8gVGFnIG9wZW4uXHJcbiAgICBjb25zdCBzdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcclxuICAgIGNvbnN0IG1hdGNoID0gL148XFwvPyhbYS16XVteXFx0XFxyXFxuXFxmIC8+XSopL2kuZXhlYyhjb250ZXh0LnNvdXJjZSk7XHJcbiAgICBjb25zdCB0YWcgPSBtYXRjaFsxXTtcclxuICAgIGNvbnN0IG5zID0gY29udGV4dC5vcHRpb25zLmdldE5hbWVzcGFjZSh0YWcsIHBhcmVudCk7XHJcbiAgICBhZHZhbmNlQnkoY29udGV4dCwgbWF0Y2hbMF0ubGVuZ3RoKTtcclxuICAgIGFkdmFuY2VTcGFjZXMoY29udGV4dCk7XHJcbiAgICAvLyBzYXZlIGN1cnJlbnQgc3RhdGUgaW4gY2FzZSB3ZSBuZWVkIHRvIHJlLXBhcnNlIGF0dHJpYnV0ZXMgd2l0aCB2LXByZVxyXG4gICAgY29uc3QgY3Vyc29yID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xyXG4gICAgY29uc3QgY3VycmVudFNvdXJjZSA9IGNvbnRleHQuc291cmNlO1xyXG4gICAgLy8gY2hlY2sgPHByZT4gdGFnXHJcbiAgICBpZiAoY29udGV4dC5vcHRpb25zLmlzUHJlVGFnKHRhZykpIHtcclxuICAgICAgICBjb250ZXh0LmluUHJlID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vIEF0dHJpYnV0ZXMuXHJcbiAgICBsZXQgcHJvcHMgPSBwYXJzZUF0dHJpYnV0ZXMoY29udGV4dCwgdHlwZSk7XHJcbiAgICAvLyBjaGVjayB2LXByZVxyXG4gICAgaWYgKHR5cGUgPT09IDAgLyogU3RhcnQgKi8gJiZcclxuICAgICAgICAhY29udGV4dC5pblZQcmUgJiZcclxuICAgICAgICBwcm9wcy5zb21lKHAgPT4gcC50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLyAmJiBwLm5hbWUgPT09ICdwcmUnKSkge1xyXG4gICAgICAgIGNvbnRleHQuaW5WUHJlID0gdHJ1ZTtcclxuICAgICAgICAvLyByZXNldCBjb250ZXh0XHJcbiAgICAgICAgZXh0ZW5kKGNvbnRleHQsIGN1cnNvcik7XHJcbiAgICAgICAgY29udGV4dC5zb3VyY2UgPSBjdXJyZW50U291cmNlO1xyXG4gICAgICAgIC8vIHJlLXBhcnNlIGF0dHJzIGFuZCBmaWx0ZXIgb3V0IHYtcHJlIGl0c2VsZlxyXG4gICAgICAgIHByb3BzID0gcGFyc2VBdHRyaWJ1dGVzKGNvbnRleHQsIHR5cGUpLmZpbHRlcihwID0+IHAubmFtZSAhPT0gJ3YtcHJlJyk7XHJcbiAgICB9XHJcbiAgICAvLyBUYWcgY2xvc2UuXHJcbiAgICBsZXQgaXNTZWxmQ2xvc2luZyA9IGZhbHNlO1xyXG4gICAgaWYgKGNvbnRleHQuc291cmNlLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCA5IC8qIEVPRl9JTl9UQUcgKi8pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaXNTZWxmQ2xvc2luZyA9IHN0YXJ0c1dpdGgoY29udGV4dC5zb3VyY2UsICcvPicpO1xyXG4gICAgICAgIGlmICh0eXBlID09PSAxIC8qIEVuZCAqLyAmJiBpc1NlbGZDbG9zaW5nKSB7XHJcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCA0IC8qIEVORF9UQUdfV0lUSF9UUkFJTElOR19TT0xJRFVTICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIGlzU2VsZkNsb3NpbmcgPyAyIDogMSk7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZSA9PT0gMSAvKiBFbmQgKi8pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyAyLnggZGVwcmVjYXRpb24gY2hlY2tzXHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgaXNDb21wYXRFbmFibGVkKFwiQ09NUElMRVJfVl9JRl9WX0ZPUl9QUkVDRURFTkNFXCIgLyogQ09NUElMRVJfVl9JRl9WX0ZPUl9QUkVDRURFTkNFICovLCBjb250ZXh0KSkge1xyXG4gICAgICAgIGxldCBoYXNJZiA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBoYXNGb3IgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHAgPSBwcm9wc1tpXTtcclxuICAgICAgICAgICAgaWYgKHAudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8pIHtcclxuICAgICAgICAgICAgICAgIGlmIChwLm5hbWUgPT09ICdpZicpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNJZiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwLm5hbWUgPT09ICdmb3InKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzRm9yID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaGFzSWYgJiYgaGFzRm9yKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuRGVwcmVjYXRpb24oXCJDT01QSUxFUl9WX0lGX1ZfRk9SX1BSRUNFREVOQ0VcIiAvKiBDT01QSUxFUl9WX0lGX1ZfRk9SX1BSRUNFREVOQ0UgKi8sIGNvbnRleHQsIGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydCkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsZXQgdGFnVHlwZSA9IDAgLyogRUxFTUVOVCAqLztcclxuICAgIGlmICghY29udGV4dC5pblZQcmUpIHtcclxuICAgICAgICBpZiAodGFnID09PSAnc2xvdCcpIHtcclxuICAgICAgICAgICAgdGFnVHlwZSA9IDIgLyogU0xPVCAqLztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGFnID09PSAndGVtcGxhdGUnKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9wcy5zb21lKHAgPT4gcC50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLyAmJiBpc1NwZWNpYWxUZW1wbGF0ZURpcmVjdGl2ZShwLm5hbWUpKSkge1xyXG4gICAgICAgICAgICAgICAgdGFnVHlwZSA9IDMgLyogVEVNUExBVEUgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNDb21wb25lbnQodGFnLCBwcm9wcywgY29udGV4dCkpIHtcclxuICAgICAgICAgICAgdGFnVHlwZSA9IDEgLyogQ09NUE9ORU5UICovO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMSAvKiBFTEVNRU5UICovLFxyXG4gICAgICAgIG5zLFxyXG4gICAgICAgIHRhZyxcclxuICAgICAgICB0YWdUeXBlLFxyXG4gICAgICAgIHByb3BzLFxyXG4gICAgICAgIGlzU2VsZkNsb3NpbmcsXHJcbiAgICAgICAgY2hpbGRyZW46IFtdLFxyXG4gICAgICAgIGxvYzogZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0KSxcclxuICAgICAgICBjb2RlZ2VuTm9kZTogdW5kZWZpbmVkIC8vIHRvIGJlIGNyZWF0ZWQgZHVyaW5nIHRyYW5zZm9ybSBwaGFzZVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpc0NvbXBvbmVudCh0YWcsIHByb3BzLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCBvcHRpb25zID0gY29udGV4dC5vcHRpb25zO1xyXG4gICAgaWYgKG9wdGlvbnMuaXNDdXN0b21FbGVtZW50KHRhZykpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAodGFnID09PSAnY29tcG9uZW50JyB8fFxyXG4gICAgICAgIC9eW0EtWl0vLnRlc3QodGFnKSB8fFxyXG4gICAgICAgIGlzQ29yZUNvbXBvbmVudCh0YWcpIHx8XHJcbiAgICAgICAgKG9wdGlvbnMuaXNCdWlsdEluQ29tcG9uZW50ICYmIG9wdGlvbnMuaXNCdWlsdEluQ29tcG9uZW50KHRhZykpIHx8XHJcbiAgICAgICAgKG9wdGlvbnMuaXNOYXRpdmVUYWcgJiYgIW9wdGlvbnMuaXNOYXRpdmVUYWcodGFnKSkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vIGF0IHRoaXMgcG9pbnQgdGhlIHRhZyBzaG91bGQgYmUgYSBuYXRpdmUgdGFnLCBidXQgY2hlY2sgZm9yIHBvdGVudGlhbCBcImlzXCJcclxuICAgIC8vIGNhc3RpbmdcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBwID0gcHJvcHNbaV07XHJcbiAgICAgICAgaWYgKHAudHlwZSA9PT0gNiAvKiBBVFRSSUJVVEUgKi8pIHtcclxuICAgICAgICAgICAgaWYgKHAubmFtZSA9PT0gJ2lzJyAmJiBwLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocC52YWx1ZS5jb250ZW50LnN0YXJ0c1dpdGgoJ3Z1ZTonKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2tDb21wYXRFbmFibGVkKFwiQ09NUElMRVJfSVNfT05fRUxFTUVOVFwiIC8qIENPTVBJTEVSX0lTX09OX0VMRU1FTlQgKi8sIGNvbnRleHQsIHAubG9jKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBkaXJlY3RpdmVcclxuICAgICAgICAgICAgLy8gdi1pcyAoVE9ETyBEZXByZWNhdGUpXHJcbiAgICAgICAgICAgIGlmIChwLm5hbWUgPT09ICdpcycpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKFxyXG4gICAgICAgICAgICAvLyA6aXMgb24gcGxhaW4gZWxlbWVudCAtIG9ubHkgdHJlYXQgYXMgY29tcG9uZW50IGluIGNvbXBhdCBtb2RlXHJcbiAgICAgICAgICAgIHAubmFtZSA9PT0gJ2JpbmQnICYmXHJcbiAgICAgICAgICAgICAgICBpc1N0YXRpY0FyZ09mKHAuYXJnLCAnaXMnKSAmJlxyXG4gICAgICAgICAgICAgICAgdHJ1ZSAmJlxyXG4gICAgICAgICAgICAgICAgY2hlY2tDb21wYXRFbmFibGVkKFwiQ09NUElMRVJfSVNfT05fRUxFTUVOVFwiIC8qIENPTVBJTEVSX0lTX09OX0VMRU1FTlQgKi8sIGNvbnRleHQsIHAubG9jKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VBdHRyaWJ1dGVzKGNvbnRleHQsIHR5cGUpIHtcclxuICAgIGNvbnN0IHByb3BzID0gW107XHJcbiAgICBjb25zdCBhdHRyaWJ1dGVOYW1lcyA9IG5ldyBTZXQoKTtcclxuICAgIHdoaWxlIChjb250ZXh0LnNvdXJjZS5sZW5ndGggPiAwICYmXHJcbiAgICAgICAgIXN0YXJ0c1dpdGgoY29udGV4dC5zb3VyY2UsICc+JykgJiZcclxuICAgICAgICAhc3RhcnRzV2l0aChjb250ZXh0LnNvdXJjZSwgJy8+JykpIHtcclxuICAgICAgICBpZiAoc3RhcnRzV2l0aChjb250ZXh0LnNvdXJjZSwgJy8nKSkge1xyXG4gICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMjIgLyogVU5FWFBFQ1RFRF9TT0xJRFVTX0lOX1RBRyAqLyk7XHJcbiAgICAgICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCAxKTtcclxuICAgICAgICAgICAgYWR2YW5jZVNwYWNlcyhjb250ZXh0KTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlID09PSAxIC8qIEVuZCAqLykge1xyXG4gICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMyAvKiBFTkRfVEFHX1dJVEhfQVRUUklCVVRFUyAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGF0dHIgPSBwYXJzZUF0dHJpYnV0ZShjb250ZXh0LCBhdHRyaWJ1dGVOYW1lcyk7XHJcbiAgICAgICAgLy8gVHJpbSB3aGl0ZXNwYWNlIGJldHdlZW4gY2xhc3NcclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvY29yZS9pc3N1ZXMvNDI1MVxyXG4gICAgICAgIGlmIChhdHRyLnR5cGUgPT09IDYgLyogQVRUUklCVVRFICovICYmXHJcbiAgICAgICAgICAgIGF0dHIudmFsdWUgJiZcclxuICAgICAgICAgICAgYXR0ci5uYW1lID09PSAnY2xhc3MnKSB7XHJcbiAgICAgICAgICAgIGF0dHIudmFsdWUuY29udGVudCA9IGF0dHIudmFsdWUuY29udGVudC5yZXBsYWNlKC9cXHMrL2csICcgJykudHJpbSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZSA9PT0gMCAvKiBTdGFydCAqLykge1xyXG4gICAgICAgICAgICBwcm9wcy5wdXNoKGF0dHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoL15bXlxcdFxcclxcblxcZiAvPl0vLnRlc3QoY29udGV4dC5zb3VyY2UpKSB7XHJcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxNSAvKiBNSVNTSU5HX1dISVRFU1BBQ0VfQkVUV0VFTl9BVFRSSUJVVEVTICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWR2YW5jZVNwYWNlcyhjb250ZXh0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcm9wcztcclxufVxyXG5mdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZShjb250ZXh0LCBuYW1lU2V0KSB7XHJcbiAgICAvLyBOYW1lLlxyXG4gICAgY29uc3Qgc3RhcnQgPSBnZXRDdXJzb3IoY29udGV4dCk7XHJcbiAgICBjb25zdCBtYXRjaCA9IC9eW15cXHRcXHJcXG5cXGYgLz5dW15cXHRcXHJcXG5cXGYgLz49XSovLmV4ZWMoY29udGV4dC5zb3VyY2UpO1xyXG4gICAgY29uc3QgbmFtZSA9IG1hdGNoWzBdO1xyXG4gICAgaWYgKG5hbWVTZXQuaGFzKG5hbWUpKSB7XHJcbiAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDIgLyogRFVQTElDQVRFX0FUVFJJQlVURSAqLyk7XHJcbiAgICB9XHJcbiAgICBuYW1lU2V0LmFkZChuYW1lKTtcclxuICAgIGlmIChuYW1lWzBdID09PSAnPScpIHtcclxuICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTkgLyogVU5FWFBFQ1RFRF9FUVVBTFNfU0lHTl9CRUZPUkVfQVRUUklCVVRFX05BTUUgKi8pO1xyXG4gICAgfVxyXG4gICAge1xyXG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSAvW1wiJzxdL2c7XHJcbiAgICAgICAgbGV0IG07XHJcbiAgICAgICAgd2hpbGUgKChtID0gcGF0dGVybi5leGVjKG5hbWUpKSkge1xyXG4gICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTcgLyogVU5FWFBFQ1RFRF9DSEFSQUNURVJfSU5fQVRUUklCVVRFX05BTUUgKi8sIG0uaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFkdmFuY2VCeShjb250ZXh0LCBuYW1lLmxlbmd0aCk7XHJcbiAgICAvLyBWYWx1ZVxyXG4gICAgbGV0IHZhbHVlID0gdW5kZWZpbmVkO1xyXG4gICAgaWYgKC9eW1xcdFxcclxcblxcZiBdKj0vLnRlc3QoY29udGV4dC5zb3VyY2UpKSB7XHJcbiAgICAgICAgYWR2YW5jZVNwYWNlcyhjb250ZXh0KTtcclxuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgMSk7XHJcbiAgICAgICAgYWR2YW5jZVNwYWNlcyhjb250ZXh0KTtcclxuICAgICAgICB2YWx1ZSA9IHBhcnNlQXR0cmlidXRlVmFsdWUoY29udGV4dCk7XHJcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTMgLyogTUlTU0lOR19BVFRSSUJVVEVfVkFMVUUgKi8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IGxvYyA9IGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydCk7XHJcbiAgICBpZiAoIWNvbnRleHQuaW5WUHJlICYmIC9eKHYtW0EtWmEtejAtOS1dfDp8XFwufEB8IykvLnRlc3QobmFtZSkpIHtcclxuICAgICAgICBjb25zdCBtYXRjaCA9IC8oPzpedi0oW2EtejAtOS1dKykpPyg/Oig/Ojp8XlxcLnxeQHxeIykoXFxbW15cXF1dK1xcXXxbXlxcLl0rKSk/KC4rKT8kL2kuZXhlYyhuYW1lKTtcclxuICAgICAgICBsZXQgaXNQcm9wU2hvcnRoYW5kID0gc3RhcnRzV2l0aChuYW1lLCAnLicpO1xyXG4gICAgICAgIGxldCBkaXJOYW1lID0gbWF0Y2hbMV0gfHxcclxuICAgICAgICAgICAgKGlzUHJvcFNob3J0aGFuZCB8fCBzdGFydHNXaXRoKG5hbWUsICc6JylcclxuICAgICAgICAgICAgICAgID8gJ2JpbmQnXHJcbiAgICAgICAgICAgICAgICA6IHN0YXJ0c1dpdGgobmFtZSwgJ0AnKVxyXG4gICAgICAgICAgICAgICAgICAgID8gJ29uJ1xyXG4gICAgICAgICAgICAgICAgICAgIDogJ3Nsb3QnKTtcclxuICAgICAgICBsZXQgYXJnO1xyXG4gICAgICAgIGlmIChtYXRjaFsyXSkge1xyXG4gICAgICAgICAgICBjb25zdCBpc1Nsb3QgPSBkaXJOYW1lID09PSAnc2xvdCc7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gbmFtZS5sYXN0SW5kZXhPZihtYXRjaFsyXSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvYyA9IGdldFNlbGVjdGlvbihjb250ZXh0LCBnZXROZXdQb3NpdGlvbihjb250ZXh0LCBzdGFydCwgc3RhcnRPZmZzZXQpLCBnZXROZXdQb3NpdGlvbihjb250ZXh0LCBzdGFydCwgc3RhcnRPZmZzZXQgKyBtYXRjaFsyXS5sZW5ndGggKyAoKGlzU2xvdCAmJiBtYXRjaFszXSkgfHwgJycpLmxlbmd0aCkpO1xyXG4gICAgICAgICAgICBsZXQgY29udGVudCA9IG1hdGNoWzJdO1xyXG4gICAgICAgICAgICBsZXQgaXNTdGF0aWMgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoY29udGVudC5zdGFydHNXaXRoKCdbJykpIHtcclxuICAgICAgICAgICAgICAgIGlzU3RhdGljID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRlbnQuZW5kc1dpdGgoJ10nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAyNyAvKiBYX01JU1NJTkdfRFlOQU1JQ19ESVJFQ1RJVkVfQVJHVU1FTlRfRU5EICovKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5zbGljZSgxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDEsIGNvbnRlbnQubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNTbG90KSB7XHJcbiAgICAgICAgICAgICAgICAvLyAjMTI0MSBzcGVjaWFsIGNhc2UgZm9yIHYtc2xvdDogdnVldGlmeSByZWxpZXMgZXh0ZW5zaXZlbHkgb24gc2xvdFxyXG4gICAgICAgICAgICAgICAgLy8gbmFtZXMgY29udGFpbmluZyBkb3RzLiB2LXNsb3QgZG9lc24ndCBoYXZlIGFueSBtb2RpZmllcnMgYW5kIFZ1ZSAyLnhcclxuICAgICAgICAgICAgICAgIC8vIHN1cHBvcnRzIHN1Y2ggdXNhZ2Ugc28gd2UgYXJlIGtlZXBpbmcgaXQgY29uc2lzdGVudCB3aXRoIDIueC5cclxuICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gbWF0Y2hbM10gfHwgJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXJnID0ge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgICAgICAgICBpc1N0YXRpYyxcclxuICAgICAgICAgICAgICAgIGNvbnN0VHlwZTogaXNTdGF0aWNcclxuICAgICAgICAgICAgICAgICAgICA/IDMgLyogQ0FOX1NUUklOR0lGWSAqL1xyXG4gICAgICAgICAgICAgICAgICAgIDogMCAvKiBOT1RfQ09OU1RBTlQgKi8sXHJcbiAgICAgICAgICAgICAgICBsb2NcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmlzUXVvdGVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlTG9jID0gdmFsdWUubG9jO1xyXG4gICAgICAgICAgICB2YWx1ZUxvYy5zdGFydC5vZmZzZXQrKztcclxuICAgICAgICAgICAgdmFsdWVMb2Muc3RhcnQuY29sdW1uKys7XHJcbiAgICAgICAgICAgIHZhbHVlTG9jLmVuZCA9IGFkdmFuY2VQb3NpdGlvbldpdGhDbG9uZSh2YWx1ZUxvYy5zdGFydCwgdmFsdWUuY29udGVudCk7XHJcbiAgICAgICAgICAgIHZhbHVlTG9jLnNvdXJjZSA9IHZhbHVlTG9jLnNvdXJjZS5zbGljZSgxLCAtMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG1vZGlmaWVycyA9IG1hdGNoWzNdID8gbWF0Y2hbM10uc2xpY2UoMSkuc3BsaXQoJy4nKSA6IFtdO1xyXG4gICAgICAgIGlmIChpc1Byb3BTaG9ydGhhbmQpXHJcbiAgICAgICAgICAgIG1vZGlmaWVycy5wdXNoKCdwcm9wJyk7XHJcbiAgICAgICAgLy8gMi54IGNvbXBhdCB2LWJpbmQ6Zm9vLnN5bmMgLT4gdi1tb2RlbDpmb29cclxuICAgICAgICBpZiAoZGlyTmFtZSA9PT0gJ2JpbmQnICYmIGFyZykge1xyXG4gICAgICAgICAgICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKCdzeW5jJykgJiZcclxuICAgICAgICAgICAgICAgIGNoZWNrQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX1ZfQklORF9TWU5DXCIgLyogQ09NUElMRVJfVl9CSU5EX1NZTkMgKi8sIGNvbnRleHQsIGxvYywgYXJnLmxvYy5zb3VyY2UpKSB7XHJcbiAgICAgICAgICAgICAgICBkaXJOYW1lID0gJ21vZGVsJztcclxuICAgICAgICAgICAgICAgIG1vZGlmaWVycy5zcGxpY2UobW9kaWZpZXJzLmluZGV4T2YoJ3N5bmMnKSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBtb2RpZmllcnMuaW5jbHVkZXMoJ3Byb3AnKSkge1xyXG4gICAgICAgICAgICAgICAgY2hlY2tDb21wYXRFbmFibGVkKFwiQ09NUElMRVJfVl9CSU5EX1BST1BcIiAvKiBDT01QSUxFUl9WX0JJTkRfUFJPUCAqLywgY29udGV4dCwgbG9jKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiA3IC8qIERJUkVDVElWRSAqLyxcclxuICAgICAgICAgICAgbmFtZTogZGlyTmFtZSxcclxuICAgICAgICAgICAgZXhwOiB2YWx1ZSAmJiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgICAgICAgICAgY29udGVudDogdmFsdWUuY29udGVudCxcclxuICAgICAgICAgICAgICAgIGlzU3RhdGljOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIC8vIFRyZWF0IGFzIG5vbi1jb25zdGFudCBieSBkZWZhdWx0LiBUaGlzIGNhbiBiZSBwb3RlbnRpYWxseSBzZXQgdG9cclxuICAgICAgICAgICAgICAgIC8vIG90aGVyIHZhbHVlcyBieSBgdHJhbnNmb3JtRXhwcmVzc2lvbmAgdG8gbWFrZSBpdCBlbGlnaWJsZSBmb3IgaG9pc3RpbmcuXHJcbiAgICAgICAgICAgICAgICBjb25zdFR5cGU6IDAgLyogTk9UX0NPTlNUQU5UICovLFxyXG4gICAgICAgICAgICAgICAgbG9jOiB2YWx1ZS5sb2NcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYXJnLFxyXG4gICAgICAgICAgICBtb2RpZmllcnMsXHJcbiAgICAgICAgICAgIGxvY1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvLyBtaXNzaW5nIGRpcmVjdGl2ZSBuYW1lIG9yIGlsbGVnYWwgZGlyZWN0aXZlIG5hbWVcclxuICAgIGlmICghY29udGV4dC5pblZQcmUgJiYgc3RhcnRzV2l0aChuYW1lLCAndi0nKSkge1xyXG4gICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAyNiAvKiBYX01JU1NJTkdfRElSRUNUSVZFX05BTUUgKi8pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiA2IC8qIEFUVFJJQlVURSAqLyxcclxuICAgICAgICBuYW1lLFxyXG4gICAgICAgIHZhbHVlOiB2YWx1ZSAmJiB7XHJcbiAgICAgICAgICAgIHR5cGU6IDIgLyogVEVYVCAqLyxcclxuICAgICAgICAgICAgY29udGVudDogdmFsdWUuY29udGVudCxcclxuICAgICAgICAgICAgbG9jOiB2YWx1ZS5sb2NcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxvY1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZVZhbHVlKGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xyXG4gICAgbGV0IGNvbnRlbnQ7XHJcbiAgICBjb25zdCBxdW90ZSA9IGNvbnRleHQuc291cmNlWzBdO1xyXG4gICAgY29uc3QgaXNRdW90ZWQgPSBxdW90ZSA9PT0gYFwiYCB8fCBxdW90ZSA9PT0gYCdgO1xyXG4gICAgaWYgKGlzUXVvdGVkKSB7XHJcbiAgICAgICAgLy8gUXVvdGVkIHZhbHVlLlxyXG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCAxKTtcclxuICAgICAgICBjb25zdCBlbmRJbmRleCA9IGNvbnRleHQuc291cmNlLmluZGV4T2YocXVvdGUpO1xyXG4gICAgICAgIGlmIChlbmRJbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgY29udGVudCA9IHBhcnNlVGV4dERhdGEoY29udGV4dCwgY29udGV4dC5zb3VyY2UubGVuZ3RoLCA0IC8qIEFUVFJJQlVURV9WQUxVRSAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb250ZW50ID0gcGFyc2VUZXh0RGF0YShjb250ZXh0LCBlbmRJbmRleCwgNCAvKiBBVFRSSUJVVEVfVkFMVUUgKi8pO1xyXG4gICAgICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gVW5xdW90ZWRcclxuICAgICAgICBjb25zdCBtYXRjaCA9IC9eW15cXHRcXHJcXG5cXGYgPl0rLy5leGVjKGNvbnRleHQuc291cmNlKTtcclxuICAgICAgICBpZiAoIW1hdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHVuZXhwZWN0ZWRDaGFycyA9IC9bXCInPD1gXS9nO1xyXG4gICAgICAgIGxldCBtO1xyXG4gICAgICAgIHdoaWxlICgobSA9IHVuZXhwZWN0ZWRDaGFycy5leGVjKG1hdGNoWzBdKSkpIHtcclxuICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDE4IC8qIFVORVhQRUNURURfQ0hBUkFDVEVSX0lOX1VOUVVPVEVEX0FUVFJJQlVURV9WQUxVRSAqLywgbS5pbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRlbnQgPSBwYXJzZVRleHREYXRhKGNvbnRleHQsIG1hdGNoWzBdLmxlbmd0aCwgNCAvKiBBVFRSSUJVVEVfVkFMVUUgKi8pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgY29udGVudCwgaXNRdW90ZWQsIGxvYzogZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0KSB9O1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlSW50ZXJwb2xhdGlvbihjb250ZXh0LCBtb2RlKSB7XHJcbiAgICBjb25zdCBbb3BlbiwgY2xvc2VdID0gY29udGV4dC5vcHRpb25zLmRlbGltaXRlcnM7XHJcbiAgICBjb25zdCBjbG9zZUluZGV4ID0gY29udGV4dC5zb3VyY2UuaW5kZXhPZihjbG9zZSwgb3Blbi5sZW5ndGgpO1xyXG4gICAgaWYgKGNsb3NlSW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDI1IC8qIFhfTUlTU0lOR19JTlRFUlBPTEFUSU9OX0VORCAqLyk7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xyXG4gICAgYWR2YW5jZUJ5KGNvbnRleHQsIG9wZW4ubGVuZ3RoKTtcclxuICAgIGNvbnN0IGlubmVyU3RhcnQgPSBnZXRDdXJzb3IoY29udGV4dCk7XHJcbiAgICBjb25zdCBpbm5lckVuZCA9IGdldEN1cnNvcihjb250ZXh0KTtcclxuICAgIGNvbnN0IHJhd0NvbnRlbnRMZW5ndGggPSBjbG9zZUluZGV4IC0gb3Blbi5sZW5ndGg7XHJcbiAgICBjb25zdCByYXdDb250ZW50ID0gY29udGV4dC5zb3VyY2Uuc2xpY2UoMCwgcmF3Q29udGVudExlbmd0aCk7XHJcbiAgICBjb25zdCBwcmVUcmltQ29udGVudCA9IHBhcnNlVGV4dERhdGEoY29udGV4dCwgcmF3Q29udGVudExlbmd0aCwgbW9kZSk7XHJcbiAgICBjb25zdCBjb250ZW50ID0gcHJlVHJpbUNvbnRlbnQudHJpbSgpO1xyXG4gICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBwcmVUcmltQ29udGVudC5pbmRleE9mKGNvbnRlbnQpO1xyXG4gICAgaWYgKHN0YXJ0T2Zmc2V0ID4gMCkge1xyXG4gICAgICAgIGFkdmFuY2VQb3NpdGlvbldpdGhNdXRhdGlvbihpbm5lclN0YXJ0LCByYXdDb250ZW50LCBzdGFydE9mZnNldCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBlbmRPZmZzZXQgPSByYXdDb250ZW50TGVuZ3RoIC0gKHByZVRyaW1Db250ZW50Lmxlbmd0aCAtIGNvbnRlbnQubGVuZ3RoIC0gc3RhcnRPZmZzZXQpO1xyXG4gICAgYWR2YW5jZVBvc2l0aW9uV2l0aE11dGF0aW9uKGlubmVyRW5kLCByYXdDb250ZW50LCBlbmRPZmZzZXQpO1xyXG4gICAgYWR2YW5jZUJ5KGNvbnRleHQsIGNsb3NlLmxlbmd0aCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDUgLyogSU5URVJQT0xBVElPTiAqLyxcclxuICAgICAgICBjb250ZW50OiB7XHJcbiAgICAgICAgICAgIHR5cGU6IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgICAgIGlzU3RhdGljOiBmYWxzZSxcclxuICAgICAgICAgICAgLy8gU2V0IGBpc0NvbnN0YW50YCB0byBmYWxzZSBieSBkZWZhdWx0IGFuZCB3aWxsIGRlY2lkZSBpbiB0cmFuc2Zvcm1FeHByZXNzaW9uXHJcbiAgICAgICAgICAgIGNvbnN0VHlwZTogMCAvKiBOT1RfQ09OU1RBTlQgKi8sXHJcbiAgICAgICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgICAgIGxvYzogZ2V0U2VsZWN0aW9uKGNvbnRleHQsIGlubmVyU3RhcnQsIGlubmVyRW5kKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbG9jOiBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQpXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlVGV4dChjb250ZXh0LCBtb2RlKSB7XHJcbiAgICBjb25zdCBlbmRUb2tlbnMgPSBtb2RlID09PSAzIC8qIENEQVRBICovID8gWyddXT4nXSA6IFsnPCcsIGNvbnRleHQub3B0aW9ucy5kZWxpbWl0ZXJzWzBdXTtcclxuICAgIGxldCBlbmRJbmRleCA9IGNvbnRleHQuc291cmNlLmxlbmd0aDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW5kVG9rZW5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSBjb250ZXh0LnNvdXJjZS5pbmRleE9mKGVuZFRva2Vuc1tpXSwgMSk7XHJcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSAmJiBlbmRJbmRleCA+IGluZGV4KSB7XHJcbiAgICAgICAgICAgIGVuZEluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3Qgc3RhcnQgPSBnZXRDdXJzb3IoY29udGV4dCk7XHJcbiAgICBjb25zdCBjb250ZW50ID0gcGFyc2VUZXh0RGF0YShjb250ZXh0LCBlbmRJbmRleCwgbW9kZSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDIgLyogVEVYVCAqLyxcclxuICAgICAgICBjb250ZW50LFxyXG4gICAgICAgIGxvYzogZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0KVxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogR2V0IHRleHQgZGF0YSB3aXRoIGEgZ2l2ZW4gbGVuZ3RoIGZyb20gdGhlIGN1cnJlbnQgbG9jYXRpb24uXHJcbiAqIFRoaXMgdHJhbnNsYXRlcyBIVE1MIGVudGl0aWVzIGluIHRoZSB0ZXh0IGRhdGEuXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZVRleHREYXRhKGNvbnRleHQsIGxlbmd0aCwgbW9kZSkge1xyXG4gICAgY29uc3QgcmF3VGV4dCA9IGNvbnRleHQuc291cmNlLnNsaWNlKDAsIGxlbmd0aCk7XHJcbiAgICBhZHZhbmNlQnkoY29udGV4dCwgbGVuZ3RoKTtcclxuICAgIGlmIChtb2RlID09PSAyIC8qIFJBV1RFWFQgKi8gfHxcclxuICAgICAgICBtb2RlID09PSAzIC8qIENEQVRBICovIHx8XHJcbiAgICAgICAgIXJhd1RleHQuaW5jbHVkZXMoJyYnKSkge1xyXG4gICAgICAgIHJldHVybiByYXdUZXh0O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gREFUQSBvciBSQ0RBVEEgY29udGFpbmluZyBcIiZcIlwiLiBFbnRpdHkgZGVjb2RpbmcgcmVxdWlyZWQuXHJcbiAgICAgICAgcmV0dXJuIGNvbnRleHQub3B0aW9ucy5kZWNvZGVFbnRpdGllcyhyYXdUZXh0LCBtb2RlID09PSA0IC8qIEFUVFJJQlVURV9WQUxVRSAqLyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q3Vyc29yKGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgY29sdW1uLCBsaW5lLCBvZmZzZXQgfSA9IGNvbnRleHQ7XHJcbiAgICByZXR1cm4geyBjb2x1bW4sIGxpbmUsIG9mZnNldCB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydCwgZW5kKSB7XHJcbiAgICBlbmQgPSBlbmQgfHwgZ2V0Q3Vyc29yKGNvbnRleHQpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzdGFydCxcclxuICAgICAgICBlbmQsXHJcbiAgICAgICAgc291cmNlOiBjb250ZXh0Lm9yaWdpbmFsU291cmNlLnNsaWNlKHN0YXJ0Lm9mZnNldCwgZW5kLm9mZnNldClcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gbGFzdCh4cykge1xyXG4gICAgcmV0dXJuIHhzW3hzLmxlbmd0aCAtIDFdO1xyXG59XHJcbmZ1bmN0aW9uIHN0YXJ0c1dpdGgoc291cmNlLCBzZWFyY2hTdHJpbmcpIHtcclxuICAgIHJldHVybiBzb3VyY2Uuc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcpO1xyXG59XHJcbmZ1bmN0aW9uIGFkdmFuY2VCeShjb250ZXh0LCBudW1iZXJPZkNoYXJhY3RlcnMpIHtcclxuICAgIGNvbnN0IHsgc291cmNlIH0gPSBjb250ZXh0O1xyXG4gICAgYWR2YW5jZVBvc2l0aW9uV2l0aE11dGF0aW9uKGNvbnRleHQsIHNvdXJjZSwgbnVtYmVyT2ZDaGFyYWN0ZXJzKTtcclxuICAgIGNvbnRleHQuc291cmNlID0gc291cmNlLnNsaWNlKG51bWJlck9mQ2hhcmFjdGVycyk7XHJcbn1cclxuZnVuY3Rpb24gYWR2YW5jZVNwYWNlcyhjb250ZXh0KSB7XHJcbiAgICBjb25zdCBtYXRjaCA9IC9eW1xcdFxcclxcblxcZiBdKy8uZXhlYyhjb250ZXh0LnNvdXJjZSk7XHJcbiAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgbWF0Y2hbMF0ubGVuZ3RoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXROZXdQb3NpdGlvbihjb250ZXh0LCBzdGFydCwgbnVtYmVyT2ZDaGFyYWN0ZXJzKSB7XHJcbiAgICByZXR1cm4gYWR2YW5jZVBvc2l0aW9uV2l0aENsb25lKHN0YXJ0LCBjb250ZXh0Lm9yaWdpbmFsU291cmNlLnNsaWNlKHN0YXJ0Lm9mZnNldCwgbnVtYmVyT2ZDaGFyYWN0ZXJzKSwgbnVtYmVyT2ZDaGFyYWN0ZXJzKTtcclxufVxyXG5mdW5jdGlvbiBlbWl0RXJyb3IoY29udGV4dCwgY29kZSwgb2Zmc2V0LCBsb2MgPSBnZXRDdXJzb3IoY29udGV4dCkpIHtcclxuICAgIGlmIChvZmZzZXQpIHtcclxuICAgICAgICBsb2Mub2Zmc2V0ICs9IG9mZnNldDtcclxuICAgICAgICBsb2MuY29sdW1uICs9IG9mZnNldDtcclxuICAgIH1cclxuICAgIGNvbnRleHQub3B0aW9ucy5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoY29kZSwge1xyXG4gICAgICAgIHN0YXJ0OiBsb2MsXHJcbiAgICAgICAgZW5kOiBsb2MsXHJcbiAgICAgICAgc291cmNlOiAnJ1xyXG4gICAgfSkpO1xyXG59XHJcbmZ1bmN0aW9uIGlzRW5kKGNvbnRleHQsIG1vZGUsIGFuY2VzdG9ycykge1xyXG4gICAgY29uc3QgcyA9IGNvbnRleHQuc291cmNlO1xyXG4gICAgc3dpdGNoIChtb2RlKSB7XHJcbiAgICAgICAgY2FzZSAwIC8qIERBVEEgKi86XHJcbiAgICAgICAgICAgIGlmIChzdGFydHNXaXRoKHMsICc8LycpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBwcm9iYWJseSBiYWQgcGVyZm9ybWFuY2VcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBhbmNlc3RvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRzV2l0aEVuZFRhZ09wZW4ocywgYW5jZXN0b3JzW2ldLnRhZykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMSAvKiBSQ0RBVEEgKi86XHJcbiAgICAgICAgY2FzZSAyIC8qIFJBV1RFWFQgKi86IHtcclxuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gbGFzdChhbmNlc3RvcnMpO1xyXG4gICAgICAgICAgICBpZiAocGFyZW50ICYmIHN0YXJ0c1dpdGhFbmRUYWdPcGVuKHMsIHBhcmVudC50YWcpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAzIC8qIENEQVRBICovOlxyXG4gICAgICAgICAgICBpZiAoc3RhcnRzV2l0aChzLCAnXV0+JykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICFzO1xyXG59XHJcbmZ1bmN0aW9uIHN0YXJ0c1dpdGhFbmRUYWdPcGVuKHNvdXJjZSwgdGFnKSB7XHJcbiAgICByZXR1cm4gKHN0YXJ0c1dpdGgoc291cmNlLCAnPC8nKSAmJlxyXG4gICAgICAgIHNvdXJjZS5zbGljZSgyLCAyICsgdGFnLmxlbmd0aCkudG9Mb3dlckNhc2UoKSA9PT0gdGFnLnRvTG93ZXJDYXNlKCkgJiZcclxuICAgICAgICAvW1xcdFxcclxcblxcZiAvPl0vLnRlc3Qoc291cmNlWzIgKyB0YWcubGVuZ3RoXSB8fCAnPicpKTtcclxufVxuXG5mdW5jdGlvbiBob2lzdFN0YXRpYyhyb290LCBjb250ZXh0KSB7XHJcbiAgICB3YWxrKHJvb3QsIGNvbnRleHQsIFxyXG4gICAgLy8gUm9vdCBub2RlIGlzIHVuZm9ydHVuYXRlbHkgbm9uLWhvaXN0YWJsZSBkdWUgdG8gcG90ZW50aWFsIHBhcmVudFxyXG4gICAgLy8gZmFsbHRocm91Z2ggYXR0cmlidXRlcy5cclxuICAgIGlzU2luZ2xlRWxlbWVudFJvb3Qocm9vdCwgcm9vdC5jaGlsZHJlblswXSkpO1xyXG59XHJcbmZ1bmN0aW9uIGlzU2luZ2xlRWxlbWVudFJvb3Qocm9vdCwgY2hpbGQpIHtcclxuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHJvb3Q7XHJcbiAgICByZXR1cm4gKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxyXG4gICAgICAgIGNoaWxkLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgICFpc1Nsb3RPdXRsZXQoY2hpbGQpKTtcclxufVxyXG5mdW5jdGlvbiB3YWxrKG5vZGUsIGNvbnRleHQsIGRvTm90SG9pc3ROb2RlID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IG5vZGU7XHJcbiAgICBjb25zdCBvcmlnaW5hbENvdW50ID0gY2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgbGV0IGhvaXN0ZWRDb3VudCA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAvLyBvbmx5IHBsYWluIGVsZW1lbnRzICYgdGV4dCBjYWxscyBhcmUgZWxpZ2libGUgZm9yIGhvaXN0aW5nLlxyXG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAgICAgY2hpbGQudGFnVHlwZSA9PT0gMCAvKiBFTEVNRU5UICovKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnN0YW50VHlwZSA9IGRvTm90SG9pc3ROb2RlXHJcbiAgICAgICAgICAgICAgICA/IDAgLyogTk9UX0NPTlNUQU5UICovXHJcbiAgICAgICAgICAgICAgICA6IGdldENvbnN0YW50VHlwZShjaGlsZCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmIChjb25zdGFudFR5cGUgPiAwIC8qIE5PVF9DT05TVEFOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnN0YW50VHlwZSA+PSAyIC8qIENBTl9IT0lTVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmNvZGVnZW5Ob2RlLnBhdGNoRmxhZyA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC0xIC8qIEhPSVNURUQgKi8gKyAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYCAvKiBIT0lTVEVEICovYCA6IGBgKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5jb2RlZ2VuTm9kZSA9IGNvbnRleHQuaG9pc3QoY2hpbGQuY29kZWdlbk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGhvaXN0ZWRDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gbm9kZSBtYXkgY29udGFpbiBkeW5hbWljIGNoaWxkcmVuLCBidXQgaXRzIHByb3BzIG1heSBiZSBlbGlnaWJsZSBmb3JcclxuICAgICAgICAgICAgICAgIC8vIGhvaXN0aW5nLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgY29kZWdlbk5vZGUgPSBjaGlsZC5jb2RlZ2VuTm9kZTtcclxuICAgICAgICAgICAgICAgIGlmIChjb2RlZ2VuTm9kZS50eXBlID09PSAxMyAvKiBWTk9ERV9DQUxMICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmxhZyA9IGdldFBhdGNoRmxhZyhjb2RlZ2VuTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCghZmxhZyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGFnID09PSA1MTIgLyogTkVFRF9QQVRDSCAqLyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGFnID09PSAxIC8qIFRFWFQgKi8pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEdlbmVyYXRlZFByb3BzQ29uc3RhbnRUeXBlKGNoaWxkLCBjb250ZXh0KSA+PVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMiAvKiBDQU5fSE9JU1QgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBnZXROb2RlUHJvcHMoY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVnZW5Ob2RlLnByb3BzID0gY29udGV4dC5ob2lzdChwcm9wcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGVnZW5Ob2RlLmR5bmFtaWNQcm9wcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlZ2VuTm9kZS5keW5hbWljUHJvcHMgPSBjb250ZXh0LmhvaXN0KGNvZGVnZW5Ob2RlLmR5bmFtaWNQcm9wcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNoaWxkLnR5cGUgPT09IDEyIC8qIFRFWFRfQ0FMTCAqLyAmJlxyXG4gICAgICAgICAgICBnZXRDb25zdGFudFR5cGUoY2hpbGQuY29udGVudCwgY29udGV4dCkgPj0gMiAvKiBDQU5fSE9JU1QgKi8pIHtcclxuICAgICAgICAgICAgY2hpbGQuY29kZWdlbk5vZGUgPSBjb250ZXh0LmhvaXN0KGNoaWxkLmNvZGVnZW5Ob2RlKTtcclxuICAgICAgICAgICAgaG9pc3RlZENvdW50Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHdhbGsgZnVydGhlclxyXG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgY29uc3QgaXNDb21wb25lbnQgPSBjaGlsZC50YWdUeXBlID09PSAxIC8qIENPTVBPTkVOVCAqLztcclxuICAgICAgICAgICAgaWYgKGlzQ29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNjb3Blcy52U2xvdCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdhbGsoY2hpbGQsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAoaXNDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuc2NvcGVzLnZTbG90LS07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2hpbGQudHlwZSA9PT0gMTEgLyogRk9SICovKSB7XHJcbiAgICAgICAgICAgIC8vIERvIG5vdCBob2lzdCB2LWZvciBzaW5nbGUgY2hpbGQgYmVjYXVzZSBpdCBoYXMgdG8gYmUgYSBibG9ja1xyXG4gICAgICAgICAgICB3YWxrKGNoaWxkLCBjb250ZXh0LCBjaGlsZC5jaGlsZHJlbi5sZW5ndGggPT09IDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaGlsZC50eXBlID09PSA5IC8qIElGICovKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGQuYnJhbmNoZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBob2lzdCB2LWlmIHNpbmdsZSBjaGlsZCBiZWNhdXNlIGl0IGhhcyB0byBiZSBhIGJsb2NrXHJcbiAgICAgICAgICAgICAgICB3YWxrKGNoaWxkLmJyYW5jaGVzW2ldLCBjb250ZXh0LCBjaGlsZC5icmFuY2hlc1tpXS5jaGlsZHJlbi5sZW5ndGggPT09IDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGhvaXN0ZWRDb3VudCAmJiBjb250ZXh0LnRyYW5zZm9ybUhvaXN0KSB7XHJcbiAgICAgICAgY29udGV4dC50cmFuc2Zvcm1Ib2lzdChjaGlsZHJlbiwgY29udGV4dCwgbm9kZSk7XHJcbiAgICB9XHJcbiAgICAvLyBhbGwgY2hpbGRyZW4gd2VyZSBob2lzdGVkIC0gdGhlIGVudGlyZSBjaGlsZHJlbiBhcnJheSBpcyBob2lzdGFibGUuXHJcbiAgICBpZiAoaG9pc3RlZENvdW50ICYmXHJcbiAgICAgICAgaG9pc3RlZENvdW50ID09PSBvcmlnaW5hbENvdW50ICYmXHJcbiAgICAgICAgbm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICBub2RlLnRhZ1R5cGUgPT09IDAgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgIG5vZGUuY29kZWdlbk5vZGUgJiZcclxuICAgICAgICBub2RlLmNvZGVnZW5Ob2RlLnR5cGUgPT09IDEzIC8qIFZOT0RFX0NBTEwgKi8gJiZcclxuICAgICAgICBpc0FycmF5KG5vZGUuY29kZWdlbk5vZGUuY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgbm9kZS5jb2RlZ2VuTm9kZS5jaGlsZHJlbiA9IGNvbnRleHQuaG9pc3QoY3JlYXRlQXJyYXlFeHByZXNzaW9uKG5vZGUuY29kZWdlbk5vZGUuY2hpbGRyZW4pKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRDb25zdGFudFR5cGUobm9kZSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBjb25zdGFudENhY2hlIH0gPSBjb250ZXh0O1xyXG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcclxuICAgICAgICBjYXNlIDEgLyogRUxFTUVOVCAqLzpcclxuICAgICAgICAgICAgaWYgKG5vZGUudGFnVHlwZSAhPT0gMCAvKiBFTEVNRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgY2FjaGVkID0gY29uc3RhbnRDYWNoZS5nZXQobm9kZSk7XHJcbiAgICAgICAgICAgIGlmIChjYWNoZWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjb2RlZ2VuTm9kZSA9IG5vZGUuY29kZWdlbk5vZGU7XHJcbiAgICAgICAgICAgIGlmIChjb2RlZ2VuTm9kZS50eXBlICE9PSAxMyAvKiBWTk9ERV9DQUxMICovKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNvZGVnZW5Ob2RlLmlzQmxvY2sgJiZcclxuICAgICAgICAgICAgICAgIG5vZGUudGFnICE9PSAnc3ZnJyAmJlxyXG4gICAgICAgICAgICAgICAgbm9kZS50YWcgIT09ICdmb3JlaWduT2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogTk9UX0NPTlNUQU5UICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGZsYWcgPSBnZXRQYXRjaEZsYWcoY29kZWdlbk5vZGUpO1xyXG4gICAgICAgICAgICBpZiAoIWZsYWcpIHtcclxuICAgICAgICAgICAgICAgIGxldCByZXR1cm5UeXBlID0gMyAvKiBDQU5fU1RSSU5HSUZZICovO1xyXG4gICAgICAgICAgICAgICAgLy8gRWxlbWVudCBpdHNlbGYgaGFzIG5vIHBhdGNoIGZsYWcuIEhvd2V2ZXIgd2Ugc3RpbGwgbmVlZCB0byBjaGVjazpcclxuICAgICAgICAgICAgICAgIC8vIDEuIEV2ZW4gZm9yIGEgbm9kZSB3aXRoIG5vIHBhdGNoIGZsYWcsIGl0IGlzIHBvc3NpYmxlIGZvciBpdCB0byBjb250YWluXHJcbiAgICAgICAgICAgICAgICAvLyBub24taG9pc3RhYmxlIGV4cHJlc3Npb25zIHRoYXQgcmVmZXJzIHRvIHNjb3BlIHZhcmlhYmxlcywgZS5nLiBjb21waWxlclxyXG4gICAgICAgICAgICAgICAgLy8gaW5qZWN0ZWQga2V5cyBvciBjYWNoZWQgZXZlbnQgaGFuZGxlcnMuIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIGFsd2F5c1xyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgdGhlIGNvZGVnZW5Ob2RlJ3MgcHJvcHMgdG8gYmUgc3VyZS5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGdlbmVyYXRlZFByb3BzVHlwZSA9IGdldEdlbmVyYXRlZFByb3BzQ29uc3RhbnRUeXBlKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRlZFByb3BzVHlwZSA9PT0gMCAvKiBOT1RfQ09OU1RBTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdGFudENhY2hlLnNldChub2RlLCAwIC8qIE5PVF9DT05TVEFOVCAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogTk9UX0NPTlNUQU5UICovO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRlZFByb3BzVHlwZSA8IHJldHVyblR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gZ2VuZXJhdGVkUHJvcHNUeXBlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gMi4gaXRzIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRUeXBlID0gZ2V0Q29uc3RhbnRUeXBlKG5vZGUuY2hpbGRyZW5baV0sIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZFR5cGUgPT09IDAgLyogTk9UX0NPTlNUQU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0YW50Q2FjaGUuc2V0KG5vZGUsIDAgLyogTk9UX0NPTlNUQU5UICovKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogTk9UX0NPTlNUQU5UICovO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRUeXBlIDwgcmV0dXJuVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gY2hpbGRUeXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIDMuIGlmIHRoZSB0eXBlIGlzIG5vdCBhbHJlYWR5IENBTl9TS0lQX1BBVENIIHdoaWNoIGlzIHRoZSBsb3dlc3Qgbm9uLTBcclxuICAgICAgICAgICAgICAgIC8vIHR5cGUsIGNoZWNrIGlmIGFueSBvZiB0aGUgcHJvcHMgY2FuIGNhdXNlIHRoZSB0eXBlIHRvIGJlIGxvd2VyZWRcclxuICAgICAgICAgICAgICAgIC8vIHdlIGNhbiBza2lwIGNhbl9wYXRjaCBiZWNhdXNlIGl0J3MgZ3VhcmFudGVlZCBieSB0aGUgYWJzZW5jZSBvZiBhXHJcbiAgICAgICAgICAgICAgICAvLyBwYXRjaEZsYWcuXHJcbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuVHlwZSA+IDEgLyogQ0FOX1NLSVBfUEFUQ0ggKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUucHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IG5vZGUucHJvcHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmIHAubmFtZSA9PT0gJ2JpbmQnICYmIHAuZXhwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHBUeXBlID0gZ2V0Q29uc3RhbnRUeXBlKHAuZXhwLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHBUeXBlID09PSAwIC8qIE5PVF9DT05TVEFOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0YW50Q2FjaGUuc2V0KG5vZGUsIDAgLyogTk9UX0NPTlNUQU5UICovKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwVHlwZSA8IHJldHVyblR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gZXhwVHlwZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG9ubHkgc3ZnL2ZvcmVpZ25PYmplY3QgY291bGQgYmUgYmxvY2sgaGVyZSwgaG93ZXZlciBpZiB0aGV5IGFyZVxyXG4gICAgICAgICAgICAgICAgLy8gc3RhdGljIHRoZW4gdGhleSBkb24ndCBuZWVkIHRvIGJlIGJsb2NrcyBzaW5jZSB0aGVyZSB3aWxsIGJlIG5vXHJcbiAgICAgICAgICAgICAgICAvLyBuZXN0ZWQgdXBkYXRlcy5cclxuICAgICAgICAgICAgICAgIGlmIChjb2RlZ2VuTm9kZS5pc0Jsb2NrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZW1vdmVIZWxwZXIoT1BFTl9CTE9DSyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZW1vdmVIZWxwZXIoZ2V0Vk5vZGVCbG9ja0hlbHBlcihjb250ZXh0LmluU1NSLCBjb2RlZ2VuTm9kZS5pc0NvbXBvbmVudCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZGVnZW5Ob2RlLmlzQmxvY2sgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmhlbHBlcihnZXRWTm9kZUhlbHBlcihjb250ZXh0LmluU1NSLCBjb2RlZ2VuTm9kZS5pc0NvbXBvbmVudCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3RhbnRDYWNoZS5zZXQobm9kZSwgcmV0dXJuVHlwZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVHlwZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0YW50Q2FjaGUuc2V0KG5vZGUsIDAgLyogTk9UX0NPTlNUQU5UICovKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIE5PVF9DT05TVEFOVCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgMiAvKiBURVhUICovOlxyXG4gICAgICAgIGNhc2UgMyAvKiBDT01NRU5UICovOlxyXG4gICAgICAgICAgICByZXR1cm4gMyAvKiBDQU5fU1RSSU5HSUZZICovO1xyXG4gICAgICAgIGNhc2UgOSAvKiBJRiAqLzpcclxuICAgICAgICBjYXNlIDExIC8qIEZPUiAqLzpcclxuICAgICAgICBjYXNlIDEwIC8qIElGX0JSQU5DSCAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIDAgLyogTk9UX0NPTlNUQU5UICovO1xyXG4gICAgICAgIGNhc2UgNSAvKiBJTlRFUlBPTEFUSU9OICovOlxyXG4gICAgICAgIGNhc2UgMTIgLyogVEVYVF9DQUxMICovOlxyXG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29uc3RhbnRUeXBlKG5vZGUuY29udGVudCwgY29udGV4dCk7XHJcbiAgICAgICAgY2FzZSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jb25zdFR5cGU7XHJcbiAgICAgICAgY2FzZSA4IC8qIENPTVBPVU5EX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIGxldCByZXR1cm5UeXBlID0gMyAvKiBDQU5fU1RSSU5HSUZZICovO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhjaGlsZCkgfHwgaXNTeW1ib2woY2hpbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZFR5cGUgPSBnZXRDb25zdGFudFR5cGUoY2hpbGQsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkVHlwZSA9PT0gMCAvKiBOT1RfQ09OU1RBTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGlsZFR5cGUgPCByZXR1cm5UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IGNoaWxkVHlwZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVHlwZTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSA7XHJcbiAgICAgICAgICAgIHJldHVybiAwIC8qIE5PVF9DT05TVEFOVCAqLztcclxuICAgIH1cclxufVxyXG5jb25zdCBhbGxvd0hvaXN0ZWRIZWxwZXJTZXQgPSBuZXcgU2V0KFtcclxuICAgIE5PUk1BTElaRV9DTEFTUyxcclxuICAgIE5PUk1BTElaRV9TVFlMRSxcclxuICAgIE5PUk1BTElaRV9QUk9QUyxcclxuICAgIEdVQVJEX1JFQUNUSVZFX1BST1BTXHJcbl0pO1xyXG5mdW5jdGlvbiBnZXRDb25zdGFudFR5cGVPZkhlbHBlckNhbGwodmFsdWUsIGNvbnRleHQpIHtcclxuICAgIGlmICh2YWx1ZS50eXBlID09PSAxNCAvKiBKU19DQUxMX0VYUFJFU1NJT04gKi8gJiZcclxuICAgICAgICAhaXNTdHJpbmcodmFsdWUuY2FsbGVlKSAmJlxyXG4gICAgICAgIGFsbG93SG9pc3RlZEhlbHBlclNldC5oYXModmFsdWUuY2FsbGVlKSkge1xyXG4gICAgICAgIGNvbnN0IGFyZyA9IHZhbHVlLmFyZ3VtZW50c1swXTtcclxuICAgICAgICBpZiAoYXJnLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldENvbnN0YW50VHlwZShhcmcsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhcmcudHlwZSA9PT0gMTQgLyogSlNfQ0FMTF9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgICAgIC8vIGluIHRoZSBjYXNlIG9mIG5lc3RlZCBoZWxwZXIgY2FsbCwgZS5nLiBgbm9ybWFsaXplUHJvcHMoZ3VhcmRSZWFjdGl2ZVByb3BzKGV4cCkpYFxyXG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29uc3RhbnRUeXBlT2ZIZWxwZXJDYWxsKGFyZywgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIDAgLyogTk9UX0NPTlNUQU5UICovO1xyXG59XHJcbmZ1bmN0aW9uIGdldEdlbmVyYXRlZFByb3BzQ29uc3RhbnRUeXBlKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGxldCByZXR1cm5UeXBlID0gMyAvKiBDQU5fU1RSSU5HSUZZICovO1xyXG4gICAgY29uc3QgcHJvcHMgPSBnZXROb2RlUHJvcHMobm9kZSk7XHJcbiAgICBpZiAocHJvcHMgJiYgcHJvcHMudHlwZSA9PT0gMTUgLyogSlNfT0JKRUNUX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICBjb25zdCB7IHByb3BlcnRpZXMgfSA9IHByb3BzO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IHByb3BlcnRpZXNbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IGtleVR5cGUgPSBnZXRDb25zdGFudFR5cGUoa2V5LCBjb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKGtleVR5cGUgPT09IDAgLyogTk9UX0NPTlNUQU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5VHlwZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoa2V5VHlwZSA8IHJldHVyblR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBrZXlUeXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCB2YWx1ZVR5cGU7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZVR5cGUgPSBnZXRDb25zdGFudFR5cGUodmFsdWUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLnR5cGUgPT09IDE0IC8qIEpTX0NBTExfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgICAgICAgICAgLy8gc29tZSBoZWxwZXIgY2FsbHMgY2FuIGJlIGhvaXN0ZWQsXHJcbiAgICAgICAgICAgICAgICAvLyBzdWNoIGFzIHRoZSBgbm9ybWFsaXplUHJvcHNgIGdlbmVyYXRlZCBieSB0aGUgY29tcGlsZXIgZm9yIHByZS1ub3JtYWxpemUgY2xhc3MsXHJcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGlzIGNhc2Ugd2UgbmVlZCB0byByZXNwZWN0IHRoZSBDb25zdGFudFR5cGUgb2YgdGhlIGhlbHBlcidzIGFyZ3VtZW50c1xyXG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlID0gZ2V0Q29uc3RhbnRUeXBlT2ZIZWxwZXJDYWxsKHZhbHVlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlVHlwZSA9IDAgLyogTk9UX0NPTlNUQU5UICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZVR5cGUgPT09IDAgLyogTk9UX0NPTlNUQU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVUeXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZVR5cGUgPCByZXR1cm5UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gdmFsdWVUeXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldHVyblR5cGU7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Tm9kZVByb3BzKG5vZGUpIHtcclxuICAgIGNvbnN0IGNvZGVnZW5Ob2RlID0gbm9kZS5jb2RlZ2VuTm9kZTtcclxuICAgIGlmIChjb2RlZ2VuTm9kZS50eXBlID09PSAxMyAvKiBWTk9ERV9DQUxMICovKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvZGVnZW5Ob2RlLnByb3BzO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFBhdGNoRmxhZyhub2RlKSB7XHJcbiAgICBjb25zdCBmbGFnID0gbm9kZS5wYXRjaEZsYWc7XHJcbiAgICByZXR1cm4gZmxhZyA/IHBhcnNlSW50KGZsYWcsIDEwKSA6IHVuZGVmaW5lZDtcclxufVxuXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2Zvcm1Db250ZXh0KHJvb3QsIHsgZmlsZW5hbWUgPSAnJywgcHJlZml4SWRlbnRpZmllcnMgPSBmYWxzZSwgaG9pc3RTdGF0aWMgPSBmYWxzZSwgY2FjaGVIYW5kbGVycyA9IGZhbHNlLCBub2RlVHJhbnNmb3JtcyA9IFtdLCBkaXJlY3RpdmVUcmFuc2Zvcm1zID0ge30sIHRyYW5zZm9ybUhvaXN0ID0gbnVsbCwgaXNCdWlsdEluQ29tcG9uZW50ID0gTk9PUCwgaXNDdXN0b21FbGVtZW50ID0gTk9PUCwgZXhwcmVzc2lvblBsdWdpbnMgPSBbXSwgc2NvcGVJZCA9IG51bGwsIHNsb3R0ZWQgPSB0cnVlLCBzc3IgPSBmYWxzZSwgaW5TU1IgPSBmYWxzZSwgc3NyQ3NzVmFycyA9IGBgLCBiaW5kaW5nTWV0YWRhdGEgPSBFTVBUWV9PQkosIGlubGluZSA9IGZhbHNlLCBpc1RTID0gZmFsc2UsIG9uRXJyb3IgPSBkZWZhdWx0T25FcnJvciwgb25XYXJuID0gZGVmYXVsdE9uV2FybiwgY29tcGF0Q29uZmlnIH0pIHtcclxuICAgIGNvbnN0IG5hbWVNYXRjaCA9IGZpbGVuYW1lLnJlcGxhY2UoL1xcPy4qJC8sICcnKS5tYXRjaCgvKFteL1xcXFxdKylcXC5cXHcrJC8pO1xyXG4gICAgY29uc3QgY29udGV4dCA9IHtcclxuICAgICAgICAvLyBvcHRpb25zXHJcbiAgICAgICAgc2VsZk5hbWU6IG5hbWVNYXRjaCAmJiBjYXBpdGFsaXplKGNhbWVsaXplJDEobmFtZU1hdGNoWzFdKSksXHJcbiAgICAgICAgcHJlZml4SWRlbnRpZmllcnMsXHJcbiAgICAgICAgaG9pc3RTdGF0aWMsXHJcbiAgICAgICAgY2FjaGVIYW5kbGVycyxcclxuICAgICAgICBub2RlVHJhbnNmb3JtcyxcclxuICAgICAgICBkaXJlY3RpdmVUcmFuc2Zvcm1zLFxyXG4gICAgICAgIHRyYW5zZm9ybUhvaXN0LFxyXG4gICAgICAgIGlzQnVpbHRJbkNvbXBvbmVudCxcclxuICAgICAgICBpc0N1c3RvbUVsZW1lbnQsXHJcbiAgICAgICAgZXhwcmVzc2lvblBsdWdpbnMsXHJcbiAgICAgICAgc2NvcGVJZCxcclxuICAgICAgICBzbG90dGVkLFxyXG4gICAgICAgIHNzcixcclxuICAgICAgICBpblNTUixcclxuICAgICAgICBzc3JDc3NWYXJzLFxyXG4gICAgICAgIGJpbmRpbmdNZXRhZGF0YSxcclxuICAgICAgICBpbmxpbmUsXHJcbiAgICAgICAgaXNUUyxcclxuICAgICAgICBvbkVycm9yLFxyXG4gICAgICAgIG9uV2FybixcclxuICAgICAgICBjb21wYXRDb25maWcsXHJcbiAgICAgICAgLy8gc3RhdGVcclxuICAgICAgICByb290LFxyXG4gICAgICAgIGhlbHBlcnM6IG5ldyBNYXAoKSxcclxuICAgICAgICBjb21wb25lbnRzOiBuZXcgU2V0KCksXHJcbiAgICAgICAgZGlyZWN0aXZlczogbmV3IFNldCgpLFxyXG4gICAgICAgIGhvaXN0czogW10sXHJcbiAgICAgICAgaW1wb3J0czogW10sXHJcbiAgICAgICAgY29uc3RhbnRDYWNoZTogbmV3IE1hcCgpLFxyXG4gICAgICAgIHRlbXBzOiAwLFxyXG4gICAgICAgIGNhY2hlZDogMCxcclxuICAgICAgICBpZGVudGlmaWVyczogT2JqZWN0LmNyZWF0ZShudWxsKSxcclxuICAgICAgICBzY29wZXM6IHtcclxuICAgICAgICAgICAgdkZvcjogMCxcclxuICAgICAgICAgICAgdlNsb3Q6IDAsXHJcbiAgICAgICAgICAgIHZQcmU6IDAsXHJcbiAgICAgICAgICAgIHZPbmNlOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwYXJlbnQ6IG51bGwsXHJcbiAgICAgICAgY3VycmVudE5vZGU6IHJvb3QsXHJcbiAgICAgICAgY2hpbGRJbmRleDogMCxcclxuICAgICAgICBpblZPbmNlOiBmYWxzZSxcclxuICAgICAgICAvLyBtZXRob2RzXHJcbiAgICAgICAgaGVscGVyKG5hbWUpIHtcclxuICAgICAgICAgICAgY29uc3QgY291bnQgPSBjb250ZXh0LmhlbHBlcnMuZ2V0KG5hbWUpIHx8IDA7XHJcbiAgICAgICAgICAgIGNvbnRleHQuaGVscGVycy5zZXQobmFtZSwgY291bnQgKyAxKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZW1vdmVIZWxwZXIobmFtZSkge1xyXG4gICAgICAgICAgICBjb25zdCBjb3VudCA9IGNvbnRleHQuaGVscGVycy5nZXQobmFtZSk7XHJcbiAgICAgICAgICAgIGlmIChjb3VudCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudENvdW50ID0gY291bnQgLSAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50Q291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmhlbHBlcnMuZGVsZXRlKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5oZWxwZXJzLnNldChuYW1lLCBjdXJyZW50Q291bnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoZWxwZXJTdHJpbmcobmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYF8ke2hlbHBlck5hbWVNYXBbY29udGV4dC5oZWxwZXIobmFtZSldfWA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZXBsYWNlTm9kZShub2RlKSB7XHJcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQuY3VycmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vZGUgYmVpbmcgcmVwbGFjZWQgaXMgYWxyZWFkeSByZW1vdmVkLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0LnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlcGxhY2Ugcm9vdCBub2RlLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRleHQucGFyZW50LmNoaWxkcmVuW2NvbnRleHQuY2hpbGRJbmRleF0gPSBjb250ZXh0LmN1cnJlbnROb2RlID0gbm9kZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlbW92ZU5vZGUobm9kZSkge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFjb250ZXh0LnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVtb3ZlIHJvb3Qgbm9kZS5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBsaXN0ID0gY29udGV4dC5wYXJlbnQuY2hpbGRyZW47XHJcbiAgICAgICAgICAgIGNvbnN0IHJlbW92YWxJbmRleCA9IG5vZGVcclxuICAgICAgICAgICAgICAgID8gbGlzdC5pbmRleE9mKG5vZGUpXHJcbiAgICAgICAgICAgICAgICA6IGNvbnRleHQuY3VycmVudE5vZGVcclxuICAgICAgICAgICAgICAgICAgICA/IGNvbnRleHQuY2hpbGRJbmRleFxyXG4gICAgICAgICAgICAgICAgICAgIDogLTE7XHJcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHJlbW92YWxJbmRleCA8IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbm9kZSBiZWluZyByZW1vdmVkIGlzIG5vdCBhIGNoaWxkIG9mIGN1cnJlbnQgcGFyZW50YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUgPT09IGNvbnRleHQuY3VycmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgbm9kZSByZW1vdmVkXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmN1cnJlbnROb2RlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQub25Ob2RlUmVtb3ZlZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gc2libGluZyBub2RlIHJlbW92ZWRcclxuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LmNoaWxkSW5kZXggPiByZW1vdmFsSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmNoaWxkSW5kZXgtLTtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uTm9kZVJlbW92ZWQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250ZXh0LnBhcmVudC5jaGlsZHJlbi5zcGxpY2UocmVtb3ZhbEluZGV4LCAxKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uTm9kZVJlbW92ZWQ6ICgpID0+IHsgfSxcclxuICAgICAgICBhZGRJZGVudGlmaWVycyhleHApIHtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlbW92ZUlkZW50aWZpZXJzKGV4cCkge1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaG9pc3QoZXhwKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1N0cmluZyhleHApKVxyXG4gICAgICAgICAgICAgICAgZXhwID0gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihleHApO1xyXG4gICAgICAgICAgICBjb250ZXh0LmhvaXN0cy5wdXNoKGV4cCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGBfaG9pc3RlZF8ke2NvbnRleHQuaG9pc3RzLmxlbmd0aH1gLCBmYWxzZSwgZXhwLmxvYywgMiAvKiBDQU5fSE9JU1QgKi8pO1xyXG4gICAgICAgICAgICBpZGVudGlmaWVyLmhvaXN0ZWQgPSBleHA7XHJcbiAgICAgICAgICAgIHJldHVybiBpZGVudGlmaWVyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2FjaGUoZXhwLCBpc1ZOb2RlID0gZmFsc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNhY2hlRXhwcmVzc2lvbihjb250ZXh0LmNhY2hlZCsrLCBleHAsIGlzVk5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB7XHJcbiAgICAgICAgY29udGV4dC5maWx0ZXJzID0gbmV3IFNldCgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbnRleHQ7XHJcbn1cclxuZnVuY3Rpb24gdHJhbnNmb3JtKHJvb3QsIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVUcmFuc2Zvcm1Db250ZXh0KHJvb3QsIG9wdGlvbnMpO1xyXG4gICAgdHJhdmVyc2VOb2RlKHJvb3QsIGNvbnRleHQpO1xyXG4gICAgaWYgKG9wdGlvbnMuaG9pc3RTdGF0aWMpIHtcclxuICAgICAgICBob2lzdFN0YXRpYyhyb290LCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGlmICghb3B0aW9ucy5zc3IpIHtcclxuICAgICAgICBjcmVhdGVSb290Q29kZWdlbihyb290LCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIC8vIGZpbmFsaXplIG1ldGEgaW5mb3JtYXRpb25cclxuICAgIHJvb3QuaGVscGVycyA9IFsuLi5jb250ZXh0LmhlbHBlcnMua2V5cygpXTtcclxuICAgIHJvb3QuY29tcG9uZW50cyA9IFsuLi5jb250ZXh0LmNvbXBvbmVudHNdO1xyXG4gICAgcm9vdC5kaXJlY3RpdmVzID0gWy4uLmNvbnRleHQuZGlyZWN0aXZlc107XHJcbiAgICByb290LmltcG9ydHMgPSBjb250ZXh0LmltcG9ydHM7XHJcbiAgICByb290LmhvaXN0cyA9IGNvbnRleHQuaG9pc3RzO1xyXG4gICAgcm9vdC50ZW1wcyA9IGNvbnRleHQudGVtcHM7XHJcbiAgICByb290LmNhY2hlZCA9IGNvbnRleHQuY2FjaGVkO1xyXG4gICAge1xyXG4gICAgICAgIHJvb3QuZmlsdGVycyA9IFsuLi5jb250ZXh0LmZpbHRlcnNdO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVJvb3RDb2RlZ2VuKHJvb3QsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgaGVscGVyIH0gPSBjb250ZXh0O1xyXG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gcm9vdDtcclxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuWzBdO1xyXG4gICAgICAgIC8vIGlmIHRoZSBzaW5nbGUgY2hpbGQgaXMgYW4gZWxlbWVudCwgdHVybiBpdCBpbnRvIGEgYmxvY2suXHJcbiAgICAgICAgaWYgKGlzU2luZ2xlRWxlbWVudFJvb3Qocm9vdCwgY2hpbGQpICYmIGNoaWxkLmNvZGVnZW5Ob2RlKSB7XHJcbiAgICAgICAgICAgIC8vIHNpbmdsZSBlbGVtZW50IHJvb3QgaXMgbmV2ZXIgaG9pc3RlZCBzbyBjb2RlZ2VuTm9kZSB3aWxsIG5ldmVyIGJlXHJcbiAgICAgICAgICAgIC8vIFNpbXBsZUV4cHJlc3Npb25Ob2RlXHJcbiAgICAgICAgICAgIGNvbnN0IGNvZGVnZW5Ob2RlID0gY2hpbGQuY29kZWdlbk5vZGU7XHJcbiAgICAgICAgICAgIGlmIChjb2RlZ2VuTm9kZS50eXBlID09PSAxMyAvKiBWTk9ERV9DQUxMICovKSB7XHJcbiAgICAgICAgICAgICAgICBtYWtlQmxvY2soY29kZWdlbk5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJvb3QuY29kZWdlbk5vZGUgPSBjb2RlZ2VuTm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIC0gc2luZ2xlIDxzbG90Lz4sIElmTm9kZSwgRm9yTm9kZTogYWxyZWFkeSBibG9ja3MuXHJcbiAgICAgICAgICAgIC8vIC0gc2luZ2xlIHRleHQgbm9kZTogYWx3YXlzIHBhdGNoZWQuXHJcbiAgICAgICAgICAgIC8vIHJvb3QgY29kZWdlbiBmYWxscyB0aHJvdWdoIHZpYSBnZW5Ob2RlKClcclxuICAgICAgICAgICAgcm9vdC5jb2RlZ2VuTm9kZSA9IGNoaWxkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAvLyByb290IGhhcyBtdWx0aXBsZSBub2RlcyAtIHJldHVybiBhIGZyYWdtZW50IGJsb2NrLlxyXG4gICAgICAgIGxldCBwYXRjaEZsYWcgPSA2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi87XHJcbiAgICAgICAgbGV0IHBhdGNoRmxhZ1RleHQgPSBQYXRjaEZsYWdOYW1lc1s2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi9dO1xyXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBmcmFnbWVudCBhY3R1YWxseSBjb250YWlucyBhIHNpbmdsZSB2YWxpZCBjaGlsZCB3aXRoXHJcbiAgICAgICAgLy8gdGhlIHJlc3QgYmVpbmcgY29tbWVudHNcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgIGNoaWxkcmVuLmZpbHRlcihjID0+IGMudHlwZSAhPT0gMyAvKiBDT01NRU5UICovKS5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgcGF0Y2hGbGFnIHw9IDIwNDggLyogREVWX1JPT1RfRlJBR01FTlQgKi87XHJcbiAgICAgICAgICAgIHBhdGNoRmxhZ1RleHQgKz0gYCwgJHtQYXRjaEZsYWdOYW1lc1syMDQ4IC8qIERFVl9ST09UX0ZSQUdNRU5UICovXX1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICByb290LmNvZGVnZW5Ob2RlID0gY3JlYXRlVk5vZGVDYWxsKGNvbnRleHQsIGhlbHBlcihGUkFHTUVOVCksIHVuZGVmaW5lZCwgcm9vdC5jaGlsZHJlbiwgcGF0Y2hGbGFnICsgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGAgLyogJHtwYXRjaEZsYWdUZXh0fSAqL2AgOiBgYCksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlLCB1bmRlZmluZWQsIGZhbHNlIC8qIGlzQ29tcG9uZW50ICovKTtcclxuICAgIH1cclxuICAgIGVsc2UgO1xyXG59XHJcbmZ1bmN0aW9uIHRyYXZlcnNlQ2hpbGRyZW4ocGFyZW50LCBjb250ZXh0KSB7XHJcbiAgICBsZXQgaSA9IDA7XHJcbiAgICBjb25zdCBub2RlUmVtb3ZlZCA9ICgpID0+IHtcclxuICAgICAgICBpLS07XHJcbiAgICB9O1xyXG4gICAgZm9yICg7IGkgPCBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjaGlsZCA9IHBhcmVudC5jaGlsZHJlbltpXTtcclxuICAgICAgICBpZiAoaXNTdHJpbmcoY2hpbGQpKVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBjb250ZXh0LnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICBjb250ZXh0LmNoaWxkSW5kZXggPSBpO1xyXG4gICAgICAgIGNvbnRleHQub25Ob2RlUmVtb3ZlZCA9IG5vZGVSZW1vdmVkO1xyXG4gICAgICAgIHRyYXZlcnNlTm9kZShjaGlsZCwgY29udGV4dCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdHJhdmVyc2VOb2RlKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnRleHQuY3VycmVudE5vZGUgPSBub2RlO1xyXG4gICAgLy8gYXBwbHkgdHJhbnNmb3JtIHBsdWdpbnNcclxuICAgIGNvbnN0IHsgbm9kZVRyYW5zZm9ybXMgfSA9IGNvbnRleHQ7XHJcbiAgICBjb25zdCBleGl0Rm5zID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qgb25FeGl0ID0gbm9kZVRyYW5zZm9ybXNbaV0obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgaWYgKG9uRXhpdCkge1xyXG4gICAgICAgICAgICBpZiAoaXNBcnJheShvbkV4aXQpKSB7XHJcbiAgICAgICAgICAgICAgICBleGl0Rm5zLnB1c2goLi4ub25FeGl0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGV4aXRGbnMucHVzaChvbkV4aXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghY29udGV4dC5jdXJyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAvLyBub2RlIHdhcyByZW1vdmVkXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIG5vZGUgbWF5IGhhdmUgYmVlbiByZXBsYWNlZFxyXG4gICAgICAgICAgICBub2RlID0gY29udGV4dC5jdXJyZW50Tm9kZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xyXG4gICAgICAgIGNhc2UgMyAvKiBDT01NRU5UICovOlxyXG4gICAgICAgICAgICBpZiAoIWNvbnRleHQuc3NyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpbmplY3QgaW1wb3J0IGZvciB0aGUgQ29tbWVudCBzeW1ib2wsIHdoaWNoIGlzIG5lZWRlZCBmb3IgY3JlYXRpbmdcclxuICAgICAgICAgICAgICAgIC8vIGNvbW1lbnQgbm9kZXMgd2l0aCBgY3JlYXRlVk5vZGVgXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmhlbHBlcihDUkVBVEVfQ09NTUVOVCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSA1IC8qIElOVEVSUE9MQVRJT04gKi86XHJcbiAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gdHJhdmVyc2UsIGJ1dCB3ZSBuZWVkIHRvIGluamVjdCB0b1N0cmluZyBoZWxwZXJcclxuICAgICAgICAgICAgaWYgKCFjb250ZXh0LnNzcikge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5oZWxwZXIoVE9fRElTUExBWV9TVFJJTkcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIC8vIGZvciBjb250YWluZXIgdHlwZXMsIGZ1cnRoZXIgdHJhdmVyc2UgZG93bndhcmRzXHJcbiAgICAgICAgY2FzZSA5IC8qIElGICovOlxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuYnJhbmNoZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRyYXZlcnNlTm9kZShub2RlLmJyYW5jaGVzW2ldLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDEwIC8qIElGX0JSQU5DSCAqLzpcclxuICAgICAgICBjYXNlIDExIC8qIEZPUiAqLzpcclxuICAgICAgICBjYXNlIDEgLyogRUxFTUVOVCAqLzpcclxuICAgICAgICBjYXNlIDAgLyogUk9PVCAqLzpcclxuICAgICAgICAgICAgdHJhdmVyc2VDaGlsZHJlbihub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICAvLyBleGl0IHRyYW5zZm9ybXNcclxuICAgIGNvbnRleHQuY3VycmVudE5vZGUgPSBub2RlO1xyXG4gICAgbGV0IGkgPSBleGl0Rm5zLmxlbmd0aDtcclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICBleGl0Rm5zW2ldKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlU3RydWN0dXJhbERpcmVjdGl2ZVRyYW5zZm9ybShuYW1lLCBmbikge1xyXG4gICAgY29uc3QgbWF0Y2hlcyA9IGlzU3RyaW5nKG5hbWUpXHJcbiAgICAgICAgPyAobikgPT4gbiA9PT0gbmFtZVxyXG4gICAgICAgIDogKG4pID0+IG5hbWUudGVzdChuKTtcclxuICAgIHJldHVybiAobm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLykge1xyXG4gICAgICAgICAgICBjb25zdCB7IHByb3BzIH0gPSBub2RlO1xyXG4gICAgICAgICAgICAvLyBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZSB0cmFuc2Zvcm1zIGFyZSBub3QgY29uY2VybmVkIHdpdGggc2xvdHNcclxuICAgICAgICAgICAgLy8gYXMgdGhleSBhcmUgaGFuZGxlZCBzZXBhcmF0ZWx5IGluIHZTbG90LnRzXHJcbiAgICAgICAgICAgIGlmIChub2RlLnRhZ1R5cGUgPT09IDMgLyogVEVNUExBVEUgKi8gJiYgcHJvcHMuc29tZShpc1ZTbG90KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGV4aXRGbnMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcCA9IHByb3BzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb3AudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8gJiYgbWF0Y2hlcyhwcm9wLm5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RydWN0dXJhbCBkaXJlY3RpdmVzIGFyZSByZW1vdmVkIHRvIGF2b2lkIGluZmluaXRlIHJlY3Vyc2lvblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsc28gd2UgcmVtb3ZlIHRoZW0gKmJlZm9yZSogYXBwbHlpbmcgc28gdGhhdCBpdCBjYW4gZnVydGhlclxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyYXZlcnNlIGl0c2VsZiBpbiBjYXNlIGl0IG1vdmVzIHRoZSBub2RlIGFyb3VuZFxyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBpLS07XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb25FeGl0ID0gZm4obm9kZSwgcHJvcCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uRXhpdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhpdEZucy5wdXNoKG9uRXhpdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGV4aXRGbnM7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxuXG5jb25zdCBQVVJFX0FOTk9UQVRJT04gPSBgLyojX19QVVJFX18qL2A7XHJcbmZ1bmN0aW9uIGNyZWF0ZUNvZGVnZW5Db250ZXh0KGFzdCwgeyBtb2RlID0gJ2Z1bmN0aW9uJywgcHJlZml4SWRlbnRpZmllcnMgPSBtb2RlID09PSAnbW9kdWxlJywgc291cmNlTWFwID0gZmFsc2UsIGZpbGVuYW1lID0gYHRlbXBsYXRlLnZ1ZS5odG1sYCwgc2NvcGVJZCA9IG51bGwsIG9wdGltaXplSW1wb3J0cyA9IGZhbHNlLCBydW50aW1lR2xvYmFsTmFtZSA9IGBWdWVgLCBydW50aW1lTW9kdWxlTmFtZSA9IGB2dWVgLCBzc3JSdW50aW1lTW9kdWxlTmFtZSA9ICd2dWUvc2VydmVyLXJlbmRlcmVyJywgc3NyID0gZmFsc2UsIGlzVFMgPSBmYWxzZSwgaW5TU1IgPSBmYWxzZSB9KSB7XHJcbiAgICBjb25zdCBjb250ZXh0ID0ge1xyXG4gICAgICAgIG1vZGUsXHJcbiAgICAgICAgcHJlZml4SWRlbnRpZmllcnMsXHJcbiAgICAgICAgc291cmNlTWFwLFxyXG4gICAgICAgIGZpbGVuYW1lLFxyXG4gICAgICAgIHNjb3BlSWQsXHJcbiAgICAgICAgb3B0aW1pemVJbXBvcnRzLFxyXG4gICAgICAgIHJ1bnRpbWVHbG9iYWxOYW1lLFxyXG4gICAgICAgIHJ1bnRpbWVNb2R1bGVOYW1lLFxyXG4gICAgICAgIHNzclJ1bnRpbWVNb2R1bGVOYW1lLFxyXG4gICAgICAgIHNzcixcclxuICAgICAgICBpc1RTLFxyXG4gICAgICAgIGluU1NSLFxyXG4gICAgICAgIHNvdXJjZTogYXN0LmxvYy5zb3VyY2UsXHJcbiAgICAgICAgY29kZTogYGAsXHJcbiAgICAgICAgY29sdW1uOiAxLFxyXG4gICAgICAgIGxpbmU6IDEsXHJcbiAgICAgICAgb2Zmc2V0OiAwLFxyXG4gICAgICAgIGluZGVudExldmVsOiAwLFxyXG4gICAgICAgIHB1cmU6IGZhbHNlLFxyXG4gICAgICAgIG1hcDogdW5kZWZpbmVkLFxyXG4gICAgICAgIGhlbHBlcihrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGBfJHtoZWxwZXJOYW1lTWFwW2tleV19YDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHB1c2goY29kZSwgbm9kZSkge1xyXG4gICAgICAgICAgICBjb250ZXh0LmNvZGUgKz0gY29kZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGluZGVudCgpIHtcclxuICAgICAgICAgICAgbmV3bGluZSgrK2NvbnRleHQuaW5kZW50TGV2ZWwpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVpbmRlbnQod2l0aG91dE5ld0xpbmUgPSBmYWxzZSkge1xyXG4gICAgICAgICAgICBpZiAod2l0aG91dE5ld0xpbmUpIHtcclxuICAgICAgICAgICAgICAgIC0tY29udGV4dC5pbmRlbnRMZXZlbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5ld2xpbmUoLS1jb250ZXh0LmluZGVudExldmVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbmV3bGluZSgpIHtcclxuICAgICAgICAgICAgbmV3bGluZShjb250ZXh0LmluZGVudExldmVsKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZnVuY3Rpb24gbmV3bGluZShuKSB7XHJcbiAgICAgICAgY29udGV4dC5wdXNoKCdcXG4nICsgYCAgYC5yZXBlYXQobikpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbnRleHQ7XHJcbn1cclxuZnVuY3Rpb24gZ2VuZXJhdGUoYXN0LCBvcHRpb25zID0ge30pIHtcclxuICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVDb2RlZ2VuQ29udGV4dChhc3QsIG9wdGlvbnMpO1xyXG4gICAgaWYgKG9wdGlvbnMub25Db250ZXh0Q3JlYXRlZClcclxuICAgICAgICBvcHRpb25zLm9uQ29udGV4dENyZWF0ZWQoY29udGV4dCk7XHJcbiAgICBjb25zdCB7IG1vZGUsIHB1c2gsIHByZWZpeElkZW50aWZpZXJzLCBpbmRlbnQsIGRlaW5kZW50LCBuZXdsaW5lLCBzY29wZUlkLCBzc3IgfSA9IGNvbnRleHQ7XHJcbiAgICBjb25zdCBoYXNIZWxwZXJzID0gYXN0LmhlbHBlcnMubGVuZ3RoID4gMDtcclxuICAgIGNvbnN0IHVzZVdpdGhCbG9jayA9ICFwcmVmaXhJZGVudGlmaWVycyAmJiBtb2RlICE9PSAnbW9kdWxlJztcclxuICAgIC8vIHByZWFtYmxlc1xyXG4gICAgLy8gaW4gc2V0dXAoKSBpbmxpbmUgbW9kZSwgdGhlIHByZWFtYmxlIGlzIGdlbmVyYXRlZCBpbiBhIHN1YiBjb250ZXh0XHJcbiAgICAvLyBhbmQgcmV0dXJuZWQgc2VwYXJhdGVseS5cclxuICAgIGNvbnN0IHByZWFtYmxlQ29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICB7XHJcbiAgICAgICAgZ2VuRnVuY3Rpb25QcmVhbWJsZShhc3QsIHByZWFtYmxlQ29udGV4dCk7XHJcbiAgICB9XHJcbiAgICAvLyBlbnRlciByZW5kZXIgZnVuY3Rpb25cclxuICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IHNzciA/IGBzc3JSZW5kZXJgIDogYHJlbmRlcmA7XHJcbiAgICBjb25zdCBhcmdzID0gc3NyID8gWydfY3R4JywgJ19wdXNoJywgJ19wYXJlbnQnLCAnX2F0dHJzJ10gOiBbJ19jdHgnLCAnX2NhY2hlJ107XHJcbiAgICBjb25zdCBzaWduYXR1cmUgPSBhcmdzLmpvaW4oJywgJyk7XHJcbiAgICB7XHJcbiAgICAgICAgcHVzaChgZnVuY3Rpb24gJHtmdW5jdGlvbk5hbWV9KCR7c2lnbmF0dXJlfSkge2ApO1xyXG4gICAgfVxyXG4gICAgaW5kZW50KCk7XHJcbiAgICBpZiAodXNlV2l0aEJsb2NrKSB7XHJcbiAgICAgICAgcHVzaChgd2l0aCAoX2N0eCkge2ApO1xyXG4gICAgICAgIGluZGVudCgpO1xyXG4gICAgICAgIC8vIGZ1bmN0aW9uIG1vZGUgY29uc3QgZGVjbGFyYXRpb25zIHNob3VsZCBiZSBpbnNpZGUgd2l0aCBibG9ja1xyXG4gICAgICAgIC8vIGFsc28gdGhleSBzaG91bGQgYmUgcmVuYW1lZCB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCB1c2VyIHByb3BlcnRpZXNcclxuICAgICAgICBpZiAoaGFzSGVscGVycykge1xyXG4gICAgICAgICAgICBwdXNoKGBjb25zdCB7ICR7YXN0LmhlbHBlcnNcclxuICAgICAgICAgICAgICAgIC5tYXAocyA9PiBgJHtoZWxwZXJOYW1lTWFwW3NdfTogXyR7aGVscGVyTmFtZU1hcFtzXX1gKVxyXG4gICAgICAgICAgICAgICAgLmpvaW4oJywgJyl9IH0gPSBfVnVlYCk7XHJcbiAgICAgICAgICAgIHB1c2goYFxcbmApO1xyXG4gICAgICAgICAgICBuZXdsaW5lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gZ2VuZXJhdGUgYXNzZXQgcmVzb2x1dGlvbiBzdGF0ZW1lbnRzXHJcbiAgICBpZiAoYXN0LmNvbXBvbmVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgZ2VuQXNzZXRzKGFzdC5jb21wb25lbnRzLCAnY29tcG9uZW50JywgY29udGV4dCk7XHJcbiAgICAgICAgaWYgKGFzdC5kaXJlY3RpdmVzLmxlbmd0aCB8fCBhc3QudGVtcHMgPiAwKSB7XHJcbiAgICAgICAgICAgIG5ld2xpbmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoYXN0LmRpcmVjdGl2ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgZ2VuQXNzZXRzKGFzdC5kaXJlY3RpdmVzLCAnZGlyZWN0aXZlJywgY29udGV4dCk7XHJcbiAgICAgICAgaWYgKGFzdC50ZW1wcyA+IDApIHtcclxuICAgICAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChhc3QuZmlsdGVycyAmJiBhc3QuZmlsdGVycy5sZW5ndGgpIHtcclxuICAgICAgICBuZXdsaW5lKCk7XHJcbiAgICAgICAgZ2VuQXNzZXRzKGFzdC5maWx0ZXJzLCAnZmlsdGVyJywgY29udGV4dCk7XHJcbiAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgfVxyXG4gICAgaWYgKGFzdC50ZW1wcyA+IDApIHtcclxuICAgICAgICBwdXNoKGBsZXQgYCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3QudGVtcHM7IGkrKykge1xyXG4gICAgICAgICAgICBwdXNoKGAke2kgPiAwID8gYCwgYCA6IGBgfV90ZW1wJHtpfWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChhc3QuY29tcG9uZW50cy5sZW5ndGggfHwgYXN0LmRpcmVjdGl2ZXMubGVuZ3RoIHx8IGFzdC50ZW1wcykge1xyXG4gICAgICAgIHB1c2goYFxcbmApO1xyXG4gICAgICAgIG5ld2xpbmUoKTtcclxuICAgIH1cclxuICAgIC8vIGdlbmVyYXRlIHRoZSBWTm9kZSB0cmVlIGV4cHJlc3Npb25cclxuICAgIGlmICghc3NyKSB7XHJcbiAgICAgICAgcHVzaChgcmV0dXJuIGApO1xyXG4gICAgfVxyXG4gICAgaWYgKGFzdC5jb2RlZ2VuTm9kZSkge1xyXG4gICAgICAgIGdlbk5vZGUoYXN0LmNvZGVnZW5Ob2RlLCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHB1c2goYG51bGxgKTtcclxuICAgIH1cclxuICAgIGlmICh1c2VXaXRoQmxvY2spIHtcclxuICAgICAgICBkZWluZGVudCgpO1xyXG4gICAgICAgIHB1c2goYH1gKTtcclxuICAgIH1cclxuICAgIGRlaW5kZW50KCk7XHJcbiAgICBwdXNoKGB9YCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGFzdCxcclxuICAgICAgICBjb2RlOiBjb250ZXh0LmNvZGUsXHJcbiAgICAgICAgcHJlYW1ibGU6IGBgLFxyXG4gICAgICAgIC8vIFNvdXJjZU1hcEdlbmVyYXRvciBkb2VzIGhhdmUgdG9KU09OKCkgbWV0aG9kIGJ1dCBpdCdzIG5vdCBpbiB0aGUgdHlwZXNcclxuICAgICAgICBtYXA6IGNvbnRleHQubWFwID8gY29udGV4dC5tYXAudG9KU09OKCkgOiB1bmRlZmluZWRcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZ2VuRnVuY3Rpb25QcmVhbWJsZShhc3QsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgc3NyLCBwcmVmaXhJZGVudGlmaWVycywgcHVzaCwgbmV3bGluZSwgcnVudGltZU1vZHVsZU5hbWUsIHJ1bnRpbWVHbG9iYWxOYW1lLCBzc3JSdW50aW1lTW9kdWxlTmFtZSB9ID0gY29udGV4dDtcclxuICAgIGNvbnN0IFZ1ZUJpbmRpbmcgPSBydW50aW1lR2xvYmFsTmFtZTtcclxuICAgIGNvbnN0IGFsaWFzSGVscGVyID0gKHMpID0+IGAke2hlbHBlck5hbWVNYXBbc119OiBfJHtoZWxwZXJOYW1lTWFwW3NdfWA7XHJcbiAgICAvLyBHZW5lcmF0ZSBjb25zdCBkZWNsYXJhdGlvbiBmb3IgaGVscGVyc1xyXG4gICAgLy8gSW4gcHJlZml4IG1vZGUsIHdlIHBsYWNlIHRoZSBjb25zdCBkZWNsYXJhdGlvbiBhdCB0b3Agc28gaXQncyBkb25lXHJcbiAgICAvLyBvbmx5IG9uY2U7IEJ1dCBpZiB3ZSBub3QgcHJlZml4aW5nLCB3ZSBwbGFjZSB0aGUgZGVjbGFyYXRpb24gaW5zaWRlIHRoZVxyXG4gICAgLy8gd2l0aCBibG9jayBzbyBpdCBkb2Vzbid0IGluY3VyIHRoZSBgaW5gIGNoZWNrIGNvc3QgZm9yIGV2ZXJ5IGhlbHBlciBhY2Nlc3MuXHJcbiAgICBpZiAoYXN0LmhlbHBlcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gXCJ3aXRoXCIgbW9kZS5cclxuICAgICAgICAgICAgLy8gc2F2ZSBWdWUgaW4gYSBzZXBhcmF0ZSB2YXJpYWJsZSB0byBhdm9pZCBjb2xsaXNpb25cclxuICAgICAgICAgICAgcHVzaChgY29uc3QgX1Z1ZSA9ICR7VnVlQmluZGluZ31cXG5gKTtcclxuICAgICAgICAgICAgLy8gaW4gXCJ3aXRoXCIgbW9kZSwgaGVscGVycyBhcmUgZGVjbGFyZWQgaW5zaWRlIHRoZSB3aXRoIGJsb2NrIHRvIGF2b2lkXHJcbiAgICAgICAgICAgIC8vIGhhcyBjaGVjayBjb3N0LCBidXQgaG9pc3RzIGFyZSBsaWZ0ZWQgb3V0IG9mIHRoZSBmdW5jdGlvbiAtIHdlIG5lZWRcclxuICAgICAgICAgICAgLy8gdG8gcHJvdmlkZSB0aGUgaGVscGVyIGhlcmUuXHJcbiAgICAgICAgICAgIGlmIChhc3QuaG9pc3RzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdGljSGVscGVycyA9IFtcclxuICAgICAgICAgICAgICAgICAgICBDUkVBVEVfVk5PREUsXHJcbiAgICAgICAgICAgICAgICAgICAgQ1JFQVRFX0VMRU1FTlRfVk5PREUsXHJcbiAgICAgICAgICAgICAgICAgICAgQ1JFQVRFX0NPTU1FTlQsXHJcbiAgICAgICAgICAgICAgICAgICAgQ1JFQVRFX1RFWFQsXHJcbiAgICAgICAgICAgICAgICAgICAgQ1JFQVRFX1NUQVRJQ1xyXG4gICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoaGVscGVyID0+IGFzdC5oZWxwZXJzLmluY2x1ZGVzKGhlbHBlcikpXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcChhbGlhc0hlbHBlcilcclxuICAgICAgICAgICAgICAgICAgICAuam9pbignLCAnKTtcclxuICAgICAgICAgICAgICAgIHB1c2goYGNvbnN0IHsgJHtzdGF0aWNIZWxwZXJzfSB9ID0gX1Z1ZVxcbmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2VuSG9pc3RzKGFzdC5ob2lzdHMsIGNvbnRleHQpO1xyXG4gICAgbmV3bGluZSgpO1xyXG4gICAgcHVzaChgcmV0dXJuIGApO1xyXG59XHJcbmZ1bmN0aW9uIGdlbkFzc2V0cyhhc3NldHMsIHR5cGUsIHsgaGVscGVyLCBwdXNoLCBuZXdsaW5lLCBpc1RTIH0pIHtcclxuICAgIGNvbnN0IHJlc29sdmVyID0gaGVscGVyKHR5cGUgPT09ICdmaWx0ZXInXHJcbiAgICAgICAgPyBSRVNPTFZFX0ZJTFRFUlxyXG4gICAgICAgIDogdHlwZSA9PT0gJ2NvbXBvbmVudCdcclxuICAgICAgICAgICAgPyBSRVNPTFZFX0NPTVBPTkVOVFxyXG4gICAgICAgICAgICA6IFJFU09MVkVfRElSRUNUSVZFKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXNzZXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IGlkID0gYXNzZXRzW2ldO1xyXG4gICAgICAgIC8vIHBvdGVudGlhbCBjb21wb25lbnQgaW1wbGljaXQgc2VsZi1yZWZlcmVuY2UgaW5mZXJyZWQgZnJvbSBTRkMgZmlsZW5hbWVcclxuICAgICAgICBjb25zdCBtYXliZVNlbGZSZWZlcmVuY2UgPSBpZC5lbmRzV2l0aCgnX19zZWxmJyk7XHJcbiAgICAgICAgaWYgKG1heWJlU2VsZlJlZmVyZW5jZSkge1xyXG4gICAgICAgICAgICBpZCA9IGlkLnNsaWNlKDAsIC02KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVzaChgY29uc3QgJHt0b1ZhbGlkQXNzZXRJZChpZCwgdHlwZSl9ID0gJHtyZXNvbHZlcn0oJHtKU09OLnN0cmluZ2lmeShpZCl9JHttYXliZVNlbGZSZWZlcmVuY2UgPyBgLCB0cnVlYCA6IGBgfSkke2lzVFMgPyBgIWAgOiBgYH1gKTtcclxuICAgICAgICBpZiAoaSA8IGFzc2V0cy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgIG5ld2xpbmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2VuSG9pc3RzKGhvaXN0cywgY29udGV4dCkge1xyXG4gICAgaWYgKCFob2lzdHMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29udGV4dC5wdXJlID0gdHJ1ZTtcclxuICAgIGNvbnN0IHsgcHVzaCwgbmV3bGluZSwgaGVscGVyLCBzY29wZUlkLCBtb2RlIH0gPSBjb250ZXh0O1xyXG4gICAgbmV3bGluZSgpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBob2lzdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBleHAgPSBob2lzdHNbaV07XHJcbiAgICAgICAgaWYgKGV4cCkge1xyXG4gICAgICAgICAgICBwdXNoKGBjb25zdCBfaG9pc3RlZF8ke2kgKyAxfSA9ICR7YGB9YCk7XHJcbiAgICAgICAgICAgIGdlbk5vZGUoZXhwLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnRleHQucHVyZSA9IGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGlzVGV4dCQxKG4pIHtcclxuICAgIHJldHVybiAoaXNTdHJpbmcobikgfHxcclxuICAgICAgICBuLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gfHxcclxuICAgICAgICBuLnR5cGUgPT09IDIgLyogVEVYVCAqLyB8fFxyXG4gICAgICAgIG4udHlwZSA9PT0gNSAvKiBJTlRFUlBPTEFUSU9OICovIHx8XHJcbiAgICAgICAgbi50eXBlID09PSA4IC8qIENPTVBPVU5EX0VYUFJFU1NJT04gKi8pO1xyXG59XHJcbmZ1bmN0aW9uIGdlbk5vZGVMaXN0QXNBcnJheShub2RlcywgY29udGV4dCkge1xyXG4gICAgY29uc3QgbXVsdGlsaW5lcyA9IG5vZGVzLmxlbmd0aCA+IDMgfHxcclxuICAgICAgICAoKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkgJiYgbm9kZXMuc29tZShuID0+IGlzQXJyYXkobikgfHwgIWlzVGV4dCQxKG4pKSk7XHJcbiAgICBjb250ZXh0LnB1c2goYFtgKTtcclxuICAgIG11bHRpbGluZXMgJiYgY29udGV4dC5pbmRlbnQoKTtcclxuICAgIGdlbk5vZGVMaXN0KG5vZGVzLCBjb250ZXh0LCBtdWx0aWxpbmVzKTtcclxuICAgIG11bHRpbGluZXMgJiYgY29udGV4dC5kZWluZGVudCgpO1xyXG4gICAgY29udGV4dC5wdXNoKGBdYCk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuTm9kZUxpc3Qobm9kZXMsIGNvbnRleHQsIG11bHRpbGluZXMgPSBmYWxzZSwgY29tbWEgPSB0cnVlKSB7XHJcbiAgICBjb25zdCB7IHB1c2gsIG5ld2xpbmUgfSA9IGNvbnRleHQ7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xyXG4gICAgICAgIGlmIChpc1N0cmluZyhub2RlKSkge1xyXG4gICAgICAgICAgICBwdXNoKG5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0FycmF5KG5vZGUpKSB7XHJcbiAgICAgICAgICAgIGdlbk5vZGVMaXN0QXNBcnJheShub2RlLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGdlbk5vZGUobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpIDwgbm9kZXMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICBpZiAobXVsdGlsaW5lcykge1xyXG4gICAgICAgICAgICAgICAgY29tbWEgJiYgcHVzaCgnLCcpO1xyXG4gICAgICAgICAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29tbWEgJiYgcHVzaCgnLCAnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZW5Ob2RlKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGlmIChpc1N0cmluZyhub2RlKSkge1xyXG4gICAgICAgIGNvbnRleHQucHVzaChub2RlKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoaXNTeW1ib2wobm9kZSkpIHtcclxuICAgICAgICBjb250ZXh0LnB1c2goY29udGV4dC5oZWxwZXIobm9kZSkpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XHJcbiAgICAgICAgY2FzZSAxIC8qIEVMRU1FTlQgKi86XHJcbiAgICAgICAgY2FzZSA5IC8qIElGICovOlxyXG4gICAgICAgIGNhc2UgMTEgLyogRk9SICovOlxyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIGFzc2VydChub2RlLmNvZGVnZW5Ob2RlICE9IG51bGwsIGBDb2RlZ2VuIG5vZGUgaXMgbWlzc2luZyBmb3IgZWxlbWVudC9pZi9mb3Igbm9kZS4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYEFwcGx5IGFwcHJvcHJpYXRlIHRyYW5zZm9ybXMgZmlyc3QuYCk7XHJcbiAgICAgICAgICAgIGdlbk5vZGUobm9kZS5jb2RlZ2VuTm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMiAvKiBURVhUICovOlxyXG4gICAgICAgICAgICBnZW5UZXh0KG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIGdlbkV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgNSAvKiBJTlRFUlBPTEFUSU9OICovOlxyXG4gICAgICAgICAgICBnZW5JbnRlcnBvbGF0aW9uKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDEyIC8qIFRFWFRfQ0FMTCAqLzpcclxuICAgICAgICAgICAgZ2VuTm9kZShub2RlLmNvZGVnZW5Ob2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSA4IC8qIENPTVBPVU5EX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIGdlbkNvbXBvdW5kRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAzIC8qIENPTU1FTlQgKi86XHJcbiAgICAgICAgICAgIGdlbkNvbW1lbnQobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTMgLyogVk5PREVfQ0FMTCAqLzpcclxuICAgICAgICAgICAgZ2VuVk5vZGVDYWxsKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDE0IC8qIEpTX0NBTExfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgZ2VuQ2FsbEV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTUgLyogSlNfT0JKRUNUX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIGdlbk9iamVjdEV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTcgLyogSlNfQVJSQVlfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgZ2VuQXJyYXlFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDE4IC8qIEpTX0ZVTkNUSU9OX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIGdlbkZ1bmN0aW9uRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxOSAvKiBKU19DT05ESVRJT05BTF9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICBnZW5Db25kaXRpb25hbEV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMjAgLyogSlNfQ0FDSEVfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgZ2VuQ2FjaGVFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDIxIC8qIEpTX0JMT0NLX1NUQVRFTUVOVCAqLzpcclxuICAgICAgICAgICAgZ2VuTm9kZUxpc3Qobm9kZS5ib2R5LCBjb250ZXh0LCB0cnVlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIC8vIFNTUiBvbmx5IHR5cGVzXHJcbiAgICAgICAgY2FzZSAyMiAvKiBKU19URU1QTEFURV9MSVRFUkFMICovOlxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDIzIC8qIEpTX0lGX1NUQVRFTUVOVCAqLzpcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyNCAvKiBKU19BU1NJR05NRU5UX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMjUgLyogSlNfU0VRVUVOQ0VfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyNiAvKiBKU19SRVRVUk5fU1RBVEVNRU5UICovOlxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGNhc2UgMTAgLyogSUZfQlJBTkNIICovOlxyXG4gICAgICAgICAgICAvLyBub29wXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgYHVuaGFuZGxlZCBjb2RlZ2VuIG5vZGUgdHlwZTogJHtub2RlLnR5cGV9YCk7XHJcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2UgZXhoYXVzdCBhbGwgcG9zc2libGUgdHlwZXNcclxuICAgICAgICAgICAgICAgIGNvbnN0IGV4aGF1c3RpdmVDaGVjayA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhoYXVzdGl2ZUNoZWNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2VuVGV4dChub2RlLCBjb250ZXh0KSB7XHJcbiAgICBjb250ZXh0LnB1c2goSlNPTi5zdHJpbmdpZnkobm9kZS5jb250ZW50KSwgbm9kZSk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IGNvbnRlbnQsIGlzU3RhdGljIH0gPSBub2RlO1xyXG4gICAgY29udGV4dC5wdXNoKGlzU3RhdGljID8gSlNPTi5zdHJpbmdpZnkoY29udGVudCkgOiBjb250ZW50LCBub2RlKTtcclxufVxyXG5mdW5jdGlvbiBnZW5JbnRlcnBvbGF0aW9uKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgcHVzaCwgaGVscGVyLCBwdXJlIH0gPSBjb250ZXh0O1xyXG4gICAgaWYgKHB1cmUpXHJcbiAgICAgICAgcHVzaChQVVJFX0FOTk9UQVRJT04pO1xyXG4gICAgcHVzaChgJHtoZWxwZXIoVE9fRElTUExBWV9TVFJJTkcpfShgKTtcclxuICAgIGdlbk5vZGUobm9kZS5jb250ZW50LCBjb250ZXh0KTtcclxuICAgIHB1c2goYClgKTtcclxufVxyXG5mdW5jdGlvbiBnZW5Db21wb3VuZEV4cHJlc3Npb24obm9kZSwgY29udGV4dCkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgIGlmIChpc1N0cmluZyhjaGlsZCkpIHtcclxuICAgICAgICAgICAgY29udGV4dC5wdXNoKGNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGdlbk5vZGUoY2hpbGQsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZW5FeHByZXNzaW9uQXNQcm9wZXJ0eUtleShub2RlLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IHB1c2ggfSA9IGNvbnRleHQ7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSA4IC8qIENPTVBPVU5EX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICBwdXNoKGBbYCk7XHJcbiAgICAgICAgZ2VuQ29tcG91bmRFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgIHB1c2goYF1gKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG5vZGUuaXNTdGF0aWMpIHtcclxuICAgICAgICAvLyBvbmx5IHF1b3RlIGtleXMgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgY29uc3QgdGV4dCA9IGlzU2ltcGxlSWRlbnRpZmllcihub2RlLmNvbnRlbnQpXHJcbiAgICAgICAgICAgID8gbm9kZS5jb250ZW50XHJcbiAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkobm9kZS5jb250ZW50KTtcclxuICAgICAgICBwdXNoKHRleHQsIG5vZGUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcHVzaChgWyR7bm9kZS5jb250ZW50fV1gLCBub2RlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZW5Db21tZW50KG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgcHVzaCwgaGVscGVyLCBwdXJlIH0gPSBjb250ZXh0O1xyXG4gICAgaWYgKHB1cmUpIHtcclxuICAgICAgICBwdXNoKFBVUkVfQU5OT1RBVElPTik7XHJcbiAgICB9XHJcbiAgICBwdXNoKGAke2hlbHBlcihDUkVBVEVfQ09NTUVOVCl9KCR7SlNPTi5zdHJpbmdpZnkobm9kZS5jb250ZW50KX0pYCwgbm9kZSk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuVk5vZGVDYWxsKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgcHVzaCwgaGVscGVyLCBwdXJlIH0gPSBjb250ZXh0O1xyXG4gICAgY29uc3QgeyB0YWcsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMsIGRpcmVjdGl2ZXMsIGlzQmxvY2ssIGRpc2FibGVUcmFja2luZywgaXNDb21wb25lbnQgfSA9IG5vZGU7XHJcbiAgICBpZiAoZGlyZWN0aXZlcykge1xyXG4gICAgICAgIHB1c2goaGVscGVyKFdJVEhfRElSRUNUSVZFUykgKyBgKGApO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzQmxvY2spIHtcclxuICAgICAgICBwdXNoKGAoJHtoZWxwZXIoT1BFTl9CTE9DSyl9KCR7ZGlzYWJsZVRyYWNraW5nID8gYHRydWVgIDogYGB9KSwgYCk7XHJcbiAgICB9XHJcbiAgICBpZiAocHVyZSkge1xyXG4gICAgICAgIHB1c2goUFVSRV9BTk5PVEFUSU9OKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGNhbGxIZWxwZXIgPSBpc0Jsb2NrXHJcbiAgICAgICAgPyBnZXRWTm9kZUJsb2NrSGVscGVyKGNvbnRleHQuaW5TU1IsIGlzQ29tcG9uZW50KVxyXG4gICAgICAgIDogZ2V0Vk5vZGVIZWxwZXIoY29udGV4dC5pblNTUiwgaXNDb21wb25lbnQpO1xyXG4gICAgcHVzaChoZWxwZXIoY2FsbEhlbHBlcikgKyBgKGAsIG5vZGUpO1xyXG4gICAgZ2VuTm9kZUxpc3QoZ2VuTnVsbGFibGVBcmdzKFt0YWcsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHNdKSwgY29udGV4dCk7XHJcbiAgICBwdXNoKGApYCk7XHJcbiAgICBpZiAoaXNCbG9jaykge1xyXG4gICAgICAgIHB1c2goYClgKTtcclxuICAgIH1cclxuICAgIGlmIChkaXJlY3RpdmVzKSB7XHJcbiAgICAgICAgcHVzaChgLCBgKTtcclxuICAgICAgICBnZW5Ob2RlKGRpcmVjdGl2ZXMsIGNvbnRleHQpO1xyXG4gICAgICAgIHB1c2goYClgKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZW5OdWxsYWJsZUFyZ3MoYXJncykge1xyXG4gICAgbGV0IGkgPSBhcmdzLmxlbmd0aDtcclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICBpZiAoYXJnc1tpXSAhPSBudWxsKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIHJldHVybiBhcmdzLnNsaWNlKDAsIGkgKyAxKS5tYXAoYXJnID0+IGFyZyB8fCBgbnVsbGApO1xyXG59XHJcbi8vIEphdmFTY3JpcHRcclxuZnVuY3Rpb24gZ2VuQ2FsbEV4cHJlc3Npb24obm9kZSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBwdXNoLCBoZWxwZXIsIHB1cmUgfSA9IGNvbnRleHQ7XHJcbiAgICBjb25zdCBjYWxsZWUgPSBpc1N0cmluZyhub2RlLmNhbGxlZSkgPyBub2RlLmNhbGxlZSA6IGhlbHBlcihub2RlLmNhbGxlZSk7XHJcbiAgICBpZiAocHVyZSkge1xyXG4gICAgICAgIHB1c2goUFVSRV9BTk5PVEFUSU9OKTtcclxuICAgIH1cclxuICAgIHB1c2goY2FsbGVlICsgYChgLCBub2RlKTtcclxuICAgIGdlbk5vZGVMaXN0KG5vZGUuYXJndW1lbnRzLCBjb250ZXh0KTtcclxuICAgIHB1c2goYClgKTtcclxufVxyXG5mdW5jdGlvbiBnZW5PYmplY3RFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgcHVzaCwgaW5kZW50LCBkZWluZGVudCwgbmV3bGluZSB9ID0gY29udGV4dDtcclxuICAgIGNvbnN0IHsgcHJvcGVydGllcyB9ID0gbm9kZTtcclxuICAgIGlmICghcHJvcGVydGllcy5sZW5ndGgpIHtcclxuICAgICAgICBwdXNoKGB7fWAsIG5vZGUpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IG11bHRpbGluZXMgPSBwcm9wZXJ0aWVzLmxlbmd0aCA+IDEgfHxcclxuICAgICAgICAoKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkgJiZcclxuICAgICAgICAgICAgcHJvcGVydGllcy5zb21lKHAgPT4gcC52YWx1ZS50eXBlICE9PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovKSk7XHJcbiAgICBwdXNoKG11bHRpbGluZXMgPyBge2AgOiBgeyBgKTtcclxuICAgIG11bHRpbGluZXMgJiYgaW5kZW50KCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IHByb3BlcnRpZXNbaV07XHJcbiAgICAgICAgLy8ga2V5XHJcbiAgICAgICAgZ2VuRXhwcmVzc2lvbkFzUHJvcGVydHlLZXkoa2V5LCBjb250ZXh0KTtcclxuICAgICAgICBwdXNoKGA6IGApO1xyXG4gICAgICAgIC8vIHZhbHVlXHJcbiAgICAgICAgZ2VuTm9kZSh2YWx1ZSwgY29udGV4dCk7XHJcbiAgICAgICAgaWYgKGkgPCBwcm9wZXJ0aWVzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgLy8gd2lsbCBvbmx5IHJlYWNoIHRoaXMgaWYgaXQncyBtdWx0aWxpbmVzXHJcbiAgICAgICAgICAgIHB1c2goYCxgKTtcclxuICAgICAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG11bHRpbGluZXMgJiYgZGVpbmRlbnQoKTtcclxuICAgIHB1c2gobXVsdGlsaW5lcyA/IGB9YCA6IGAgfWApO1xyXG59XHJcbmZ1bmN0aW9uIGdlbkFycmF5RXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XHJcbiAgICBnZW5Ob2RlTGlzdEFzQXJyYXkobm9kZS5lbGVtZW50cywgY29udGV4dCk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuRnVuY3Rpb25FeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgcHVzaCwgaW5kZW50LCBkZWluZGVudCB9ID0gY29udGV4dDtcclxuICAgIGNvbnN0IHsgcGFyYW1zLCByZXR1cm5zLCBib2R5LCBuZXdsaW5lLCBpc1Nsb3QgfSA9IG5vZGU7XHJcbiAgICBpZiAoaXNTbG90KSB7XHJcbiAgICAgICAgLy8gd3JhcCBzbG90IGZ1bmN0aW9ucyB3aXRoIG93bmVyIGNvbnRleHRcclxuICAgICAgICBwdXNoKGBfJHtoZWxwZXJOYW1lTWFwW1dJVEhfQ1RYXX0oYCk7XHJcbiAgICB9XHJcbiAgICBwdXNoKGAoYCwgbm9kZSk7XHJcbiAgICBpZiAoaXNBcnJheShwYXJhbXMpKSB7XHJcbiAgICAgICAgZ2VuTm9kZUxpc3QocGFyYW1zLCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHBhcmFtcykge1xyXG4gICAgICAgIGdlbk5vZGUocGFyYW1zLCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIHB1c2goYCkgPT4gYCk7XHJcbiAgICBpZiAobmV3bGluZSB8fCBib2R5KSB7XHJcbiAgICAgICAgcHVzaChge2ApO1xyXG4gICAgICAgIGluZGVudCgpO1xyXG4gICAgfVxyXG4gICAgaWYgKHJldHVybnMpIHtcclxuICAgICAgICBpZiAobmV3bGluZSkge1xyXG4gICAgICAgICAgICBwdXNoKGByZXR1cm4gYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0FycmF5KHJldHVybnMpKSB7XHJcbiAgICAgICAgICAgIGdlbk5vZGVMaXN0QXNBcnJheShyZXR1cm5zLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGdlbk5vZGUocmV0dXJucywgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYm9keSkge1xyXG4gICAgICAgIGdlbk5vZGUoYm9keSwgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBpZiAobmV3bGluZSB8fCBib2R5KSB7XHJcbiAgICAgICAgZGVpbmRlbnQoKTtcclxuICAgICAgICBwdXNoKGB9YCk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNTbG90KSB7XHJcbiAgICAgICAgaWYgKG5vZGUuaXNOb25TY29wZWRTbG90KSB7XHJcbiAgICAgICAgICAgIHB1c2goYCwgdW5kZWZpbmVkLCB0cnVlYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1c2goYClgKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZW5Db25kaXRpb25hbEV4cHJlc3Npb24obm9kZSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyB0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUsIG5ld2xpbmU6IG5lZWROZXdsaW5lIH0gPSBub2RlO1xyXG4gICAgY29uc3QgeyBwdXNoLCBpbmRlbnQsIGRlaW5kZW50LCBuZXdsaW5lIH0gPSBjb250ZXh0O1xyXG4gICAgaWYgKHRlc3QudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgIGNvbnN0IG5lZWRzUGFyZW5zID0gIWlzU2ltcGxlSWRlbnRpZmllcih0ZXN0LmNvbnRlbnQpO1xyXG4gICAgICAgIG5lZWRzUGFyZW5zICYmIHB1c2goYChgKTtcclxuICAgICAgICBnZW5FeHByZXNzaW9uKHRlc3QsIGNvbnRleHQpO1xyXG4gICAgICAgIG5lZWRzUGFyZW5zICYmIHB1c2goYClgKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHB1c2goYChgKTtcclxuICAgICAgICBnZW5Ob2RlKHRlc3QsIGNvbnRleHQpO1xyXG4gICAgICAgIHB1c2goYClgKTtcclxuICAgIH1cclxuICAgIG5lZWROZXdsaW5lICYmIGluZGVudCgpO1xyXG4gICAgY29udGV4dC5pbmRlbnRMZXZlbCsrO1xyXG4gICAgbmVlZE5ld2xpbmUgfHwgcHVzaChgIGApO1xyXG4gICAgcHVzaChgPyBgKTtcclxuICAgIGdlbk5vZGUoY29uc2VxdWVudCwgY29udGV4dCk7XHJcbiAgICBjb250ZXh0LmluZGVudExldmVsLS07XHJcbiAgICBuZWVkTmV3bGluZSAmJiBuZXdsaW5lKCk7XHJcbiAgICBuZWVkTmV3bGluZSB8fCBwdXNoKGAgYCk7XHJcbiAgICBwdXNoKGA6IGApO1xyXG4gICAgY29uc3QgaXNOZXN0ZWQgPSBhbHRlcm5hdGUudHlwZSA9PT0gMTkgLyogSlNfQ09ORElUSU9OQUxfRVhQUkVTU0lPTiAqLztcclxuICAgIGlmICghaXNOZXN0ZWQpIHtcclxuICAgICAgICBjb250ZXh0LmluZGVudExldmVsKys7XHJcbiAgICB9XHJcbiAgICBnZW5Ob2RlKGFsdGVybmF0ZSwgY29udGV4dCk7XHJcbiAgICBpZiAoIWlzTmVzdGVkKSB7XHJcbiAgICAgICAgY29udGV4dC5pbmRlbnRMZXZlbC0tO1xyXG4gICAgfVxyXG4gICAgbmVlZE5ld2xpbmUgJiYgZGVpbmRlbnQodHJ1ZSAvKiB3aXRob3V0IG5ld2xpbmUgKi8pO1xyXG59XHJcbmZ1bmN0aW9uIGdlbkNhY2hlRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IHB1c2gsIGhlbHBlciwgaW5kZW50LCBkZWluZGVudCwgbmV3bGluZSB9ID0gY29udGV4dDtcclxuICAgIHB1c2goYF9jYWNoZVske25vZGUuaW5kZXh9XSB8fCAoYCk7XHJcbiAgICBpZiAobm9kZS5pc1ZOb2RlKSB7XHJcbiAgICAgICAgaW5kZW50KCk7XHJcbiAgICAgICAgcHVzaChgJHtoZWxwZXIoU0VUX0JMT0NLX1RSQUNLSU5HKX0oLTEpLGApO1xyXG4gICAgICAgIG5ld2xpbmUoKTtcclxuICAgIH1cclxuICAgIHB1c2goYF9jYWNoZVske25vZGUuaW5kZXh9XSA9IGApO1xyXG4gICAgZ2VuTm9kZShub2RlLnZhbHVlLCBjb250ZXh0KTtcclxuICAgIGlmIChub2RlLmlzVk5vZGUpIHtcclxuICAgICAgICBwdXNoKGAsYCk7XHJcbiAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgICAgIHB1c2goYCR7aGVscGVyKFNFVF9CTE9DS19UUkFDS0lORyl9KDEpLGApO1xyXG4gICAgICAgIG5ld2xpbmUoKTtcclxuICAgICAgICBwdXNoKGBfY2FjaGVbJHtub2RlLmluZGV4fV1gKTtcclxuICAgICAgICBkZWluZGVudCgpO1xyXG4gICAgfVxyXG4gICAgcHVzaChgKWApO1xyXG59XG5cbmZ1bmN0aW9uIHdhbGtJZGVudGlmaWVycyhyb290LCBvbklkZW50aWZpZXIsIGluY2x1ZGVBbGwgPSBmYWxzZSwgcGFyZW50U3RhY2sgPSBbXSwga25vd25JZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpKSB7XHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzUmVmZXJlbmNlZElkZW50aWZpZXIoaWQsIHBhcmVudCwgcGFyZW50U3RhY2spIHtcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNJbkRlc3RydWN0dXJlQXNzaWdubWVudChwYXJlbnQsIHBhcmVudFN0YWNrKSB7XHJcbiAgICBpZiAocGFyZW50ICYmXHJcbiAgICAgICAgKHBhcmVudC50eXBlID09PSAnT2JqZWN0UHJvcGVydHknIHx8IHBhcmVudC50eXBlID09PSAnQXJyYXlQYXR0ZXJuJykpIHtcclxuICAgICAgICBsZXQgaSA9IHBhcmVudFN0YWNrLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHAgPSBwYXJlbnRTdGFja1tpXTtcclxuICAgICAgICAgICAgaWYgKHAudHlwZSA9PT0gJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocC50eXBlICE9PSAnT2JqZWN0UHJvcGVydHknICYmICFwLnR5cGUuZW5kc1dpdGgoJ1BhdHRlcm4nKSkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gd2Fsa0Z1bmN0aW9uUGFyYW1zKG5vZGUsIG9uSWRlbnQpIHtcclxuICAgIGZvciAoY29uc3QgcCBvZiBub2RlLnBhcmFtcykge1xyXG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZXh0cmFjdElkZW50aWZpZXJzKHApKSB7XHJcbiAgICAgICAgICAgIG9uSWRlbnQoaWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB3YWxrQmxvY2tEZWNsYXJhdGlvbnMoYmxvY2ssIG9uSWRlbnQpIHtcclxuICAgIGZvciAoY29uc3Qgc3RtdCBvZiBibG9jay5ib2R5KSB7XHJcbiAgICAgICAgaWYgKHN0bXQudHlwZSA9PT0gJ1ZhcmlhYmxlRGVjbGFyYXRpb24nKSB7XHJcbiAgICAgICAgICAgIGlmIChzdG10LmRlY2xhcmUpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBkZWNsIG9mIHN0bXQuZGVjbGFyYXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGV4dHJhY3RJZGVudGlmaWVycyhkZWNsLmlkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uSWRlbnQoaWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHN0bXQudHlwZSA9PT0gJ0Z1bmN0aW9uRGVjbGFyYXRpb24nIHx8XHJcbiAgICAgICAgICAgIHN0bXQudHlwZSA9PT0gJ0NsYXNzRGVjbGFyYXRpb24nKSB7XHJcbiAgICAgICAgICAgIGlmIChzdG10LmRlY2xhcmUgfHwgIXN0bXQuaWQpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgb25JZGVudChzdG10LmlkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZXh0cmFjdElkZW50aWZpZXJzKHBhcmFtLCBub2RlcyA9IFtdKSB7XHJcbiAgICBzd2l0Y2ggKHBhcmFtLnR5cGUpIHtcclxuICAgICAgICBjYXNlICdJZGVudGlmaWVyJzpcclxuICAgICAgICAgICAgbm9kZXMucHVzaChwYXJhbSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ01lbWJlckV4cHJlc3Npb24nOlxyXG4gICAgICAgICAgICBsZXQgb2JqZWN0ID0gcGFyYW07XHJcbiAgICAgICAgICAgIHdoaWxlIChvYmplY3QudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nKSB7XHJcbiAgICAgICAgICAgICAgICBvYmplY3QgPSBvYmplY3Qub2JqZWN0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5vZGVzLnB1c2gob2JqZWN0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnT2JqZWN0UGF0dGVybic6XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBwYXJhbS5wcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcC50eXBlID09PSAnUmVzdEVsZW1lbnQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFjdElkZW50aWZpZXJzKHByb3AuYXJndW1lbnQsIG5vZGVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhY3RJZGVudGlmaWVycyhwcm9wLnZhbHVlLCBub2Rlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnQXJyYXlQYXR0ZXJuJzpcclxuICAgICAgICAgICAgcGFyYW0uZWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhY3RJZGVudGlmaWVycyhlbGVtZW50LCBub2Rlcyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdSZXN0RWxlbWVudCc6XHJcbiAgICAgICAgICAgIGV4dHJhY3RJZGVudGlmaWVycyhwYXJhbS5hcmd1bWVudCwgbm9kZXMpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdBc3NpZ25tZW50UGF0dGVybic6XHJcbiAgICAgICAgICAgIGV4dHJhY3RJZGVudGlmaWVycyhwYXJhbS5sZWZ0LCBub2Rlcyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5vZGVzO1xyXG59XHJcbmNvbnN0IGlzRnVuY3Rpb25UeXBlID0gKG5vZGUpID0+IHtcclxuICAgIHJldHVybiAvRnVuY3Rpb24oPzpFeHByZXNzaW9ufERlY2xhcmF0aW9uKSR8TWV0aG9kJC8udGVzdChub2RlLnR5cGUpO1xyXG59O1xyXG5jb25zdCBpc1N0YXRpY1Byb3BlcnR5ID0gKG5vZGUpID0+IG5vZGUgJiZcclxuICAgIChub2RlLnR5cGUgPT09ICdPYmplY3RQcm9wZXJ0eScgfHwgbm9kZS50eXBlID09PSAnT2JqZWN0TWV0aG9kJykgJiZcclxuICAgICFub2RlLmNvbXB1dGVkO1xyXG5jb25zdCBpc1N0YXRpY1Byb3BlcnR5S2V5ID0gKG5vZGUsIHBhcmVudCkgPT4gaXNTdGF0aWNQcm9wZXJ0eShwYXJlbnQpICYmIHBhcmVudC5rZXkgPT09IG5vZGU7XG5cbi8vIHRoZXNlIGtleXdvcmRzIHNob3VsZCBub3QgYXBwZWFyIGluc2lkZSBleHByZXNzaW9ucywgYnV0IG9wZXJhdG9ycyBsaWtlXHJcbi8vIHR5cGVvZiwgaW5zdGFuY2VvZiBhbmQgaW4gYXJlIGFsbG93ZWRcclxuY29uc3QgcHJvaGliaXRlZEtleXdvcmRSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArXHJcbiAgICAoJ2RvLGlmLGZvcixsZXQsbmV3LHRyeSx2YXIsY2FzZSxlbHNlLHdpdGgsYXdhaXQsYnJlYWssY2F0Y2gsY2xhc3MsY29uc3QsJyArXHJcbiAgICAgICAgJ3N1cGVyLHRocm93LHdoaWxlLHlpZWxkLGRlbGV0ZSxleHBvcnQsaW1wb3J0LHJldHVybixzd2l0Y2gsZGVmYXVsdCwnICtcclxuICAgICAgICAnZXh0ZW5kcyxmaW5hbGx5LGNvbnRpbnVlLGRlYnVnZ2VyLGZ1bmN0aW9uLGFyZ3VtZW50cyx0eXBlb2Ysdm9pZCcpXHJcbiAgICAgICAgLnNwbGl0KCcsJylcclxuICAgICAgICAuam9pbignXFxcXGJ8XFxcXGInKSArXHJcbiAgICAnXFxcXGInKTtcclxuLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xyXG5jb25zdCBzdHJpcFN0cmluZ1JFID0gLycoPzpbXidcXFxcXXxcXFxcLikqJ3xcIig/OlteXCJcXFxcXXxcXFxcLikqXCJ8YCg/OlteYFxcXFxdfFxcXFwuKSpcXCRcXHt8XFx9KD86W15gXFxcXF18XFxcXC4pKmB8YCg/OlteYFxcXFxdfFxcXFwuKSpgL2c7XHJcbi8qKlxyXG4gKiBWYWxpZGF0ZSBhIG5vbi1wcmVmaXhlZCBleHByZXNzaW9uLlxyXG4gKiBUaGlzIGlzIG9ubHkgY2FsbGVkIHdoZW4gdXNpbmcgdGhlIGluLWJyb3dzZXIgcnVudGltZSBjb21waWxlciBzaW5jZSBpdFxyXG4gKiBkb2Vzbid0IHByZWZpeCBleHByZXNzaW9ucy5cclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlQnJvd3NlckV4cHJlc3Npb24obm9kZSwgY29udGV4dCwgYXNQYXJhbXMgPSBmYWxzZSwgYXNSYXdTdGF0ZW1lbnRzID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IGV4cCA9IG5vZGUuY29udGVudDtcclxuICAgIC8vIGVtcHR5IGV4cHJlc3Npb25zIGFyZSB2YWxpZGF0ZWQgcGVyLWRpcmVjdGl2ZSBzaW5jZSBzb21lIGRpcmVjdGl2ZXNcclxuICAgIC8vIGRvIGFsbG93IGVtcHR5IGV4cHJlc3Npb25zLlxyXG4gICAgaWYgKCFleHAudHJpbSgpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBuZXcgRnVuY3Rpb24oYXNSYXdTdGF0ZW1lbnRzXHJcbiAgICAgICAgICAgID8gYCAke2V4cH0gYFxyXG4gICAgICAgICAgICA6IGByZXR1cm4gJHthc1BhcmFtcyA/IGAoJHtleHB9KSA9PiB7fWAgOiBgKCR7ZXhwfSlgfWApO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBsZXQgbWVzc2FnZSA9IGUubWVzc2FnZTtcclxuICAgICAgICBjb25zdCBrZXl3b3JkTWF0Y2ggPSBleHBcclxuICAgICAgICAgICAgLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpXHJcbiAgICAgICAgICAgIC5tYXRjaChwcm9oaWJpdGVkS2V5d29yZFJFKTtcclxuICAgICAgICBpZiAoa2V5d29yZE1hdGNoKSB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCBrZXl3b3JkIGFzIHByb3BlcnR5IG5hbWU6IFwiJHtrZXl3b3JkTWF0Y2hbMF19XCJgO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig0NCAvKiBYX0lOVkFMSURfRVhQUkVTU0lPTiAqLywgbm9kZS5sb2MsIHVuZGVmaW5lZCwgbWVzc2FnZSkpO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IHRyYW5zZm9ybUV4cHJlc3Npb24gPSAobm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gNSAvKiBJTlRFUlBPTEFUSU9OICovKSB7XHJcbiAgICAgICAgbm9kZS5jb250ZW50ID0gcHJvY2Vzc0V4cHJlc3Npb24obm9kZS5jb250ZW50LCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovKSB7XHJcbiAgICAgICAgLy8gaGFuZGxlIGRpcmVjdGl2ZXMgb24gZWxlbWVudFxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBkaXIgPSBub2RlLnByb3BzW2ldO1xyXG4gICAgICAgICAgICAvLyBkbyBub3QgcHJvY2VzcyBmb3Igdi1vbiAmIHYtZm9yIHNpbmNlIHRoZXkgYXJlIHNwZWNpYWwgaGFuZGxlZFxyXG4gICAgICAgICAgICBpZiAoZGlyLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmIGRpci5uYW1lICE9PSAnZm9yJykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXhwID0gZGlyLmV4cDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFyZyA9IGRpci5hcmc7XHJcbiAgICAgICAgICAgICAgICAvLyBkbyBub3QgcHJvY2VzcyBleHAgaWYgdGhpcyBpcyB2LW9uOmFyZyAtIHdlIG5lZWQgc3BlY2lhbCBoYW5kbGluZ1xyXG4gICAgICAgICAgICAgICAgLy8gZm9yIHdyYXBwaW5nIGlubGluZSBzdGF0ZW1lbnRzLlxyXG4gICAgICAgICAgICAgICAgaWYgKGV4cCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGV4cC50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIShkaXIubmFtZSA9PT0gJ29uJyAmJiBhcmcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlyLmV4cCA9IHByb2Nlc3NFeHByZXNzaW9uKGV4cCwgY29udGV4dCwgXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2xvdCBhcmdzIG11c3QgYmUgcHJvY2Vzc2VkIGFzIGZ1bmN0aW9uIHBhcmFtc1xyXG4gICAgICAgICAgICAgICAgICAgIGRpci5uYW1lID09PSAnc2xvdCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGFyZyAmJiBhcmcudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyAmJiAhYXJnLmlzU3RhdGljKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlyLmFyZyA9IHByb2Nlc3NFeHByZXNzaW9uKGFyZywgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbi8vIEltcG9ydGFudDogc2luY2UgdGhpcyBmdW5jdGlvbiB1c2VzIE5vZGUuanMgb25seSBkZXBlbmRlbmNpZXMsIGl0IHNob3VsZFxyXG4vLyBhbHdheXMgYmUgdXNlZCB3aXRoIGEgbGVhZGluZyAhdHJ1ZSBjaGVjayBzbyB0aGF0IGl0IGNhbiBiZVxyXG4vLyB0cmVlLXNoYWtlbiBmcm9tIHRoZSBicm93c2VyIGJ1aWxkLlxyXG5mdW5jdGlvbiBwcm9jZXNzRXhwcmVzc2lvbihub2RlLCBjb250ZXh0LCBcclxuLy8gc29tZSBleHByZXNzaW9ucyBsaWtlIHYtc2xvdCBwcm9wcyAmIHYtZm9yIGFsaWFzZXMgc2hvdWxkIGJlIHBhcnNlZCBhc1xyXG4vLyBmdW5jdGlvbiBwYXJhbXNcclxuYXNQYXJhbXMgPSBmYWxzZSwgXHJcbi8vIHYtb24gaGFuZGxlciB2YWx1ZXMgbWF5IGNvbnRhaW4gbXVsdGlwbGUgc3RhdGVtZW50c1xyXG5hc1Jhd1N0YXRlbWVudHMgPSBmYWxzZSwgbG9jYWxWYXJzID0gT2JqZWN0LmNyZWF0ZShjb250ZXh0LmlkZW50aWZpZXJzKSkge1xyXG4gICAge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgLy8gc2ltcGxlIGluLWJyb3dzZXIgdmFsaWRhdGlvbiAoc2FtZSBsb2dpYyBpbiAyLngpXHJcbiAgICAgICAgICAgIHZhbGlkYXRlQnJvd3NlckV4cHJlc3Npb24obm9kZSwgY29udGV4dCwgYXNQYXJhbXMsIGFzUmF3U3RhdGVtZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IHRyYW5zZm9ybUlmID0gY3JlYXRlU3RydWN0dXJhbERpcmVjdGl2ZVRyYW5zZm9ybSgvXihpZnxlbHNlfGVsc2UtaWYpJC8sIChub2RlLCBkaXIsIGNvbnRleHQpID0+IHtcclxuICAgIHJldHVybiBwcm9jZXNzSWYobm9kZSwgZGlyLCBjb250ZXh0LCAoaWZOb2RlLCBicmFuY2gsIGlzUm9vdCkgPT4ge1xyXG4gICAgICAgIC8vICMxNTg3OiBXZSBuZWVkIHRvIGR5bmFtaWNhbGx5IGluY3JlbWVudCB0aGUga2V5IGJhc2VkIG9uIHRoZSBjdXJyZW50XHJcbiAgICAgICAgLy8gbm9kZSdzIHNpYmxpbmcgbm9kZXMsIHNpbmNlIGNoYWluZWQgdi1pZi9lbHNlIGJyYW5jaGVzIGFyZVxyXG4gICAgICAgIC8vIHJlbmRlcmVkIGF0IHRoZSBzYW1lIGRlcHRoXHJcbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSBjb250ZXh0LnBhcmVudC5jaGlsZHJlbjtcclxuICAgICAgICBsZXQgaSA9IHNpYmxpbmdzLmluZGV4T2YoaWZOb2RlKTtcclxuICAgICAgICBsZXQga2V5ID0gMDtcclxuICAgICAgICB3aGlsZSAoaS0tID49IDApIHtcclxuICAgICAgICAgICAgY29uc3Qgc2libGluZyA9IHNpYmxpbmdzW2ldO1xyXG4gICAgICAgICAgICBpZiAoc2libGluZyAmJiBzaWJsaW5nLnR5cGUgPT09IDkgLyogSUYgKi8pIHtcclxuICAgICAgICAgICAgICAgIGtleSArPSBzaWJsaW5nLmJyYW5jaGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBFeGl0IGNhbGxiYWNrLiBDb21wbGV0ZSB0aGUgY29kZWdlbk5vZGUgd2hlbiBhbGwgY2hpbGRyZW4gaGF2ZSBiZWVuXHJcbiAgICAgICAgLy8gdHJhbnNmb3JtZWQuXHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzUm9vdCkge1xyXG4gICAgICAgICAgICAgICAgaWZOb2RlLmNvZGVnZW5Ob2RlID0gY3JlYXRlQ29kZWdlbk5vZGVGb3JCcmFuY2goYnJhbmNoLCBrZXksIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gYXR0YWNoIHRoaXMgYnJhbmNoJ3MgY29kZWdlbiBub2RlIHRvIHRoZSB2LWlmIHJvb3QuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRDb25kaXRpb24gPSBnZXRQYXJlbnRDb25kaXRpb24oaWZOb2RlLmNvZGVnZW5Ob2RlKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudENvbmRpdGlvbi5hbHRlcm5hdGUgPSBjcmVhdGVDb2RlZ2VuTm9kZUZvckJyYW5jaChicmFuY2gsIGtleSArIGlmTm9kZS5icmFuY2hlcy5sZW5ndGggLSAxLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxufSk7XHJcbi8vIHRhcmdldC1hZ25vc3RpYyB0cmFuc2Zvcm0gdXNlZCBmb3IgYm90aCBDbGllbnQgYW5kIFNTUlxyXG5mdW5jdGlvbiBwcm9jZXNzSWYobm9kZSwgZGlyLCBjb250ZXh0LCBwcm9jZXNzQ29kZWdlbikge1xyXG4gICAgaWYgKGRpci5uYW1lICE9PSAnZWxzZScgJiZcclxuICAgICAgICAoIWRpci5leHAgfHwgIWRpci5leHAuY29udGVudC50cmltKCkpKSB7XHJcbiAgICAgICAgY29uc3QgbG9jID0gZGlyLmV4cCA/IGRpci5leHAubG9jIDogbm9kZS5sb2M7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMjggLyogWF9WX0lGX05PX0VYUFJFU1NJT04gKi8sIGRpci5sb2MpKTtcclxuICAgICAgICBkaXIuZXhwID0gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgdHJ1ZWAsIGZhbHNlLCBsb2MpO1xyXG4gICAgfVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB0cnVlICYmIGRpci5leHApIHtcclxuICAgICAgICB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKGRpci5leHAsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgaWYgKGRpci5uYW1lID09PSAnaWYnKSB7XHJcbiAgICAgICAgY29uc3QgYnJhbmNoID0gY3JlYXRlSWZCcmFuY2gobm9kZSwgZGlyKTtcclxuICAgICAgICBjb25zdCBpZk5vZGUgPSB7XHJcbiAgICAgICAgICAgIHR5cGU6IDkgLyogSUYgKi8sXHJcbiAgICAgICAgICAgIGxvYzogbm9kZS5sb2MsXHJcbiAgICAgICAgICAgIGJyYW5jaGVzOiBbYnJhbmNoXVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29udGV4dC5yZXBsYWNlTm9kZShpZk5vZGUpO1xyXG4gICAgICAgIGlmIChwcm9jZXNzQ29kZWdlbikge1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvY2Vzc0NvZGVnZW4oaWZOb2RlLCBicmFuY2gsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGxvY2F0ZSB0aGUgYWRqYWNlbnQgdi1pZlxyXG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gY29udGV4dC5wYXJlbnQuY2hpbGRyZW47XHJcbiAgICAgICAgY29uc3QgY29tbWVudHMgPSBbXTtcclxuICAgICAgICBsZXQgaSA9IHNpYmxpbmdzLmluZGV4T2Yobm9kZSk7XHJcbiAgICAgICAgd2hpbGUgKGktLSA+PSAtMSkge1xyXG4gICAgICAgICAgICBjb25zdCBzaWJsaW5nID0gc2libGluZ3NbaV07XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgc2libGluZyAmJiBzaWJsaW5nLnR5cGUgPT09IDMgLyogQ09NTUVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5yZW1vdmVOb2RlKHNpYmxpbmcpO1xyXG4gICAgICAgICAgICAgICAgY29tbWVudHMudW5zaGlmdChzaWJsaW5nKTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzaWJsaW5nICYmXHJcbiAgICAgICAgICAgICAgICBzaWJsaW5nLnR5cGUgPT09IDIgLyogVEVYVCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgIXNpYmxpbmcuY29udGVudC50cmltKCkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlbW92ZU5vZGUoc2libGluZyk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc2libGluZyAmJiBzaWJsaW5nLnR5cGUgPT09IDkgLyogSUYgKi8pIHtcclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHYtZWxzZSB3YXMgZm9sbG93ZWQgYnkgdi1lbHNlLWlmXHJcbiAgICAgICAgICAgICAgICBpZiAoZGlyLm5hbWUgPT09ICdlbHNlLWlmJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHNpYmxpbmcuYnJhbmNoZXNbc2libGluZy5icmFuY2hlcy5sZW5ndGggLSAxXS5jb25kaXRpb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDMwIC8qIFhfVl9FTFNFX05PX0FESkFDRU5UX0lGICovLCBub2RlLmxvYykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gbW92ZSB0aGUgbm9kZSB0byB0aGUgaWYgbm9kZSdzIGJyYW5jaGVzXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlbW92ZU5vZGUoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJyYW5jaCA9IGNyZWF0ZUlmQnJhbmNoKG5vZGUsIGRpcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudHMubGVuZ3RoICYmXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gIzM2MTkgaWdub3JlIGNvbW1lbnRzIGlmIHRoZSB2LWlmIGlzIGRpcmVjdCBjaGlsZCBvZiA8dHJhbnNpdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICAhKGNvbnRleHQucGFyZW50ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucGFyZW50LnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0J1aWx0SW5UeXBlKGNvbnRleHQucGFyZW50LnRhZywgJ3RyYW5zaXRpb24nKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmFuY2guY2hpbGRyZW4gPSBbLi4uY29tbWVudHMsIC4uLmJyYW5jaC5jaGlsZHJlbl07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB1c2VyIGlzIGZvcmNpbmcgc2FtZSBrZXkgb24gZGlmZmVyZW50IGJyYW5jaGVzXHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICF0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYnJhbmNoLnVzZXJLZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5nLmJyYW5jaGVzLmZvckVhY2goKHsgdXNlcktleSB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTYW1lS2V5KHVzZXJLZXksIGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigyOSAvKiBYX1ZfSUZfU0FNRV9LRVkgKi8sIGJyYW5jaC51c2VyS2V5LmxvYykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzaWJsaW5nLmJyYW5jaGVzLnB1c2goYnJhbmNoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9uRXhpdCA9IHByb2Nlc3NDb2RlZ2VuICYmIHByb2Nlc3NDb2RlZ2VuKHNpYmxpbmcsIGJyYW5jaCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgLy8gc2luY2UgdGhlIGJyYW5jaCB3YXMgcmVtb3ZlZCwgaXQgd2lsbCBub3QgYmUgdHJhdmVyc2VkLlxyXG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRvIHRyYXZlcnNlIGhlcmUuXHJcbiAgICAgICAgICAgICAgICB0cmF2ZXJzZU5vZGUoYnJhbmNoLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIC8vIGNhbGwgb24gZXhpdFxyXG4gICAgICAgICAgICAgICAgaWYgKG9uRXhpdClcclxuICAgICAgICAgICAgICAgICAgICBvbkV4aXQoKTtcclxuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0byByZXNldCBjdXJyZW50Tm9kZSBhZnRlciB0cmF2ZXJzYWwgdG8gaW5kaWNhdGUgdGhpc1xyXG4gICAgICAgICAgICAgICAgLy8gbm9kZSBoYXMgYmVlbiByZW1vdmVkLlxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5jdXJyZW50Tm9kZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzMCAvKiBYX1ZfRUxTRV9OT19BREpBQ0VOVF9JRiAqLywgbm9kZS5sb2MpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlSWZCcmFuY2gobm9kZSwgZGlyKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDEwIC8qIElGX0JSQU5DSCAqLyxcclxuICAgICAgICBsb2M6IG5vZGUubG9jLFxyXG4gICAgICAgIGNvbmRpdGlvbjogZGlyLm5hbWUgPT09ICdlbHNlJyA/IHVuZGVmaW5lZCA6IGRpci5leHAsXHJcbiAgICAgICAgY2hpbGRyZW46IG5vZGUudGFnVHlwZSA9PT0gMyAvKiBURU1QTEFURSAqLyAmJiAhZmluZERpcihub2RlLCAnZm9yJylcclxuICAgICAgICAgICAgPyBub2RlLmNoaWxkcmVuXHJcbiAgICAgICAgICAgIDogW25vZGVdLFxyXG4gICAgICAgIHVzZXJLZXk6IGZpbmRQcm9wKG5vZGUsIGBrZXlgKVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDb2RlZ2VuTm9kZUZvckJyYW5jaChicmFuY2gsIGtleUluZGV4LCBjb250ZXh0KSB7XHJcbiAgICBpZiAoYnJhbmNoLmNvbmRpdGlvbikge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVDb25kaXRpb25hbEV4cHJlc3Npb24oYnJhbmNoLmNvbmRpdGlvbiwgY3JlYXRlQ2hpbGRyZW5Db2RlZ2VuTm9kZShicmFuY2gsIGtleUluZGV4LCBjb250ZXh0KSwgXHJcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIHBhc3MgaW4gYXNCbG9jazogdHJ1ZSBzbyB0aGF0IHRoZSBjb21tZW50IG5vZGUgY2FsbFxyXG4gICAgICAgIC8vIGNsb3NlcyB0aGUgY3VycmVudCBibG9jay5cclxuICAgICAgICBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihDUkVBVEVfQ09NTUVOVCksIFtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ1widi1pZlwiJyA6ICdcIlwiJyxcclxuICAgICAgICAgICAgJ3RydWUnXHJcbiAgICAgICAgXSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNoaWxkcmVuQ29kZWdlbk5vZGUoYnJhbmNoLCBrZXlJbmRleCwgY29udGV4dCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW5Db2RlZ2VuTm9kZShicmFuY2gsIGtleUluZGV4LCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IGhlbHBlciB9ID0gY29udGV4dDtcclxuICAgIGNvbnN0IGtleVByb3BlcnR5ID0gY3JlYXRlT2JqZWN0UHJvcGVydHkoYGtleWAsIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYCR7a2V5SW5kZXh9YCwgZmFsc2UsIGxvY1N0dWIsIDIgLyogQ0FOX0hPSVNUICovKSk7XHJcbiAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSBicmFuY2g7XHJcbiAgICBjb25zdCBmaXJzdENoaWxkID0gY2hpbGRyZW5bMF07XHJcbiAgICBjb25zdCBuZWVkRnJhZ21lbnRXcmFwcGVyID0gY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8IGZpcnN0Q2hpbGQudHlwZSAhPT0gMSAvKiBFTEVNRU5UICovO1xyXG4gICAgaWYgKG5lZWRGcmFnbWVudFdyYXBwZXIpIHtcclxuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGZpcnN0Q2hpbGQudHlwZSA9PT0gMTEgLyogRk9SICovKSB7XHJcbiAgICAgICAgICAgIC8vIG9wdGltaXplIGF3YXkgbmVzdGVkIGZyYWdtZW50cyB3aGVuIGNoaWxkIGlzIGEgRm9yTm9kZVxyXG4gICAgICAgICAgICBjb25zdCB2bm9kZUNhbGwgPSBmaXJzdENoaWxkLmNvZGVnZW5Ob2RlO1xyXG4gICAgICAgICAgICBpbmplY3RQcm9wKHZub2RlQ2FsbCwga2V5UHJvcGVydHksIGNvbnRleHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gdm5vZGVDYWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IHBhdGNoRmxhZyA9IDY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqLztcclxuICAgICAgICAgICAgbGV0IHBhdGNoRmxhZ1RleHQgPSBQYXRjaEZsYWdOYW1lc1s2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi9dO1xyXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgZnJhZ21lbnQgYWN0dWFsbHkgY29udGFpbnMgYSBzaW5nbGUgdmFsaWQgY2hpbGQgd2l0aFxyXG4gICAgICAgICAgICAvLyB0aGUgcmVzdCBiZWluZyBjb21tZW50c1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5maWx0ZXIoYyA9PiBjLnR5cGUgIT09IDMgLyogQ09NTUVOVCAqLykubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRjaEZsYWcgfD0gMjA0OCAvKiBERVZfUk9PVF9GUkFHTUVOVCAqLztcclxuICAgICAgICAgICAgICAgIHBhdGNoRmxhZ1RleHQgKz0gYCwgJHtQYXRjaEZsYWdOYW1lc1syMDQ4IC8qIERFVl9ST09UX0ZSQUdNRU5UICovXX1gO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZUNhbGwoY29udGV4dCwgaGVscGVyKEZSQUdNRU5UKSwgY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihba2V5UHJvcGVydHldKSwgY2hpbGRyZW4sIHBhdGNoRmxhZyArICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgIC8qICR7cGF0Y2hGbGFnVGV4dH0gKi9gIDogYGApLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSwgZmFsc2UsIGZhbHNlIC8qIGlzQ29tcG9uZW50ICovLCBicmFuY2gubG9jKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCByZXQgPSBmaXJzdENoaWxkLmNvZGVnZW5Ob2RlO1xyXG4gICAgICAgIGNvbnN0IHZub2RlQ2FsbCA9IGdldE1lbW9lZFZOb2RlQ2FsbChyZXQpO1xyXG4gICAgICAgIC8vIENoYW5nZSBjcmVhdGVWTm9kZSB0byBjcmVhdGVCbG9jay5cclxuICAgICAgICBpZiAodm5vZGVDYWxsLnR5cGUgPT09IDEzIC8qIFZOT0RFX0NBTEwgKi8pIHtcclxuICAgICAgICAgICAgbWFrZUJsb2NrKHZub2RlQ2FsbCwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluamVjdCBicmFuY2gga2V5XHJcbiAgICAgICAgaW5qZWN0UHJvcCh2bm9kZUNhbGwsIGtleVByb3BlcnR5LCBjb250ZXh0KTtcclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzU2FtZUtleShhLCBiKSB7XHJcbiAgICBpZiAoIWEgfHwgYS50eXBlICE9PSBiLnR5cGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoYS50eXBlID09PSA2IC8qIEFUVFJJQlVURSAqLykge1xyXG4gICAgICAgIGlmIChhLnZhbHVlLmNvbnRlbnQgIT09IGIudmFsdWUuY29udGVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gZGlyZWN0aXZlXHJcbiAgICAgICAgY29uc3QgZXhwID0gYS5leHA7XHJcbiAgICAgICAgY29uc3QgYnJhbmNoRXhwID0gYi5leHA7XHJcbiAgICAgICAgaWYgKGV4cC50eXBlICE9PSBicmFuY2hFeHAudHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChleHAudHlwZSAhPT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyB8fFxyXG4gICAgICAgICAgICBleHAuaXNTdGF0aWMgIT09IGJyYW5jaEV4cC5pc1N0YXRpYyB8fFxyXG4gICAgICAgICAgICBleHAuY29udGVudCAhPT0gYnJhbmNoRXhwLmNvbnRlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGdldFBhcmVudENvbmRpdGlvbihub2RlKSB7XHJcbiAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IDE5IC8qIEpTX0NPTkRJVElPTkFMX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUuYWx0ZXJuYXRlLnR5cGUgPT09IDE5IC8qIEpTX0NPTkRJVElPTkFMX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmFsdGVybmF0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMjAgLyogSlNfQ0FDSEVfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgICAgICBub2RlID0gbm9kZS52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY29uc3QgdHJhbnNmb3JtRm9yID0gY3JlYXRlU3RydWN0dXJhbERpcmVjdGl2ZVRyYW5zZm9ybSgnZm9yJywgKG5vZGUsIGRpciwgY29udGV4dCkgPT4ge1xyXG4gICAgY29uc3QgeyBoZWxwZXIsIHJlbW92ZUhlbHBlciB9ID0gY29udGV4dDtcclxuICAgIHJldHVybiBwcm9jZXNzRm9yKG5vZGUsIGRpciwgY29udGV4dCwgZm9yTm9kZSA9PiB7XHJcbiAgICAgICAgLy8gY3JlYXRlIHRoZSBsb29wIHJlbmRlciBmdW5jdGlvbiBleHByZXNzaW9uIG5vdywgYW5kIGFkZCB0aGVcclxuICAgICAgICAvLyBpdGVyYXRvciBvbiBleGl0IGFmdGVyIGFsbCBjaGlsZHJlbiBoYXZlIGJlZW4gdHJhdmVyc2VkXHJcbiAgICAgICAgY29uc3QgcmVuZGVyRXhwID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oaGVscGVyKFJFTkRFUl9MSVNUKSwgW1xyXG4gICAgICAgICAgICBmb3JOb2RlLnNvdXJjZVxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIGNvbnN0IGlzVGVtcGxhdGUgPSBpc1RlbXBsYXRlTm9kZShub2RlKTtcclxuICAgICAgICBjb25zdCBtZW1vID0gZmluZERpcihub2RlLCAnbWVtbycpO1xyXG4gICAgICAgIGNvbnN0IGtleVByb3AgPSBmaW5kUHJvcChub2RlLCBga2V5YCk7XHJcbiAgICAgICAgY29uc3Qga2V5RXhwID0ga2V5UHJvcCAmJlxyXG4gICAgICAgICAgICAoa2V5UHJvcC50eXBlID09PSA2IC8qIEFUVFJJQlVURSAqL1xyXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGtleVByb3AudmFsdWUuY29udGVudCwgdHJ1ZSlcclxuICAgICAgICAgICAgICAgIDoga2V5UHJvcC5leHApO1xyXG4gICAgICAgIGNvbnN0IGtleVByb3BlcnR5ID0ga2V5UHJvcCA/IGNyZWF0ZU9iamVjdFByb3BlcnR5KGBrZXlgLCBrZXlFeHApIDogbnVsbDtcclxuICAgICAgICBjb25zdCBpc1N0YWJsZUZyYWdtZW50ID0gZm9yTm9kZS5zb3VyY2UudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyAmJlxyXG4gICAgICAgICAgICBmb3JOb2RlLnNvdXJjZS5jb25zdFR5cGUgPiAwIC8qIE5PVF9DT05TVEFOVCAqLztcclxuICAgICAgICBjb25zdCBmcmFnbWVudEZsYWcgPSBpc1N0YWJsZUZyYWdtZW50XHJcbiAgICAgICAgICAgID8gNjQgLyogU1RBQkxFX0ZSQUdNRU5UICovXHJcbiAgICAgICAgICAgIDoga2V5UHJvcFxyXG4gICAgICAgICAgICAgICAgPyAxMjggLyogS0VZRURfRlJBR01FTlQgKi9cclxuICAgICAgICAgICAgICAgIDogMjU2IC8qIFVOS0VZRURfRlJBR01FTlQgKi87XHJcbiAgICAgICAgZm9yTm9kZS5jb2RlZ2VuTm9kZSA9IGNyZWF0ZVZOb2RlQ2FsbChjb250ZXh0LCBoZWxwZXIoRlJBR01FTlQpLCB1bmRlZmluZWQsIHJlbmRlckV4cCwgZnJhZ21lbnRGbGFnICtcclxuICAgICAgICAgICAgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGAgLyogJHtQYXRjaEZsYWdOYW1lc1tmcmFnbWVudEZsYWddfSAqL2AgOiBgYCksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlIC8qIGlzQmxvY2sgKi8sICFpc1N0YWJsZUZyYWdtZW50IC8qIGRpc2FibGVUcmFja2luZyAqLywgZmFsc2UgLyogaXNDb21wb25lbnQgKi8sIG5vZGUubG9jKTtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBmaW5pc2ggdGhlIGNvZGVnZW4gbm93IHRoYXQgYWxsIGNoaWxkcmVuIGhhdmUgYmVlbiB0cmF2ZXJzZWRcclxuICAgICAgICAgICAgbGV0IGNoaWxkQmxvY2s7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IGZvck5vZGU7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIDx0ZW1wbGF0ZSB2LWZvcj4ga2V5IHBsYWNlbWVudFxyXG4gICAgICAgICAgICBpZiAoKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCAhdHJ1ZSkgJiYgaXNUZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5zb21lKGMgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBmaW5kUHJvcChjLCAna2V5Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDMzIC8qIFhfVl9GT1JfVEVNUExBVEVfS0VZX1BMQUNFTUVOVCAqLywga2V5LmxvYykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBuZWVkRnJhZ21lbnRXcmFwcGVyID0gY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8IGNoaWxkcmVuWzBdLnR5cGUgIT09IDEgLyogRUxFTUVOVCAqLztcclxuICAgICAgICAgICAgY29uc3Qgc2xvdE91dGxldCA9IGlzU2xvdE91dGxldChub2RlKVxyXG4gICAgICAgICAgICAgICAgPyBub2RlXHJcbiAgICAgICAgICAgICAgICA6IGlzVGVtcGxhdGUgJiZcclxuICAgICAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGlzU2xvdE91dGxldChub2RlLmNoaWxkcmVuWzBdKVxyXG4gICAgICAgICAgICAgICAgICAgID8gbm9kZS5jaGlsZHJlblswXSAvLyBhcGktZXh0cmFjdG9yIHNvbWVob3cgZmFpbHMgdG8gaW5mZXIgdGhpc1xyXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICAgICAgaWYgKHNsb3RPdXRsZXQpIHtcclxuICAgICAgICAgICAgICAgIC8vIDxzbG90IHYtZm9yPVwiLi4uXCI+IG9yIDx0ZW1wbGF0ZSB2LWZvcj1cIi4uLlwiPjxzbG90Lz48L3RlbXBsYXRlPlxyXG4gICAgICAgICAgICAgICAgY2hpbGRCbG9jayA9IHNsb3RPdXRsZXQuY29kZWdlbk5vZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNUZW1wbGF0ZSAmJiBrZXlQcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIDx0ZW1wbGF0ZSB2LWZvcj1cIi4uLlwiIDprZXk9XCIuLi5cIj48c2xvdC8+PC90ZW1wbGF0ZT5cclxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGluamVjdCB0aGUga2V5IHRvIHRoZSByZW5kZXJTbG90KCkgY2FsbC5cclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcHJvcHMgZm9yIHJlbmRlclNsb3QgaXMgcGFzc2VkIGFzIHRoZSAzcmQgYXJndW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0UHJvcChjaGlsZEJsb2NrLCBrZXlQcm9wZXJ0eSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobmVlZEZyYWdtZW50V3JhcHBlcikge1xyXG4gICAgICAgICAgICAgICAgLy8gPHRlbXBsYXRlIHYtZm9yPVwiLi4uXCI+IHdpdGggdGV4dCBvciBtdWx0aS1lbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGdlbmVyYXRlIGEgZnJhZ21lbnQgYmxvY2sgZm9yIGVhY2ggbG9vcFxyXG4gICAgICAgICAgICAgICAgY2hpbGRCbG9jayA9IGNyZWF0ZVZOb2RlQ2FsbChjb250ZXh0LCBoZWxwZXIoRlJBR01FTlQpLCBrZXlQcm9wZXJ0eSA/IGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oW2tleVByb3BlcnR5XSkgOiB1bmRlZmluZWQsIG5vZGUuY2hpbGRyZW4sIDY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqLyArXHJcbiAgICAgICAgICAgICAgICAgICAgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGAgLyogJHtQYXRjaEZsYWdOYW1lc1s2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi9dfSAqL2BcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBgYCksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlLCB1bmRlZmluZWQsIGZhbHNlIC8qIGlzQ29tcG9uZW50ICovKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vcm1hbCBlbGVtZW50IHYtZm9yLiBEaXJlY3RseSB1c2UgdGhlIGNoaWxkJ3MgY29kZWdlbk5vZGVcclxuICAgICAgICAgICAgICAgIC8vIGJ1dCBtYXJrIGl0IGFzIGEgYmxvY2suXHJcbiAgICAgICAgICAgICAgICBjaGlsZEJsb2NrID0gY2hpbGRyZW5bMF1cclxuICAgICAgICAgICAgICAgICAgICAuY29kZWdlbk5vZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNUZW1wbGF0ZSAmJiBrZXlQcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluamVjdFByb3AoY2hpbGRCbG9jaywga2V5UHJvcGVydHksIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkQmxvY2suaXNCbG9jayAhPT0gIWlzU3RhYmxlRnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRCbG9jay5pc0Jsb2NrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN3aXRjaCBmcm9tIGJsb2NrIHRvIHZub2RlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUhlbHBlcihPUEVOX0JMT0NLKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlSGVscGVyKGdldFZOb2RlQmxvY2tIZWxwZXIoY29udGV4dC5pblNTUiwgY2hpbGRCbG9jay5pc0NvbXBvbmVudCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3dpdGNoIGZyb20gdm5vZGUgdG8gYmxvY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlSGVscGVyKGdldFZOb2RlSGVscGVyKGNvbnRleHQuaW5TU1IsIGNoaWxkQmxvY2suaXNDb21wb25lbnQpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjaGlsZEJsb2NrLmlzQmxvY2sgPSAhaXNTdGFibGVGcmFnbWVudDtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZEJsb2NrLmlzQmxvY2spIHtcclxuICAgICAgICAgICAgICAgICAgICBoZWxwZXIoT1BFTl9CTE9DSyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyKGdldFZOb2RlQmxvY2tIZWxwZXIoY29udGV4dC5pblNTUiwgY2hpbGRCbG9jay5pc0NvbXBvbmVudCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyKGdldFZOb2RlSGVscGVyKGNvbnRleHQuaW5TU1IsIGNoaWxkQmxvY2suaXNDb21wb25lbnQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWVtbykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbG9vcCA9IGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbihjcmVhdGVGb3JMb29wUGFyYW1zKGZvck5vZGUucGFyc2VSZXN1bHQsIFtcclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGBfY2FjaGVkYClcclxuICAgICAgICAgICAgICAgIF0pKTtcclxuICAgICAgICAgICAgICAgIGxvb3AuYm9keSA9IGNyZWF0ZUJsb2NrU3RhdGVtZW50KFtcclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oW2Bjb25zdCBfbWVtbyA9IChgLCBtZW1vLmV4cCwgYClgXSksXHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYGlmIChfY2FjaGVkYCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uKGtleUV4cCA/IFtgICYmIF9jYWNoZWQua2V5ID09PSBgLCBrZXlFeHBdIDogW10pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBgICYmICR7Y29udGV4dC5oZWxwZXJTdHJpbmcoSVNfTUVNT19TQU1FKX0oX2NhY2hlZCwgX21lbW8pKSByZXR1cm4gX2NhY2hlZGBcclxuICAgICAgICAgICAgICAgICAgICBdKSxcclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oW2Bjb25zdCBfaXRlbSA9IGAsIGNoaWxkQmxvY2tdKSxcclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGBfaXRlbS5tZW1vID0gX21lbW9gKSxcclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGByZXR1cm4gX2l0ZW1gKVxyXG4gICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJFeHAuYXJndW1lbnRzLnB1c2gobG9vcCwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgX2NhY2hlYCksIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oU3RyaW5nKGNvbnRleHQuY2FjaGVkKyspKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJFeHAuYXJndW1lbnRzLnB1c2goY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKGNyZWF0ZUZvckxvb3BQYXJhbXMoZm9yTm9kZS5wYXJzZVJlc3VsdCksIGNoaWxkQmxvY2ssIHRydWUgLyogZm9yY2UgbmV3bGluZSAqLykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG59KTtcclxuLy8gdGFyZ2V0LWFnbm9zdGljIHRyYW5zZm9ybSB1c2VkIGZvciBib3RoIENsaWVudCBhbmQgU1NSXHJcbmZ1bmN0aW9uIHByb2Nlc3NGb3Iobm9kZSwgZGlyLCBjb250ZXh0LCBwcm9jZXNzQ29kZWdlbikge1xyXG4gICAgaWYgKCFkaXIuZXhwKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzEgLyogWF9WX0ZPUl9OT19FWFBSRVNTSU9OICovLCBkaXIubG9jKSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcGFyc2VSZXN1bHQgPSBwYXJzZUZvckV4cHJlc3Npb24oXHJcbiAgICAvLyBjYW4gb25seSBiZSBzaW1wbGUgZXhwcmVzc2lvbiBiZWNhdXNlIHZGb3IgdHJhbnNmb3JtIGlzIGFwcGxpZWRcclxuICAgIC8vIGJlZm9yZSBleHByZXNzaW9uIHRyYW5zZm9ybS5cclxuICAgIGRpci5leHAsIGNvbnRleHQpO1xyXG4gICAgaWYgKCFwYXJzZVJlc3VsdCkge1xyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDMyIC8qIFhfVl9GT1JfTUFMRk9STUVEX0VYUFJFU1NJT04gKi8sIGRpci5sb2MpKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IGFkZElkZW50aWZpZXJzLCByZW1vdmVJZGVudGlmaWVycywgc2NvcGVzIH0gPSBjb250ZXh0O1xyXG4gICAgY29uc3QgeyBzb3VyY2UsIHZhbHVlLCBrZXksIGluZGV4IH0gPSBwYXJzZVJlc3VsdDtcclxuICAgIGNvbnN0IGZvck5vZGUgPSB7XHJcbiAgICAgICAgdHlwZTogMTEgLyogRk9SICovLFxyXG4gICAgICAgIGxvYzogZGlyLmxvYyxcclxuICAgICAgICBzb3VyY2UsXHJcbiAgICAgICAgdmFsdWVBbGlhczogdmFsdWUsXHJcbiAgICAgICAga2V5QWxpYXM6IGtleSxcclxuICAgICAgICBvYmplY3RJbmRleEFsaWFzOiBpbmRleCxcclxuICAgICAgICBwYXJzZVJlc3VsdCxcclxuICAgICAgICBjaGlsZHJlbjogaXNUZW1wbGF0ZU5vZGUobm9kZSkgPyBub2RlLmNoaWxkcmVuIDogW25vZGVdXHJcbiAgICB9O1xyXG4gICAgY29udGV4dC5yZXBsYWNlTm9kZShmb3JOb2RlKTtcclxuICAgIC8vIGJvb2trZWVwaW5nXHJcbiAgICBzY29wZXMudkZvcisrO1xyXG4gICAgY29uc3Qgb25FeGl0ID0gcHJvY2Vzc0NvZGVnZW4gJiYgcHJvY2Vzc0NvZGVnZW4oZm9yTm9kZSk7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIHNjb3Blcy52Rm9yLS07XHJcbiAgICAgICAgaWYgKG9uRXhpdClcclxuICAgICAgICAgICAgb25FeGl0KCk7XHJcbiAgICB9O1xyXG59XHJcbmNvbnN0IGZvckFsaWFzUkUgPSAvKFtcXHNcXFNdKj8pXFxzKyg/OmlufG9mKVxccysoW1xcc1xcU10qKS87XHJcbi8vIFRoaXMgcmVnZXggZG9lc24ndCBjb3ZlciB0aGUgY2FzZSBpZiBrZXkgb3IgaW5kZXggYWxpYXNlcyBoYXZlIGRlc3RydWN0dXJpbmcsXHJcbi8vIGJ1dCB0aG9zZSBkbyBub3QgbWFrZSBzZW5zZSBpbiB0aGUgZmlyc3QgcGxhY2UsIHNvIHRoaXMgd29ya3MgaW4gcHJhY3RpY2UuXHJcbmNvbnN0IGZvckl0ZXJhdG9yUkUgPSAvLChbXixcXH1cXF1dKikoPzosKFteLFxcfVxcXV0qKSk/JC87XHJcbmNvbnN0IHN0cmlwUGFyZW5zUkUgPSAvXlxcKHxcXCkkL2c7XHJcbmZ1bmN0aW9uIHBhcnNlRm9yRXhwcmVzc2lvbihpbnB1dCwgY29udGV4dCkge1xyXG4gICAgY29uc3QgbG9jID0gaW5wdXQubG9jO1xyXG4gICAgY29uc3QgZXhwID0gaW5wdXQuY29udGVudDtcclxuICAgIGNvbnN0IGluTWF0Y2ggPSBleHAubWF0Y2goZm9yQWxpYXNSRSk7XHJcbiAgICBpZiAoIWluTWF0Y2gpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgY29uc3QgWywgTEhTLCBSSFNdID0gaW5NYXRjaDtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHtcclxuICAgICAgICBzb3VyY2U6IGNyZWF0ZUFsaWFzRXhwcmVzc2lvbihsb2MsIFJIUy50cmltKCksIGV4cC5pbmRleE9mKFJIUywgTEhTLmxlbmd0aCkpLFxyXG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXHJcbiAgICAgICAga2V5OiB1bmRlZmluZWQsXHJcbiAgICAgICAgaW5kZXg6IHVuZGVmaW5lZFxyXG4gICAgfTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgdHJ1ZSkge1xyXG4gICAgICAgIHZhbGlkYXRlQnJvd3NlckV4cHJlc3Npb24ocmVzdWx0LnNvdXJjZSwgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBsZXQgdmFsdWVDb250ZW50ID0gTEhTLnRyaW0oKS5yZXBsYWNlKHN0cmlwUGFyZW5zUkUsICcnKS50cmltKCk7XHJcbiAgICBjb25zdCB0cmltbWVkT2Zmc2V0ID0gTEhTLmluZGV4T2YodmFsdWVDb250ZW50KTtcclxuICAgIGNvbnN0IGl0ZXJhdG9yTWF0Y2ggPSB2YWx1ZUNvbnRlbnQubWF0Y2goZm9ySXRlcmF0b3JSRSk7XHJcbiAgICBpZiAoaXRlcmF0b3JNYXRjaCkge1xyXG4gICAgICAgIHZhbHVlQ29udGVudCA9IHZhbHVlQ29udGVudC5yZXBsYWNlKGZvckl0ZXJhdG9yUkUsICcnKS50cmltKCk7XHJcbiAgICAgICAgY29uc3Qga2V5Q29udGVudCA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xyXG4gICAgICAgIGxldCBrZXlPZmZzZXQ7XHJcbiAgICAgICAgaWYgKGtleUNvbnRlbnQpIHtcclxuICAgICAgICAgICAga2V5T2Zmc2V0ID0gZXhwLmluZGV4T2Yoa2V5Q29udGVudCwgdHJpbW1lZE9mZnNldCArIHZhbHVlQ29udGVudC5sZW5ndGgpO1xyXG4gICAgICAgICAgICByZXN1bHQua2V5ID0gY3JlYXRlQWxpYXNFeHByZXNzaW9uKGxvYywga2V5Q29udGVudCwga2V5T2Zmc2V0KTtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKHJlc3VsdC5rZXksIGNvbnRleHQsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpdGVyYXRvck1hdGNoWzJdKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4Q29udGVudCA9IGl0ZXJhdG9yTWF0Y2hbMl0udHJpbSgpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXhDb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuaW5kZXggPSBjcmVhdGVBbGlhc0V4cHJlc3Npb24obG9jLCBpbmRleENvbnRlbnQsIGV4cC5pbmRleE9mKGluZGV4Q29udGVudCwgcmVzdWx0LmtleVxyXG4gICAgICAgICAgICAgICAgICAgID8ga2V5T2Zmc2V0ICsga2V5Q29udGVudC5sZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICA6IHRyaW1tZWRPZmZzZXQgKyB2YWx1ZUNvbnRlbnQubGVuZ3RoKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKHJlc3VsdC5pbmRleCwgY29udGV4dCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodmFsdWVDb250ZW50KSB7XHJcbiAgICAgICAgcmVzdWx0LnZhbHVlID0gY3JlYXRlQWxpYXNFeHByZXNzaW9uKGxvYywgdmFsdWVDb250ZW50LCB0cmltbWVkT2Zmc2V0KTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHRydWUpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihyZXN1bHQudmFsdWUsIGNvbnRleHQsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQWxpYXNFeHByZXNzaW9uKHJhbmdlLCBjb250ZW50LCBvZmZzZXQpIHtcclxuICAgIHJldHVybiBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGNvbnRlbnQsIGZhbHNlLCBnZXRJbm5lclJhbmdlKHJhbmdlLCBvZmZzZXQsIGNvbnRlbnQubGVuZ3RoKSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRm9yTG9vcFBhcmFtcyh7IHZhbHVlLCBrZXksIGluZGV4IH0sIG1lbW9BcmdzID0gW10pIHtcclxuICAgIHJldHVybiBjcmVhdGVQYXJhbXNMaXN0KFt2YWx1ZSwga2V5LCBpbmRleCwgLi4ubWVtb0FyZ3NdKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVQYXJhbXNMaXN0KGFyZ3MpIHtcclxuICAgIGxldCBpID0gYXJncy5sZW5ndGg7XHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgaWYgKGFyZ3NbaV0pXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyZ3NcclxuICAgICAgICAuc2xpY2UoMCwgaSArIDEpXHJcbiAgICAgICAgLm1hcCgoYXJnLCBpKSA9PiBhcmcgfHwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgX2AucmVwZWF0KGkgKyAxKSwgZmFsc2UpKTtcclxufVxuXG5jb25zdCBkZWZhdWx0RmFsbGJhY2sgPSBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGB1bmRlZmluZWRgLCBmYWxzZSk7XHJcbi8vIEEgTm9kZVRyYW5zZm9ybSB0aGF0OlxyXG4vLyAxLiBUcmFja3Mgc2NvcGUgaWRlbnRpZmllcnMgZm9yIHNjb3BlZCBzbG90cyBzbyB0aGF0IHRoZXkgZG9uJ3QgZ2V0IHByZWZpeGVkXHJcbi8vICAgIGJ5IHRyYW5zZm9ybUV4cHJlc3Npb24uIFRoaXMgaXMgb25seSBhcHBsaWVkIGluIG5vbi1icm93c2VyIGJ1aWxkcyB3aXRoXHJcbi8vICAgIHsgcHJlZml4SWRlbnRpZmllcnM6IHRydWUgfS5cclxuLy8gMi4gVHJhY2sgdi1zbG90IGRlcHRocyBzbyB0aGF0IHdlIGtub3cgYSBzbG90IGlzIGluc2lkZSBhbm90aGVyIHNsb3QuXHJcbi8vICAgIE5vdGUgdGhlIGV4aXQgY2FsbGJhY2sgaXMgZXhlY3V0ZWQgYmVmb3JlIGJ1aWxkU2xvdHMoKSBvbiB0aGUgc2FtZSBub2RlLFxyXG4vLyAgICBzbyBvbmx5IG5lc3RlZCBzbG90cyBzZWUgcG9zaXRpdmUgbnVtYmVycy5cclxuY29uc3QgdHJhY2tTbG90U2NvcGVzID0gKG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgIChub2RlLnRhZ1R5cGUgPT09IDEgLyogQ09NUE9ORU5UICovIHx8XHJcbiAgICAgICAgICAgIG5vZGUudGFnVHlwZSA9PT0gMyAvKiBURU1QTEFURSAqLykpIHtcclxuICAgICAgICAvLyBXZSBhcmUgb25seSBjaGVja2luZyBub24tZW1wdHkgdi1zbG90IGhlcmVcclxuICAgICAgICAvLyBzaW5jZSB3ZSBvbmx5IGNhcmUgYWJvdXQgc2xvdHMgdGhhdCBpbnRyb2R1Y2Ugc2NvcGUgdmFyaWFibGVzLlxyXG4gICAgICAgIGNvbnN0IHZTbG90ID0gZmluZERpcihub2RlLCAnc2xvdCcpO1xyXG4gICAgICAgIGlmICh2U2xvdCkge1xyXG4gICAgICAgICAgICB2U2xvdC5leHA7XHJcbiAgICAgICAgICAgIGNvbnRleHQuc2NvcGVzLnZTbG90Kys7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNjb3Blcy52U2xvdC0tO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuLy8gQSBOb2RlVHJhbnNmb3JtIHRoYXQgdHJhY2tzIHNjb3BlIGlkZW50aWZpZXJzIGZvciBzY29wZWQgc2xvdHMgd2l0aCB2LWZvci5cclxuLy8gVGhpcyB0cmFuc2Zvcm0gaXMgb25seSBhcHBsaWVkIGluIG5vbi1icm93c2VyIGJ1aWxkcyB3aXRoIHsgcHJlZml4SWRlbnRpZmllcnM6IHRydWUgfVxyXG5jb25zdCB0cmFja1ZGb3JTbG90U2NvcGVzID0gKG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGxldCB2Rm9yO1xyXG4gICAgaWYgKGlzVGVtcGxhdGVOb2RlKG5vZGUpICYmXHJcbiAgICAgICAgbm9kZS5wcm9wcy5zb21lKGlzVlNsb3QpICYmXHJcbiAgICAgICAgKHZGb3IgPSBmaW5kRGlyKG5vZGUsICdmb3InKSkpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSAodkZvci5wYXJzZVJlc3VsdCA9IHBhcnNlRm9yRXhwcmVzc2lvbih2Rm9yLmV4cCwgY29udGV4dCkpO1xyXG4gICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSwga2V5LCBpbmRleCB9ID0gcmVzdWx0O1xyXG4gICAgICAgICAgICBjb25zdCB7IGFkZElkZW50aWZpZXJzLCByZW1vdmVJZGVudGlmaWVycyB9ID0gY29udGV4dDtcclxuICAgICAgICAgICAgdmFsdWUgJiYgYWRkSWRlbnRpZmllcnModmFsdWUpO1xyXG4gICAgICAgICAgICBrZXkgJiYgYWRkSWRlbnRpZmllcnMoa2V5KTtcclxuICAgICAgICAgICAgaW5kZXggJiYgYWRkSWRlbnRpZmllcnMoaW5kZXgpO1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgJiYgcmVtb3ZlSWRlbnRpZmllcnModmFsdWUpO1xyXG4gICAgICAgICAgICAgICAga2V5ICYmIHJlbW92ZUlkZW50aWZpZXJzKGtleSk7XHJcbiAgICAgICAgICAgICAgICBpbmRleCAmJiByZW1vdmVJZGVudGlmaWVycyhpbmRleCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5jb25zdCBidWlsZENsaWVudFNsb3RGbiA9IChwcm9wcywgY2hpbGRyZW4sIGxvYykgPT4gY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKHByb3BzLCBjaGlsZHJlbiwgZmFsc2UgLyogbmV3bGluZSAqLywgdHJ1ZSAvKiBpc1Nsb3QgKi8sIGNoaWxkcmVuLmxlbmd0aCA/IGNoaWxkcmVuWzBdLmxvYyA6IGxvYyk7XHJcbi8vIEluc3RlYWQgb2YgYmVpbmcgYSBEaXJlY3RpdmVUcmFuc2Zvcm0sIHYtc2xvdCBwcm9jZXNzaW5nIGlzIGNhbGxlZCBkdXJpbmdcclxuLy8gdHJhbnNmb3JtRWxlbWVudCB0byBidWlsZCB0aGUgc2xvdHMgb2JqZWN0IGZvciBhIGNvbXBvbmVudC5cclxuZnVuY3Rpb24gYnVpbGRTbG90cyhub2RlLCBjb250ZXh0LCBidWlsZFNsb3RGbiA9IGJ1aWxkQ2xpZW50U2xvdEZuKSB7XHJcbiAgICBjb250ZXh0LmhlbHBlcihXSVRIX0NUWCk7XHJcbiAgICBjb25zdCB7IGNoaWxkcmVuLCBsb2MgfSA9IG5vZGU7XHJcbiAgICBjb25zdCBzbG90c1Byb3BlcnRpZXMgPSBbXTtcclxuICAgIGNvbnN0IGR5bmFtaWNTbG90cyA9IFtdO1xyXG4gICAgLy8gSWYgdGhlIHNsb3QgaXMgaW5zaWRlIGEgdi1mb3Igb3IgYW5vdGhlciB2LXNsb3QsIGZvcmNlIGl0IHRvIGJlIGR5bmFtaWNcclxuICAgIC8vIHNpbmNlIGl0IGxpa2VseSB1c2VzIGEgc2NvcGUgdmFyaWFibGUuXHJcbiAgICBsZXQgaGFzRHluYW1pY1Nsb3RzID0gY29udGV4dC5zY29wZXMudlNsb3QgPiAwIHx8IGNvbnRleHQuc2NvcGVzLnZGb3IgPiAwO1xyXG4gICAgLy8gMS4gQ2hlY2sgZm9yIHNsb3Qgd2l0aCBzbG90UHJvcHMgb24gY29tcG9uZW50IGl0c2VsZi5cclxuICAgIC8vICAgIDxDb21wIHYtc2xvdD1cInsgcHJvcCB9XCIvPlxyXG4gICAgY29uc3Qgb25Db21wb25lbnRTbG90ID0gZmluZERpcihub2RlLCAnc2xvdCcsIHRydWUpO1xyXG4gICAgaWYgKG9uQ29tcG9uZW50U2xvdCkge1xyXG4gICAgICAgIGNvbnN0IHsgYXJnLCBleHAgfSA9IG9uQ29tcG9uZW50U2xvdDtcclxuICAgICAgICBpZiAoYXJnICYmICFpc1N0YXRpY0V4cChhcmcpKSB7XHJcbiAgICAgICAgICAgIGhhc0R5bmFtaWNTbG90cyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNsb3RzUHJvcGVydGllcy5wdXNoKGNyZWF0ZU9iamVjdFByb3BlcnR5KGFyZyB8fCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKCdkZWZhdWx0JywgdHJ1ZSksIGJ1aWxkU2xvdEZuKGV4cCwgY2hpbGRyZW4sIGxvYykpKTtcclxuICAgIH1cclxuICAgIC8vIDIuIEl0ZXJhdGUgdGhyb3VnaCBjaGlsZHJlbiBhbmQgY2hlY2sgZm9yIHRlbXBsYXRlIHNsb3RzXHJcbiAgICAvLyAgICA8dGVtcGxhdGUgdi1zbG90OmZvbz1cInsgcHJvcCB9XCI+XHJcbiAgICBsZXQgaGFzVGVtcGxhdGVTbG90cyA9IGZhbHNlO1xyXG4gICAgbGV0IGhhc05hbWVkRGVmYXVsdFNsb3QgPSBmYWxzZTtcclxuICAgIGNvbnN0IGltcGxpY2l0RGVmYXVsdENoaWxkcmVuID0gW107XHJcbiAgICBjb25zdCBzZWVuU2xvdE5hbWVzID0gbmV3IFNldCgpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHNsb3RFbGVtZW50ID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgbGV0IHNsb3REaXI7XHJcbiAgICAgICAgaWYgKCFpc1RlbXBsYXRlTm9kZShzbG90RWxlbWVudCkgfHxcclxuICAgICAgICAgICAgIShzbG90RGlyID0gZmluZERpcihzbG90RWxlbWVudCwgJ3Nsb3QnLCB0cnVlKSkpIHtcclxuICAgICAgICAgICAgLy8gbm90IGEgPHRlbXBsYXRlIHYtc2xvdD4sIHNraXAuXHJcbiAgICAgICAgICAgIGlmIChzbG90RWxlbWVudC50eXBlICE9PSAzIC8qIENPTU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgIGltcGxpY2l0RGVmYXVsdENoaWxkcmVuLnB1c2goc2xvdEVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob25Db21wb25lbnRTbG90KSB7XHJcbiAgICAgICAgICAgIC8vIGFscmVhZHkgaGFzIG9uLWNvbXBvbmVudCBzbG90IC0gdGhpcyBpcyBpbmNvcnJlY3QgdXNhZ2UuXHJcbiAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDM3IC8qIFhfVl9TTE9UX01JWEVEX1NMT1RfVVNBR0UgKi8sIHNsb3REaXIubG9jKSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBoYXNUZW1wbGF0ZVNsb3RzID0gdHJ1ZTtcclxuICAgICAgICBjb25zdCB7IGNoaWxkcmVuOiBzbG90Q2hpbGRyZW4sIGxvYzogc2xvdExvYyB9ID0gc2xvdEVsZW1lbnQ7XHJcbiAgICAgICAgY29uc3QgeyBhcmc6IHNsb3ROYW1lID0gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgZGVmYXVsdGAsIHRydWUpLCBleHA6IHNsb3RQcm9wcywgbG9jOiBkaXJMb2MgfSA9IHNsb3REaXI7XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgbmFtZSBpcyBkeW5hbWljLlxyXG4gICAgICAgIGxldCBzdGF0aWNTbG90TmFtZTtcclxuICAgICAgICBpZiAoaXNTdGF0aWNFeHAoc2xvdE5hbWUpKSB7XHJcbiAgICAgICAgICAgIHN0YXRpY1Nsb3ROYW1lID0gc2xvdE5hbWUgPyBzbG90TmFtZS5jb250ZW50IDogYGRlZmF1bHRgO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaGFzRHluYW1pY1Nsb3RzID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2xvdEZ1bmN0aW9uID0gYnVpbGRTbG90Rm4oc2xvdFByb3BzLCBzbG90Q2hpbGRyZW4sIHNsb3RMb2MpO1xyXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgc2xvdCBpcyBjb25kaXRpb25hbCAodi1pZi92LWZvcilcclxuICAgICAgICBsZXQgdklmO1xyXG4gICAgICAgIGxldCB2RWxzZTtcclxuICAgICAgICBsZXQgdkZvcjtcclxuICAgICAgICBpZiAoKHZJZiA9IGZpbmREaXIoc2xvdEVsZW1lbnQsICdpZicpKSkge1xyXG4gICAgICAgICAgICBoYXNEeW5hbWljU2xvdHMgPSB0cnVlO1xyXG4gICAgICAgICAgICBkeW5hbWljU2xvdHMucHVzaChjcmVhdGVDb25kaXRpb25hbEV4cHJlc3Npb24odklmLmV4cCwgYnVpbGREeW5hbWljU2xvdChzbG90TmFtZSwgc2xvdEZ1bmN0aW9uKSwgZGVmYXVsdEZhbGxiYWNrKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCh2RWxzZSA9IGZpbmREaXIoc2xvdEVsZW1lbnQsIC9eZWxzZSgtaWYpPyQvLCB0cnVlIC8qIGFsbG93RW1wdHkgKi8pKSkge1xyXG4gICAgICAgICAgICAvLyBmaW5kIGFkamFjZW50IHYtaWZcclxuICAgICAgICAgICAgbGV0IGogPSBpO1xyXG4gICAgICAgICAgICBsZXQgcHJldjtcclxuICAgICAgICAgICAgd2hpbGUgKGotLSkge1xyXG4gICAgICAgICAgICAgICAgcHJldiA9IGNoaWxkcmVuW2pdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXYudHlwZSAhPT0gMyAvKiBDT01NRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByZXYgJiYgaXNUZW1wbGF0ZU5vZGUocHJldikgJiYgZmluZERpcihwcmV2LCAnaWYnKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG5vZGVcclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgIGktLTtcclxuICAgICAgICAgICAgICAgIC8vIGF0dGFjaCB0aGlzIHNsb3QgdG8gcHJldmlvdXMgY29uZGl0aW9uYWxcclxuICAgICAgICAgICAgICAgIGxldCBjb25kaXRpb25hbCA9IGR5bmFtaWNTbG90c1tkeW5hbWljU2xvdHMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29uZGl0aW9uYWwuYWx0ZXJuYXRlLnR5cGUgPT09IDE5IC8qIEpTX0NPTkRJVElPTkFMX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb25hbCA9IGNvbmRpdGlvbmFsLmFsdGVybmF0ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbmRpdGlvbmFsLmFsdGVybmF0ZSA9IHZFbHNlLmV4cFxyXG4gICAgICAgICAgICAgICAgICAgID8gY3JlYXRlQ29uZGl0aW9uYWxFeHByZXNzaW9uKHZFbHNlLmV4cCwgYnVpbGREeW5hbWljU2xvdChzbG90TmFtZSwgc2xvdEZ1bmN0aW9uKSwgZGVmYXVsdEZhbGxiYWNrKVxyXG4gICAgICAgICAgICAgICAgICAgIDogYnVpbGREeW5hbWljU2xvdChzbG90TmFtZSwgc2xvdEZ1bmN0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDMwIC8qIFhfVl9FTFNFX05PX0FESkFDRU5UX0lGICovLCB2RWxzZS5sb2MpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgodkZvciA9IGZpbmREaXIoc2xvdEVsZW1lbnQsICdmb3InKSkpIHtcclxuICAgICAgICAgICAgaGFzRHluYW1pY1Nsb3RzID0gdHJ1ZTtcclxuICAgICAgICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSB2Rm9yLnBhcnNlUmVzdWx0IHx8XHJcbiAgICAgICAgICAgICAgICBwYXJzZUZvckV4cHJlc3Npb24odkZvci5leHAsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAocGFyc2VSZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFJlbmRlciB0aGUgZHluYW1pYyBzbG90cyBhcyBhbiBhcnJheSBhbmQgYWRkIGl0IHRvIHRoZSBjcmVhdGVTbG90KClcclxuICAgICAgICAgICAgICAgIC8vIGFyZ3MuIFRoZSBydW50aW1lIGtub3dzIGhvdyB0byBoYW5kbGUgaXQgYXBwcm9wcmlhdGVseS5cclxuICAgICAgICAgICAgICAgIGR5bmFtaWNTbG90cy5wdXNoKGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKFJFTkRFUl9MSVNUKSwgW1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlUmVzdWx0LnNvdXJjZSxcclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24oY3JlYXRlRm9yTG9vcFBhcmFtcyhwYXJzZVJlc3VsdCksIGJ1aWxkRHluYW1pY1Nsb3Qoc2xvdE5hbWUsIHNsb3RGdW5jdGlvbiksIHRydWUgLyogZm9yY2UgbmV3bGluZSAqLylcclxuICAgICAgICAgICAgICAgIF0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDMyIC8qIFhfVl9GT1JfTUFMRk9STUVEX0VYUFJFU1NJT04gKi8sIHZGb3IubG9jKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGR1cGxpY2F0ZSBzdGF0aWMgbmFtZXNcclxuICAgICAgICAgICAgaWYgKHN0YXRpY1Nsb3ROYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VlblNsb3ROYW1lcy5oYXMoc3RhdGljU2xvdE5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzggLyogWF9WX1NMT1RfRFVQTElDQVRFX1NMT1RfTkFNRVMgKi8sIGRpckxvYykpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2VlblNsb3ROYW1lcy5hZGQoc3RhdGljU2xvdE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRpY1Nsb3ROYW1lID09PSAnZGVmYXVsdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNOYW1lZERlZmF1bHRTbG90ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzbG90c1Byb3BlcnRpZXMucHVzaChjcmVhdGVPYmplY3RQcm9wZXJ0eShzbG90TmFtZSwgc2xvdEZ1bmN0aW9uKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFvbkNvbXBvbmVudFNsb3QpIHtcclxuICAgICAgICBjb25zdCBidWlsZERlZmF1bHRTbG90UHJvcGVydHkgPSAocHJvcHMsIGNoaWxkcmVuKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZuID0gYnVpbGRTbG90Rm4ocHJvcHMsIGNoaWxkcmVuLCBsb2MpO1xyXG4gICAgICAgICAgICBpZiAoY29udGV4dC5jb21wYXRDb25maWcpIHtcclxuICAgICAgICAgICAgICAgIGZuLmlzTm9uU2NvcGVkU2xvdCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU9iamVjdFByb3BlcnR5KGBkZWZhdWx0YCwgZm4pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKCFoYXNUZW1wbGF0ZVNsb3RzKSB7XHJcbiAgICAgICAgICAgIC8vIGltcGxpY2l0IGRlZmF1bHQgc2xvdCAob24gY29tcG9uZW50KVxyXG4gICAgICAgICAgICBzbG90c1Byb3BlcnRpZXMucHVzaChidWlsZERlZmF1bHRTbG90UHJvcGVydHkodW5kZWZpbmVkLCBjaGlsZHJlbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpbXBsaWNpdERlZmF1bHRDaGlsZHJlbi5sZW5ndGggJiZcclxuICAgICAgICAgICAgLy8gIzM3NjZcclxuICAgICAgICAgICAgLy8gd2l0aCB3aGl0ZXNwYWNlOiAncHJlc2VydmUnLCB3aGl0ZXNwYWNlcyBiZXR3ZWVuIHNsb3RzIHdpbGwgZW5kIHVwIGluXHJcbiAgICAgICAgICAgIC8vIGltcGxpY2l0RGVmYXVsdENoaWxkcmVuLiBJZ25vcmUgaWYgYWxsIGltcGxpY2l0IGNoaWxkcmVuIGFyZSB3aGl0ZXNwYWNlcy5cclxuICAgICAgICAgICAgaW1wbGljaXREZWZhdWx0Q2hpbGRyZW4uc29tZShub2RlID0+IGlzTm9uV2hpdGVzcGFjZUNvbnRlbnQobm9kZSkpKSB7XHJcbiAgICAgICAgICAgIC8vIGltcGxpY2l0IGRlZmF1bHQgc2xvdCAobWl4ZWQgd2l0aCBuYW1lZCBzbG90cylcclxuICAgICAgICAgICAgaWYgKGhhc05hbWVkRGVmYXVsdFNsb3QpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDM5IC8qIFhfVl9TTE9UX0VYVFJBTkVPVVNfREVGQVVMVF9TTE9UX0NISUxEUkVOICovLCBpbXBsaWNpdERlZmF1bHRDaGlsZHJlblswXS5sb2MpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNsb3RzUHJvcGVydGllcy5wdXNoKGJ1aWxkRGVmYXVsdFNsb3RQcm9wZXJ0eSh1bmRlZmluZWQsIGltcGxpY2l0RGVmYXVsdENoaWxkcmVuKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBzbG90RmxhZyA9IGhhc0R5bmFtaWNTbG90c1xyXG4gICAgICAgID8gMiAvKiBEWU5BTUlDICovXHJcbiAgICAgICAgOiBoYXNGb3J3YXJkZWRTbG90cyhub2RlLmNoaWxkcmVuKVxyXG4gICAgICAgICAgICA/IDMgLyogRk9SV0FSREVEICovXHJcbiAgICAgICAgICAgIDogMSAvKiBTVEFCTEUgKi87XHJcbiAgICBsZXQgc2xvdHMgPSBjcmVhdGVPYmplY3RFeHByZXNzaW9uKHNsb3RzUHJvcGVydGllcy5jb25jYXQoY3JlYXRlT2JqZWN0UHJvcGVydHkoYF9gLCBcclxuICAgIC8vIDIgPSBjb21waWxlZCBidXQgZHluYW1pYyA9IGNhbiBza2lwIG5vcm1hbGl6YXRpb24sIGJ1dCBtdXN0IHJ1biBkaWZmXHJcbiAgICAvLyAxID0gY29tcGlsZWQgYW5kIHN0YXRpYyA9IGNhbiBza2lwIG5vcm1hbGl6YXRpb24gQU5EIGRpZmYgYXMgb3B0aW1pemVkXHJcbiAgICBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKHNsb3RGbGFnICsgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGAgLyogJHtzbG90RmxhZ3NUZXh0W3Nsb3RGbGFnXX0gKi9gIDogYGApLCBmYWxzZSkpKSwgbG9jKTtcclxuICAgIGlmIChkeW5hbWljU2xvdHMubGVuZ3RoKSB7XHJcbiAgICAgICAgc2xvdHMgPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihDUkVBVEVfU0xPVFMpLCBbXHJcbiAgICAgICAgICAgIHNsb3RzLFxyXG4gICAgICAgICAgICBjcmVhdGVBcnJheUV4cHJlc3Npb24oZHluYW1pY1Nsb3RzKVxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzbG90cyxcclxuICAgICAgICBoYXNEeW5hbWljU2xvdHNcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gYnVpbGREeW5hbWljU2xvdChuYW1lLCBmbikge1xyXG4gICAgcmV0dXJuIGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oW1xyXG4gICAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KGBuYW1lYCwgbmFtZSksXHJcbiAgICAgICAgY3JlYXRlT2JqZWN0UHJvcGVydHkoYGZuYCwgZm4pXHJcbiAgICBdKTtcclxufVxyXG5mdW5jdGlvbiBoYXNGb3J3YXJkZWRTbG90cyhjaGlsZHJlbikge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgc3dpdGNoIChjaGlsZC50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMSAvKiBFTEVNRU5UICovOlxyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnRhZ1R5cGUgPT09IDIgLyogU0xPVCAqLyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGhhc0ZvcndhcmRlZFNsb3RzKGNoaWxkLmNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgOSAvKiBJRiAqLzpcclxuICAgICAgICAgICAgICAgIGlmIChoYXNGb3J3YXJkZWRTbG90cyhjaGlsZC5icmFuY2hlcykpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxMCAvKiBJRl9CUkFOQ0ggKi86XHJcbiAgICAgICAgICAgIGNhc2UgMTEgLyogRk9SICovOlxyXG4gICAgICAgICAgICAgICAgaWYgKGhhc0ZvcndhcmRlZFNsb3RzKGNoaWxkLmNoaWxkcmVuKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBpc05vbldoaXRlc3BhY2VDb250ZW50KG5vZGUpIHtcclxuICAgIGlmIChub2RlLnR5cGUgIT09IDIgLyogVEVYVCAqLyAmJiBub2RlLnR5cGUgIT09IDEyIC8qIFRFWFRfQ0FMTCAqLylcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIHJldHVybiBub2RlLnR5cGUgPT09IDIgLyogVEVYVCAqL1xyXG4gICAgICAgID8gISFub2RlLmNvbnRlbnQudHJpbSgpXHJcbiAgICAgICAgOiBpc05vbldoaXRlc3BhY2VDb250ZW50KG5vZGUuY29udGVudCk7XHJcbn1cblxuLy8gc29tZSBkaXJlY3RpdmUgdHJhbnNmb3JtcyAoZS5nLiB2LW1vZGVsKSBtYXkgcmV0dXJuIGEgc3ltYm9sIGZvciBydW50aW1lXHJcbi8vIGltcG9ydCwgd2hpY2ggc2hvdWxkIGJlIHVzZWQgaW5zdGVhZCBvZiBhIHJlc29sdmVEaXJlY3RpdmUgY2FsbC5cclxuY29uc3QgZGlyZWN0aXZlSW1wb3J0TWFwID0gbmV3IFdlYWtNYXAoKTtcclxuLy8gZ2VuZXJhdGUgYSBKYXZhU2NyaXB0IEFTVCBmb3IgdGhpcyBlbGVtZW50J3MgY29kZWdlblxyXG5jb25zdCB0cmFuc2Zvcm1FbGVtZW50ID0gKG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIC8vIHBlcmZvcm0gdGhlIHdvcmsgb24gZXhpdCwgYWZ0ZXIgYWxsIGNoaWxkIGV4cHJlc3Npb25zIGhhdmUgYmVlblxyXG4gICAgLy8gcHJvY2Vzc2VkIGFuZCBtZXJnZWQuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gcG9zdFRyYW5zZm9ybUVsZW1lbnQoKSB7XHJcbiAgICAgICAgbm9kZSA9IGNvbnRleHQuY3VycmVudE5vZGU7XHJcbiAgICAgICAgaWYgKCEobm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAgICAgKG5vZGUudGFnVHlwZSA9PT0gMCAvKiBFTEVNRU5UICovIHx8XHJcbiAgICAgICAgICAgICAgICBub2RlLnRhZ1R5cGUgPT09IDEgLyogQ09NUE9ORU5UICovKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IHRhZywgcHJvcHMgfSA9IG5vZGU7XHJcbiAgICAgICAgY29uc3QgaXNDb21wb25lbnQgPSBub2RlLnRhZ1R5cGUgPT09IDEgLyogQ09NUE9ORU5UICovO1xyXG4gICAgICAgIC8vIFRoZSBnb2FsIG9mIHRoZSB0cmFuc2Zvcm0gaXMgdG8gY3JlYXRlIGEgY29kZWdlbk5vZGUgaW1wbGVtZW50aW5nIHRoZVxyXG4gICAgICAgIC8vIFZOb2RlQ2FsbCBpbnRlcmZhY2UuXHJcbiAgICAgICAgbGV0IHZub2RlVGFnID0gaXNDb21wb25lbnRcclxuICAgICAgICAgICAgPyByZXNvbHZlQ29tcG9uZW50VHlwZShub2RlLCBjb250ZXh0KVxyXG4gICAgICAgICAgICA6IGBcIiR7dGFnfVwiYDtcclxuICAgICAgICBjb25zdCBpc0R5bmFtaWNDb21wb25lbnQgPSBpc09iamVjdCh2bm9kZVRhZykgJiYgdm5vZGVUYWcuY2FsbGVlID09PSBSRVNPTFZFX0RZTkFNSUNfQ09NUE9ORU5UO1xyXG4gICAgICAgIGxldCB2bm9kZVByb3BzO1xyXG4gICAgICAgIGxldCB2bm9kZUNoaWxkcmVuO1xyXG4gICAgICAgIGxldCB2bm9kZVBhdGNoRmxhZztcclxuICAgICAgICBsZXQgcGF0Y2hGbGFnID0gMDtcclxuICAgICAgICBsZXQgdm5vZGVEeW5hbWljUHJvcHM7XHJcbiAgICAgICAgbGV0IGR5bmFtaWNQcm9wTmFtZXM7XHJcbiAgICAgICAgbGV0IHZub2RlRGlyZWN0aXZlcztcclxuICAgICAgICBsZXQgc2hvdWxkVXNlQmxvY2sgPSBcclxuICAgICAgICAvLyBkeW5hbWljIGNvbXBvbmVudCBtYXkgcmVzb2x2ZSB0byBwbGFpbiBlbGVtZW50c1xyXG4gICAgICAgIGlzRHluYW1pY0NvbXBvbmVudCB8fFxyXG4gICAgICAgICAgICB2bm9kZVRhZyA9PT0gVEVMRVBPUlQgfHxcclxuICAgICAgICAgICAgdm5vZGVUYWcgPT09IFNVU1BFTlNFIHx8XHJcbiAgICAgICAgICAgICghaXNDb21wb25lbnQgJiZcclxuICAgICAgICAgICAgICAgIC8vIDxzdmc+IGFuZCA8Zm9yZWlnbk9iamVjdD4gbXVzdCBiZSBmb3JjZWQgaW50byBibG9ja3Mgc28gdGhhdCBibG9ja1xyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlcyBpbnNpZGUgZ2V0IHByb3BlciBpc1NWRyBmbGFnIGF0IHJ1bnRpbWUuICgjNjM5LCAjNjQzKVxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0ZWNobmljYWxseSB3ZWItc3BlY2lmaWMsIGJ1dCBzcGxpdHRpbmcgdGhlIGxvZ2ljIG91dCBvZiBjb3JlXHJcbiAgICAgICAgICAgICAgICAvLyBsZWFkcyB0byB0b28gbXVjaCB1bm5lY2Vzc2FyeSBjb21wbGV4aXR5LlxyXG4gICAgICAgICAgICAgICAgKHRhZyA9PT0gJ3N2ZycgfHwgdGFnID09PSAnZm9yZWlnbk9iamVjdCcpKTtcclxuICAgICAgICAvLyBwcm9wc1xyXG4gICAgICAgIGlmIChwcm9wcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3BzQnVpbGRSZXN1bHQgPSBidWlsZFByb3BzKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB2bm9kZVByb3BzID0gcHJvcHNCdWlsZFJlc3VsdC5wcm9wcztcclxuICAgICAgICAgICAgcGF0Y2hGbGFnID0gcHJvcHNCdWlsZFJlc3VsdC5wYXRjaEZsYWc7XHJcbiAgICAgICAgICAgIGR5bmFtaWNQcm9wTmFtZXMgPSBwcm9wc0J1aWxkUmVzdWx0LmR5bmFtaWNQcm9wTmFtZXM7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGl2ZXMgPSBwcm9wc0J1aWxkUmVzdWx0LmRpcmVjdGl2ZXM7XHJcbiAgICAgICAgICAgIHZub2RlRGlyZWN0aXZlcyA9XHJcbiAgICAgICAgICAgICAgICBkaXJlY3RpdmVzICYmIGRpcmVjdGl2ZXMubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgPyBjcmVhdGVBcnJheUV4cHJlc3Npb24oZGlyZWN0aXZlcy5tYXAoZGlyID0+IGJ1aWxkRGlyZWN0aXZlQXJncyhkaXIsIGNvbnRleHQpKSlcclxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgaWYgKHByb3BzQnVpbGRSZXN1bHQuc2hvdWxkVXNlQmxvY2spIHtcclxuICAgICAgICAgICAgICAgIHNob3VsZFVzZUJsb2NrID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjaGlsZHJlblxyXG4gICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgaWYgKHZub2RlVGFnID09PSBLRUVQX0FMSVZFKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBbHRob3VnaCBhIGJ1aWx0LWluIGNvbXBvbmVudCwgd2UgY29tcGlsZSBLZWVwQWxpdmUgd2l0aCByYXcgY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgIC8vIGluc3RlYWQgb2Ygc2xvdCBmdW5jdGlvbnMgc28gdGhhdCBpdCBjYW4gYmUgdXNlZCBpbnNpZGUgVHJhbnNpdGlvblxyXG4gICAgICAgICAgICAgICAgLy8gb3Igb3RoZXIgVHJhbnNpdGlvbi13cmFwcGluZyBIT0NzLlxyXG4gICAgICAgICAgICAgICAgLy8gVG8gZW5zdXJlIGNvcnJlY3QgdXBkYXRlcyB3aXRoIGJsb2NrIG9wdGltaXphdGlvbnMsIHdlIG5lZWQgdG86XHJcbiAgICAgICAgICAgICAgICAvLyAxLiBGb3JjZSBrZWVwLWFsaXZlIGludG8gYSBibG9jay4gVGhpcyBhdm9pZHMgaXRzIGNoaWxkcmVuIGJlaW5nXHJcbiAgICAgICAgICAgICAgICAvLyAgICBjb2xsZWN0ZWQgYnkgYSBwYXJlbnQgYmxvY2suXHJcbiAgICAgICAgICAgICAgICBzaG91bGRVc2VCbG9jayA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAvLyAyLiBGb3JjZSBrZWVwLWFsaXZlIHRvIGFsd2F5cyBiZSB1cGRhdGVkLCBzaW5jZSBpdCB1c2VzIHJhdyBjaGlsZHJlbi5cclxuICAgICAgICAgICAgICAgIHBhdGNoRmxhZyB8PSAxMDI0IC8qIERZTkFNSUNfU0xPVFMgKi87XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDQ1IC8qIFhfS0VFUF9BTElWRV9JTlZBTElEX0NISUxEUkVOICovLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBub2RlLmNoaWxkcmVuWzBdLmxvYy5zdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBub2RlLmNoaWxkcmVuW25vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMV0ubG9jLmVuZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiAnJ1xyXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBzaG91bGRCdWlsZEFzU2xvdHMgPSBpc0NvbXBvbmVudCAmJlxyXG4gICAgICAgICAgICAgICAgLy8gVGVsZXBvcnQgaXMgbm90IGEgcmVhbCBjb21wb25lbnQgYW5kIGhhcyBkZWRpY2F0ZWQgcnVudGltZSBoYW5kbGluZ1xyXG4gICAgICAgICAgICAgICAgdm5vZGVUYWcgIT09IFRFTEVQT1JUICYmXHJcbiAgICAgICAgICAgICAgICAvLyBleHBsYWluZWQgYWJvdmUuXHJcbiAgICAgICAgICAgICAgICB2bm9kZVRhZyAhPT0gS0VFUF9BTElWRTtcclxuICAgICAgICAgICAgaWYgKHNob3VsZEJ1aWxkQXNTbG90cykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBzbG90cywgaGFzRHluYW1pY1Nsb3RzIH0gPSBidWlsZFNsb3RzKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgdm5vZGVDaGlsZHJlbiA9IHNsb3RzO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc0R5bmFtaWNTbG90cykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoRmxhZyB8PSAxMDI0IC8qIERZTkFNSUNfU0xPVFMgKi87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgdm5vZGVUYWcgIT09IFRFTEVQT1JUKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5bMF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gY2hpbGQudHlwZTtcclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBkeW5hbWljIHRleHQgY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGhhc0R5bmFtaWNUZXh0Q2hpbGQgPSB0eXBlID09PSA1IC8qIElOVEVSUE9MQVRJT04gKi8gfHxcclxuICAgICAgICAgICAgICAgICAgICB0eXBlID09PSA4IC8qIENPTVBPVU5EX0VYUFJFU1NJT04gKi87XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzRHluYW1pY1RleHRDaGlsZCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGdldENvbnN0YW50VHlwZShjaGlsZCwgY29udGV4dCkgPT09IDAgLyogTk9UX0NPTlNUQU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hGbGFnIHw9IDEgLyogVEVYVCAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHBhc3MgZGlyZWN0bHkgaWYgdGhlIG9ubHkgY2hpbGQgaXMgYSB0ZXh0IG5vZGVcclxuICAgICAgICAgICAgICAgIC8vIChwbGFpbiAvIGludGVycG9sYXRpb24gLyBleHByZXNzaW9uKVxyXG4gICAgICAgICAgICAgICAgaWYgKGhhc0R5bmFtaWNUZXh0Q2hpbGQgfHwgdHlwZSA9PT0gMiAvKiBURVhUICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdm5vZGVDaGlsZHJlbiA9IGNoaWxkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdm5vZGVDaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZUNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBwYXRjaEZsYWcgJiBkeW5hbWljUHJvcE5hbWVzXHJcbiAgICAgICAgaWYgKHBhdGNoRmxhZyAhPT0gMCkge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGF0Y2hGbGFnIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpYWwgZmxhZ3MgKG5lZ2F0aXZlIGFuZCBtdXR1YWxseSBleGNsdXNpdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgdm5vZGVQYXRjaEZsYWcgPSBwYXRjaEZsYWcgKyBgIC8qICR7UGF0Y2hGbGFnTmFtZXNbcGF0Y2hGbGFnXX0gKi9gO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYml0d2lzZSBmbGFnc1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZsYWdOYW1lcyA9IE9iamVjdC5rZXlzKFBhdGNoRmxhZ05hbWVzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKE51bWJlcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihuID0+IG4gPiAwICYmIHBhdGNoRmxhZyAmIG4pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAobiA9PiBQYXRjaEZsYWdOYW1lc1tuXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oYCwgYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdm5vZGVQYXRjaEZsYWcgPSBwYXRjaEZsYWcgKyBgIC8qICR7ZmxhZ05hbWVzfSAqL2A7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZVBhdGNoRmxhZyA9IFN0cmluZyhwYXRjaEZsYWcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkeW5hbWljUHJvcE5hbWVzICYmIGR5bmFtaWNQcm9wTmFtZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZUR5bmFtaWNQcm9wcyA9IHN0cmluZ2lmeUR5bmFtaWNQcm9wTmFtZXMoZHluYW1pY1Byb3BOYW1lcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbm9kZS5jb2RlZ2VuTm9kZSA9IGNyZWF0ZVZOb2RlQ2FsbChjb250ZXh0LCB2bm9kZVRhZywgdm5vZGVQcm9wcywgdm5vZGVDaGlsZHJlbiwgdm5vZGVQYXRjaEZsYWcsIHZub2RlRHluYW1pY1Byb3BzLCB2bm9kZURpcmVjdGl2ZXMsICEhc2hvdWxkVXNlQmxvY2ssIGZhbHNlIC8qIGRpc2FibGVUcmFja2luZyAqLywgaXNDb21wb25lbnQsIG5vZGUubG9jKTtcclxuICAgIH07XHJcbn07XHJcbmZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnRUeXBlKG5vZGUsIGNvbnRleHQsIHNzciA9IGZhbHNlKSB7XHJcbiAgICBsZXQgeyB0YWcgfSA9IG5vZGU7XHJcbiAgICAvLyAxLiBkeW5hbWljIGNvbXBvbmVudFxyXG4gICAgY29uc3QgaXNFeHBsaWNpdER5bmFtaWMgPSBpc0NvbXBvbmVudFRhZyh0YWcpO1xyXG4gICAgY29uc3QgaXNQcm9wID0gZmluZFByb3Aobm9kZSwgJ2lzJyk7XHJcbiAgICBpZiAoaXNQcm9wKSB7XHJcbiAgICAgICAgaWYgKGlzRXhwbGljaXREeW5hbWljIHx8XHJcbiAgICAgICAgICAgIChpc0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9JU19PTl9FTEVNRU5UXCIgLyogQ09NUElMRVJfSVNfT05fRUxFTUVOVCAqLywgY29udGV4dCkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4cCA9IGlzUHJvcC50eXBlID09PSA2IC8qIEFUVFJJQlVURSAqL1xyXG4gICAgICAgICAgICAgICAgPyBpc1Byb3AudmFsdWUgJiYgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihpc1Byb3AudmFsdWUuY29udGVudCwgdHJ1ZSlcclxuICAgICAgICAgICAgICAgIDogaXNQcm9wLmV4cDtcclxuICAgICAgICAgICAgaWYgKGV4cCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKFJFU09MVkVfRFlOQU1JQ19DT01QT05FTlQpLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgZXhwXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc1Byb3AudHlwZSA9PT0gNiAvKiBBVFRSSUJVVEUgKi8gJiZcclxuICAgICAgICAgICAgaXNQcm9wLnZhbHVlLmNvbnRlbnQuc3RhcnRzV2l0aCgndnVlOicpKSB7XHJcbiAgICAgICAgICAgIC8vIDxidXR0b24gaXM9XCJ2dWU6eHh4XCI+XHJcbiAgICAgICAgICAgIC8vIGlmIG5vdCA8Y29tcG9uZW50Piwgb25seSBpcyB2YWx1ZSB0aGF0IHN0YXJ0cyB3aXRoIFwidnVlOlwiIHdpbGwgYmVcclxuICAgICAgICAgICAgLy8gdHJlYXRlZCBhcyBjb21wb25lbnQgYnkgdGhlIHBhcnNlIHBoYXNlIGFuZCByZWFjaCBoZXJlLCB1bmxlc3MgaXQnc1xyXG4gICAgICAgICAgICAvLyBjb21wYXQgbW9kZSB3aGVyZSBhbGwgaXMgdmFsdWVzIGFyZSBjb25zaWRlcmVkIGNvbXBvbmVudHNcclxuICAgICAgICAgICAgdGFnID0gaXNQcm9wLnZhbHVlLmNvbnRlbnQuc2xpY2UoNCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gMS41IHYtaXMgKFRPRE86IERlcHJlY2F0ZSlcclxuICAgIGNvbnN0IGlzRGlyID0gIWlzRXhwbGljaXREeW5hbWljICYmIGZpbmREaXIobm9kZSwgJ2lzJyk7XHJcbiAgICBpZiAoaXNEaXIgJiYgaXNEaXIuZXhwKSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKFJFU09MVkVfRFlOQU1JQ19DT01QT05FTlQpLCBbXHJcbiAgICAgICAgICAgIGlzRGlyLmV4cFxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgLy8gMi4gYnVpbHQtaW4gY29tcG9uZW50cyAoVGVsZXBvcnQsIFRyYW5zaXRpb24sIEtlZXBBbGl2ZSwgU3VzcGVuc2UuLi4pXHJcbiAgICBjb25zdCBidWlsdEluID0gaXNDb3JlQ29tcG9uZW50KHRhZykgfHwgY29udGV4dC5pc0J1aWx0SW5Db21wb25lbnQodGFnKTtcclxuICAgIGlmIChidWlsdEluKSB7XHJcbiAgICAgICAgLy8gYnVpbHQtaW5zIGFyZSBzaW1wbHkgZmFsbHRocm91Z2hzIC8gaGF2ZSBzcGVjaWFsIGhhbmRsaW5nIGR1cmluZyBzc3JcclxuICAgICAgICAvLyBzbyB3ZSBkb24ndCBuZWVkIHRvIGltcG9ydCB0aGVpciBydW50aW1lIGVxdWl2YWxlbnRzXHJcbiAgICAgICAgaWYgKCFzc3IpXHJcbiAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKGJ1aWx0SW4pO1xyXG4gICAgICAgIHJldHVybiBidWlsdEluO1xyXG4gICAgfVxyXG4gICAgLy8gNS4gdXNlciBjb21wb25lbnQgKHJlc29sdmUpXHJcbiAgICBjb250ZXh0LmhlbHBlcihSRVNPTFZFX0NPTVBPTkVOVCk7XHJcbiAgICBjb250ZXh0LmNvbXBvbmVudHMuYWRkKHRhZyk7XHJcbiAgICByZXR1cm4gdG9WYWxpZEFzc2V0SWQodGFnLCBgY29tcG9uZW50YCk7XHJcbn1cclxuZnVuY3Rpb24gYnVpbGRQcm9wcyhub2RlLCBjb250ZXh0LCBwcm9wcyA9IG5vZGUucHJvcHMsIHNzciA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCB7IHRhZywgbG9jOiBlbGVtZW50TG9jLCBjaGlsZHJlbiB9ID0gbm9kZTtcclxuICAgIGNvbnN0IGlzQ29tcG9uZW50ID0gbm9kZS50YWdUeXBlID09PSAxIC8qIENPTVBPTkVOVCAqLztcclxuICAgIGxldCBwcm9wZXJ0aWVzID0gW107XHJcbiAgICBjb25zdCBtZXJnZUFyZ3MgPSBbXTtcclxuICAgIGNvbnN0IHJ1bnRpbWVEaXJlY3RpdmVzID0gW107XHJcbiAgICBjb25zdCBoYXNDaGlsZHJlbiA9IGNoaWxkcmVuLmxlbmd0aCA+IDA7XHJcbiAgICBsZXQgc2hvdWxkVXNlQmxvY2sgPSBmYWxzZTtcclxuICAgIC8vIHBhdGNoRmxhZyBhbmFseXNpc1xyXG4gICAgbGV0IHBhdGNoRmxhZyA9IDA7XHJcbiAgICBsZXQgaGFzUmVmID0gZmFsc2U7XHJcbiAgICBsZXQgaGFzQ2xhc3NCaW5kaW5nID0gZmFsc2U7XHJcbiAgICBsZXQgaGFzU3R5bGVCaW5kaW5nID0gZmFsc2U7XHJcbiAgICBsZXQgaGFzSHlkcmF0aW9uRXZlbnRCaW5kaW5nID0gZmFsc2U7XHJcbiAgICBsZXQgaGFzRHluYW1pY0tleXMgPSBmYWxzZTtcclxuICAgIGxldCBoYXNWbm9kZUhvb2sgPSBmYWxzZTtcclxuICAgIGNvbnN0IGR5bmFtaWNQcm9wTmFtZXMgPSBbXTtcclxuICAgIGNvbnN0IGFuYWx5emVQYXRjaEZsYWcgPSAoeyBrZXksIHZhbHVlIH0pID0+IHtcclxuICAgICAgICBpZiAoaXNTdGF0aWNFeHAoa2V5KSkge1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lID0ga2V5LmNvbnRlbnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzRXZlbnRIYW5kbGVyID0gaXNPbihuYW1lKTtcclxuICAgICAgICAgICAgaWYgKCFpc0NvbXBvbmVudCAmJlxyXG4gICAgICAgICAgICAgICAgaXNFdmVudEhhbmRsZXIgJiZcclxuICAgICAgICAgICAgICAgIC8vIG9taXQgdGhlIGZsYWcgZm9yIGNsaWNrIGhhbmRsZXJzIGJlY2F1c2UgaHlkcmF0aW9uIGdpdmVzIGNsaWNrXHJcbiAgICAgICAgICAgICAgICAvLyBkZWRpY2F0ZWQgZmFzdCBwYXRoLlxyXG4gICAgICAgICAgICAgICAgbmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnb25jbGljaycgJiZcclxuICAgICAgICAgICAgICAgIC8vIG9taXQgdi1tb2RlbCBoYW5kbGVyc1xyXG4gICAgICAgICAgICAgICAgbmFtZSAhPT0gJ29uVXBkYXRlOm1vZGVsVmFsdWUnICYmXHJcbiAgICAgICAgICAgICAgICAvLyBvbWl0IG9uVm5vZGVYWFggaG9va3NcclxuICAgICAgICAgICAgICAgICFpc1Jlc2VydmVkUHJvcChuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgaGFzSHlkcmF0aW9uRXZlbnRCaW5kaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNFdmVudEhhbmRsZXIgJiYgaXNSZXNlcnZlZFByb3AobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIGhhc1Zub2RlSG9vayA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT09IDIwIC8qIEpTX0NBQ0hFX0VYUFJFU1NJT04gKi8gfHxcclxuICAgICAgICAgICAgICAgICgodmFsdWUudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnR5cGUgPT09IDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLykgJiZcclxuICAgICAgICAgICAgICAgICAgICBnZXRDb25zdGFudFR5cGUodmFsdWUsIGNvbnRleHQpID4gMCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIHNraXAgaWYgdGhlIHByb3AgaXMgYSBjYWNoZWQgaGFuZGxlciBvciBoYXMgY29uc3RhbnQgdmFsdWVcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3JlZicpIHtcclxuICAgICAgICAgICAgICAgIGhhc1JlZiA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ2NsYXNzJykge1xyXG4gICAgICAgICAgICAgICAgaGFzQ2xhc3NCaW5kaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnc3R5bGUnKSB7XHJcbiAgICAgICAgICAgICAgICBoYXNTdHlsZUJpbmRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgIT09ICdrZXknICYmICFkeW5hbWljUHJvcE5hbWVzLmluY2x1ZGVzKG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBkeW5hbWljUHJvcE5hbWVzLnB1c2gobmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdHJlYXQgdGhlIGR5bmFtaWMgY2xhc3MgYW5kIHN0eWxlIGJpbmRpbmcgb2YgdGhlIGNvbXBvbmVudCBhcyBkeW5hbWljIHByb3BzXHJcbiAgICAgICAgICAgIGlmIChpc0NvbXBvbmVudCAmJlxyXG4gICAgICAgICAgICAgICAgKG5hbWUgPT09ICdjbGFzcycgfHwgbmFtZSA9PT0gJ3N0eWxlJykgJiZcclxuICAgICAgICAgICAgICAgICFkeW5hbWljUHJvcE5hbWVzLmluY2x1ZGVzKG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBkeW5hbWljUHJvcE5hbWVzLnB1c2gobmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhhc0R5bmFtaWNLZXlzID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIC8vIHN0YXRpYyBhdHRyaWJ1dGVcclxuICAgICAgICBjb25zdCBwcm9wID0gcHJvcHNbaV07XHJcbiAgICAgICAgaWYgKHByb3AudHlwZSA9PT0gNiAvKiBBVFRSSUJVVEUgKi8pIHtcclxuICAgICAgICAgICAgY29uc3QgeyBsb2MsIG5hbWUsIHZhbHVlIH0gPSBwcm9wO1xyXG4gICAgICAgICAgICBsZXQgaXNTdGF0aWMgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3JlZicpIHtcclxuICAgICAgICAgICAgICAgIGhhc1JlZiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5zY29wZXMudkZvciA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2goY3JlYXRlT2JqZWN0UHJvcGVydHkoY3JlYXRlU2ltcGxlRXhwcmVzc2lvbigncmVmX2ZvcicsIHRydWUpLCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKCd0cnVlJykpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBza2lwIGlzIG9uIDxjb21wb25lbnQ+LCBvciBpcz1cInZ1ZTp4eHhcIlxyXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lzJyAmJlxyXG4gICAgICAgICAgICAgICAgKGlzQ29tcG9uZW50VGFnKHRhZykgfHxcclxuICAgICAgICAgICAgICAgICAgICAodmFsdWUgJiYgdmFsdWUuY29udGVudC5zdGFydHNXaXRoKCd2dWU6JykpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKGlzQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX0lTX09OX0VMRU1FTlRcIiAvKiBDT01QSUxFUl9JU19PTl9FTEVNRU5UICovLCBjb250ZXh0KSkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2goY3JlYXRlT2JqZWN0UHJvcGVydHkoY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihuYW1lLCB0cnVlLCBnZXRJbm5lclJhbmdlKGxvYywgMCwgbmFtZS5sZW5ndGgpKSwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbih2YWx1ZSA/IHZhbHVlLmNvbnRlbnQgOiAnJywgaXNTdGF0aWMsIHZhbHVlID8gdmFsdWUubG9jIDogbG9jKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZGlyZWN0aXZlc1xyXG4gICAgICAgICAgICBjb25zdCB7IG5hbWUsIGFyZywgZXhwLCBsb2MgfSA9IHByb3A7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzVkJpbmQgPSBuYW1lID09PSAnYmluZCc7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzVk9uID0gbmFtZSA9PT0gJ29uJztcclxuICAgICAgICAgICAgLy8gc2tpcCB2LXNsb3QgLSBpdCBpcyBoYW5kbGVkIGJ5IGl0cyBkZWRpY2F0ZWQgdHJhbnNmb3JtLlxyXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3Nsb3QnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQ29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDAgLyogWF9WX1NMT1RfTUlTUExBQ0VEICovLCBsb2MpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNraXAgdi1vbmNlL3YtbWVtbyAtIHRoZXkgYXJlIGhhbmRsZWQgYnkgZGVkaWNhdGVkIHRyYW5zZm9ybXMuXHJcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnb25jZScgfHwgbmFtZSA9PT0gJ21lbW8nKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBza2lwIHYtaXMgYW5kIDppcyBvbiA8Y29tcG9uZW50PlxyXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lzJyB8fFxyXG4gICAgICAgICAgICAgICAgKGlzVkJpbmQgJiZcclxuICAgICAgICAgICAgICAgICAgICBpc1N0YXRpY0FyZ09mKGFyZywgJ2lzJykgJiZcclxuICAgICAgICAgICAgICAgICAgICAoaXNDb21wb25lbnRUYWcodGFnKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoaXNDb21wYXRFbmFibGVkKFwiQ09NUElMRVJfSVNfT05fRUxFTUVOVFwiIC8qIENPTVBJTEVSX0lTX09OX0VMRU1FTlQgKi8sIGNvbnRleHQpKSkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBza2lwIHYtb24gaW4gU1NSIGNvbXBpbGF0aW9uXHJcbiAgICAgICAgICAgIGlmIChpc1ZPbiAmJiBzc3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgLy8gIzkzODogZWxlbWVudHMgd2l0aCBkeW5hbWljIGtleXMgc2hvdWxkIGJlIGZvcmNlZCBpbnRvIGJsb2Nrc1xyXG4gICAgICAgICAgICAoaXNWQmluZCAmJiBpc1N0YXRpY0FyZ09mKGFyZywgJ2tleScpKSB8fFxyXG4gICAgICAgICAgICAgICAgLy8gaW5saW5lIGJlZm9yZS11cGRhdGUgaG9va3MgbmVlZCB0byBmb3JjZSBibG9jayBzbyB0aGF0IGl0IGlzIGludm9rZWRcclxuICAgICAgICAgICAgICAgIC8vIGJlZm9yZSBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgKGlzVk9uICYmIGhhc0NoaWxkcmVuICYmIGlzU3RhdGljQXJnT2YoYXJnLCAndnVlOmJlZm9yZS11cGRhdGUnKSkpIHtcclxuICAgICAgICAgICAgICAgIHNob3VsZFVzZUJsb2NrID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNWQmluZCAmJiBpc1N0YXRpY0FyZ09mKGFyZywgJ3JlZicpICYmIGNvbnRleHQuc2NvcGVzLnZGb3IgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2goY3JlYXRlT2JqZWN0UHJvcGVydHkoY3JlYXRlU2ltcGxlRXhwcmVzc2lvbigncmVmX2ZvcicsIHRydWUpLCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKCd0cnVlJykpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIHYtYmluZCBhbmQgdi1vbiB3aXRoIG5vIGFyZ3VtZW50XHJcbiAgICAgICAgICAgIGlmICghYXJnICYmIChpc1ZCaW5kIHx8IGlzVk9uKSkge1xyXG4gICAgICAgICAgICAgICAgaGFzRHluYW1pY0tleXMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXJnZUFyZ3MucHVzaChjcmVhdGVPYmplY3RFeHByZXNzaW9uKGRlZHVwZVByb3BlcnRpZXMocHJvcGVydGllcyksIGVsZW1lbnRMb2MpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWQmluZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAyLnggdi1iaW5kIG9iamVjdCBvcmRlciBjb21wYXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNPdmVycmlkYWJsZUtleXMgPSBtZXJnZUFyZ3Muc29tZShhcmcgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJnLnR5cGUgPT09IDE1IC8qIEpTX09CSkVDVF9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnLnByb3BlcnRpZXMuc29tZSgoeyBrZXkgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkudHlwZSAhPT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAha2V5LmlzU3RhdGljKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGtleS5jb250ZW50ICE9PSAnY2xhc3MnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleS5jb250ZW50ICE9PSAnc3R5bGUnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFpc09uKGtleS5jb250ZW50KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGR5bmFtaWMgZXhwcmVzc2lvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3ZlcnJpZGFibGVLZXlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX1ZfQklORF9PQkpFQ1RfT1JERVJcIiAvKiBDT01QSUxFUl9WX0JJTkRfT0JKRUNUX09SREVSICovLCBjb250ZXh0LCBsb2MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9WX0JJTkRfT0JKRUNUX09SREVSXCIgLyogQ09NUElMRVJfVl9CSU5EX09CSkVDVF9PUkRFUiAqLywgY29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXJnZUFyZ3MudW5zaGlmdChleHApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlQXJncy5wdXNoKGV4cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB2LW9uPVwib2JqXCIgLT4gdG9IYW5kbGVycyhvYmopXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlQXJncy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IDE0IC8qIEpTX0NBTExfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxlZTogY29udGV4dC5oZWxwZXIoVE9fSEFORExFUlMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbZXhwXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcihpc1ZCaW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gMzQgLyogWF9WX0JJTkRfTk9fRVhQUkVTU0lPTiAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDM1IC8qIFhfVl9PTl9OT19FWFBSRVNTSU9OICovLCBsb2MpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGl2ZVRyYW5zZm9ybSA9IGNvbnRleHQuZGlyZWN0aXZlVHJhbnNmb3Jtc1tuYW1lXTtcclxuICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZVRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICAgICAgLy8gaGFzIGJ1aWx0LWluIGRpcmVjdGl2ZSB0cmFuc2Zvcm0uXHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHByb3BzLCBuZWVkUnVudGltZSB9ID0gZGlyZWN0aXZlVHJhbnNmb3JtKHByb3AsIG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgIXNzciAmJiBwcm9wcy5mb3JFYWNoKGFuYWx5emVQYXRjaEZsYWcpO1xyXG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKC4uLnByb3BzKTtcclxuICAgICAgICAgICAgICAgIGlmIChuZWVkUnVudGltZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJ1bnRpbWVEaXJlY3RpdmVzLnB1c2gocHJvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3ltYm9sKG5lZWRSdW50aW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmVJbXBvcnRNYXAuc2V0KHByb3AsIG5lZWRSdW50aW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzQnVpbHRJbkRpcmVjdGl2ZShuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gbm8gYnVpbHQtaW4gdHJhbnNmb3JtLCB0aGlzIGlzIGEgdXNlciBjdXN0b20gZGlyZWN0aXZlLlxyXG4gICAgICAgICAgICAgICAgcnVudGltZURpcmVjdGl2ZXMucHVzaChwcm9wKTtcclxuICAgICAgICAgICAgICAgIC8vIGN1c3RvbSBkaXJzIG1heSB1c2UgYmVmb3JlVXBkYXRlIHNvIHRoZXkgbmVlZCB0byBmb3JjZSBibG9ja3NcclxuICAgICAgICAgICAgICAgIC8vIHRvIGVuc3VyZSBiZWZvcmUtdXBkYXRlIGdldHMgY2FsbGVkIGJlZm9yZSBjaGlsZHJlbiB1cGRhdGVcclxuICAgICAgICAgICAgICAgIGlmIChoYXNDaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFVzZUJsb2NrID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxldCBwcm9wc0V4cHJlc3Npb24gPSB1bmRlZmluZWQ7XHJcbiAgICAvLyBoYXMgdi1iaW5kPVwib2JqZWN0XCIgb3Igdi1vbj1cIm9iamVjdFwiLCB3cmFwIHdpdGggbWVyZ2VQcm9wc1xyXG4gICAgaWYgKG1lcmdlQXJncy5sZW5ndGgpIHtcclxuICAgICAgICBpZiAocHJvcGVydGllcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbWVyZ2VBcmdzLnB1c2goY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihkZWR1cGVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpLCBlbGVtZW50TG9jKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtZXJnZUFyZ3MubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICBwcm9wc0V4cHJlc3Npb24gPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihNRVJHRV9QUk9QUyksIG1lcmdlQXJncywgZWxlbWVudExvYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBzaW5nbGUgdi1iaW5kIHdpdGggbm90aGluZyBlbHNlIC0gbm8gbmVlZCBmb3IgYSBtZXJnZVByb3BzIGNhbGxcclxuICAgICAgICAgICAgcHJvcHNFeHByZXNzaW9uID0gbWVyZ2VBcmdzWzBdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHByb3BlcnRpZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgcHJvcHNFeHByZXNzaW9uID0gY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihkZWR1cGVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpLCBlbGVtZW50TG9jKTtcclxuICAgIH1cclxuICAgIC8vIHBhdGNoRmxhZyBhbmFseXNpc1xyXG4gICAgaWYgKGhhc0R5bmFtaWNLZXlzKSB7XHJcbiAgICAgICAgcGF0Y2hGbGFnIHw9IDE2IC8qIEZVTExfUFJPUFMgKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoaGFzQ2xhc3NCaW5kaW5nICYmICFpc0NvbXBvbmVudCkge1xyXG4gICAgICAgICAgICBwYXRjaEZsYWcgfD0gMiAvKiBDTEFTUyAqLztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhhc1N0eWxlQmluZGluZyAmJiAhaXNDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgcGF0Y2hGbGFnIHw9IDQgLyogU1RZTEUgKi87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkeW5hbWljUHJvcE5hbWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBwYXRjaEZsYWcgfD0gOCAvKiBQUk9QUyAqLztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhhc0h5ZHJhdGlvbkV2ZW50QmluZGluZykge1xyXG4gICAgICAgICAgICBwYXRjaEZsYWcgfD0gMzIgLyogSFlEUkFURV9FVkVOVFMgKi87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFzaG91bGRVc2VCbG9jayAmJlxyXG4gICAgICAgIChwYXRjaEZsYWcgPT09IDAgfHwgcGF0Y2hGbGFnID09PSAzMiAvKiBIWURSQVRFX0VWRU5UUyAqLykgJiZcclxuICAgICAgICAoaGFzUmVmIHx8IGhhc1Zub2RlSG9vayB8fCBydW50aW1lRGlyZWN0aXZlcy5sZW5ndGggPiAwKSkge1xyXG4gICAgICAgIHBhdGNoRmxhZyB8PSA1MTIgLyogTkVFRF9QQVRDSCAqLztcclxuICAgIH1cclxuICAgIC8vIHByZS1ub3JtYWxpemUgcHJvcHMsIFNTUiBpcyBza2lwcGVkIGZvciBub3dcclxuICAgIGlmICghY29udGV4dC5pblNTUiAmJiBwcm9wc0V4cHJlc3Npb24pIHtcclxuICAgICAgICBzd2l0Y2ggKHByb3BzRXhwcmVzc2lvbi50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMTUgLyogSlNfT0JKRUNUX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgICAgICAvLyBtZWFucyB0aGF0IHRoZXJlIGlzIG5vIHYtYmluZCxcclxuICAgICAgICAgICAgICAgIC8vIGJ1dCBzdGlsbCBuZWVkIHRvIGRlYWwgd2l0aCBkeW5hbWljIGtleSBiaW5kaW5nXHJcbiAgICAgICAgICAgICAgICBsZXQgY2xhc3NLZXlJbmRleCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlS2V5SW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgIGxldCBoYXNEeW5hbWljS2V5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzRXhwcmVzc2lvbi5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcHJvcHNFeHByZXNzaW9uLnByb3BlcnRpZXNbaV0ua2V5O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0YXRpY0V4cChrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkuY29udGVudCA9PT0gJ2NsYXNzJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NLZXlJbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5LmNvbnRlbnQgPT09ICdzdHlsZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlS2V5SW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFrZXkuaXNIYW5kbGVyS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0R5bmFtaWNLZXkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGNsYXNzUHJvcCA9IHByb3BzRXhwcmVzc2lvbi5wcm9wZXJ0aWVzW2NsYXNzS2V5SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3R5bGVQcm9wID0gcHJvcHNFeHByZXNzaW9uLnByb3BlcnRpZXNbc3R5bGVLZXlJbmRleF07XHJcbiAgICAgICAgICAgICAgICAvLyBubyBkeW5hbWljIGtleVxyXG4gICAgICAgICAgICAgICAgaWYgKCFoYXNEeW5hbWljS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsYXNzUHJvcCAmJiAhaXNTdGF0aWNFeHAoY2xhc3NQcm9wLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc1Byb3AudmFsdWUgPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihOT1JNQUxJWkVfQ0xBU1MpLCBbY2xhc3NQcm9wLnZhbHVlXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZVByb3AgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgIWlzU3RhdGljRXhwKHN0eWxlUHJvcC52YWx1ZSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHN0YXRpYyBzdHlsZSBpcyBjb21waWxlZCBpbnRvIGFuIG9iamVjdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gdXNlIGBoYXNTdHlsZUJpbmRpbmdgIHRvIGVuc3VyZSB0aGF0IGl0IGlzIGEgZHluYW1pYyBzdHlsZSBiaW5kaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChoYXNTdHlsZUJpbmRpbmcgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHYtYmluZDpzdHlsZSBhbmQgc3R5bGUgYm90aCBleGlzdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHYtYmluZDpzdHlsZSB3aXRoIHN0YXRpYyBsaXRlcmFsIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVQcm9wLnZhbHVlLnR5cGUgPT09IDE3IC8qIEpTX0FSUkFZX0VYUFJFU1NJT04gKi8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlUHJvcC52YWx1ZSA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKE5PUk1BTElaRV9TVFlMRSksIFtzdHlsZVByb3AudmFsdWVdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBkeW5hbWljIGtleSBiaW5kaW5nLCB3cmFwIHdpdGggYG5vcm1hbGl6ZVByb3BzYFxyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzRXhwcmVzc2lvbiA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKE5PUk1BTElaRV9QUk9QUyksIFtwcm9wc0V4cHJlc3Npb25dKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDE0IC8qIEpTX0NBTExfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgICAgIC8vIG1lcmdlUHJvcHMgY2FsbCwgZG8gbm90aGluZ1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAvLyBzaW5nbGUgdi1iaW5kXHJcbiAgICAgICAgICAgICAgICBwcm9wc0V4cHJlc3Npb24gPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihOT1JNQUxJWkVfUFJPUFMpLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoR1VBUkRfUkVBQ1RJVkVfUFJPUFMpLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzRXhwcmVzc2lvblxyXG4gICAgICAgICAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcHJvcHM6IHByb3BzRXhwcmVzc2lvbixcclxuICAgICAgICBkaXJlY3RpdmVzOiBydW50aW1lRGlyZWN0aXZlcyxcclxuICAgICAgICBwYXRjaEZsYWcsXHJcbiAgICAgICAgZHluYW1pY1Byb3BOYW1lcyxcclxuICAgICAgICBzaG91bGRVc2VCbG9ja1xyXG4gICAgfTtcclxufVxyXG4vLyBEZWR1cGUgcHJvcHMgaW4gYW4gb2JqZWN0IGxpdGVyYWwuXHJcbi8vIExpdGVyYWwgZHVwbGljYXRlZCBhdHRyaWJ1dGVzIHdvdWxkIGhhdmUgYmVlbiB3YXJuZWQgZHVyaW5nIHRoZSBwYXJzZSBwaGFzZSxcclxuLy8gaG93ZXZlciwgaXQncyBwb3NzaWJsZSB0byBlbmNvdW50ZXIgZHVwbGljYXRlZCBgb25YWFhgIGhhbmRsZXJzIHdpdGggZGlmZmVyZW50XHJcbi8vIG1vZGlmaWVycy4gV2UgYWxzbyBuZWVkIHRvIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBjbGFzcyAvIHN0eWxlIGF0dHJpYnV0ZXMuXHJcbi8vIC0gb25YWFggaGFuZGxlcnMgLyBzdHlsZTogbWVyZ2UgaW50byBhcnJheVxyXG4vLyAtIGNsYXNzOiBtZXJnZSBpbnRvIHNpbmdsZSBleHByZXNzaW9uIHdpdGggY29uY2F0ZW5hdGlvblxyXG5mdW5jdGlvbiBkZWR1cGVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpIHtcclxuICAgIGNvbnN0IGtub3duUHJvcHMgPSBuZXcgTWFwKCk7XHJcbiAgICBjb25zdCBkZWR1cGVkID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBwcm9wID0gcHJvcGVydGllc1tpXTtcclxuICAgICAgICAvLyBkeW5hbWljIGtleXMgYXJlIGFsd2F5cyBhbGxvd2VkXHJcbiAgICAgICAgaWYgKHByb3Aua2V5LnR5cGUgPT09IDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLyB8fCAhcHJvcC5rZXkuaXNTdGF0aWMpIHtcclxuICAgICAgICAgICAgZGVkdXBlZC5wdXNoKHByb3ApO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IHByb3Aua2V5LmNvbnRlbnQ7XHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBrbm93blByb3BzLmdldChuYW1lKTtcclxuICAgICAgICBpZiAoZXhpc3RpbmcpIHtcclxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdzdHlsZScgfHwgbmFtZSA9PT0gJ2NsYXNzJyB8fCBpc09uKG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBtZXJnZUFzQXJyYXkoZXhpc3RpbmcsIHByb3ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgZHVwbGljYXRlLCBzaG91bGQgaGF2ZSBlbWl0dGVkIGVycm9yIGR1cmluZyBwYXJzZVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAga25vd25Qcm9wcy5zZXQobmFtZSwgcHJvcCk7XHJcbiAgICAgICAgICAgIGRlZHVwZWQucHVzaChwcm9wKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGVkdXBlZDtcclxufVxyXG5mdW5jdGlvbiBtZXJnZUFzQXJyYXkoZXhpc3RpbmcsIGluY29taW5nKSB7XHJcbiAgICBpZiAoZXhpc3RpbmcudmFsdWUudHlwZSA9PT0gMTcgLyogSlNfQVJSQVlfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgIGV4aXN0aW5nLnZhbHVlLmVsZW1lbnRzLnB1c2goaW5jb21pbmcudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZXhpc3RpbmcudmFsdWUgPSBjcmVhdGVBcnJheUV4cHJlc3Npb24oW2V4aXN0aW5nLnZhbHVlLCBpbmNvbWluZy52YWx1ZV0sIGV4aXN0aW5nLmxvYyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYnVpbGREaXJlY3RpdmVBcmdzKGRpciwgY29udGV4dCkge1xyXG4gICAgY29uc3QgZGlyQXJncyA9IFtdO1xyXG4gICAgY29uc3QgcnVudGltZSA9IGRpcmVjdGl2ZUltcG9ydE1hcC5nZXQoZGlyKTtcclxuICAgIGlmIChydW50aW1lKSB7XHJcbiAgICAgICAgLy8gYnVpbHQtaW4gZGlyZWN0aXZlIHdpdGggcnVudGltZVxyXG4gICAgICAgIGRpckFyZ3MucHVzaChjb250ZXh0LmhlbHBlclN0cmluZyhydW50aW1lKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGluamVjdCBzdGF0ZW1lbnQgZm9yIHJlc29sdmluZyBkaXJlY3RpdmVcclxuICAgICAgICAgICAgY29udGV4dC5oZWxwZXIoUkVTT0xWRV9ESVJFQ1RJVkUpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmRpcmVjdGl2ZXMuYWRkKGRpci5uYW1lKTtcclxuICAgICAgICAgICAgZGlyQXJncy5wdXNoKHRvVmFsaWRBc3NldElkKGRpci5uYW1lLCBgZGlyZWN0aXZlYCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHsgbG9jIH0gPSBkaXI7XHJcbiAgICBpZiAoZGlyLmV4cClcclxuICAgICAgICBkaXJBcmdzLnB1c2goZGlyLmV4cCk7XHJcbiAgICBpZiAoZGlyLmFyZykge1xyXG4gICAgICAgIGlmICghZGlyLmV4cCkge1xyXG4gICAgICAgICAgICBkaXJBcmdzLnB1c2goYHZvaWQgMGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkaXJBcmdzLnB1c2goZGlyLmFyZyk7XHJcbiAgICB9XHJcbiAgICBpZiAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycykubGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKCFkaXIuYXJnKSB7XHJcbiAgICAgICAgICAgIGlmICghZGlyLmV4cCkge1xyXG4gICAgICAgICAgICAgICAgZGlyQXJncy5wdXNoKGB2b2lkIDBgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkaXJBcmdzLnB1c2goYHZvaWQgMGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0cnVlRXhwcmVzc2lvbiA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYHRydWVgLCBmYWxzZSwgbG9jKTtcclxuICAgICAgICBkaXJBcmdzLnB1c2goY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihkaXIubW9kaWZpZXJzLm1hcChtb2RpZmllciA9PiBjcmVhdGVPYmplY3RQcm9wZXJ0eShtb2RpZmllciwgdHJ1ZUV4cHJlc3Npb24pKSwgbG9jKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3JlYXRlQXJyYXlFeHByZXNzaW9uKGRpckFyZ3MsIGRpci5sb2MpO1xyXG59XHJcbmZ1bmN0aW9uIHN0cmluZ2lmeUR5bmFtaWNQcm9wTmFtZXMocHJvcHMpIHtcclxuICAgIGxldCBwcm9wc05hbWVzU3RyaW5nID0gYFtgO1xyXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBwcm9wcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBwcm9wc05hbWVzU3RyaW5nICs9IEpTT04uc3RyaW5naWZ5KHByb3BzW2ldKTtcclxuICAgICAgICBpZiAoaSA8IGwgLSAxKVxyXG4gICAgICAgICAgICBwcm9wc05hbWVzU3RyaW5nICs9ICcsICc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJvcHNOYW1lc1N0cmluZyArIGBdYDtcclxufVxyXG5mdW5jdGlvbiBpc0NvbXBvbmVudFRhZyh0YWcpIHtcclxuICAgIHJldHVybiB0YWcgPT09ICdjb21wb25lbnQnIHx8IHRhZyA9PT0gJ0NvbXBvbmVudCc7XHJcbn1cblxuKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICA/IE9iamVjdC5mcmVlemUoe30pXHJcbiAgICA6IHt9O1xyXG4ocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBPYmplY3QuZnJlZXplKFtdKSA6IFtdO1xyXG5jb25zdCBjYWNoZVN0cmluZ0Z1bmN0aW9uID0gKGZuKSA9PiB7XHJcbiAgICBjb25zdCBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICByZXR1cm4gKChzdHIpID0+IHtcclxuICAgICAgICBjb25zdCBoaXQgPSBjYWNoZVtzdHJdO1xyXG4gICAgICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKTtcclxuICAgIH0pO1xyXG59O1xyXG5jb25zdCBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IGNhbWVsaXplID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiB7XHJcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgKF8sIGMpID0+IChjID8gYy50b1VwcGVyQ2FzZSgpIDogJycpKTtcclxufSk7XG5cbmNvbnN0IHRyYW5zZm9ybVNsb3RPdXRsZXQgPSAobm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgaWYgKGlzU2xvdE91dGxldChub2RlKSkge1xyXG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW4sIGxvYyB9ID0gbm9kZTtcclxuICAgICAgICBjb25zdCB7IHNsb3ROYW1lLCBzbG90UHJvcHMgfSA9IHByb2Nlc3NTbG90T3V0bGV0KG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgIGNvbnN0IHNsb3RBcmdzID0gW1xyXG4gICAgICAgICAgICBjb250ZXh0LnByZWZpeElkZW50aWZpZXJzID8gYF9jdHguJHNsb3RzYCA6IGAkc2xvdHNgLFxyXG4gICAgICAgICAgICBzbG90TmFtZSxcclxuICAgICAgICAgICAgJ3t9JyxcclxuICAgICAgICAgICAgJ3VuZGVmaW5lZCcsXHJcbiAgICAgICAgICAgICd0cnVlJ1xyXG4gICAgICAgIF07XHJcbiAgICAgICAgbGV0IGV4cGVjdGVkTGVuID0gMjtcclxuICAgICAgICBpZiAoc2xvdFByb3BzKSB7XHJcbiAgICAgICAgICAgIHNsb3RBcmdzWzJdID0gc2xvdFByb3BzO1xyXG4gICAgICAgICAgICBleHBlY3RlZExlbiA9IDM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgc2xvdEFyZ3NbM10gPSBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24oW10sIGNoaWxkcmVuLCBmYWxzZSwgZmFsc2UsIGxvYyk7XHJcbiAgICAgICAgICAgIGV4cGVjdGVkTGVuID0gNDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbnRleHQuc2NvcGVJZCAmJiAhY29udGV4dC5zbG90dGVkKSB7XHJcbiAgICAgICAgICAgIGV4cGVjdGVkTGVuID0gNTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2xvdEFyZ3Muc3BsaWNlKGV4cGVjdGVkTGVuKTsgLy8gcmVtb3ZlIHVudXNlZCBhcmd1bWVudHNcclxuICAgICAgICBub2RlLmNvZGVnZW5Ob2RlID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoUkVOREVSX1NMT1QpLCBzbG90QXJncywgbG9jKTtcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gcHJvY2Vzc1Nsb3RPdXRsZXQobm9kZSwgY29udGV4dCkge1xyXG4gICAgbGV0IHNsb3ROYW1lID0gYFwiZGVmYXVsdFwiYDtcclxuICAgIGxldCBzbG90UHJvcHMgPSB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBub25OYW1lUHJvcHMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHAgPSBub2RlLnByb3BzW2ldO1xyXG4gICAgICAgIGlmIChwLnR5cGUgPT09IDYgLyogQVRUUklCVVRFICovKSB7XHJcbiAgICAgICAgICAgIGlmIChwLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocC5uYW1lID09PSAnbmFtZScpIHtcclxuICAgICAgICAgICAgICAgICAgICBzbG90TmFtZSA9IEpTT04uc3RyaW5naWZ5KHAudmFsdWUuY29udGVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwLm5hbWUgPSBjYW1lbGl6ZShwLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vbk5hbWVQcm9wcy5wdXNoKHApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAocC5uYW1lID09PSAnYmluZCcgJiYgaXNTdGF0aWNBcmdPZihwLmFyZywgJ25hbWUnKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHAuZXhwKVxyXG4gICAgICAgICAgICAgICAgICAgIHNsb3ROYW1lID0gcC5leHA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocC5uYW1lID09PSAnYmluZCcgJiYgcC5hcmcgJiYgaXNTdGF0aWNFeHAocC5hcmcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcC5hcmcuY29udGVudCA9IGNhbWVsaXplKHAuYXJnLmNvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbm9uTmFtZVByb3BzLnB1c2gocCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobm9uTmFtZVByb3BzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zdCB7IHByb3BzLCBkaXJlY3RpdmVzIH0gPSBidWlsZFByb3BzKG5vZGUsIGNvbnRleHQsIG5vbk5hbWVQcm9wcyk7XHJcbiAgICAgICAgc2xvdFByb3BzID0gcHJvcHM7XHJcbiAgICAgICAgaWYgKGRpcmVjdGl2ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDM2IC8qIFhfVl9TTE9UX1VORVhQRUNURURfRElSRUNUSVZFX09OX1NMT1RfT1VUTEVUICovLCBkaXJlY3RpdmVzWzBdLmxvYykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc2xvdE5hbWUsXHJcbiAgICAgICAgc2xvdFByb3BzXHJcbiAgICB9O1xyXG59XG5cbmNvbnN0IGZuRXhwUkUgPSAvXlxccyooW1xcdyRfXSt8KGFzeW5jXFxzKik/XFwoW14pXSo/XFwpKVxccyo9PnxeXFxzKihhc3luY1xccyspP2Z1bmN0aW9uKD86XFxzK1tcXHckXSspP1xccypcXCgvO1xyXG5jb25zdCB0cmFuc2Zvcm1PbiA9IChkaXIsIG5vZGUsIGNvbnRleHQsIGF1Z21lbnRvcikgPT4ge1xyXG4gICAgY29uc3QgeyBsb2MsIG1vZGlmaWVycywgYXJnIH0gPSBkaXI7XHJcbiAgICBpZiAoIWRpci5leHAgJiYgIW1vZGlmaWVycy5sZW5ndGgpIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzNSAvKiBYX1ZfT05fTk9fRVhQUkVTU0lPTiAqLywgbG9jKSk7XHJcbiAgICB9XHJcbiAgICBsZXQgZXZlbnROYW1lO1xyXG4gICAgaWYgKGFyZy50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgaWYgKGFyZy5pc1N0YXRpYykge1xyXG4gICAgICAgICAgICBsZXQgcmF3TmFtZSA9IGFyZy5jb250ZW50O1xyXG4gICAgICAgICAgICAvLyBUT0RPIGRlcHJlY2F0ZSBAdm5vZGVYWFggdXNhZ2VcclxuICAgICAgICAgICAgaWYgKHJhd05hbWUuc3RhcnRzV2l0aCgndnVlOicpKSB7XHJcbiAgICAgICAgICAgICAgICByYXdOYW1lID0gYHZub2RlLSR7cmF3TmFtZS5zbGljZSg0KX1gO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGZvciBhbGwgZXZlbnQgbGlzdGVuZXJzLCBhdXRvIGNvbnZlcnQgaXQgdG8gY2FtZWxDYXNlLiBTZWUgaXNzdWUgIzIyNDlcclxuICAgICAgICAgICAgZXZlbnROYW1lID0gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbih0b0hhbmRsZXJLZXkoY2FtZWxpemUkMShyYXdOYW1lKSksIHRydWUsIGFyZy5sb2MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gIzIzODhcclxuICAgICAgICAgICAgZXZlbnROYW1lID0gY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtcclxuICAgICAgICAgICAgICAgIGAke2NvbnRleHQuaGVscGVyU3RyaW5nKFRPX0hBTkRMRVJfS0VZKX0oYCxcclxuICAgICAgICAgICAgICAgIGFyZyxcclxuICAgICAgICAgICAgICAgIGApYFxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBhbHJlYWR5IGEgY29tcG91bmQgZXhwcmVzc2lvbi5cclxuICAgICAgICBldmVudE5hbWUgPSBhcmc7XHJcbiAgICAgICAgZXZlbnROYW1lLmNoaWxkcmVuLnVuc2hpZnQoYCR7Y29udGV4dC5oZWxwZXJTdHJpbmcoVE9fSEFORExFUl9LRVkpfShgKTtcclxuICAgICAgICBldmVudE5hbWUuY2hpbGRyZW4ucHVzaChgKWApO1xyXG4gICAgfVxyXG4gICAgLy8gaGFuZGxlciBwcm9jZXNzaW5nXHJcbiAgICBsZXQgZXhwID0gZGlyLmV4cDtcclxuICAgIGlmIChleHAgJiYgIWV4cC5jb250ZW50LnRyaW0oKSkge1xyXG4gICAgICAgIGV4cCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGxldCBzaG91bGRDYWNoZSA9IGNvbnRleHQuY2FjaGVIYW5kbGVycyAmJiAhZXhwICYmICFjb250ZXh0LmluVk9uY2U7XHJcbiAgICBpZiAoZXhwKSB7XHJcbiAgICAgICAgY29uc3QgaXNNZW1iZXJFeHAgPSBpc01lbWJlckV4cHJlc3Npb24oZXhwLmNvbnRlbnQpO1xyXG4gICAgICAgIGNvbnN0IGlzSW5saW5lU3RhdGVtZW50ID0gIShpc01lbWJlckV4cCB8fCBmbkV4cFJFLnRlc3QoZXhwLmNvbnRlbnQpKTtcclxuICAgICAgICBjb25zdCBoYXNNdWx0aXBsZVN0YXRlbWVudHMgPSBleHAuY29udGVudC5pbmNsdWRlcyhgO2ApO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgdHJ1ZSkge1xyXG4gICAgICAgICAgICB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKGV4cCwgY29udGV4dCwgZmFsc2UsIGhhc011bHRpcGxlU3RhdGVtZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0lubGluZVN0YXRlbWVudCB8fCAoc2hvdWxkQ2FjaGUgJiYgaXNNZW1iZXJFeHApKSB7XHJcbiAgICAgICAgICAgIC8vIHdyYXAgaW5saW5lIHN0YXRlbWVudCBpbiBhIGZ1bmN0aW9uIGV4cHJlc3Npb25cclxuICAgICAgICAgICAgZXhwID0gY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtcclxuICAgICAgICAgICAgICAgIGAke2lzSW5saW5lU3RhdGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgPyBgJGV2ZW50YFxyXG4gICAgICAgICAgICAgICAgICAgIDogYCR7YGB9KC4uLmFyZ3MpYH0gPT4gJHtoYXNNdWx0aXBsZVN0YXRlbWVudHMgPyBge2AgOiBgKGB9YCxcclxuICAgICAgICAgICAgICAgIGV4cCxcclxuICAgICAgICAgICAgICAgIGhhc011bHRpcGxlU3RhdGVtZW50cyA/IGB9YCA6IGApYFxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsZXQgcmV0ID0ge1xyXG4gICAgICAgIHByb3BzOiBbXHJcbiAgICAgICAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KGV2ZW50TmFtZSwgZXhwIHx8IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYCgpID0+IHt9YCwgZmFsc2UsIGxvYykpXHJcbiAgICAgICAgXVxyXG4gICAgfTtcclxuICAgIC8vIGFwcGx5IGV4dGVuZGVkIGNvbXBpbGVyIGF1Z21lbnRvclxyXG4gICAgaWYgKGF1Z21lbnRvcikge1xyXG4gICAgICAgIHJldCA9IGF1Z21lbnRvcihyZXQpO1xyXG4gICAgfVxyXG4gICAgaWYgKHNob3VsZENhY2hlKSB7XHJcbiAgICAgICAgLy8gY2FjaGUgaGFuZGxlcnMgc28gdGhhdCBpdCdzIGFsd2F5cyB0aGUgc2FtZSBoYW5kbGVyIGJlaW5nIHBhc3NlZCBkb3duLlxyXG4gICAgICAgIC8vIHRoaXMgYXZvaWRzIHVubmVjZXNzYXJ5IHJlLXJlbmRlcnMgd2hlbiB1c2VycyB1c2UgaW5saW5lIGhhbmRsZXJzIG9uXHJcbiAgICAgICAgLy8gY29tcG9uZW50cy5cclxuICAgICAgICByZXQucHJvcHNbMF0udmFsdWUgPSBjb250ZXh0LmNhY2hlKHJldC5wcm9wc1swXS52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvLyBtYXJrIHRoZSBrZXkgYXMgaGFuZGxlciBmb3IgcHJvcHMgbm9ybWFsaXphdGlvbiBjaGVja1xyXG4gICAgcmV0LnByb3BzLmZvckVhY2gocCA9PiAocC5rZXkuaXNIYW5kbGVyS2V5ID0gdHJ1ZSkpO1xyXG4gICAgcmV0dXJuIHJldDtcclxufTtcblxuLy8gdi1iaW5kIHdpdGhvdXQgYXJnIGlzIGhhbmRsZWQgZGlyZWN0bHkgaW4gLi90cmFuc2Zvcm1FbGVtZW50cy50cyBkdWUgdG8gaXQgYWZmZWN0aW5nXHJcbi8vIGNvZGVnZW4gZm9yIHRoZSBlbnRpcmUgcHJvcHMgb2JqZWN0LiBUaGlzIHRyYW5zZm9ybSBoZXJlIGlzIG9ubHkgZm9yIHYtYmluZFxyXG4vLyAqd2l0aCogYXJncy5cclxuY29uc3QgdHJhbnNmb3JtQmluZCA9IChkaXIsIF9ub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBjb25zdCB7IGV4cCwgbW9kaWZpZXJzLCBsb2MgfSA9IGRpcjtcclxuICAgIGNvbnN0IGFyZyA9IGRpci5hcmc7XHJcbiAgICBpZiAoYXJnLnR5cGUgIT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICBhcmcuY2hpbGRyZW4udW5zaGlmdChgKGApO1xyXG4gICAgICAgIGFyZy5jaGlsZHJlbi5wdXNoKGApIHx8IFwiXCJgKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFhcmcuaXNTdGF0aWMpIHtcclxuICAgICAgICBhcmcuY29udGVudCA9IGAke2FyZy5jb250ZW50fSB8fCBcIlwiYDtcclxuICAgIH1cclxuICAgIC8vIC5zeW5jIGlzIHJlcGxhY2VkIGJ5IHYtbW9kZWw6YXJnXHJcbiAgICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKCdjYW1lbCcpKSB7XHJcbiAgICAgICAgaWYgKGFyZy50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgICAgIGlmIChhcmcuaXNTdGF0aWMpIHtcclxuICAgICAgICAgICAgICAgIGFyZy5jb250ZW50ID0gY2FtZWxpemUkMShhcmcuY29udGVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhcmcuY29udGVudCA9IGAke2NvbnRleHQuaGVscGVyU3RyaW5nKENBTUVMSVpFKX0oJHthcmcuY29udGVudH0pYDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYXJnLmNoaWxkcmVuLnVuc2hpZnQoYCR7Y29udGV4dC5oZWxwZXJTdHJpbmcoQ0FNRUxJWkUpfShgKTtcclxuICAgICAgICAgICAgYXJnLmNoaWxkcmVuLnB1c2goYClgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIWNvbnRleHQuaW5TU1IpIHtcclxuICAgICAgICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKCdwcm9wJykpIHtcclxuICAgICAgICAgICAgaW5qZWN0UHJlZml4KGFyZywgJy4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcygnYXR0cicpKSB7XHJcbiAgICAgICAgICAgIGluamVjdFByZWZpeChhcmcsICdeJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFleHAgfHxcclxuICAgICAgICAoZXhwLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gJiYgIWV4cC5jb250ZW50LnRyaW0oKSkpIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzNCAvKiBYX1ZfQklORF9OT19FWFBSRVNTSU9OICovLCBsb2MpKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwcm9wczogW2NyZWF0ZU9iamVjdFByb3BlcnR5KGFyZywgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbignJywgdHJ1ZSwgbG9jKSldXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcHJvcHM6IFtjcmVhdGVPYmplY3RQcm9wZXJ0eShhcmcsIGV4cCldXHJcbiAgICB9O1xyXG59O1xyXG5jb25zdCBpbmplY3RQcmVmaXggPSAoYXJnLCBwcmVmaXgpID0+IHtcclxuICAgIGlmIChhcmcudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgIGlmIChhcmcuaXNTdGF0aWMpIHtcclxuICAgICAgICAgICAgYXJnLmNvbnRlbnQgPSBwcmVmaXggKyBhcmcuY29udGVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFyZy5jb250ZW50ID0gYFxcYCR7cHJlZml4fVxcJHske2FyZy5jb250ZW50fX1cXGBgO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFyZy5jaGlsZHJlbi51bnNoaWZ0KGAnJHtwcmVmaXh9JyArIChgKTtcclxuICAgICAgICBhcmcuY2hpbGRyZW4ucHVzaChgKWApO1xyXG4gICAgfVxyXG59O1xuXG4vLyBNZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzIGFuZCBleHByZXNzaW9ucyBpbnRvIGEgc2luZ2xlIGV4cHJlc3Npb25cclxuLy8gZS5nLiA8ZGl2PmFiYyB7eyBkIH19IHt7IGUgfX08L2Rpdj4gc2hvdWxkIGhhdmUgYSBzaW5nbGUgZXhwcmVzc2lvbiBub2RlIGFzIGNoaWxkLlxyXG5jb25zdCB0cmFuc2Zvcm1UZXh0ID0gKG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDAgLyogUk9PVCAqLyB8fFxyXG4gICAgICAgIG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovIHx8XHJcbiAgICAgICAgbm9kZS50eXBlID09PSAxMSAvKiBGT1IgKi8gfHxcclxuICAgICAgICBub2RlLnR5cGUgPT09IDEwIC8qIElGX0JSQU5DSCAqLykge1xyXG4gICAgICAgIC8vIHBlcmZvcm0gdGhlIHRyYW5zZm9ybSBvbiBub2RlIGV4aXQgc28gdGhhdCBhbGwgZXhwcmVzc2lvbnMgaGF2ZSBhbHJlYWR5XHJcbiAgICAgICAgLy8gYmVlbiBwcm9jZXNzZWQuXHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudENvbnRhaW5lciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgbGV0IGhhc1RleHQgPSBmYWxzZTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1RleHQoY2hpbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzVGV4dCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IGNoaWxkcmVuW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNUZXh0KG5leHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRDb250YWluZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29udGFpbmVyID0gY2hpbGRyZW5baV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jOiBjaGlsZC5sb2MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbY2hpbGRdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZSBpbnRvIGN1cnJlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250YWluZXIuY2hpbGRyZW4ucHVzaChgICsgYCwgbmV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaiwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqLS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29udGFpbmVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFoYXNUZXh0IHx8XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCB3aXRoIGEgc2luZ2xlIHRleHQgY2hpbGQsIGxlYXZlIGl0XHJcbiAgICAgICAgICAgICAgICAvLyBhcy1pcyBzaW5jZSB0aGUgcnVudGltZSBoYXMgZGVkaWNhdGVkIGZhc3QgcGF0aCBmb3IgdGhpcyBieSBkaXJlY3RseVxyXG4gICAgICAgICAgICAgICAgLy8gc2V0dGluZyB0ZXh0Q29udGVudCBvZiB0aGUgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgIC8vIGZvciBjb21wb25lbnQgcm9vdCBpdCdzIGFsd2F5cyBub3JtYWxpemVkIGFueXdheS5cclxuICAgICAgICAgICAgICAgIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcclxuICAgICAgICAgICAgICAgICAgICAobm9kZS50eXBlID09PSAwIC8qIFJPT1QgKi8gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnRhZ1R5cGUgPT09IDAgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIzM3NTZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN1c3RvbSBkaXJlY3RpdmVzIGNhbiBwb3RlbnRpYWxseSBhZGQgRE9NIGVsZW1lbnRzIGFyYml0cmFyaWx5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBhdm9pZCBzZXR0aW5nIHRleHRDb250ZW50IG9mIHRoZSBlbGVtZW50IGF0IHJ1bnRpbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIGF2b2lkIGFjY2lkZW50YWxseSBvdmVyd3JpdGluZyB0aGUgRE9NIGVsZW1lbnRzIGFkZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBieSB0aGUgdXNlciB0aHJvdWdoIGN1c3RvbSBkaXJlY3RpdmVzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIW5vZGUucHJvcHMuZmluZChwID0+IHAudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhY29udGV4dC5kaXJlY3RpdmVUcmFuc2Zvcm1zW3AubmFtZV0pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiBjb21wYXQgbW9kZSwgPHRlbXBsYXRlPiB0YWdzIHdpdGggbm8gc3BlY2lhbCBkaXJlY3RpdmVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIGJlIHJlbmRlcmVkIGFzIGEgZnJhZ21lbnQgc28gaXRzIGNoaWxkcmVuIG11c3QgYmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnRlZCBpbnRvIHZub2Rlcy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICEobm9kZS50YWcgPT09ICd0ZW1wbGF0ZScpKSkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcHJlLWNvbnZlcnQgdGV4dCBub2RlcyBpbnRvIGNyZWF0ZVRleHRWTm9kZSh0ZXh0KSBjYWxscyB0byBhdm9pZFxyXG4gICAgICAgICAgICAvLyBydW50aW1lIG5vcm1hbGl6YXRpb24uXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNUZXh0KGNoaWxkKSB8fCBjaGlsZC50eXBlID09PSA4IC8qIENPTVBPVU5EX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsQXJncyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZVRleHRWTm9kZSBkZWZhdWx0cyB0byBzaW5nbGUgd2hpdGVzcGFjZSwgc28gaWYgaXQgaXMgYVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBzcGFjZSB0aGUgY29kZSBjb3VsZCBiZSBhbiBlbXB0eSBjYWxsIHRvIHNhdmUgYnl0ZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT09IDIgLyogVEVYVCAqLyB8fCBjaGlsZC5jb250ZW50ICE9PSAnICcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbEFyZ3MucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1hcmsgZHluYW1pYyB0ZXh0IHdpdGggZmxhZyBzbyBpdCBnZXRzIHBhdGNoZWQgaW5zaWRlIGEgYmxvY2tcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQuc3NyICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbnN0YW50VHlwZShjaGlsZCwgY29udGV4dCkgPT09IDAgLyogTk9UX0NPTlNUQU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxBcmdzLnB1c2goMSAvKiBURVhUICovICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgIC8qICR7UGF0Y2hGbGFnTmFtZXNbMSAvKiBURVhUICovXX0gKi9gIDogYGApKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IDEyIC8qIFRFWFRfQ0FMTCAqLyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogY2hpbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYzogY2hpbGQubG9jLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlZ2VuTm9kZTogY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoQ1JFQVRFX1RFWFQpLCBjYWxsQXJncylcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufTtcblxuY29uc3Qgc2VlbiA9IG5ldyBXZWFrU2V0KCk7XHJcbmNvbnN0IHRyYW5zZm9ybU9uY2UgPSAobm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovICYmIGZpbmREaXIobm9kZSwgJ29uY2UnLCB0cnVlKSkge1xyXG4gICAgICAgIGlmIChzZWVuLmhhcyhub2RlKSB8fCBjb250ZXh0LmluVk9uY2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZWVuLmFkZChub2RlKTtcclxuICAgICAgICBjb250ZXh0LmluVk9uY2UgPSB0cnVlO1xyXG4gICAgICAgIGNvbnRleHQuaGVscGVyKFNFVF9CTE9DS19UUkFDS0lORyk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgY29udGV4dC5pblZPbmNlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1ciA9IGNvbnRleHQuY3VycmVudE5vZGU7XHJcbiAgICAgICAgICAgIGlmIChjdXIuY29kZWdlbk5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGN1ci5jb2RlZ2VuTm9kZSA9IGNvbnRleHQuY2FjaGUoY3VyLmNvZGVnZW5Ob2RlLCB0cnVlIC8qIGlzVk5vZGUgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufTtcblxuY29uc3QgdHJhbnNmb3JtTW9kZWwgPSAoZGlyLCBub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBjb25zdCB7IGV4cCwgYXJnIH0gPSBkaXI7XHJcbiAgICBpZiAoIWV4cCkge1xyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDQxIC8qIFhfVl9NT0RFTF9OT19FWFBSRVNTSU9OICovLCBkaXIubG9jKSk7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRyYW5zZm9ybVByb3BzKCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCByYXdFeHAgPSBleHAubG9jLnNvdXJjZTtcclxuICAgIGNvbnN0IGV4cFN0cmluZyA9IGV4cC50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovID8gZXhwLmNvbnRlbnQgOiByYXdFeHA7XHJcbiAgICAvLyBpbSBTRkMgPHNjcmlwdCBzZXR1cD4gaW5saW5lIG1vZGUsIHRoZSBleHAgbWF5IGhhdmUgYmVlbiB0cmFuc2Zvcm1lZCBpbnRvXHJcbiAgICAvLyBfdW5yZWYoZXhwKVxyXG4gICAgY29udGV4dC5iaW5kaW5nTWV0YWRhdGFbcmF3RXhwXTtcclxuICAgIGNvbnN0IG1heWJlUmVmID0gIXRydWUgICAgLyogU0VUVVBfQ09OU1QgKi87XHJcbiAgICBpZiAoIWV4cFN0cmluZy50cmltKCkgfHxcclxuICAgICAgICAoIWlzTWVtYmVyRXhwcmVzc2lvbihleHBTdHJpbmcpICYmICFtYXliZVJlZikpIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig0MiAvKiBYX1ZfTU9ERUxfTUFMRk9STUVEX0VYUFJFU1NJT04gKi8sIGV4cC5sb2MpKTtcclxuICAgICAgICByZXR1cm4gY3JlYXRlVHJhbnNmb3JtUHJvcHMoKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHByb3BOYW1lID0gYXJnID8gYXJnIDogY3JlYXRlU2ltcGxlRXhwcmVzc2lvbignbW9kZWxWYWx1ZScsIHRydWUpO1xyXG4gICAgY29uc3QgZXZlbnROYW1lID0gYXJnXHJcbiAgICAgICAgPyBpc1N0YXRpY0V4cChhcmcpXHJcbiAgICAgICAgICAgID8gYG9uVXBkYXRlOiR7YXJnLmNvbnRlbnR9YFxyXG4gICAgICAgICAgICA6IGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbJ1wib25VcGRhdGU6XCIgKyAnLCBhcmddKVxyXG4gICAgICAgIDogYG9uVXBkYXRlOm1vZGVsVmFsdWVgO1xyXG4gICAgbGV0IGFzc2lnbm1lbnRFeHA7XHJcbiAgICBjb25zdCBldmVudEFyZyA9IGNvbnRleHQuaXNUUyA/IGAoJGV2ZW50OiBhbnkpYCA6IGAkZXZlbnRgO1xyXG4gICAge1xyXG4gICAgICAgIGFzc2lnbm1lbnRFeHAgPSBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oW1xyXG4gICAgICAgICAgICBgJHtldmVudEFyZ30gPT4gKChgLFxyXG4gICAgICAgICAgICBleHAsXHJcbiAgICAgICAgICAgIGApID0gJGV2ZW50KWBcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHByb3BzID0gW1xyXG4gICAgICAgIC8vIG1vZGVsVmFsdWU6IGZvb1xyXG4gICAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KHByb3BOYW1lLCBkaXIuZXhwKSxcclxuICAgICAgICAvLyBcIm9uVXBkYXRlOm1vZGVsVmFsdWVcIjogJGV2ZW50ID0+IChmb28gPSAkZXZlbnQpXHJcbiAgICAgICAgY3JlYXRlT2JqZWN0UHJvcGVydHkoZXZlbnROYW1lLCBhc3NpZ25tZW50RXhwKVxyXG4gICAgXTtcclxuICAgIC8vIG1vZGVsTW9kaWZpZXJzOiB7IGZvbzogdHJ1ZSwgXCJiYXItYmF6XCI6IHRydWUgfVxyXG4gICAgaWYgKGRpci5tb2RpZmllcnMubGVuZ3RoICYmIG5vZGUudGFnVHlwZSA9PT0gMSAvKiBDT01QT05FTlQgKi8pIHtcclxuICAgICAgICBjb25zdCBtb2RpZmllcnMgPSBkaXIubW9kaWZpZXJzXHJcbiAgICAgICAgICAgIC5tYXAobSA9PiAoaXNTaW1wbGVJZGVudGlmaWVyKG0pID8gbSA6IEpTT04uc3RyaW5naWZ5KG0pKSArIGA6IHRydWVgKVxyXG4gICAgICAgICAgICAuam9pbihgLCBgKTtcclxuICAgICAgICBjb25zdCBtb2RpZmllcnNLZXkgPSBhcmdcclxuICAgICAgICAgICAgPyBpc1N0YXRpY0V4cChhcmcpXHJcbiAgICAgICAgICAgICAgICA/IGAke2FyZy5jb250ZW50fU1vZGlmaWVyc2BcclxuICAgICAgICAgICAgICAgIDogY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFthcmcsICcgKyBcIk1vZGlmaWVyc1wiJ10pXHJcbiAgICAgICAgICAgIDogYG1vZGVsTW9kaWZpZXJzYDtcclxuICAgICAgICBwcm9wcy5wdXNoKGNyZWF0ZU9iamVjdFByb3BlcnR5KG1vZGlmaWVyc0tleSwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgeyAke21vZGlmaWVyc30gfWAsIGZhbHNlLCBkaXIubG9jLCAyIC8qIENBTl9IT0lTVCAqLykpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjcmVhdGVUcmFuc2Zvcm1Qcm9wcyhwcm9wcyk7XHJcbn07XHJcbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zZm9ybVByb3BzKHByb3BzID0gW10pIHtcclxuICAgIHJldHVybiB7IHByb3BzIH07XHJcbn1cblxuY29uc3QgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcclxuY29uc3QgdHJhbnNmb3JtRmlsdGVyID0gKG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGlmICghaXNDb21wYXRFbmFibGVkKFwiQ09NUElMRVJfRklMVEVSXCIgLyogQ09NUElMRVJfRklMVEVSUyAqLywgY29udGV4dCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAobm9kZS50eXBlID09PSA1IC8qIElOVEVSUE9MQVRJT04gKi8pIHtcclxuICAgICAgICAvLyBmaWx0ZXIgcmV3cml0ZSBpcyBhcHBsaWVkIGJlZm9yZSBleHByZXNzaW9uIHRyYW5zZm9ybSBzbyBvbmx5XHJcbiAgICAgICAgLy8gc2ltcGxlIGV4cHJlc3Npb25zIGFyZSBwb3NzaWJsZSBhdCB0aGlzIHN0YWdlXHJcbiAgICAgICAgcmV3cml0ZUZpbHRlcihub2RlLmNvbnRlbnQsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovKSB7XHJcbiAgICAgICAgbm9kZS5wcm9wcy5mb3JFYWNoKChwcm9wKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChwcm9wLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmXHJcbiAgICAgICAgICAgICAgICBwcm9wLm5hbWUgIT09ICdmb3InICYmXHJcbiAgICAgICAgICAgICAgICBwcm9wLmV4cCkge1xyXG4gICAgICAgICAgICAgICAgcmV3cml0ZUZpbHRlcihwcm9wLmV4cCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gcmV3cml0ZUZpbHRlcihub2RlLCBjb250ZXh0KSB7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgcGFyc2VGaWx0ZXIobm9kZSwgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgICAgICAgICAgcGFyc2VGaWx0ZXIoY2hpbGQsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkLnR5cGUgPT09IDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgICAgICAgICAgcmV3cml0ZUZpbHRlcihub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZC50eXBlID09PSA1IC8qIElOVEVSUE9MQVRJT04gKi8pIHtcclxuICAgICAgICAgICAgICAgIHJld3JpdGVGaWx0ZXIoY2hpbGQuY29udGVudCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VGaWx0ZXIobm9kZSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgZXhwID0gbm9kZS5jb250ZW50O1xyXG4gICAgbGV0IGluU2luZ2xlID0gZmFsc2U7XHJcbiAgICBsZXQgaW5Eb3VibGUgPSBmYWxzZTtcclxuICAgIGxldCBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7XHJcbiAgICBsZXQgaW5SZWdleCA9IGZhbHNlO1xyXG4gICAgbGV0IGN1cmx5ID0gMDtcclxuICAgIGxldCBzcXVhcmUgPSAwO1xyXG4gICAgbGV0IHBhcmVuID0gMDtcclxuICAgIGxldCBsYXN0RmlsdGVySW5kZXggPSAwO1xyXG4gICAgbGV0IGMsIHByZXYsIGksIGV4cHJlc3Npb24sIGZpbHRlcnMgPSBbXTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBleHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBwcmV2ID0gYztcclxuICAgICAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaWYgKGluU2luZ2xlKSB7XHJcbiAgICAgICAgICAgIGlmIChjID09PSAweDI3ICYmIHByZXYgIT09IDB4NWMpXHJcbiAgICAgICAgICAgICAgICBpblNpbmdsZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpbkRvdWJsZSkge1xyXG4gICAgICAgICAgICBpZiAoYyA9PT0gMHgyMiAmJiBwcmV2ICE9PSAweDVjKVxyXG4gICAgICAgICAgICAgICAgaW5Eb3VibGUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaW5UZW1wbGF0ZVN0cmluZykge1xyXG4gICAgICAgICAgICBpZiAoYyA9PT0gMHg2MCAmJiBwcmV2ICE9PSAweDVjKVxyXG4gICAgICAgICAgICAgICAgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpblJlZ2V4KSB7XHJcbiAgICAgICAgICAgIGlmIChjID09PSAweDJmICYmIHByZXYgIT09IDB4NWMpXHJcbiAgICAgICAgICAgICAgICBpblJlZ2V4ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGMgPT09IDB4N2MgJiYgLy8gcGlwZVxyXG4gICAgICAgICAgICBleHAuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N2MgJiZcclxuICAgICAgICAgICAgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdjICYmXHJcbiAgICAgICAgICAgICFjdXJseSAmJlxyXG4gICAgICAgICAgICAhc3F1YXJlICYmXHJcbiAgICAgICAgICAgICFwYXJlbikge1xyXG4gICAgICAgICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXHJcbiAgICAgICAgICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcclxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcHVzaEZpbHRlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGMpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMHgyMjpcclxuICAgICAgICAgICAgICAgICAgICBpbkRvdWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIFwiXHJcbiAgICAgICAgICAgICAgICBjYXNlIDB4Mjc6XHJcbiAgICAgICAgICAgICAgICAgICAgaW5TaW5nbGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAnXHJcbiAgICAgICAgICAgICAgICBjYXNlIDB4NjA6XHJcbiAgICAgICAgICAgICAgICAgICAgaW5UZW1wbGF0ZVN0cmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIGBcclxuICAgICAgICAgICAgICAgIGNhc2UgMHgyODpcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbisrO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAoXHJcbiAgICAgICAgICAgICAgICBjYXNlIDB4Mjk6XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW4tLTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gKVxyXG4gICAgICAgICAgICAgICAgY2FzZSAweDViOlxyXG4gICAgICAgICAgICAgICAgICAgIHNxdWFyZSsrO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBbXHJcbiAgICAgICAgICAgICAgICBjYXNlIDB4NWQ6XHJcbiAgICAgICAgICAgICAgICAgICAgc3F1YXJlLS07XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIF1cclxuICAgICAgICAgICAgICAgIGNhc2UgMHg3YjpcclxuICAgICAgICAgICAgICAgICAgICBjdXJseSsrO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDB4N2Q6XHJcbiAgICAgICAgICAgICAgICAgICAgY3VybHktLTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjID09PSAweDJmKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAvXHJcbiAgICAgICAgICAgICAgICBsZXQgaiA9IGkgLSAxO1xyXG4gICAgICAgICAgICAgICAgbGV0IHA7XHJcbiAgICAgICAgICAgICAgICAvLyBmaW5kIGZpcnN0IG5vbi13aGl0ZXNwYWNlIHByZXYgY2hhclxyXG4gICAgICAgICAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAgIT09ICcgJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIXAgfHwgIXZhbGlkRGl2aXNpb25DaGFyUkUudGVzdChwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluUmVnZXggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobGFzdEZpbHRlckluZGV4ICE9PSAwKSB7XHJcbiAgICAgICAgcHVzaEZpbHRlcigpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcHVzaEZpbHRlcigpIHtcclxuICAgICAgICBmaWx0ZXJzLnB1c2goZXhwLnNsaWNlKGxhc3RGaWx0ZXJJbmRleCwgaSkudHJpbSgpKTtcclxuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcclxuICAgIH1cclxuICAgIGlmIChmaWx0ZXJzLmxlbmd0aCkge1xyXG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICB3YXJuRGVwcmVjYXRpb24oXCJDT01QSUxFUl9GSUxURVJcIiAvKiBDT01QSUxFUl9GSUxURVJTICovLCBjb250ZXh0LCBub2RlLmxvYyk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHdyYXBGaWx0ZXIoZXhwcmVzc2lvbiwgZmlsdGVyc1tpXSwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5vZGUuY29udGVudCA9IGV4cHJlc3Npb247XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gd3JhcEZpbHRlcihleHAsIGZpbHRlciwgY29udGV4dCkge1xyXG4gICAgY29udGV4dC5oZWxwZXIoUkVTT0xWRV9GSUxURVIpO1xyXG4gICAgY29uc3QgaSA9IGZpbHRlci5pbmRleE9mKCcoJyk7XHJcbiAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICBjb250ZXh0LmZpbHRlcnMuYWRkKGZpbHRlcik7XHJcbiAgICAgICAgcmV0dXJuIGAke3RvVmFsaWRBc3NldElkKGZpbHRlciwgJ2ZpbHRlcicpfSgke2V4cH0pYDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSBmaWx0ZXIuc2xpY2UoMCwgaSk7XHJcbiAgICAgICAgY29uc3QgYXJncyA9IGZpbHRlci5zbGljZShpICsgMSk7XHJcbiAgICAgICAgY29udGV4dC5maWx0ZXJzLmFkZChuYW1lKTtcclxuICAgICAgICByZXR1cm4gYCR7dG9WYWxpZEFzc2V0SWQobmFtZSwgJ2ZpbHRlcicpfSgke2V4cH0ke2FyZ3MgIT09ICcpJyA/ICcsJyArIGFyZ3MgOiBhcmdzfWA7XHJcbiAgICB9XHJcbn1cblxuY29uc3Qgc2VlbiQxID0gbmV3IFdlYWtTZXQoKTtcclxuY29uc3QgdHJhbnNmb3JtTWVtbyA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICBjb25zdCBkaXIgPSBmaW5kRGlyKG5vZGUsICdtZW1vJyk7XHJcbiAgICAgICAgaWYgKCFkaXIgfHwgc2VlbiQxLmhhcyhub2RlKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNlZW4kMS5hZGQobm9kZSk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY29kZWdlbk5vZGUgPSBub2RlLmNvZGVnZW5Ob2RlIHx8XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmN1cnJlbnROb2RlLmNvZGVnZW5Ob2RlO1xyXG4gICAgICAgICAgICBpZiAoY29kZWdlbk5vZGUgJiYgY29kZWdlbk5vZGUudHlwZSA9PT0gMTMgLyogVk5PREVfQ0FMTCAqLykge1xyXG4gICAgICAgICAgICAgICAgLy8gbm9uLWNvbXBvbmVudCBzdWIgdHJlZSBzaG91bGQgYmUgdHVybmVkIGludG8gYSBibG9ja1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUudGFnVHlwZSAhPT0gMSAvKiBDT01QT05FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBtYWtlQmxvY2soY29kZWdlbk5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbm9kZS5jb2RlZ2VuTm9kZSA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKFdJVEhfTUVNTyksIFtcclxuICAgICAgICAgICAgICAgICAgICBkaXIuZXhwLFxyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbih1bmRlZmluZWQsIGNvZGVnZW5Ob2RlKSxcclxuICAgICAgICAgICAgICAgICAgICBgX2NhY2hlYCxcclxuICAgICAgICAgICAgICAgICAgICBTdHJpbmcoY29udGV4dC5jYWNoZWQrKylcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufTtcblxuZnVuY3Rpb24gZ2V0QmFzZVRyYW5zZm9ybVByZXNldChwcmVmaXhJZGVudGlmaWVycykge1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBbXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybU9uY2UsXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybUlmLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm1NZW1vLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm1Gb3IsXHJcbiAgICAgICAgICAgIC4uLihbdHJhbnNmb3JtRmlsdGVyXSApLFxyXG4gICAgICAgICAgICAuLi4oKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgICAgICAgICAgICAgPyBbdHJhbnNmb3JtRXhwcmVzc2lvbl1cclxuICAgICAgICAgICAgICAgICAgICA6IFtdKSxcclxuICAgICAgICAgICAgdHJhbnNmb3JtU2xvdE91dGxldCxcclxuICAgICAgICAgICAgdHJhbnNmb3JtRWxlbWVudCxcclxuICAgICAgICAgICAgdHJhY2tTbG90U2NvcGVzLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm1UZXh0XHJcbiAgICAgICAgXSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG9uOiB0cmFuc2Zvcm1PbixcclxuICAgICAgICAgICAgYmluZDogdHJhbnNmb3JtQmluZCxcclxuICAgICAgICAgICAgbW9kZWw6IHRyYW5zZm9ybU1vZGVsXHJcbiAgICAgICAgfVxyXG4gICAgXTtcclxufVxyXG4vLyB3ZSBuYW1lIGl0IGBiYXNlQ29tcGlsZWAgc28gdGhhdCBoaWdoZXIgb3JkZXIgY29tcGlsZXJzIGxpa2VcclxuLy8gQHZ1ZS9jb21waWxlci1kb20gY2FuIGV4cG9ydCBgY29tcGlsZWAgd2hpbGUgcmUtZXhwb3J0aW5nIGV2ZXJ5dGhpbmcgZWxzZS5cclxuZnVuY3Rpb24gYmFzZUNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgY29uc3Qgb25FcnJvciA9IG9wdGlvbnMub25FcnJvciB8fCBkZWZhdWx0T25FcnJvcjtcclxuICAgIGNvbnN0IGlzTW9kdWxlTW9kZSA9IG9wdGlvbnMubW9kZSA9PT0gJ21vZHVsZSc7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIHtcclxuICAgICAgICBpZiAob3B0aW9ucy5wcmVmaXhJZGVudGlmaWVycyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBvbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDYgLyogWF9QUkVGSVhfSURfTk9UX1NVUFBPUlRFRCAqLykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc01vZHVsZU1vZGUpIHtcclxuICAgICAgICAgICAgb25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDQ3IC8qIFhfTU9EVUxFX01PREVfTk9UX1NVUFBPUlRFRCAqLykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHByZWZpeElkZW50aWZpZXJzID0gIXRydWUgO1xyXG4gICAgaWYgKG9wdGlvbnMuY2FjaGVIYW5kbGVycykge1xyXG4gICAgICAgIG9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig0OCAvKiBYX0NBQ0hFX0hBTkRMRVJfTk9UX1NVUFBPUlRFRCAqLykpO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnMuc2NvcGVJZCAmJiAhaXNNb2R1bGVNb2RlKSB7XHJcbiAgICAgICAgb25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDQ5IC8qIFhfU0NPUEVfSURfTk9UX1NVUFBPUlRFRCAqLykpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYXN0ID0gaXNTdHJpbmcodGVtcGxhdGUpID8gYmFzZVBhcnNlKHRlbXBsYXRlLCBvcHRpb25zKSA6IHRlbXBsYXRlO1xyXG4gICAgY29uc3QgW25vZGVUcmFuc2Zvcm1zLCBkaXJlY3RpdmVUcmFuc2Zvcm1zXSA9IGdldEJhc2VUcmFuc2Zvcm1QcmVzZXQoKTtcclxuICAgIHRyYW5zZm9ybShhc3QsIGV4dGVuZCh7fSwgb3B0aW9ucywge1xyXG4gICAgICAgIHByZWZpeElkZW50aWZpZXJzLFxyXG4gICAgICAgIG5vZGVUcmFuc2Zvcm1zOiBbXHJcbiAgICAgICAgICAgIC4uLm5vZGVUcmFuc2Zvcm1zLFxyXG4gICAgICAgICAgICAuLi4ob3B0aW9ucy5ub2RlVHJhbnNmb3JtcyB8fCBbXSkgLy8gdXNlciB0cmFuc2Zvcm1zXHJcbiAgICAgICAgXSxcclxuICAgICAgICBkaXJlY3RpdmVUcmFuc2Zvcm1zOiBleHRlbmQoe30sIGRpcmVjdGl2ZVRyYW5zZm9ybXMsIG9wdGlvbnMuZGlyZWN0aXZlVHJhbnNmb3JtcyB8fCB7fSAvLyB1c2VyIHRyYW5zZm9ybXNcclxuICAgICAgICApXHJcbiAgICB9KSk7XHJcbiAgICByZXR1cm4gZ2VuZXJhdGUoYXN0LCBleHRlbmQoe30sIG9wdGlvbnMsIHtcclxuICAgICAgICBwcmVmaXhJZGVudGlmaWVyc1xyXG4gICAgfSkpO1xyXG59XG5cbmNvbnN0IG5vb3BEaXJlY3RpdmVUcmFuc2Zvcm0gPSAoKSA9PiAoeyBwcm9wczogW10gfSk7XG5cbmV4cG9ydCB7IEJBU0VfVFJBTlNJVElPTiwgQ0FNRUxJWkUsIENBUElUQUxJWkUsIENSRUFURV9CTE9DSywgQ1JFQVRFX0NPTU1FTlQsIENSRUFURV9FTEVNRU5UX0JMT0NLLCBDUkVBVEVfRUxFTUVOVF9WTk9ERSwgQ1JFQVRFX1NMT1RTLCBDUkVBVEVfU1RBVElDLCBDUkVBVEVfVEVYVCwgQ1JFQVRFX1ZOT0RFLCBGUkFHTUVOVCwgR1VBUkRfUkVBQ1RJVkVfUFJPUFMsIElTX01FTU9fU0FNRSwgSVNfUkVGLCBLRUVQX0FMSVZFLCBNRVJHRV9QUk9QUywgTk9STUFMSVpFX0NMQVNTLCBOT1JNQUxJWkVfUFJPUFMsIE5PUk1BTElaRV9TVFlMRSwgT1BFTl9CTE9DSywgUE9QX1NDT1BFX0lELCBQVVNIX1NDT1BFX0lELCBSRU5ERVJfTElTVCwgUkVOREVSX1NMT1QsIFJFU09MVkVfQ09NUE9ORU5ULCBSRVNPTFZFX0RJUkVDVElWRSwgUkVTT0xWRV9EWU5BTUlDX0NPTVBPTkVOVCwgUkVTT0xWRV9GSUxURVIsIFNFVF9CTE9DS19UUkFDS0lORywgU1VTUEVOU0UsIFRFTEVQT1JULCBUT19ESVNQTEFZX1NUUklORywgVE9fSEFORExFUlMsIFRPX0hBTkRMRVJfS0VZLCBVTlJFRiwgV0lUSF9DVFgsIFdJVEhfRElSRUNUSVZFUywgV0lUSF9NRU1PLCBhZHZhbmNlUG9zaXRpb25XaXRoQ2xvbmUsIGFkdmFuY2VQb3NpdGlvbldpdGhNdXRhdGlvbiwgYXNzZXJ0LCBiYXNlQ29tcGlsZSwgYmFzZVBhcnNlLCBidWlsZERpcmVjdGl2ZUFyZ3MsIGJ1aWxkUHJvcHMsIGJ1aWxkU2xvdHMsIGNoZWNrQ29tcGF0RW5hYmxlZCwgY3JlYXRlQXJyYXlFeHByZXNzaW9uLCBjcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbiwgY3JlYXRlQmxvY2tTdGF0ZW1lbnQsIGNyZWF0ZUNhY2hlRXhwcmVzc2lvbiwgY3JlYXRlQ2FsbEV4cHJlc3Npb24sIGNyZWF0ZUNvbXBpbGVyRXJyb3IsIGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbiwgY3JlYXRlQ29uZGl0aW9uYWxFeHByZXNzaW9uLCBjcmVhdGVGb3JMb29wUGFyYW1zLCBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24sIGNyZWF0ZUlmU3RhdGVtZW50LCBjcmVhdGVJbnRlcnBvbGF0aW9uLCBjcmVhdGVPYmplY3RFeHByZXNzaW9uLCBjcmVhdGVPYmplY3RQcm9wZXJ0eSwgY3JlYXRlUmV0dXJuU3RhdGVtZW50LCBjcmVhdGVSb290LCBjcmVhdGVTZXF1ZW5jZUV4cHJlc3Npb24sIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24sIGNyZWF0ZVN0cnVjdHVyYWxEaXJlY3RpdmVUcmFuc2Zvcm0sIGNyZWF0ZVRlbXBsYXRlTGl0ZXJhbCwgY3JlYXRlVHJhbnNmb3JtQ29udGV4dCwgY3JlYXRlVk5vZGVDYWxsLCBleHRyYWN0SWRlbnRpZmllcnMsIGZpbmREaXIsIGZpbmRQcm9wLCBnZW5lcmF0ZSwgZ2V0QmFzZVRyYW5zZm9ybVByZXNldCwgZ2V0SW5uZXJSYW5nZSwgZ2V0TWVtb2VkVk5vZGVDYWxsLCBnZXRWTm9kZUJsb2NrSGVscGVyLCBnZXRWTm9kZUhlbHBlciwgaGFzRHluYW1pY0tleVZCaW5kLCBoYXNTY29wZVJlZiwgaGVscGVyTmFtZU1hcCwgaW5qZWN0UHJvcCwgaXNCdWlsdEluVHlwZSwgaXNDb3JlQ29tcG9uZW50LCBpc0Z1bmN0aW9uVHlwZSwgaXNJbkRlc3RydWN0dXJlQXNzaWdubWVudCwgaXNNZW1iZXJFeHByZXNzaW9uLCBpc01lbWJlckV4cHJlc3Npb25Ccm93c2VyLCBpc01lbWJlckV4cHJlc3Npb25Ob2RlLCBpc1JlZmVyZW5jZWRJZGVudGlmaWVyLCBpc1NpbXBsZUlkZW50aWZpZXIsIGlzU2xvdE91dGxldCwgaXNTdGF0aWNBcmdPZiwgaXNTdGF0aWNFeHAsIGlzU3RhdGljUHJvcGVydHksIGlzU3RhdGljUHJvcGVydHlLZXksIGlzVGVtcGxhdGVOb2RlLCBpc1RleHQsIGlzVlNsb3QsIGxvY1N0dWIsIG1ha2VCbG9jaywgbm9vcERpcmVjdGl2ZVRyYW5zZm9ybSwgcHJvY2Vzc0V4cHJlc3Npb24sIHByb2Nlc3NGb3IsIHByb2Nlc3NJZiwgcHJvY2Vzc1Nsb3RPdXRsZXQsIHJlZ2lzdGVyUnVudGltZUhlbHBlcnMsIHJlc29sdmVDb21wb25lbnRUeXBlLCB0b1ZhbGlkQXNzZXRJZCwgdHJhY2tTbG90U2NvcGVzLCB0cmFja1ZGb3JTbG90U2NvcGVzLCB0cmFuc2Zvcm0sIHRyYW5zZm9ybUJpbmQsIHRyYW5zZm9ybUVsZW1lbnQsIHRyYW5zZm9ybUV4cHJlc3Npb24sIHRyYW5zZm9ybU1vZGVsLCB0cmFuc2Zvcm1PbiwgdHJhdmVyc2VOb2RlLCB3YWxrQmxvY2tEZWNsYXJhdGlvbnMsIHdhbGtGdW5jdGlvblBhcmFtcywgd2Fsa0lkZW50aWZpZXJzLCB3YXJuRGVwcmVjYXRpb24gfTtcbiIsImltcG9ydCB7IHJlZ2lzdGVyUnVudGltZUhlbHBlcnMsIGlzQnVpbHRJblR5cGUsIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24sIGNyZWF0ZUNvbXBpbGVyRXJyb3IsIGNyZWF0ZU9iamVjdFByb3BlcnR5LCBjcmVhdGVDYWxsRXhwcmVzc2lvbiwgVE9fRElTUExBWV9TVFJJTkcsIHRyYW5zZm9ybU1vZGVsIGFzIHRyYW5zZm9ybU1vZGVsJDEsIGZpbmRQcm9wLCBoYXNEeW5hbWljS2V5VkJpbmQsIHRyYW5zZm9ybU9uIGFzIHRyYW5zZm9ybU9uJDEsIGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbiwgaXNTdGF0aWNFeHAsIGNoZWNrQ29tcGF0RW5hYmxlZCwgbm9vcERpcmVjdGl2ZVRyYW5zZm9ybSwgYmFzZUNvbXBpbGUsIGJhc2VQYXJzZSB9IGZyb20gJ0B2dWUvY29tcGlsZXItY29yZSc7XG5leHBvcnQgKiBmcm9tICdAdnVlL2NvbXBpbGVyLWNvcmUnO1xuaW1wb3J0IHsgaXNWb2lkVGFnLCBpc0hUTUxUYWcsIGlzU1ZHVGFnLCBtYWtlTWFwLCBwYXJzZVN0cmluZ1N0eWxlLCBjYXBpdGFsaXplLCBleHRlbmQgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmNvbnN0IFZfTU9ERUxfUkFESU8gPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHZNb2RlbFJhZGlvYCA6IGBgKTtcclxuY29uc3QgVl9NT0RFTF9DSEVDS0JPWCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdk1vZGVsQ2hlY2tib3hgIDogYGApO1xyXG5jb25zdCBWX01PREVMX1RFWFQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHZNb2RlbFRleHRgIDogYGApO1xyXG5jb25zdCBWX01PREVMX1NFTEVDVCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdk1vZGVsU2VsZWN0YCA6IGBgKTtcclxuY29uc3QgVl9NT0RFTF9EWU5BTUlDID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB2TW9kZWxEeW5hbWljYCA6IGBgKTtcclxuY29uc3QgVl9PTl9XSVRIX01PRElGSUVSUyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdk9uTW9kaWZpZXJzR3VhcmRgIDogYGApO1xyXG5jb25zdCBWX09OX1dJVEhfS0VZUyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdk9uS2V5c0d1YXJkYCA6IGBgKTtcclxuY29uc3QgVl9TSE9XID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB2U2hvd2AgOiBgYCk7XHJcbmNvbnN0IFRSQU5TSVRJT04gPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYFRyYW5zaXRpb25gIDogYGApO1xyXG5jb25zdCBUUkFOU0lUSU9OX0dST1VQID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBUcmFuc2l0aW9uR3JvdXBgIDogYGApO1xyXG5yZWdpc3RlclJ1bnRpbWVIZWxwZXJzKHtcclxuICAgIFtWX01PREVMX1JBRElPXTogYHZNb2RlbFJhZGlvYCxcclxuICAgIFtWX01PREVMX0NIRUNLQk9YXTogYHZNb2RlbENoZWNrYm94YCxcclxuICAgIFtWX01PREVMX1RFWFRdOiBgdk1vZGVsVGV4dGAsXHJcbiAgICBbVl9NT0RFTF9TRUxFQ1RdOiBgdk1vZGVsU2VsZWN0YCxcclxuICAgIFtWX01PREVMX0RZTkFNSUNdOiBgdk1vZGVsRHluYW1pY2AsXHJcbiAgICBbVl9PTl9XSVRIX01PRElGSUVSU106IGB3aXRoTW9kaWZpZXJzYCxcclxuICAgIFtWX09OX1dJVEhfS0VZU106IGB3aXRoS2V5c2AsXHJcbiAgICBbVl9TSE9XXTogYHZTaG93YCxcclxuICAgIFtUUkFOU0lUSU9OXTogYFRyYW5zaXRpb25gLFxyXG4gICAgW1RSQU5TSVRJT05fR1JPVVBdOiBgVHJhbnNpdGlvbkdyb3VwYFxyXG59KTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXHJcbmxldCBkZWNvZGVyO1xyXG5mdW5jdGlvbiBkZWNvZGVIdG1sQnJvd3NlcihyYXcsIGFzQXR0ciA9IGZhbHNlKSB7XHJcbiAgICBpZiAoIWRlY29kZXIpIHtcclxuICAgICAgICBkZWNvZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICB9XHJcbiAgICBpZiAoYXNBdHRyKSB7XHJcbiAgICAgICAgZGVjb2Rlci5pbm5lckhUTUwgPSBgPGRpdiBmb289XCIke3Jhdy5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyl9XCI+YDtcclxuICAgICAgICByZXR1cm4gZGVjb2Rlci5jaGlsZHJlblswXS5nZXRBdHRyaWJ1dGUoJ2ZvbycpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZGVjb2Rlci5pbm5lckhUTUwgPSByYXc7XHJcbiAgICAgICAgcmV0dXJuIGRlY29kZXIudGV4dENvbnRlbnQ7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgaXNSYXdUZXh0Q29udGFpbmVyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKCdzdHlsZSxpZnJhbWUsc2NyaXB0LG5vc2NyaXB0JywgdHJ1ZSk7XHJcbmNvbnN0IHBhcnNlck9wdGlvbnMgPSB7XHJcbiAgICBpc1ZvaWRUYWcsXHJcbiAgICBpc05hdGl2ZVRhZzogdGFnID0+IGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHVGFnKHRhZyksXHJcbiAgICBpc1ByZVRhZzogdGFnID0+IHRhZyA9PT0gJ3ByZScsXHJcbiAgICBkZWNvZGVFbnRpdGllczogZGVjb2RlSHRtbEJyb3dzZXIgLFxyXG4gICAgaXNCdWlsdEluQ29tcG9uZW50OiAodGFnKSA9PiB7XHJcbiAgICAgICAgaWYgKGlzQnVpbHRJblR5cGUodGFnLCBgVHJhbnNpdGlvbmApKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBUUkFOU0lUSU9OO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0J1aWx0SW5UeXBlKHRhZywgYFRyYW5zaXRpb25Hcm91cGApKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBUUkFOU0lUSU9OX0dST1VQO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9wYXJzaW5nLmh0bWwjdHJlZS1jb25zdHJ1Y3Rpb24tZGlzcGF0Y2hlclxyXG4gICAgZ2V0TmFtZXNwYWNlKHRhZywgcGFyZW50KSB7XHJcbiAgICAgICAgbGV0IG5zID0gcGFyZW50ID8gcGFyZW50Lm5zIDogMCAvKiBIVE1MICovO1xyXG4gICAgICAgIGlmIChwYXJlbnQgJiYgbnMgPT09IDIgLyogTUFUSF9NTCAqLykge1xyXG4gICAgICAgICAgICBpZiAocGFyZW50LnRhZyA9PT0gJ2Fubm90YXRpb24teG1sJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhZyA9PT0gJ3N2ZycpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTVkcgKi87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50LnByb3BzLnNvbWUoYSA9PiBhLnR5cGUgPT09IDYgLyogQVRUUklCVVRFICovICYmXHJcbiAgICAgICAgICAgICAgICAgICAgYS5uYW1lID09PSAnZW5jb2RpbmcnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgYS52YWx1ZSAhPSBudWxsICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKGEudmFsdWUuY29udGVudCA9PT0gJ3RleHQvaHRtbCcgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYS52YWx1ZS5jb250ZW50ID09PSAnYXBwbGljYXRpb24veGh0bWwreG1sJykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbnMgPSAwIC8qIEhUTUwgKi87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoL15tKD86W2lvbnNdfHRleHQpJC8udGVzdChwYXJlbnQudGFnKSAmJlxyXG4gICAgICAgICAgICAgICAgdGFnICE9PSAnbWdseXBoJyAmJlxyXG4gICAgICAgICAgICAgICAgdGFnICE9PSAnbWFsaWdubWFyaycpIHtcclxuICAgICAgICAgICAgICAgIG5zID0gMCAvKiBIVE1MICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhcmVudCAmJiBucyA9PT0gMSAvKiBTVkcgKi8pIHtcclxuICAgICAgICAgICAgaWYgKHBhcmVudC50YWcgPT09ICdmb3JlaWduT2JqZWN0JyB8fFxyXG4gICAgICAgICAgICAgICAgcGFyZW50LnRhZyA9PT0gJ2Rlc2MnIHx8XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQudGFnID09PSAndGl0bGUnKSB7XHJcbiAgICAgICAgICAgICAgICBucyA9IDAgLyogSFRNTCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobnMgPT09IDAgLyogSFRNTCAqLykge1xyXG4gICAgICAgICAgICBpZiAodGFnID09PSAnc3ZnJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU1ZHICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0YWcgPT09ICdtYXRoJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDIgLyogTUFUSF9NTCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnM7XHJcbiAgICB9LFxyXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvcGFyc2luZy5odG1sI3BhcnNpbmctaHRtbC1mcmFnbWVudHNcclxuICAgIGdldFRleHRNb2RlKHsgdGFnLCBucyB9KSB7XHJcbiAgICAgICAgaWYgKG5zID09PSAwIC8qIEhUTUwgKi8pIHtcclxuICAgICAgICAgICAgaWYgKHRhZyA9PT0gJ3RleHRhcmVhJyB8fCB0YWcgPT09ICd0aXRsZScpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFJDREFUQSAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNSYXdUZXh0Q29udGFpbmVyKHRhZykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAyIC8qIFJBV1RFWFQgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDAgLyogREFUQSAqLztcclxuICAgIH1cclxufTtcblxuLy8gUGFyc2UgaW5saW5lIENTUyBzdHJpbmdzIGZvciBzdGF0aWMgc3R5bGUgYXR0cmlidXRlcyBpbnRvIGFuIG9iamVjdC5cclxuLy8gVGhpcyBpcyBhIE5vZGVUcmFuc2Zvcm0gc2luY2UgaXQgd29ya3Mgb24gdGhlIHN0YXRpYyBgc3R5bGVgIGF0dHJpYnV0ZSBhbmRcclxuLy8gY29udmVydHMgaXQgaW50byBhIGR5bmFtaWMgZXF1aXZhbGVudDpcclxuLy8gc3R5bGU9XCJjb2xvcjogcmVkXCIgLT4gOnN0eWxlPSd7IFwiY29sb3JcIjogXCJyZWRcIiB9J1xyXG4vLyBJdCBpcyB0aGVuIHByb2Nlc3NlZCBieSBgdHJhbnNmb3JtRWxlbWVudGAgYW5kIGluY2x1ZGVkIGluIHRoZSBnZW5lcmF0ZWRcclxuLy8gcHJvcHMuXHJcbmNvbnN0IHRyYW5zZm9ybVN0eWxlID0gbm9kZSA9PiB7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICBub2RlLnByb3BzLmZvckVhY2goKHAsIGkpID0+IHtcclxuICAgICAgICAgICAgaWYgKHAudHlwZSA9PT0gNiAvKiBBVFRSSUJVVEUgKi8gJiYgcC5uYW1lID09PSAnc3R5bGUnICYmIHAudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgcCB3aXRoIGFuIGV4cHJlc3Npb24gbm9kZVxyXG4gICAgICAgICAgICAgICAgbm9kZS5wcm9wc1tpXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiA3IC8qIERJUkVDVElWRSAqLyxcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBgYmluZGAsXHJcbiAgICAgICAgICAgICAgICAgICAgYXJnOiBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGBzdHlsZWAsIHRydWUsIHAubG9jKSxcclxuICAgICAgICAgICAgICAgICAgICBleHA6IHBhcnNlSW5saW5lQ1NTKHAudmFsdWUuY29udGVudCwgcC5sb2MpLFxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVyczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgbG9jOiBwLmxvY1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBwYXJzZUlubGluZUNTUyA9IChjc3NUZXh0LCBsb2MpID0+IHtcclxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBwYXJzZVN0cmluZ1N0eWxlKGNzc1RleHQpO1xyXG4gICAgcmV0dXJuIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oSlNPTi5zdHJpbmdpZnkobm9ybWFsaXplZCksIGZhbHNlLCBsb2MsIDMgLyogQ0FOX1NUUklOR0lGWSAqLyk7XHJcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoY29kZSwgbG9jKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlQ29tcGlsZXJFcnJvcihjb2RlLCBsb2MsIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCAhdHJ1ZSA/IERPTUVycm9yTWVzc2FnZXMgOiB1bmRlZmluZWQpO1xyXG59XHJcbmNvbnN0IERPTUVycm9yTWVzc2FnZXMgPSB7XHJcbiAgICBbNTAgLyogWF9WX0hUTUxfTk9fRVhQUkVTU0lPTiAqL106IGB2LWh0bWwgaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXHJcbiAgICBbNTEgLyogWF9WX0hUTUxfV0lUSF9DSElMRFJFTiAqL106IGB2LWh0bWwgd2lsbCBvdmVycmlkZSBlbGVtZW50IGNoaWxkcmVuLmAsXHJcbiAgICBbNTIgLyogWF9WX1RFWFRfTk9fRVhQUkVTU0lPTiAqL106IGB2LXRleHQgaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXHJcbiAgICBbNTMgLyogWF9WX1RFWFRfV0lUSF9DSElMRFJFTiAqL106IGB2LXRleHQgd2lsbCBvdmVycmlkZSBlbGVtZW50IGNoaWxkcmVuLmAsXHJcbiAgICBbNTQgLyogWF9WX01PREVMX09OX0lOVkFMSURfRUxFTUVOVCAqL106IGB2LW1vZGVsIGNhbiBvbmx5IGJlIHVzZWQgb24gPGlucHV0PiwgPHRleHRhcmVhPiBhbmQgPHNlbGVjdD4gZWxlbWVudHMuYCxcclxuICAgIFs1NSAvKiBYX1ZfTU9ERUxfQVJHX09OX0VMRU1FTlQgKi9dOiBgdi1tb2RlbCBhcmd1bWVudCBpcyBub3Qgc3VwcG9ydGVkIG9uIHBsYWluIGVsZW1lbnRzLmAsXHJcbiAgICBbNTYgLyogWF9WX01PREVMX09OX0ZJTEVfSU5QVVRfRUxFTUVOVCAqL106IGB2LW1vZGVsIGNhbm5vdCBiZSB1c2VkIG9uIGZpbGUgaW5wdXRzIHNpbmNlIHRoZXkgYXJlIHJlYWQtb25seS4gVXNlIGEgdi1vbjpjaGFuZ2UgbGlzdGVuZXIgaW5zdGVhZC5gLFxyXG4gICAgWzU3IC8qIFhfVl9NT0RFTF9VTk5FQ0VTU0FSWV9WQUxVRSAqL106IGBVbm5lY2Vzc2FyeSB2YWx1ZSBiaW5kaW5nIHVzZWQgYWxvbmdzaWRlIHYtbW9kZWwuIEl0IHdpbGwgaW50ZXJmZXJlIHdpdGggdi1tb2RlbCdzIGJlaGF2aW9yLmAsXHJcbiAgICBbNTggLyogWF9WX1NIT1dfTk9fRVhQUkVTU0lPTiAqL106IGB2LXNob3cgaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXHJcbiAgICBbNTkgLyogWF9UUkFOU0lUSU9OX0lOVkFMSURfQ0hJTERSRU4gKi9dOiBgPFRyYW5zaXRpb24+IGV4cGVjdHMgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudCBvciBjb21wb25lbnQuYCxcclxuICAgIFs2MCAvKiBYX0lHTk9SRURfU0lERV9FRkZFQ1RfVEFHICovXTogYFRhZ3Mgd2l0aCBzaWRlIGVmZmVjdCAoPHNjcmlwdD4gYW5kIDxzdHlsZT4pIGFyZSBpZ25vcmVkIGluIGNsaWVudCBjb21wb25lbnQgdGVtcGxhdGVzLmBcclxufTtcblxuY29uc3QgdHJhbnNmb3JtVkh0bWwgPSAoZGlyLCBub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBjb25zdCB7IGV4cCwgbG9jIH0gPSBkaXI7XHJcbiAgICBpZiAoIWV4cCkge1xyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVET01Db21waWxlckVycm9yKDUwIC8qIFhfVl9IVE1MX05PX0VYUFJFU1NJT04gKi8sIGxvYykpO1xyXG4gICAgfVxyXG4gICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTEgLyogWF9WX0hUTUxfV0lUSF9DSElMRFJFTiAqLywgbG9jKSk7XHJcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwcm9wczogW1xyXG4gICAgICAgICAgICBjcmVhdGVPYmplY3RQcm9wZXJ0eShjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGBpbm5lckhUTUxgLCB0cnVlLCBsb2MpLCBleHAgfHwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbignJywgdHJ1ZSkpXHJcbiAgICAgICAgXVxyXG4gICAgfTtcclxufTtcblxuY29uc3QgdHJhbnNmb3JtVlRleHQgPSAoZGlyLCBub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBjb25zdCB7IGV4cCwgbG9jIH0gPSBkaXI7XHJcbiAgICBpZiAoIWV4cCkge1xyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVET01Db21waWxlckVycm9yKDUyIC8qIFhfVl9URVhUX05PX0VYUFJFU1NJT04gKi8sIGxvYykpO1xyXG4gICAgfVxyXG4gICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTMgLyogWF9WX1RFWFRfV0lUSF9DSElMRFJFTiAqLywgbG9jKSk7XHJcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwcm9wczogW1xyXG4gICAgICAgICAgICBjcmVhdGVPYmplY3RQcm9wZXJ0eShjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGB0ZXh0Q29udGVudGAsIHRydWUpLCBleHBcclxuICAgICAgICAgICAgICAgID8gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXJTdHJpbmcoVE9fRElTUExBWV9TVFJJTkcpLCBbZXhwXSwgbG9jKVxyXG4gICAgICAgICAgICAgICAgOiBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKCcnLCB0cnVlKSlcclxuICAgICAgICBdXHJcbiAgICB9O1xyXG59O1xuXG5jb25zdCB0cmFuc2Zvcm1Nb2RlbCA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGNvbnN0IGJhc2VSZXN1bHQgPSB0cmFuc2Zvcm1Nb2RlbCQxKGRpciwgbm9kZSwgY29udGV4dCk7XHJcbiAgICAvLyBiYXNlIHRyYW5zZm9ybSBoYXMgZXJyb3JzIE9SIGNvbXBvbmVudCB2LW1vZGVsIChvbmx5IG5lZWQgcHJvcHMpXHJcbiAgICBpZiAoIWJhc2VSZXN1bHQucHJvcHMubGVuZ3RoIHx8IG5vZGUudGFnVHlwZSA9PT0gMSAvKiBDT01QT05FTlQgKi8pIHtcclxuICAgICAgICByZXR1cm4gYmFzZVJlc3VsdDtcclxuICAgIH1cclxuICAgIGlmIChkaXIuYXJnKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTUgLyogWF9WX01PREVMX0FSR19PTl9FTEVNRU5UICovLCBkaXIuYXJnLmxvYykpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY2hlY2tEdXBsaWNhdGVkVmFsdWUoKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBmaW5kUHJvcChub2RlLCAndmFsdWUnKTtcclxuICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTcgLyogWF9WX01PREVMX1VOTkVDRVNTQVJZX1ZBTFVFICovLCB2YWx1ZS5sb2MpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IHRhZyB9ID0gbm9kZTtcclxuICAgIGNvbnN0IGlzQ3VzdG9tRWxlbWVudCA9IGNvbnRleHQuaXNDdXN0b21FbGVtZW50KHRhZyk7XHJcbiAgICBpZiAodGFnID09PSAnaW5wdXQnIHx8XHJcbiAgICAgICAgdGFnID09PSAndGV4dGFyZWEnIHx8XHJcbiAgICAgICAgdGFnID09PSAnc2VsZWN0JyB8fFxyXG4gICAgICAgIGlzQ3VzdG9tRWxlbWVudCkge1xyXG4gICAgICAgIGxldCBkaXJlY3RpdmVUb1VzZSA9IFZfTU9ERUxfVEVYVDtcclxuICAgICAgICBsZXQgaXNJbnZhbGlkVHlwZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0YWcgPT09ICdpbnB1dCcgfHwgaXNDdXN0b21FbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBmaW5kUHJvcChub2RlLCBgdHlwZWApO1xyXG4gICAgICAgICAgICBpZiAodHlwZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyA6dHlwZT1cImZvb1wiXHJcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlVG9Vc2UgPSBWX01PREVMX0RZTkFNSUM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlLnZhbHVlLmNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmFkaW8nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlVG9Vc2UgPSBWX01PREVMX1JBRElPO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZVRvVXNlID0gVl9NT0RFTF9DSEVDS0JPWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmaWxlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzSW52YWxpZFR5cGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTYgLyogWF9WX01PREVMX09OX0ZJTEVfSU5QVVRfRUxFTUVOVCAqLywgZGlyLmxvYykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0ZXh0IHR5cGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjaGVja0R1cGxpY2F0ZWRWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0R5bmFtaWNLZXlWQmluZChub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZWxlbWVudCBoYXMgYmluZGluZ3Mgd2l0aCBkeW5hbWljIGtleXMsIHdoaWNoIGNhbiBwb3NzaWJseSBjb250YWluXHJcbiAgICAgICAgICAgICAgICAvLyBcInR5cGVcIi5cclxuICAgICAgICAgICAgICAgIGRpcmVjdGl2ZVRvVXNlID0gVl9NT0RFTF9EWU5BTUlDO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gdGV4dCB0eXBlXHJcbiAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY2hlY2tEdXBsaWNhdGVkVmFsdWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0YWcgPT09ICdzZWxlY3QnKSB7XHJcbiAgICAgICAgICAgIGRpcmVjdGl2ZVRvVXNlID0gVl9NT0RFTF9TRUxFQ1Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0ZXh0YXJlYVxyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY2hlY2tEdXBsaWNhdGVkVmFsdWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaW5qZWN0IHJ1bnRpbWUgZGlyZWN0aXZlXHJcbiAgICAgICAgLy8gYnkgcmV0dXJuaW5nIHRoZSBoZWxwZXIgc3ltYm9sIHZpYSBuZWVkUnVudGltZVxyXG4gICAgICAgIC8vIHRoZSBpbXBvcnQgd2lsbCByZXBsYWNlZCBhIHJlc29sdmVEaXJlY3RpdmUgY2FsbC5cclxuICAgICAgICBpZiAoIWlzSW52YWxpZFR5cGUpIHtcclxuICAgICAgICAgICAgYmFzZVJlc3VsdC5uZWVkUnVudGltZSA9IGNvbnRleHQuaGVscGVyKGRpcmVjdGl2ZVRvVXNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1NCAvKiBYX1ZfTU9ERUxfT05fSU5WQUxJRF9FTEVNRU5UICovLCBkaXIubG9jKSk7XHJcbiAgICB9XHJcbiAgICAvLyBuYXRpdmUgdm1vZGVsIGRvZXNuJ3QgbmVlZCB0aGUgYG1vZGVsVmFsdWVgIHByb3BzIHNpbmNlIHRoZXkgYXJlIGFsc29cclxuICAgIC8vIHBhc3NlZCB0byB0aGUgcnVudGltZSBhcyBgYmluZGluZy52YWx1ZWAuIHJlbW92aW5nIGl0IHJlZHVjZXMgY29kZSBzaXplLlxyXG4gICAgYmFzZVJlc3VsdC5wcm9wcyA9IGJhc2VSZXN1bHQucHJvcHMuZmlsdGVyKHAgPT4gIShwLmtleS50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovICYmXHJcbiAgICAgICAgcC5rZXkuY29udGVudCA9PT0gJ21vZGVsVmFsdWUnKSk7XHJcbiAgICByZXR1cm4gYmFzZVJlc3VsdDtcclxufTtcblxuY29uc3QgaXNFdmVudE9wdGlvbk1vZGlmaWVyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGBwYXNzaXZlLG9uY2UsY2FwdHVyZWApO1xyXG5jb25zdCBpc05vbktleU1vZGlmaWVyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKFxyXG4vLyBldmVudCBwcm9wYWdhdGlvbiBtYW5hZ2VtZW50XHJcbmBzdG9wLHByZXZlbnQsc2VsZixgICtcclxuICAgIC8vIHN5c3RlbSBtb2RpZmllcnMgKyBleGFjdFxyXG4gICAgYGN0cmwsc2hpZnQsYWx0LG1ldGEsZXhhY3QsYCArXHJcbiAgICAvLyBtb3VzZVxyXG4gICAgYG1pZGRsZWApO1xyXG4vLyBsZWZ0ICYgcmlnaHQgY291bGQgYmUgbW91c2Ugb3Iga2V5IG1vZGlmaWVycyBiYXNlZCBvbiBldmVudCB0eXBlXHJcbmNvbnN0IG1heWJlS2V5TW9kaWZpZXIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoJ2xlZnQscmlnaHQnKTtcclxuY29uc3QgaXNLZXlib2FyZEV2ZW50ID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGBvbmtleXVwLG9ua2V5ZG93bixvbmtleXByZXNzYCwgdHJ1ZSk7XHJcbmNvbnN0IHJlc29sdmVNb2RpZmllcnMgPSAoa2V5LCBtb2RpZmllcnMsIGNvbnRleHQsIGxvYykgPT4ge1xyXG4gICAgY29uc3Qga2V5TW9kaWZpZXJzID0gW107XHJcbiAgICBjb25zdCBub25LZXlNb2RpZmllcnMgPSBbXTtcclxuICAgIGNvbnN0IGV2ZW50T3B0aW9uTW9kaWZpZXJzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGlmaWVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IG1vZGlmaWVyID0gbW9kaWZpZXJzW2ldO1xyXG4gICAgICAgIGlmIChtb2RpZmllciA9PT0gJ25hdGl2ZScgJiZcclxuICAgICAgICAgICAgY2hlY2tDb21wYXRFbmFibGVkKFwiQ09NUElMRVJfVl9PTl9OQVRJVkVcIiAvKiBDT01QSUxFUl9WX09OX05BVElWRSAqLywgY29udGV4dCwgbG9jKSkge1xyXG4gICAgICAgICAgICBldmVudE9wdGlvbk1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNFdmVudE9wdGlvbk1vZGlmaWVyKG1vZGlmaWVyKSkge1xyXG4gICAgICAgICAgICAvLyBldmVudE9wdGlvbk1vZGlmaWVyczogbW9kaWZpZXJzIGZvciBhZGRFdmVudExpc3RlbmVyKCkgb3B0aW9ucyxcclxuICAgICAgICAgICAgLy8gZS5nLiAucGFzc2l2ZSAmIC5jYXB0dXJlXHJcbiAgICAgICAgICAgIGV2ZW50T3B0aW9uTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gcnVudGltZU1vZGlmaWVyczogbW9kaWZpZXJzIHRoYXQgbmVlZHMgcnVudGltZSBndWFyZHNcclxuICAgICAgICAgICAgaWYgKG1heWJlS2V5TW9kaWZpZXIobW9kaWZpZXIpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNTdGF0aWNFeHAoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0tleWJvYXJkRXZlbnQoa2V5LmNvbnRlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vbktleU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXlNb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9uS2V5TW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTm9uS2V5TW9kaWZpZXIobW9kaWZpZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9uS2V5TW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5TW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBrZXlNb2RpZmllcnMsXHJcbiAgICAgICAgbm9uS2V5TW9kaWZpZXJzLFxyXG4gICAgICAgIGV2ZW50T3B0aW9uTW9kaWZpZXJzXHJcbiAgICB9O1xyXG59O1xyXG5jb25zdCB0cmFuc2Zvcm1DbGljayA9IChrZXksIGV2ZW50KSA9PiB7XHJcbiAgICBjb25zdCBpc1N0YXRpY0NsaWNrID0gaXNTdGF0aWNFeHAoa2V5KSAmJiBrZXkuY29udGVudC50b0xvd2VyQ2FzZSgpID09PSAnb25jbGljayc7XHJcbiAgICByZXR1cm4gaXNTdGF0aWNDbGlja1xyXG4gICAgICAgID8gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihldmVudCwgdHJ1ZSlcclxuICAgICAgICA6IGtleS50eXBlICE9PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovXHJcbiAgICAgICAgICAgID8gY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtcclxuICAgICAgICAgICAgICAgIGAoYCxcclxuICAgICAgICAgICAgICAgIGtleSxcclxuICAgICAgICAgICAgICAgIGApID09PSBcIm9uQ2xpY2tcIiA/IFwiJHtldmVudH1cIiA6IChgLFxyXG4gICAgICAgICAgICAgICAga2V5LFxyXG4gICAgICAgICAgICAgICAgYClgXHJcbiAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgIDoga2V5O1xyXG59O1xyXG5jb25zdCB0cmFuc2Zvcm1PbiA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIHJldHVybiB0cmFuc2Zvcm1PbiQxKGRpciwgbm9kZSwgY29udGV4dCwgYmFzZVJlc3VsdCA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBtb2RpZmllcnMgfSA9IGRpcjtcclxuICAgICAgICBpZiAoIW1vZGlmaWVycy5sZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybiBiYXNlUmVzdWx0O1xyXG4gICAgICAgIGxldCB7IGtleSwgdmFsdWU6IGhhbmRsZXJFeHAgfSA9IGJhc2VSZXN1bHQucHJvcHNbMF07XHJcbiAgICAgICAgY29uc3QgeyBrZXlNb2RpZmllcnMsIG5vbktleU1vZGlmaWVycywgZXZlbnRPcHRpb25Nb2RpZmllcnMgfSA9IHJlc29sdmVNb2RpZmllcnMoa2V5LCBtb2RpZmllcnMsIGNvbnRleHQsIGRpci5sb2MpO1xyXG4gICAgICAgIC8vIG5vcm1hbGl6ZSBjbGljay5yaWdodCBhbmQgY2xpY2subWlkZGxlIHNpbmNlIHRoZXkgZG9uJ3QgYWN0dWFsbHkgZmlyZVxyXG4gICAgICAgIGlmIChub25LZXlNb2RpZmllcnMuaW5jbHVkZXMoJ3JpZ2h0JykpIHtcclxuICAgICAgICAgICAga2V5ID0gdHJhbnNmb3JtQ2xpY2soa2V5LCBgb25Db250ZXh0bWVudWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9uS2V5TW9kaWZpZXJzLmluY2x1ZGVzKCdtaWRkbGUnKSkge1xyXG4gICAgICAgICAgICBrZXkgPSB0cmFuc2Zvcm1DbGljayhrZXksIGBvbk1vdXNldXBgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vbktleU1vZGlmaWVycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaGFuZGxlckV4cCA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKFZfT05fV0lUSF9NT0RJRklFUlMpLCBbXHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyRXhwLFxyXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkobm9uS2V5TW9kaWZpZXJzKVxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGtleU1vZGlmaWVycy5sZW5ndGggJiZcclxuICAgICAgICAgICAgLy8gaWYgZXZlbnQgbmFtZSBpcyBkeW5hbWljLCBhbHdheXMgd3JhcCB3aXRoIGtleXMgZ3VhcmRcclxuICAgICAgICAgICAgKCFpc1N0YXRpY0V4cChrZXkpIHx8IGlzS2V5Ym9hcmRFdmVudChrZXkuY29udGVudCkpKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZXJFeHAgPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihWX09OX1dJVEhfS0VZUyksIFtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXJFeHAsXHJcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShrZXlNb2RpZmllcnMpXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXZlbnRPcHRpb25Nb2RpZmllcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVyUG9zdGZpeCA9IGV2ZW50T3B0aW9uTW9kaWZpZXJzLm1hcChjYXBpdGFsaXplKS5qb2luKCcnKTtcclxuICAgICAgICAgICAga2V5ID0gaXNTdGF0aWNFeHAoa2V5KVxyXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGAke2tleS5jb250ZW50fSR7bW9kaWZpZXJQb3N0Zml4fWAsIHRydWUpXHJcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbYChgLCBrZXksIGApICsgXCIke21vZGlmaWVyUG9zdGZpeH1cImBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJvcHM6IFtjcmVhdGVPYmplY3RQcm9wZXJ0eShrZXksIGhhbmRsZXJFeHApXVxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxufTtcblxuY29uc3QgdHJhbnNmb3JtU2hvdyA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGNvbnN0IHsgZXhwLCBsb2MgfSA9IGRpcjtcclxuICAgIGlmICghZXhwKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTggLyogWF9WX1NIT1dfTk9fRVhQUkVTU0lPTiAqLywgbG9jKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHByb3BzOiBbXSxcclxuICAgICAgICBuZWVkUnVudGltZTogY29udGV4dC5oZWxwZXIoVl9TSE9XKVxyXG4gICAgfTtcclxufTtcblxuY29uc3Qgd2FyblRyYW5zaXRpb25DaGlsZHJlbiA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICBub2RlLnRhZ1R5cGUgPT09IDEgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gY29udGV4dC5pc0J1aWx0SW5Db21wb25lbnQobm9kZS50YWcpO1xyXG4gICAgICAgIGlmIChjb21wb25lbnQgPT09IFRSQU5TSVRJT04pIHtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCAmJiBoYXNNdWx0aXBsZUNoaWxkcmVuKG5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTkgLyogWF9UUkFOU0lUSU9OX0lOVkFMSURfQ0hJTERSRU4gKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG5vZGUuY2hpbGRyZW5bMF0ubG9jLnN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IG5vZGUuY2hpbGRyZW5bbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxXS5sb2MuZW5kLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6ICcnXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gaGFzTXVsdGlwbGVDaGlsZHJlbihub2RlKSB7XHJcbiAgICAvLyAjMTM1MiBmaWx0ZXIgb3V0IHBvdGVudGlhbCBjb21tZW50IG5vZGVzLlxyXG4gICAgY29uc3QgY2hpbGRyZW4gPSAobm9kZS5jaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4uZmlsdGVyKGMgPT4gYy50eXBlICE9PSAzIC8qIENPTU1FTlQgKi8gJiZcclxuICAgICAgICAhKGMudHlwZSA9PT0gMiAvKiBURVhUICovICYmICFjLmNvbnRlbnQudHJpbSgpKSkpO1xyXG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlblswXTtcclxuICAgIHJldHVybiAoY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8XHJcbiAgICAgICAgY2hpbGQudHlwZSA9PT0gMTEgLyogRk9SICovIHx8XHJcbiAgICAgICAgKGNoaWxkLnR5cGUgPT09IDkgLyogSUYgKi8gJiYgY2hpbGQuYnJhbmNoZXMuc29tZShoYXNNdWx0aXBsZUNoaWxkcmVuKSkpO1xyXG59XG5cbmNvbnN0IGlnbm9yZVNpZGVFZmZlY3RUYWdzID0gKG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgIG5vZGUudGFnVHlwZSA9PT0gMCAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgKG5vZGUudGFnID09PSAnc2NyaXB0JyB8fCBub2RlLnRhZyA9PT0gJ3N0eWxlJykpIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig2MCAvKiBYX0lHTk9SRURfU0lERV9FRkZFQ1RfVEFHICovLCBub2RlLmxvYykpO1xyXG4gICAgICAgIGNvbnRleHQucmVtb3ZlTm9kZSgpO1xyXG4gICAgfVxyXG59O1xuXG5jb25zdCBET01Ob2RlVHJhbnNmb3JtcyA9IFtcclxuICAgIHRyYW5zZm9ybVN0eWxlLFxyXG4gICAgLi4uKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IFt3YXJuVHJhbnNpdGlvbkNoaWxkcmVuXSA6IFtdKVxyXG5dO1xyXG5jb25zdCBET01EaXJlY3RpdmVUcmFuc2Zvcm1zID0ge1xyXG4gICAgY2xvYWs6IG5vb3BEaXJlY3RpdmVUcmFuc2Zvcm0sXHJcbiAgICBodG1sOiB0cmFuc2Zvcm1WSHRtbCxcclxuICAgIHRleHQ6IHRyYW5zZm9ybVZUZXh0LFxyXG4gICAgbW9kZWw6IHRyYW5zZm9ybU1vZGVsLFxyXG4gICAgb246IHRyYW5zZm9ybU9uLFxyXG4gICAgc2hvdzogdHJhbnNmb3JtU2hvd1xyXG59O1xyXG5mdW5jdGlvbiBjb21waWxlKHRlbXBsYXRlLCBvcHRpb25zID0ge30pIHtcclxuICAgIHJldHVybiBiYXNlQ29tcGlsZSh0ZW1wbGF0ZSwgZXh0ZW5kKHt9LCBwYXJzZXJPcHRpb25zLCBvcHRpb25zLCB7XHJcbiAgICAgICAgbm9kZVRyYW5zZm9ybXM6IFtcclxuICAgICAgICAgICAgLy8gaWdub3JlIDxzY3JpcHQ+IGFuZCA8dGFnPlxyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBwdXQgaW5zaWRlIERPTU5vZGVUcmFuc2Zvcm1zIGJlY2F1c2UgdGhhdCBsaXN0IGlzIHVzZWRcclxuICAgICAgICAgICAgLy8gYnkgY29tcGlsZXItc3NyIHRvIGdlbmVyYXRlIHZub2RlIGZhbGxiYWNrIGJyYW5jaGVzXHJcbiAgICAgICAgICAgIGlnbm9yZVNpZGVFZmZlY3RUYWdzLFxyXG4gICAgICAgICAgICAuLi5ET01Ob2RlVHJhbnNmb3JtcyxcclxuICAgICAgICAgICAgLi4uKG9wdGlvbnMubm9kZVRyYW5zZm9ybXMgfHwgW10pXHJcbiAgICAgICAgXSxcclxuICAgICAgICBkaXJlY3RpdmVUcmFuc2Zvcm1zOiBleHRlbmQoe30sIERPTURpcmVjdGl2ZVRyYW5zZm9ybXMsIG9wdGlvbnMuZGlyZWN0aXZlVHJhbnNmb3JtcyB8fCB7fSksXHJcbiAgICAgICAgdHJhbnNmb3JtSG9pc3Q6IG51bGwgXHJcbiAgICB9KSk7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2UodGVtcGxhdGUsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgcmV0dXJuIGJhc2VQYXJzZSh0ZW1wbGF0ZSwgZXh0ZW5kKHt9LCBwYXJzZXJPcHRpb25zLCBvcHRpb25zKSk7XHJcbn1cblxuZXhwb3J0IHsgRE9NRGlyZWN0aXZlVHJhbnNmb3JtcywgRE9NTm9kZVRyYW5zZm9ybXMsIFRSQU5TSVRJT04sIFRSQU5TSVRJT05fR1JPVVAsIFZfTU9ERUxfQ0hFQ0tCT1gsIFZfTU9ERUxfRFlOQU1JQywgVl9NT0RFTF9SQURJTywgVl9NT0RFTF9TRUxFQ1QsIFZfTU9ERUxfVEVYVCwgVl9PTl9XSVRIX0tFWVMsIFZfT05fV0lUSF9NT0RJRklFUlMsIFZfU0hPVywgY29tcGlsZSwgY3JlYXRlRE9NQ29tcGlsZXJFcnJvciwgcGFyc2UsIHBhcnNlck9wdGlvbnMsIHRyYW5zZm9ybVN0eWxlIH07XG4iLCJpbXBvcnQgeyBleHRlbmQsIGlzQXJyYXksIGlzTWFwLCBpc0ludGVnZXJLZXksIGlzU3ltYm9sLCBoYXNPd24sIGlzT2JqZWN0LCBoYXNDaGFuZ2VkLCBtYWtlTWFwLCBjYXBpdGFsaXplLCB0b1Jhd1R5cGUsIGRlZiwgaXNGdW5jdGlvbiwgTk9PUCB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuZnVuY3Rpb24gd2Fybihtc2csIC4uLmFyZ3MpIHtcclxuICAgIGNvbnNvbGUud2FybihgW1Z1ZSB3YXJuXSAke21zZ31gLCAuLi5hcmdzKTtcclxufVxuXG5sZXQgYWN0aXZlRWZmZWN0U2NvcGU7XHJcbmNsYXNzIEVmZmVjdFNjb3BlIHtcclxuICAgIGNvbnN0cnVjdG9yKGRldGFjaGVkID0gZmFsc2UpIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5lZmZlY3RzID0gW107XHJcbiAgICAgICAgdGhpcy5jbGVhbnVwcyA9IFtdO1xyXG4gICAgICAgIGlmICghZGV0YWNoZWQgJiYgYWN0aXZlRWZmZWN0U2NvcGUpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBhY3RpdmVFZmZlY3RTY29wZTtcclxuICAgICAgICAgICAgdGhpcy5pbmRleCA9XHJcbiAgICAgICAgICAgICAgICAoYWN0aXZlRWZmZWN0U2NvcGUuc2NvcGVzIHx8IChhY3RpdmVFZmZlY3RTY29wZS5zY29wZXMgPSBbXSkpLnB1c2godGhpcykgLSAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJ1bihmbikge1xyXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBjYW5ub3QgcnVuIGFuIGluYWN0aXZlIGVmZmVjdCBzY29wZS5gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbigpIHtcclxuICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IHRoaXM7XHJcbiAgICB9XHJcbiAgICBvZmYoKSB7XHJcbiAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgPSB0aGlzLnBhcmVudDtcclxuICAgIH1cclxuICAgIHN0b3AoZnJvbVBhcmVudCkge1xyXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSkge1xyXG4gICAgICAgICAgICBsZXQgaSwgbDtcclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuZWZmZWN0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWZmZWN0c1tpXS5zdG9wKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuY2xlYW51cHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFudXBzW2ldKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuc2NvcGVzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5zY29wZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY29wZXNbaV0uc3RvcCh0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBuZXN0ZWQgc2NvcGUsIGRlcmVmZXJlbmNlIGZyb20gcGFyZW50IHRvIGF2b2lkIG1lbW9yeSBsZWFrc1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQgJiYgIWZyb21QYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIC8vIG9wdGltaXplZCBPKDEpIHJlbW92YWxcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzLnBhcmVudC5zY29wZXMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFzdCAmJiBsYXN0ICE9PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuc2NvcGVzW3RoaXMuaW5kZXhdID0gbGFzdDtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0LmluZGV4ID0gdGhpcy5pbmRleDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBlZmZlY3RTY29wZShkZXRhY2hlZCkge1xyXG4gICAgcmV0dXJuIG5ldyBFZmZlY3RTY29wZShkZXRhY2hlZCk7XHJcbn1cclxuZnVuY3Rpb24gcmVjb3JkRWZmZWN0U2NvcGUoZWZmZWN0LCBzY29wZSA9IGFjdGl2ZUVmZmVjdFNjb3BlKSB7XHJcbiAgICBpZiAoc2NvcGUgJiYgc2NvcGUuYWN0aXZlKSB7XHJcbiAgICAgICAgc2NvcGUuZWZmZWN0cy5wdXNoKGVmZmVjdCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q3VycmVudFNjb3BlKCkge1xyXG4gICAgcmV0dXJuIGFjdGl2ZUVmZmVjdFNjb3BlO1xyXG59XHJcbmZ1bmN0aW9uIG9uU2NvcGVEaXNwb3NlKGZuKSB7XHJcbiAgICBpZiAoYWN0aXZlRWZmZWN0U2NvcGUpIHtcclxuICAgICAgICBhY3RpdmVFZmZlY3RTY29wZS5jbGVhbnVwcy5wdXNoKGZuKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm4oYG9uU2NvcGVEaXNwb3NlKCkgaXMgY2FsbGVkIHdoZW4gdGhlcmUgaXMgbm8gYWN0aXZlIGVmZmVjdCBzY29wZWAgK1xyXG4gICAgICAgICAgICBgIHRvIGJlIGFzc29jaWF0ZWQgd2l0aC5gKTtcclxuICAgIH1cclxufVxuXG5jb25zdCBjcmVhdGVEZXAgPSAoZWZmZWN0cykgPT4ge1xyXG4gICAgY29uc3QgZGVwID0gbmV3IFNldChlZmZlY3RzKTtcclxuICAgIGRlcC53ID0gMDtcclxuICAgIGRlcC5uID0gMDtcclxuICAgIHJldHVybiBkZXA7XHJcbn07XHJcbmNvbnN0IHdhc1RyYWNrZWQgPSAoZGVwKSA9PiAoZGVwLncgJiB0cmFja09wQml0KSA+IDA7XHJcbmNvbnN0IG5ld1RyYWNrZWQgPSAoZGVwKSA9PiAoZGVwLm4gJiB0cmFja09wQml0KSA+IDA7XHJcbmNvbnN0IGluaXREZXBNYXJrZXJzID0gKHsgZGVwcyB9KSA9PiB7XHJcbiAgICBpZiAoZGVwcy5sZW5ndGgpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZGVwc1tpXS53IHw9IHRyYWNrT3BCaXQ7IC8vIHNldCB3YXMgdHJhY2tlZFxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuY29uc3QgZmluYWxpemVEZXBNYXJrZXJzID0gKGVmZmVjdCkgPT4ge1xyXG4gICAgY29uc3QgeyBkZXBzIH0gPSBlZmZlY3Q7XHJcbiAgICBpZiAoZGVwcy5sZW5ndGgpIHtcclxuICAgICAgICBsZXQgcHRyID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgZGVwID0gZGVwc1tpXTtcclxuICAgICAgICAgICAgaWYgKHdhc1RyYWNrZWQoZGVwKSAmJiAhbmV3VHJhY2tlZChkZXApKSB7XHJcbiAgICAgICAgICAgICAgICBkZXAuZGVsZXRlKGVmZmVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkZXBzW3B0cisrXSA9IGRlcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjbGVhciBiaXRzXHJcbiAgICAgICAgICAgIGRlcC53ICY9IH50cmFja09wQml0O1xyXG4gICAgICAgICAgICBkZXAubiAmPSB+dHJhY2tPcEJpdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVwcy5sZW5ndGggPSBwdHI7XHJcbiAgICB9XHJcbn07XG5cbmNvbnN0IHRhcmdldE1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbi8vIFRoZSBudW1iZXIgb2YgZWZmZWN0cyBjdXJyZW50bHkgYmVpbmcgdHJhY2tlZCByZWN1cnNpdmVseS5cclxubGV0IGVmZmVjdFRyYWNrRGVwdGggPSAwO1xyXG5sZXQgdHJhY2tPcEJpdCA9IDE7XHJcbi8qKlxyXG4gKiBUaGUgYml0d2lzZSB0cmFjayBtYXJrZXJzIHN1cHBvcnQgYXQgbW9zdCAzMCBsZXZlbHMgb2YgcmVjdXJzaW9uLlxyXG4gKiBUaGlzIHZhbHVlIGlzIGNob3NlbiB0byBlbmFibGUgbW9kZXJuIEpTIGVuZ2luZXMgdG8gdXNlIGEgU01JIG9uIGFsbCBwbGF0Zm9ybXMuXHJcbiAqIFdoZW4gcmVjdXJzaW9uIGRlcHRoIGlzIGdyZWF0ZXIsIGZhbGwgYmFjayB0byB1c2luZyBhIGZ1bGwgY2xlYW51cC5cclxuICovXHJcbmNvbnN0IG1heE1hcmtlckJpdHMgPSAzMDtcclxubGV0IGFjdGl2ZUVmZmVjdDtcclxuY29uc3QgSVRFUkFURV9LRVkgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ2l0ZXJhdGUnIDogJycpO1xyXG5jb25zdCBNQVBfS0VZX0lURVJBVEVfS0VZID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdNYXAga2V5IGl0ZXJhdGUnIDogJycpO1xyXG5jbGFzcyBSZWFjdGl2ZUVmZmVjdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihmbiwgc2NoZWR1bGVyID0gbnVsbCwgc2NvcGUpIHtcclxuICAgICAgICB0aGlzLmZuID0gZm47XHJcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XHJcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZGVwcyA9IFtdO1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHJlY29yZEVmZmVjdFNjb3BlKHRoaXMsIHNjb3BlKTtcclxuICAgIH1cclxuICAgIHJ1bigpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBwYXJlbnQgPSBhY3RpdmVFZmZlY3Q7XHJcbiAgICAgICAgbGV0IGxhc3RTaG91bGRUcmFjayA9IHNob3VsZFRyYWNrO1xyXG4gICAgICAgIHdoaWxlIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgaWYgKHBhcmVudCA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gYWN0aXZlRWZmZWN0O1xyXG4gICAgICAgICAgICBhY3RpdmVFZmZlY3QgPSB0aGlzO1xyXG4gICAgICAgICAgICBzaG91bGRUcmFjayA9IHRydWU7XHJcbiAgICAgICAgICAgIHRyYWNrT3BCaXQgPSAxIDw8ICsrZWZmZWN0VHJhY2tEZXB0aDtcclxuICAgICAgICAgICAgaWYgKGVmZmVjdFRyYWNrRGVwdGggPD0gbWF4TWFya2VyQml0cykge1xyXG4gICAgICAgICAgICAgICAgaW5pdERlcE1hcmtlcnModGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhbnVwRWZmZWN0KHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICBpZiAoZWZmZWN0VHJhY2tEZXB0aCA8PSBtYXhNYXJrZXJCaXRzKSB7XHJcbiAgICAgICAgICAgICAgICBmaW5hbGl6ZURlcE1hcmtlcnModGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJhY2tPcEJpdCA9IDEgPDwgLS1lZmZlY3RUcmFja0RlcHRoO1xyXG4gICAgICAgICAgICBhY3RpdmVFZmZlY3QgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICAgICAgc2hvdWxkVHJhY2sgPSBsYXN0U2hvdWxkVHJhY2s7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgIGNsZWFudXBFZmZlY3QodGhpcyk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9uU3RvcCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vblN0b3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjbGVhbnVwRWZmZWN0KGVmZmVjdCkge1xyXG4gICAgY29uc3QgeyBkZXBzIH0gPSBlZmZlY3Q7XHJcbiAgICBpZiAoZGVwcy5sZW5ndGgpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZGVwc1tpXS5kZWxldGUoZWZmZWN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVwcy5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGVmZmVjdChmbiwgb3B0aW9ucykge1xyXG4gICAgaWYgKGZuLmVmZmVjdCkge1xyXG4gICAgICAgIGZuID0gZm4uZWZmZWN0LmZuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgX2VmZmVjdCA9IG5ldyBSZWFjdGl2ZUVmZmVjdChmbik7XHJcbiAgICBpZiAob3B0aW9ucykge1xyXG4gICAgICAgIGV4dGVuZChfZWZmZWN0LCBvcHRpb25zKTtcclxuICAgICAgICBpZiAob3B0aW9ucy5zY29wZSlcclxuICAgICAgICAgICAgcmVjb3JkRWZmZWN0U2NvcGUoX2VmZmVjdCwgb3B0aW9ucy5zY29wZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMubGF6eSkge1xyXG4gICAgICAgIF9lZmZlY3QucnVuKCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBydW5uZXIgPSBfZWZmZWN0LnJ1bi5iaW5kKF9lZmZlY3QpO1xyXG4gICAgcnVubmVyLmVmZmVjdCA9IF9lZmZlY3Q7XHJcbiAgICByZXR1cm4gcnVubmVyO1xyXG59XHJcbmZ1bmN0aW9uIHN0b3AocnVubmVyKSB7XHJcbiAgICBydW5uZXIuZWZmZWN0LnN0b3AoKTtcclxufVxyXG5sZXQgc2hvdWxkVHJhY2sgPSB0cnVlO1xyXG5jb25zdCB0cmFja1N0YWNrID0gW107XHJcbmZ1bmN0aW9uIHBhdXNlVHJhY2tpbmcoKSB7XHJcbiAgICB0cmFja1N0YWNrLnB1c2goc2hvdWxkVHJhY2spO1xyXG4gICAgc2hvdWxkVHJhY2sgPSBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBlbmFibGVUcmFja2luZygpIHtcclxuICAgIHRyYWNrU3RhY2sucHVzaChzaG91bGRUcmFjayk7XHJcbiAgICBzaG91bGRUcmFjayA9IHRydWU7XHJcbn1cclxuZnVuY3Rpb24gcmVzZXRUcmFja2luZygpIHtcclxuICAgIGNvbnN0IGxhc3QgPSB0cmFja1N0YWNrLnBvcCgpO1xyXG4gICAgc2hvdWxkVHJhY2sgPSBsYXN0ID09PSB1bmRlZmluZWQgPyB0cnVlIDogbGFzdDtcclxufVxyXG5mdW5jdGlvbiB0cmFjayh0YXJnZXQsIHR5cGUsIGtleSkge1xyXG4gICAgaWYgKHNob3VsZFRyYWNrICYmIGFjdGl2ZUVmZmVjdCkge1xyXG4gICAgICAgIGxldCBkZXBzTWFwID0gdGFyZ2V0TWFwLmdldCh0YXJnZXQpO1xyXG4gICAgICAgIGlmICghZGVwc01hcCkge1xyXG4gICAgICAgICAgICB0YXJnZXRNYXAuc2V0KHRhcmdldCwgKGRlcHNNYXAgPSBuZXcgTWFwKCkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGRlcCA9IGRlcHNNYXAuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYgKCFkZXApIHtcclxuICAgICAgICAgICAgZGVwc01hcC5zZXQoa2V5LCAoZGVwID0gY3JlYXRlRGVwKCkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZXZlbnRJbmZvID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgICAgID8geyBlZmZlY3Q6IGFjdGl2ZUVmZmVjdCwgdGFyZ2V0LCB0eXBlLCBrZXkgfVxyXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgICAgICB0cmFja0VmZmVjdHMoZGVwLCBldmVudEluZm8pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRyYWNrRWZmZWN0cyhkZXAsIGRlYnVnZ2VyRXZlbnRFeHRyYUluZm8pIHtcclxuICAgIGxldCBzaG91bGRUcmFjayA9IGZhbHNlO1xyXG4gICAgaWYgKGVmZmVjdFRyYWNrRGVwdGggPD0gbWF4TWFya2VyQml0cykge1xyXG4gICAgICAgIGlmICghbmV3VHJhY2tlZChkZXApKSB7XHJcbiAgICAgICAgICAgIGRlcC5uIHw9IHRyYWNrT3BCaXQ7IC8vIHNldCBuZXdseSB0cmFja2VkXHJcbiAgICAgICAgICAgIHNob3VsZFRyYWNrID0gIXdhc1RyYWNrZWQoZGVwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBGdWxsIGNsZWFudXAgbW9kZS5cclxuICAgICAgICBzaG91bGRUcmFjayA9ICFkZXAuaGFzKGFjdGl2ZUVmZmVjdCk7XHJcbiAgICB9XHJcbiAgICBpZiAoc2hvdWxkVHJhY2spIHtcclxuICAgICAgICBkZXAuYWRkKGFjdGl2ZUVmZmVjdCk7XHJcbiAgICAgICAgYWN0aXZlRWZmZWN0LmRlcHMucHVzaChkZXApO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgYWN0aXZlRWZmZWN0Lm9uVHJhY2spIHtcclxuICAgICAgICAgICAgYWN0aXZlRWZmZWN0Lm9uVHJhY2soT2JqZWN0LmFzc2lnbih7XHJcbiAgICAgICAgICAgICAgICBlZmZlY3Q6IGFjdGl2ZUVmZmVjdFxyXG4gICAgICAgICAgICB9LCBkZWJ1Z2dlckV2ZW50RXh0cmFJbmZvKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRyaWdnZXIodGFyZ2V0LCB0eXBlLCBrZXksIG5ld1ZhbHVlLCBvbGRWYWx1ZSwgb2xkVGFyZ2V0KSB7XHJcbiAgICBjb25zdCBkZXBzTWFwID0gdGFyZ2V0TWFwLmdldCh0YXJnZXQpO1xyXG4gICAgaWYgKCFkZXBzTWFwKSB7XHJcbiAgICAgICAgLy8gbmV2ZXIgYmVlbiB0cmFja2VkXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgbGV0IGRlcHMgPSBbXTtcclxuICAgIGlmICh0eXBlID09PSBcImNsZWFyXCIgLyogQ0xFQVIgKi8pIHtcclxuICAgICAgICAvLyBjb2xsZWN0aW9uIGJlaW5nIGNsZWFyZWRcclxuICAgICAgICAvLyB0cmlnZ2VyIGFsbCBlZmZlY3RzIGZvciB0YXJnZXRcclxuICAgICAgICBkZXBzID0gWy4uLmRlcHNNYXAudmFsdWVzKCldO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoa2V5ID09PSAnbGVuZ3RoJyAmJiBpc0FycmF5KHRhcmdldCkpIHtcclxuICAgICAgICBkZXBzTWFwLmZvckVhY2goKGRlcCwga2V5KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdsZW5ndGgnIHx8IGtleSA+PSBuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgZGVwcy5wdXNoKGRlcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIHNjaGVkdWxlIHJ1bnMgZm9yIFNFVCB8IEFERCB8IERFTEVURVxyXG4gICAgICAgIGlmIChrZXkgIT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBkZXBzLnB1c2goZGVwc01hcC5nZXQoa2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFsc28gcnVuIGZvciBpdGVyYXRpb24ga2V5IG9uIEFERCB8IERFTEVURSB8IE1hcC5TRVRcclxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBcImFkZFwiIC8qIEFERCAqLzpcclxuICAgICAgICAgICAgICAgIGlmICghaXNBcnJheSh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KE1BUF9LRVlfSVRFUkFURV9LRVkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0ludGVnZXJLZXkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5ldyBpbmRleCBhZGRlZCB0byBhcnJheSAtPiBsZW5ndGggY2hhbmdlc1xyXG4gICAgICAgICAgICAgICAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldCgnbGVuZ3RoJykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJkZWxldGVcIiAvKiBERUxFVEUgKi86XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldChNQVBfS0VZX0lURVJBVEVfS0VZKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJzZXRcIiAvKiBTRVQgKi86XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgZXZlbnRJbmZvID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgPyB7IHRhcmdldCwgdHlwZSwga2V5LCBuZXdWYWx1ZSwgb2xkVmFsdWUsIG9sZFRhcmdldCB9XHJcbiAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICBpZiAoZGVwcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICBpZiAoZGVwc1swXSkge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRWZmZWN0cyhkZXBzWzBdLCBldmVudEluZm8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdHJpZ2dlckVmZmVjdHMoZGVwc1swXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBlZmZlY3RzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBkZXAgb2YgZGVwcykge1xyXG4gICAgICAgICAgICBpZiAoZGVwKSB7XHJcbiAgICAgICAgICAgICAgICBlZmZlY3RzLnB1c2goLi4uZGVwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHRyaWdnZXJFZmZlY3RzKGNyZWF0ZURlcChlZmZlY3RzKSwgZXZlbnRJbmZvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRyaWdnZXJFZmZlY3RzKGNyZWF0ZURlcChlZmZlY3RzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRyaWdnZXJFZmZlY3RzKGRlcCwgZGVidWdnZXJFdmVudEV4dHJhSW5mbykge1xyXG4gICAgLy8gc3ByZWFkIGludG8gYXJyYXkgZm9yIHN0YWJpbGl6YXRpb25cclxuICAgIGZvciAoY29uc3QgZWZmZWN0IG9mIGlzQXJyYXkoZGVwKSA/IGRlcCA6IFsuLi5kZXBdKSB7XHJcbiAgICAgICAgaWYgKGVmZmVjdCAhPT0gYWN0aXZlRWZmZWN0IHx8IGVmZmVjdC5hbGxvd1JlY3Vyc2UpIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBlZmZlY3Qub25UcmlnZ2VyKSB7XHJcbiAgICAgICAgICAgICAgICBlZmZlY3Qub25UcmlnZ2VyKGV4dGVuZCh7IGVmZmVjdCB9LCBkZWJ1Z2dlckV2ZW50RXh0cmFJbmZvKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVmZmVjdC5zY2hlZHVsZXIpIHtcclxuICAgICAgICAgICAgICAgIGVmZmVjdC5zY2hlZHVsZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVmZmVjdC5ydW4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jb25zdCBpc05vblRyYWNrYWJsZUtleXMgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoYF9fcHJvdG9fXyxfX3ZfaXNSZWYsX19pc1Z1ZWApO1xyXG5jb25zdCBidWlsdEluU3ltYm9scyA9IG5ldyBTZXQoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoU3ltYm9sKVxyXG4gICAgLm1hcChrZXkgPT4gU3ltYm9sW2tleV0pXHJcbiAgICAuZmlsdGVyKGlzU3ltYm9sKSk7XHJcbmNvbnN0IGdldCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlR2V0dGVyKCk7XHJcbmNvbnN0IHNoYWxsb3dHZXQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZUdldHRlcihmYWxzZSwgdHJ1ZSk7XHJcbmNvbnN0IHJlYWRvbmx5R2V0ID0gLyojX19QVVJFX18qLyBjcmVhdGVHZXR0ZXIodHJ1ZSk7XHJcbmNvbnN0IHNoYWxsb3dSZWFkb25seUdldCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlR2V0dGVyKHRydWUsIHRydWUpO1xyXG5jb25zdCBhcnJheUluc3RydW1lbnRhdGlvbnMgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZUFycmF5SW5zdHJ1bWVudGF0aW9ucygpO1xyXG5mdW5jdGlvbiBjcmVhdGVBcnJheUluc3RydW1lbnRhdGlvbnMoKSB7XHJcbiAgICBjb25zdCBpbnN0cnVtZW50YXRpb25zID0ge307XHJcbiAgICBbJ2luY2x1ZGVzJywgJ2luZGV4T2YnLCAnbGFzdEluZGV4T2YnXS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgaW5zdHJ1bWVudGF0aW9uc1trZXldID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcclxuICAgICAgICAgICAgY29uc3QgYXJyID0gdG9SYXcodGhpcyk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRyYWNrKGFyciwgXCJnZXRcIiAvKiBHRVQgKi8sIGkgKyAnJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gd2UgcnVuIHRoZSBtZXRob2QgdXNpbmcgdGhlIG9yaWdpbmFsIGFyZ3MgZmlyc3QgKHdoaWNoIG1heSBiZSByZWFjdGl2ZSlcclxuICAgICAgICAgICAgY29uc3QgcmVzID0gYXJyW2tleV0oLi4uYXJncyk7XHJcbiAgICAgICAgICAgIGlmIChyZXMgPT09IC0xIHx8IHJlcyA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoYXQgZGlkbid0IHdvcmssIHJ1biBpdCBhZ2FpbiB1c2luZyByYXcgdmFsdWVzLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycltrZXldKC4uLmFyZ3MubWFwKHRvUmF3KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG4gICAgWydwdXNoJywgJ3BvcCcsICdzaGlmdCcsICd1bnNoaWZ0JywgJ3NwbGljZSddLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICBpbnN0cnVtZW50YXRpb25zW2tleV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgICAgICBwYXVzZVRyYWNraW5nKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHRvUmF3KHRoaXMpW2tleV0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gaW5zdHJ1bWVudGF0aW9ucztcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVHZXR0ZXIoaXNSZWFkb25seSA9IGZhbHNlLCBzaGFsbG93ID0gZmFsc2UpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBnZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSB7XHJcbiAgICAgICAgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFjdGl2ZVwiIC8qIElTX1JFQUNUSVZFICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhaXNSZWFkb25seTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWRvbmx5XCIgLyogSVNfUkVBRE9OTFkgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzUmVhZG9ubHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNTaGFsbG93XCIgLyogSVNfU0hBTExPVyAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gc2hhbGxvdztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9yYXdcIiAvKiBSQVcgKi8gJiZcclxuICAgICAgICAgICAgcmVjZWl2ZXIgPT09XHJcbiAgICAgICAgICAgICAgICAoaXNSZWFkb25seVxyXG4gICAgICAgICAgICAgICAgICAgID8gc2hhbGxvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNoYWxsb3dSZWFkb25seU1hcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHJlYWRvbmx5TWFwXHJcbiAgICAgICAgICAgICAgICAgICAgOiBzaGFsbG93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2hhbGxvd1JlYWN0aXZlTWFwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcmVhY3RpdmVNYXApLmdldCh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRhcmdldElzQXJyYXkgPSBpc0FycmF5KHRhcmdldCk7XHJcbiAgICAgICAgaWYgKCFpc1JlYWRvbmx5ICYmIHRhcmdldElzQXJyYXkgJiYgaGFzT3duKGFycmF5SW5zdHJ1bWVudGF0aW9ucywga2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQoYXJyYXlJbnN0cnVtZW50YXRpb25zLCBrZXksIHJlY2VpdmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzID0gUmVmbGVjdC5nZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKTtcclxuICAgICAgICBpZiAoaXNTeW1ib2woa2V5KSA/IGJ1aWx0SW5TeW1ib2xzLmhhcyhrZXkpIDogaXNOb25UcmFja2FibGVLZXlzKGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc1JlYWRvbmx5KSB7XHJcbiAgICAgICAgICAgIHRyYWNrKHRhcmdldCwgXCJnZXRcIiAvKiBHRVQgKi8sIGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaGFsbG93KSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1JlZihyZXMpKSB7XHJcbiAgICAgICAgICAgIC8vIHJlZiB1bndyYXBwaW5nIC0gZG9lcyBub3QgYXBwbHkgZm9yIEFycmF5ICsgaW50ZWdlciBrZXkuXHJcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFVud3JhcCA9ICF0YXJnZXRJc0FycmF5IHx8ICFpc0ludGVnZXJLZXkoa2V5KTtcclxuICAgICAgICAgICAgcmV0dXJuIHNob3VsZFVud3JhcCA/IHJlcy52YWx1ZSA6IHJlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcclxuICAgICAgICAgICAgLy8gQ29udmVydCByZXR1cm5lZCB2YWx1ZSBpbnRvIGEgcHJveHkgYXMgd2VsbC4gd2UgZG8gdGhlIGlzT2JqZWN0IGNoZWNrXHJcbiAgICAgICAgICAgIC8vIGhlcmUgdG8gYXZvaWQgaW52YWxpZCB2YWx1ZSB3YXJuaW5nLiBBbHNvIG5lZWQgdG8gbGF6eSBhY2Nlc3MgcmVhZG9ubHlcclxuICAgICAgICAgICAgLy8gYW5kIHJlYWN0aXZlIGhlcmUgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jeS5cclxuICAgICAgICAgICAgcmV0dXJuIGlzUmVhZG9ubHkgPyByZWFkb25seShyZXMpIDogcmVhY3RpdmUocmVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH07XHJcbn1cclxuY29uc3Qgc2V0ID0gLyojX19QVVJFX18qLyBjcmVhdGVTZXR0ZXIoKTtcclxuY29uc3Qgc2hhbGxvd1NldCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlU2V0dGVyKHRydWUpO1xyXG5mdW5jdGlvbiBjcmVhdGVTZXR0ZXIoc2hhbGxvdyA9IGZhbHNlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gc2V0KHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpIHtcclxuICAgICAgICBsZXQgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcclxuICAgICAgICBpZiAoaXNSZWFkb25seShvbGRWYWx1ZSkgJiYgaXNSZWYob2xkVmFsdWUpICYmICFpc1JlZih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXNoYWxsb3cgJiYgIWlzUmVhZG9ubHkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNTaGFsbG93KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IHRvUmF3KG9sZFZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzQXJyYXkodGFyZ2V0KSAmJiBpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgb2xkVmFsdWUudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGhhZEtleSA9IGlzQXJyYXkodGFyZ2V0KSAmJiBpc0ludGVnZXJLZXkoa2V5KVxyXG4gICAgICAgICAgICA/IE51bWJlcihrZXkpIDwgdGFyZ2V0Lmxlbmd0aFxyXG4gICAgICAgICAgICA6IGhhc093bih0YXJnZXQsIGtleSk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5zZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcik7XHJcbiAgICAgICAgLy8gZG9uJ3QgdHJpZ2dlciBpZiB0YXJnZXQgaXMgc29tZXRoaW5nIHVwIGluIHRoZSBwcm90b3R5cGUgY2hhaW4gb2Ygb3JpZ2luYWxcclxuICAgICAgICBpZiAodGFyZ2V0ID09PSB0b1JhdyhyZWNlaXZlcikpIHtcclxuICAgICAgICAgICAgaWYgKCFoYWRLZXkpIHtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiIC8qIEFERCAqLywga2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzQ2hhbmdlZCh2YWx1ZSwgb2xkVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJzZXRcIiAvKiBTRVQgKi8sIGtleSwgdmFsdWUsIG9sZFZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xyXG4gICAgY29uc3QgaGFkS2V5ID0gaGFzT3duKHRhcmdldCwga2V5KTtcclxuICAgIGNvbnN0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XHJcbiAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KTtcclxuICAgIGlmIChyZXN1bHQgJiYgaGFkS2V5KSB7XHJcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiZGVsZXRlXCIgLyogREVMRVRFICovLCBrZXksIHVuZGVmaW5lZCwgb2xkVmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBoYXModGFyZ2V0LCBrZXkpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuaGFzKHRhcmdldCwga2V5KTtcclxuICAgIGlmICghaXNTeW1ib2woa2V5KSB8fCAhYnVpbHRJblN5bWJvbHMuaGFzKGtleSkpIHtcclxuICAgICAgICB0cmFjayh0YXJnZXQsIFwiaGFzXCIgLyogSEFTICovLCBrZXkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBvd25LZXlzKHRhcmdldCkge1xyXG4gICAgdHJhY2sodGFyZ2V0LCBcIml0ZXJhdGVcIiAvKiBJVEVSQVRFICovLCBpc0FycmF5KHRhcmdldCkgPyAnbGVuZ3RoJyA6IElURVJBVEVfS0VZKTtcclxuICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcclxufVxyXG5jb25zdCBtdXRhYmxlSGFuZGxlcnMgPSB7XHJcbiAgICBnZXQsXHJcbiAgICBzZXQsXHJcbiAgICBkZWxldGVQcm9wZXJ0eSxcclxuICAgIGhhcyxcclxuICAgIG93bktleXNcclxufTtcclxuY29uc3QgcmVhZG9ubHlIYW5kbGVycyA9IHtcclxuICAgIGdldDogcmVhZG9ubHlHZXQsXHJcbiAgICBzZXQodGFyZ2V0LCBrZXkpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgU2V0IG9wZXJhdGlvbiBvbiBrZXkgXCIke1N0cmluZyhrZXkpfVwiIGZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsIHRhcmdldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSxcclxuICAgIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYERlbGV0ZSBvcGVyYXRpb24gb24ga2V5IFwiJHtTdHJpbmcoa2V5KX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLCB0YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufTtcclxuY29uc3Qgc2hhbGxvd1JlYWN0aXZlSGFuZGxlcnMgPSAvKiNfX1BVUkVfXyovIGV4dGVuZCh7fSwgbXV0YWJsZUhhbmRsZXJzLCB7XHJcbiAgICBnZXQ6IHNoYWxsb3dHZXQsXHJcbiAgICBzZXQ6IHNoYWxsb3dTZXRcclxufSk7XHJcbi8vIFByb3BzIGhhbmRsZXJzIGFyZSBzcGVjaWFsIGluIHRoZSBzZW5zZSB0aGF0IGl0IHNob3VsZCBub3QgdW53cmFwIHRvcC1sZXZlbFxyXG4vLyByZWZzIChpbiBvcmRlciB0byBhbGxvdyByZWZzIHRvIGJlIGV4cGxpY2l0bHkgcGFzc2VkIGRvd24pLCBidXQgc2hvdWxkXHJcbi8vIHJldGFpbiB0aGUgcmVhY3Rpdml0eSBvZiB0aGUgbm9ybWFsIHJlYWRvbmx5IG9iamVjdC5cclxuY29uc3Qgc2hhbGxvd1JlYWRvbmx5SGFuZGxlcnMgPSAvKiNfX1BVUkVfXyovIGV4dGVuZCh7fSwgcmVhZG9ubHlIYW5kbGVycywge1xyXG4gICAgZ2V0OiBzaGFsbG93UmVhZG9ubHlHZXRcclxufSk7XG5cbmNvbnN0IHRvU2hhbGxvdyA9ICh2YWx1ZSkgPT4gdmFsdWU7XHJcbmNvbnN0IGdldFByb3RvID0gKHYpID0+IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2Yodik7XHJcbmZ1bmN0aW9uIGdldCQxKHRhcmdldCwga2V5LCBpc1JlYWRvbmx5ID0gZmFsc2UsIGlzU2hhbGxvdyA9IGZhbHNlKSB7XHJcbiAgICAvLyAjMTc3MjogcmVhZG9ubHkocmVhY3RpdmUoTWFwKSkgc2hvdWxkIHJldHVybiByZWFkb25seSArIHJlYWN0aXZlIHZlcnNpb25cclxuICAgIC8vIG9mIHRoZSB2YWx1ZVxyXG4gICAgdGFyZ2V0ID0gdGFyZ2V0W1wiX192X3Jhd1wiIC8qIFJBVyAqL107XHJcbiAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xyXG4gICAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcclxuICAgIGlmIChrZXkgIT09IHJhd0tleSkge1xyXG4gICAgICAgICFpc1JlYWRvbmx5ICYmIHRyYWNrKHJhd1RhcmdldCwgXCJnZXRcIiAvKiBHRVQgKi8sIGtleSk7XHJcbiAgICB9XHJcbiAgICAhaXNSZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiZ2V0XCIgLyogR0VUICovLCByYXdLZXkpO1xyXG4gICAgY29uc3QgeyBoYXMgfSA9IGdldFByb3RvKHJhd1RhcmdldCk7XHJcbiAgICBjb25zdCB3cmFwID0gaXNTaGFsbG93ID8gdG9TaGFsbG93IDogaXNSZWFkb25seSA/IHRvUmVhZG9ubHkgOiB0b1JlYWN0aXZlO1xyXG4gICAgaWYgKGhhcy5jYWxsKHJhd1RhcmdldCwga2V5KSkge1xyXG4gICAgICAgIHJldHVybiB3cmFwKHRhcmdldC5nZXQoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChoYXMuY2FsbChyYXdUYXJnZXQsIHJhd0tleSkpIHtcclxuICAgICAgICByZXR1cm4gd3JhcCh0YXJnZXQuZ2V0KHJhd0tleSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodGFyZ2V0ICE9PSByYXdUYXJnZXQpIHtcclxuICAgICAgICAvLyAjMzYwMiByZWFkb25seShyZWFjdGl2ZShNYXApKVxyXG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IHRoZSBuZXN0ZWQgcmVhY3RpdmUgYE1hcGAgY2FuIGRvIHRyYWNraW5nIGZvciBpdHNlbGZcclxuICAgICAgICB0YXJnZXQuZ2V0KGtleSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaGFzJDEoa2V5LCBpc1JlYWRvbmx5ID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IHRhcmdldCA9IHRoaXNbXCJfX3ZfcmF3XCIgLyogUkFXICovXTtcclxuICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XHJcbiAgICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xyXG4gICAgaWYgKGtleSAhPT0gcmF3S2V5KSB7XHJcbiAgICAgICAgIWlzUmVhZG9ubHkgJiYgdHJhY2socmF3VGFyZ2V0LCBcImhhc1wiIC8qIEhBUyAqLywga2V5KTtcclxuICAgIH1cclxuICAgICFpc1JlYWRvbmx5ICYmIHRyYWNrKHJhd1RhcmdldCwgXCJoYXNcIiAvKiBIQVMgKi8sIHJhd0tleSk7XHJcbiAgICByZXR1cm4ga2V5ID09PSByYXdLZXlcclxuICAgICAgICA/IHRhcmdldC5oYXMoa2V5KVxyXG4gICAgICAgIDogdGFyZ2V0LmhhcyhrZXkpIHx8IHRhcmdldC5oYXMocmF3S2V5KTtcclxufVxyXG5mdW5jdGlvbiBzaXplKHRhcmdldCwgaXNSZWFkb25seSA9IGZhbHNlKSB7XHJcbiAgICB0YXJnZXQgPSB0YXJnZXRbXCJfX3ZfcmF3XCIgLyogUkFXICovXTtcclxuICAgICFpc1JlYWRvbmx5ICYmIHRyYWNrKHRvUmF3KHRhcmdldCksIFwiaXRlcmF0ZVwiIC8qIElURVJBVEUgKi8sIElURVJBVEVfS0VZKTtcclxuICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsICdzaXplJywgdGFyZ2V0KTtcclxufVxyXG5mdW5jdGlvbiBhZGQodmFsdWUpIHtcclxuICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XHJcbiAgICBjb25zdCBwcm90byA9IGdldFByb3RvKHRhcmdldCk7XHJcbiAgICBjb25zdCBoYWRLZXkgPSBwcm90by5oYXMuY2FsbCh0YXJnZXQsIHZhbHVlKTtcclxuICAgIGlmICghaGFkS2V5KSB7XHJcbiAgICAgICAgdGFyZ2V0LmFkZCh2YWx1ZSk7XHJcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIgLyogQUREICovLCB2YWx1ZSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuZnVuY3Rpb24gc2V0JDEoa2V5LCB2YWx1ZSkge1xyXG4gICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XHJcbiAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcclxuICAgIGNvbnN0IHsgaGFzLCBnZXQgfSA9IGdldFByb3RvKHRhcmdldCk7XHJcbiAgICBsZXQgaGFkS2V5ID0gaGFzLmNhbGwodGFyZ2V0LCBrZXkpO1xyXG4gICAgaWYgKCFoYWRLZXkpIHtcclxuICAgICAgICBrZXkgPSB0b1JhdyhrZXkpO1xyXG4gICAgICAgIGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzLCBrZXkpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb2xkVmFsdWUgPSBnZXQuY2FsbCh0YXJnZXQsIGtleSk7XHJcbiAgICB0YXJnZXQuc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgaWYgKCFoYWRLZXkpIHtcclxuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiAvKiBBREQgKi8sIGtleSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaGFzQ2hhbmdlZCh2YWx1ZSwgb2xkVmFsdWUpKSB7XHJcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwic2V0XCIgLyogU0VUICovLCBrZXksIHZhbHVlLCBvbGRWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5mdW5jdGlvbiBkZWxldGVFbnRyeShrZXkpIHtcclxuICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xyXG4gICAgY29uc3QgeyBoYXMsIGdldCB9ID0gZ2V0UHJvdG8odGFyZ2V0KTtcclxuICAgIGxldCBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XHJcbiAgICBpZiAoIWhhZEtleSkge1xyXG4gICAgICAgIGtleSA9IHRvUmF3KGtleSk7XHJcbiAgICAgICAgaGFkS2V5ID0gaGFzLmNhbGwodGFyZ2V0LCBrZXkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMsIGtleSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvbGRWYWx1ZSA9IGdldCA/IGdldC5jYWxsKHRhcmdldCwga2V5KSA6IHVuZGVmaW5lZDtcclxuICAgIC8vIGZvcndhcmQgdGhlIG9wZXJhdGlvbiBiZWZvcmUgcXVldWVpbmcgcmVhY3Rpb25zXHJcbiAgICBjb25zdCByZXN1bHQgPSB0YXJnZXQuZGVsZXRlKGtleSk7XHJcbiAgICBpZiAoaGFkS2V5KSB7XHJcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiZGVsZXRlXCIgLyogREVMRVRFICovLCBrZXksIHVuZGVmaW5lZCwgb2xkVmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBjbGVhcigpIHtcclxuICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xyXG4gICAgY29uc3QgaGFkSXRlbXMgPSB0YXJnZXQuc2l6ZSAhPT0gMDtcclxuICAgIGNvbnN0IG9sZFRhcmdldCA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgID8gaXNNYXAodGFyZ2V0KVxyXG4gICAgICAgICAgICA/IG5ldyBNYXAodGFyZ2V0KVxyXG4gICAgICAgICAgICA6IG5ldyBTZXQodGFyZ2V0KVxyXG4gICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgLy8gZm9yd2FyZCB0aGUgb3BlcmF0aW9uIGJlZm9yZSBxdWV1ZWluZyByZWFjdGlvbnNcclxuICAgIGNvbnN0IHJlc3VsdCA9IHRhcmdldC5jbGVhcigpO1xyXG4gICAgaWYgKGhhZEl0ZW1zKSB7XHJcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiY2xlYXJcIiAvKiBDTEVBUiAqLywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG9sZFRhcmdldCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUZvckVhY2goaXNSZWFkb25seSwgaXNTaGFsbG93KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xyXG4gICAgICAgIGNvbnN0IG9ic2VydmVkID0gdGhpcztcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSBvYnNlcnZlZFtcIl9fdl9yYXdcIiAvKiBSQVcgKi9dO1xyXG4gICAgICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XHJcbiAgICAgICAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdyA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcclxuICAgICAgICAhaXNSZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiaXRlcmF0ZVwiIC8qIElURVJBVEUgKi8sIElURVJBVEVfS0VZKTtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0LmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcclxuICAgICAgICAgICAgLy8gaW1wb3J0YW50OiBtYWtlIHN1cmUgdGhlIGNhbGxiYWNrIGlzXHJcbiAgICAgICAgICAgIC8vIDEuIGludm9rZWQgd2l0aCB0aGUgcmVhY3RpdmUgbWFwIGFzIGB0aGlzYCBhbmQgM3JkIGFyZ1xyXG4gICAgICAgICAgICAvLyAyLiB0aGUgdmFsdWUgcmVjZWl2ZWQgc2hvdWxkIGJlIGEgY29ycmVzcG9uZGluZyByZWFjdGl2ZS9yZWFkb25seS5cclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgd3JhcCh2YWx1ZSksIHdyYXAoa2V5KSwgb2JzZXJ2ZWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIGlzUmVhZG9ubHksIGlzU2hhbGxvdykge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpc1tcIl9fdl9yYXdcIiAvKiBSQVcgKi9dO1xyXG4gICAgICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0SXNNYXAgPSBpc01hcChyYXdUYXJnZXQpO1xyXG4gICAgICAgIGNvbnN0IGlzUGFpciA9IG1ldGhvZCA9PT0gJ2VudHJpZXMnIHx8IChtZXRob2QgPT09IFN5bWJvbC5pdGVyYXRvciAmJiB0YXJnZXRJc01hcCk7XHJcbiAgICAgICAgY29uc3QgaXNLZXlPbmx5ID0gbWV0aG9kID09PSAna2V5cycgJiYgdGFyZ2V0SXNNYXA7XHJcbiAgICAgICAgY29uc3QgaW5uZXJJdGVyYXRvciA9IHRhcmdldFttZXRob2RdKC4uLmFyZ3MpO1xyXG4gICAgICAgIGNvbnN0IHdyYXAgPSBpc1NoYWxsb3cgPyB0b1NoYWxsb3cgOiBpc1JlYWRvbmx5ID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XHJcbiAgICAgICAgIWlzUmVhZG9ubHkgJiZcclxuICAgICAgICAgICAgdHJhY2socmF3VGFyZ2V0LCBcIml0ZXJhdGVcIiAvKiBJVEVSQVRFICovLCBpc0tleU9ubHkgPyBNQVBfS0VZX0lURVJBVEVfS0VZIDogSVRFUkFURV9LRVkpO1xyXG4gICAgICAgIC8vIHJldHVybiBhIHdyYXBwZWQgaXRlcmF0b3Igd2hpY2ggcmV0dXJucyBvYnNlcnZlZCB2ZXJzaW9ucyBvZiB0aGVcclxuICAgICAgICAvLyB2YWx1ZXMgZW1pdHRlZCBmcm9tIHRoZSByZWFsIGl0ZXJhdG9yXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLy8gaXRlcmF0b3IgcHJvdG9jb2xcclxuICAgICAgICAgICAgbmV4dCgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGlubmVySXRlcmF0b3IubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbmVcclxuICAgICAgICAgICAgICAgICAgICA/IHsgdmFsdWUsIGRvbmUgfVxyXG4gICAgICAgICAgICAgICAgICAgIDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaXNQYWlyID8gW3dyYXAodmFsdWVbMF0pLCB3cmFwKHZhbHVlWzFdKV0gOiB3cmFwKHZhbHVlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vIGl0ZXJhYmxlIHByb3RvY29sXHJcbiAgICAgICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVSZWFkb25seU1ldGhvZCh0eXBlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGFyZ3NbMF0gPyBgb24ga2V5IFwiJHthcmdzWzBdfVwiIGAgOiBgYDtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGAke2NhcGl0YWxpemUodHlwZSl9IG9wZXJhdGlvbiAke2tleX1mYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLCB0b1Jhdyh0aGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0eXBlID09PSBcImRlbGV0ZVwiIC8qIERFTEVURSAqLyA/IGZhbHNlIDogdGhpcztcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlSW5zdHJ1bWVudGF0aW9ucygpIHtcclxuICAgIGNvbnN0IG11dGFibGVJbnN0cnVtZW50YXRpb25zID0ge1xyXG4gICAgICAgIGdldChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldCQxKHRoaXMsIGtleSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNpemUodGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoYXM6IGhhcyQxLFxyXG4gICAgICAgIGFkZCxcclxuICAgICAgICBzZXQ6IHNldCQxLFxyXG4gICAgICAgIGRlbGV0ZTogZGVsZXRlRW50cnksXHJcbiAgICAgICAgY2xlYXIsXHJcbiAgICAgICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaChmYWxzZSwgZmFsc2UpXHJcbiAgICB9O1xyXG4gICAgY29uc3Qgc2hhbGxvd0luc3RydW1lbnRhdGlvbnMgPSB7XHJcbiAgICAgICAgZ2V0KGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEodGhpcywga2V5LCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNpemUodGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoYXM6IGhhcyQxLFxyXG4gICAgICAgIGFkZCxcclxuICAgICAgICBzZXQ6IHNldCQxLFxyXG4gICAgICAgIGRlbGV0ZTogZGVsZXRlRW50cnksXHJcbiAgICAgICAgY2xlYXIsXHJcbiAgICAgICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaChmYWxzZSwgdHJ1ZSlcclxuICAgIH07XHJcbiAgICBjb25zdCByZWFkb25seUluc3RydW1lbnRhdGlvbnMgPSB7XHJcbiAgICAgICAgZ2V0KGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEodGhpcywga2V5LCB0cnVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2l6ZSh0aGlzLCB0cnVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhhcyhrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhhcyQxLmNhbGwodGhpcywga2V5LCB0cnVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJhZGRcIiAvKiBBREQgKi8pLFxyXG4gICAgICAgIHNldDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJzZXRcIiAvKiBTRVQgKi8pLFxyXG4gICAgICAgIGRlbGV0ZTogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJkZWxldGVcIiAvKiBERUxFVEUgKi8pLFxyXG4gICAgICAgIGNsZWFyOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImNsZWFyXCIgLyogQ0xFQVIgKi8pLFxyXG4gICAgICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2godHJ1ZSwgZmFsc2UpXHJcbiAgICB9O1xyXG4gICAgY29uc3Qgc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyA9IHtcclxuICAgICAgICBnZXQoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXQkMSh0aGlzLCBrZXksIHRydWUsIHRydWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzaXplKHRoaXMsIHRydWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFzKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaGFzJDEuY2FsbCh0aGlzLCBrZXksIHRydWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImFkZFwiIC8qIEFERCAqLyksXHJcbiAgICAgICAgc2V0OiBjcmVhdGVSZWFkb25seU1ldGhvZChcInNldFwiIC8qIFNFVCAqLyksXHJcbiAgICAgICAgZGVsZXRlOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImRlbGV0ZVwiIC8qIERFTEVURSAqLyksXHJcbiAgICAgICAgY2xlYXI6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiY2xlYXJcIiAvKiBDTEVBUiAqLyksXHJcbiAgICAgICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaCh0cnVlLCB0cnVlKVxyXG4gICAgfTtcclxuICAgIGNvbnN0IGl0ZXJhdG9yTWV0aG9kcyA9IFsna2V5cycsICd2YWx1ZXMnLCAnZW50cmllcycsIFN5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpdGVyYXRvck1ldGhvZHMuZm9yRWFjaChtZXRob2QgPT4ge1xyXG4gICAgICAgIG11dGFibGVJbnN0cnVtZW50YXRpb25zW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIGZhbHNlLCBmYWxzZSk7XHJcbiAgICAgICAgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIHRydWUsIGZhbHNlKTtcclxuICAgICAgICBzaGFsbG93SW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICAgICAgc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCB0cnVlLCB0cnVlKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBtdXRhYmxlSW5zdHJ1bWVudGF0aW9ucyxcclxuICAgICAgICByZWFkb25seUluc3RydW1lbnRhdGlvbnMsXHJcbiAgICAgICAgc2hhbGxvd0luc3RydW1lbnRhdGlvbnMsXHJcbiAgICAgICAgc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc1xyXG4gICAgXTtcclxufVxyXG5jb25zdCBbbXV0YWJsZUluc3RydW1lbnRhdGlvbnMsIHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucywgc2hhbGxvd0luc3RydW1lbnRhdGlvbnMsIHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnNdID0gLyogI19fUFVSRV9fKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9ucygpO1xyXG5mdW5jdGlvbiBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoaXNSZWFkb25seSwgc2hhbGxvdykge1xyXG4gICAgY29uc3QgaW5zdHJ1bWVudGF0aW9ucyA9IHNoYWxsb3dcclxuICAgICAgICA/IGlzUmVhZG9ubHlcclxuICAgICAgICAgICAgPyBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zXHJcbiAgICAgICAgICAgIDogc2hhbGxvd0luc3RydW1lbnRhdGlvbnNcclxuICAgICAgICA6IGlzUmVhZG9ubHlcclxuICAgICAgICAgICAgPyByZWFkb25seUluc3RydW1lbnRhdGlvbnNcclxuICAgICAgICAgICAgOiBtdXRhYmxlSW5zdHJ1bWVudGF0aW9ucztcclxuICAgIHJldHVybiAodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSA9PiB7XHJcbiAgICAgICAgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFjdGl2ZVwiIC8qIElTX1JFQUNUSVZFICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhaXNSZWFkb25seTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWRvbmx5XCIgLyogSVNfUkVBRE9OTFkgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzUmVhZG9ubHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfcmF3XCIgLyogUkFXICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBSZWZsZWN0LmdldChoYXNPd24oaW5zdHJ1bWVudGF0aW9ucywga2V5KSAmJiBrZXkgaW4gdGFyZ2V0XHJcbiAgICAgICAgICAgID8gaW5zdHJ1bWVudGF0aW9uc1xyXG4gICAgICAgICAgICA6IHRhcmdldCwga2V5LCByZWNlaXZlcik7XHJcbiAgICB9O1xyXG59XHJcbmNvbnN0IG11dGFibGVDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XHJcbiAgICBnZXQ6IC8qI19fUFVSRV9fKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGZhbHNlLCBmYWxzZSlcclxufTtcclxuY29uc3Qgc2hhbGxvd0NvbGxlY3Rpb25IYW5kbGVycyA9IHtcclxuICAgIGdldDogLyojX19QVVJFX18qLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoZmFsc2UsIHRydWUpXHJcbn07XHJcbmNvbnN0IHJlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xyXG4gICAgZ2V0OiAvKiNfX1BVUkVfXyovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcih0cnVlLCBmYWxzZSlcclxufTtcclxuY29uc3Qgc2hhbGxvd1JlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xyXG4gICAgZ2V0OiAvKiNfX1BVUkVfXyovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcih0cnVlLCB0cnVlKVxyXG59O1xyXG5mdW5jdGlvbiBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhcywga2V5KSB7XHJcbiAgICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xyXG4gICAgaWYgKHJhd0tleSAhPT0ga2V5ICYmIGhhcy5jYWxsKHRhcmdldCwgcmF3S2V5KSkge1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSB0b1Jhd1R5cGUodGFyZ2V0KTtcclxuICAgICAgICBjb25zb2xlLndhcm4oYFJlYWN0aXZlICR7dHlwZX0gY29udGFpbnMgYm90aCB0aGUgcmF3IGFuZCByZWFjdGl2ZSBgICtcclxuICAgICAgICAgICAgYHZlcnNpb25zIG9mIHRoZSBzYW1lIG9iamVjdCR7dHlwZSA9PT0gYE1hcGAgPyBgIGFzIGtleXNgIDogYGB9LCBgICtcclxuICAgICAgICAgICAgYHdoaWNoIGNhbiBsZWFkIHRvIGluY29uc2lzdGVuY2llcy4gYCArXHJcbiAgICAgICAgICAgIGBBdm9pZCBkaWZmZXJlbnRpYXRpbmcgYmV0d2VlbiB0aGUgcmF3IGFuZCByZWFjdGl2ZSB2ZXJzaW9ucyBgICtcclxuICAgICAgICAgICAgYG9mIGFuIG9iamVjdCBhbmQgb25seSB1c2UgdGhlIHJlYWN0aXZlIHZlcnNpb24gaWYgcG9zc2libGUuYCk7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgcmVhY3RpdmVNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG5jb25zdCBzaGFsbG93UmVhY3RpdmVNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG5jb25zdCByZWFkb25seU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IHNoYWxsb3dSZWFkb25seU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmZ1bmN0aW9uIHRhcmdldFR5cGVNYXAocmF3VHlwZSkge1xyXG4gICAgc3dpdGNoIChyYXdUeXBlKSB7XHJcbiAgICAgICAgY2FzZSAnT2JqZWN0JzpcclxuICAgICAgICBjYXNlICdBcnJheSc6XHJcbiAgICAgICAgICAgIHJldHVybiAxIC8qIENPTU1PTiAqLztcclxuICAgICAgICBjYXNlICdNYXAnOlxyXG4gICAgICAgIGNhc2UgJ1NldCc6XHJcbiAgICAgICAgY2FzZSAnV2Vha01hcCc6XHJcbiAgICAgICAgY2FzZSAnV2Vha1NldCc6XHJcbiAgICAgICAgICAgIHJldHVybiAyIC8qIENPTExFQ1RJT04gKi87XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIDAgLyogSU5WQUxJRCAqLztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRUYXJnZXRUeXBlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWVbXCJfX3Zfc2tpcFwiIC8qIFNLSVAgKi9dIHx8ICFPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKVxyXG4gICAgICAgID8gMCAvKiBJTlZBTElEICovXHJcbiAgICAgICAgOiB0YXJnZXRUeXBlTWFwKHRvUmF3VHlwZSh2YWx1ZSkpO1xyXG59XHJcbmZ1bmN0aW9uIHJlYWN0aXZlKHRhcmdldCkge1xyXG4gICAgLy8gaWYgdHJ5aW5nIHRvIG9ic2VydmUgYSByZWFkb25seSBwcm94eSwgcmV0dXJuIHRoZSByZWFkb25seSB2ZXJzaW9uLlxyXG4gICAgaWYgKGlzUmVhZG9ubHkodGFyZ2V0KSkge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCBmYWxzZSwgbXV0YWJsZUhhbmRsZXJzLCBtdXRhYmxlQ29sbGVjdGlvbkhhbmRsZXJzLCByZWFjdGl2ZU1hcCk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybiBhIHNoYWxsb3dseS1yZWFjdGl2ZSBjb3B5IG9mIHRoZSBvcmlnaW5hbCBvYmplY3QsIHdoZXJlIG9ubHkgdGhlIHJvb3RcclxuICogbGV2ZWwgcHJvcGVydGllcyBhcmUgcmVhY3RpdmUuIEl0IGFsc28gZG9lcyBub3QgYXV0by11bndyYXAgcmVmcyAoZXZlbiBhdCB0aGVcclxuICogcm9vdCBsZXZlbCkuXHJcbiAqL1xyXG5mdW5jdGlvbiBzaGFsbG93UmVhY3RpdmUodGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCBmYWxzZSwgc2hhbGxvd1JlYWN0aXZlSGFuZGxlcnMsIHNoYWxsb3dDb2xsZWN0aW9uSGFuZGxlcnMsIHNoYWxsb3dSZWFjdGl2ZU1hcCk7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSByZWFkb25seSBjb3B5IG9mIHRoZSBvcmlnaW5hbCBvYmplY3QuIE5vdGUgdGhlIHJldHVybmVkIGNvcHkgaXMgbm90XHJcbiAqIG1hZGUgcmVhY3RpdmUsIGJ1dCBgcmVhZG9ubHlgIGNhbiBiZSBjYWxsZWQgb24gYW4gYWxyZWFkeSByZWFjdGl2ZSBvYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiByZWFkb25seSh0YXJnZXQpIHtcclxuICAgIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIHRydWUsIHJlYWRvbmx5SGFuZGxlcnMsIHJlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzLCByZWFkb25seU1hcCk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSByZWFjdGl2ZS1jb3B5IG9mIHRoZSBvcmlnaW5hbCBvYmplY3QsIHdoZXJlIG9ubHkgdGhlIHJvb3QgbGV2ZWxcclxuICogcHJvcGVydGllcyBhcmUgcmVhZG9ubHksIGFuZCBkb2VzIE5PVCB1bndyYXAgcmVmcyBub3IgcmVjdXJzaXZlbHkgY29udmVydFxyXG4gKiByZXR1cm5lZCBwcm9wZXJ0aWVzLlxyXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGNyZWF0aW5nIHRoZSBwcm9wcyBwcm94eSBvYmplY3QgZm9yIHN0YXRlZnVsIGNvbXBvbmVudHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBzaGFsbG93UmVhZG9ubHkodGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCB0cnVlLCBzaGFsbG93UmVhZG9ubHlIYW5kbGVycywgc2hhbGxvd1JlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzLCBzaGFsbG93UmVhZG9ubHlNYXApO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgaXNSZWFkb25seSwgYmFzZUhhbmRsZXJzLCBjb2xsZWN0aW9uSGFuZGxlcnMsIHByb3h5TWFwKSB7XHJcbiAgICBpZiAoIWlzT2JqZWN0KHRhcmdldCkpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgdmFsdWUgY2Fubm90IGJlIG1hZGUgcmVhY3RpdmU6ICR7U3RyaW5nKHRhcmdldCl9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICAvLyB0YXJnZXQgaXMgYWxyZWFkeSBhIFByb3h5LCByZXR1cm4gaXQuXHJcbiAgICAvLyBleGNlcHRpb246IGNhbGxpbmcgcmVhZG9ubHkoKSBvbiBhIHJlYWN0aXZlIG9iamVjdFxyXG4gICAgaWYgKHRhcmdldFtcIl9fdl9yYXdcIiAvKiBSQVcgKi9dICYmXHJcbiAgICAgICAgIShpc1JlYWRvbmx5ICYmIHRhcmdldFtcIl9fdl9pc1JlYWN0aXZlXCIgLyogSVNfUkVBQ1RJVkUgKi9dKSkge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICAvLyB0YXJnZXQgYWxyZWFkeSBoYXMgY29ycmVzcG9uZGluZyBQcm94eVxyXG4gICAgY29uc3QgZXhpc3RpbmdQcm94eSA9IHByb3h5TWFwLmdldCh0YXJnZXQpO1xyXG4gICAgaWYgKGV4aXN0aW5nUHJveHkpIHtcclxuICAgICAgICByZXR1cm4gZXhpc3RpbmdQcm94eTtcclxuICAgIH1cclxuICAgIC8vIG9ubHkgYSB3aGl0ZWxpc3Qgb2YgdmFsdWUgdHlwZXMgY2FuIGJlIG9ic2VydmVkLlxyXG4gICAgY29uc3QgdGFyZ2V0VHlwZSA9IGdldFRhcmdldFR5cGUodGFyZ2V0KTtcclxuICAgIGlmICh0YXJnZXRUeXBlID09PSAwIC8qIElOVkFMSUQgKi8pIHtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkodGFyZ2V0LCB0YXJnZXRUeXBlID09PSAyIC8qIENPTExFQ1RJT04gKi8gPyBjb2xsZWN0aW9uSGFuZGxlcnMgOiBiYXNlSGFuZGxlcnMpO1xyXG4gICAgcHJveHlNYXAuc2V0KHRhcmdldCwgcHJveHkpO1xyXG4gICAgcmV0dXJuIHByb3h5O1xyXG59XHJcbmZ1bmN0aW9uIGlzUmVhY3RpdmUodmFsdWUpIHtcclxuICAgIGlmIChpc1JlYWRvbmx5KHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBpc1JlYWN0aXZlKHZhbHVlW1wiX192X3Jhd1wiIC8qIFJBVyAqL10pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzUmVhY3RpdmVcIiAvKiBJU19SRUFDVElWRSAqL10pO1xyXG59XHJcbmZ1bmN0aW9uIGlzUmVhZG9ubHkodmFsdWUpIHtcclxuICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZVtcIl9fdl9pc1JlYWRvbmx5XCIgLyogSVNfUkVBRE9OTFkgKi9dKTtcclxufVxyXG5mdW5jdGlvbiBpc1NoYWxsb3codmFsdWUpIHtcclxuICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZVtcIl9fdl9pc1NoYWxsb3dcIiAvKiBJU19TSEFMTE9XICovXSk7XHJcbn1cclxuZnVuY3Rpb24gaXNQcm94eSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGlzUmVhY3RpdmUodmFsdWUpIHx8IGlzUmVhZG9ubHkodmFsdWUpO1xyXG59XHJcbmZ1bmN0aW9uIHRvUmF3KG9ic2VydmVkKSB7XHJcbiAgICBjb25zdCByYXcgPSBvYnNlcnZlZCAmJiBvYnNlcnZlZFtcIl9fdl9yYXdcIiAvKiBSQVcgKi9dO1xyXG4gICAgcmV0dXJuIHJhdyA/IHRvUmF3KHJhdykgOiBvYnNlcnZlZDtcclxufVxyXG5mdW5jdGlvbiBtYXJrUmF3KHZhbHVlKSB7XHJcbiAgICBkZWYodmFsdWUsIFwiX192X3NraXBcIiAvKiBTS0lQICovLCB0cnVlKTtcclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG5jb25zdCB0b1JlYWN0aXZlID0gKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgPyByZWFjdGl2ZSh2YWx1ZSkgOiB2YWx1ZTtcclxuY29uc3QgdG9SZWFkb25seSA9ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpID8gcmVhZG9ubHkodmFsdWUpIDogdmFsdWU7XG5cbmZ1bmN0aW9uIHRyYWNrUmVmVmFsdWUocmVmKSB7XHJcbiAgICBpZiAoc2hvdWxkVHJhY2sgJiYgYWN0aXZlRWZmZWN0KSB7XHJcbiAgICAgICAgcmVmID0gdG9SYXcocmVmKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHRyYWNrRWZmZWN0cyhyZWYuZGVwIHx8IChyZWYuZGVwID0gY3JlYXRlRGVwKCkpLCB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHJlZixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwiZ2V0XCIgLyogR0VUICovLFxyXG4gICAgICAgICAgICAgICAga2V5OiAndmFsdWUnXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdHJhY2tFZmZlY3RzKHJlZi5kZXAgfHwgKHJlZi5kZXAgPSBjcmVhdGVEZXAoKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0cmlnZ2VyUmVmVmFsdWUocmVmLCBuZXdWYWwpIHtcclxuICAgIHJlZiA9IHRvUmF3KHJlZik7XHJcbiAgICBpZiAocmVmLmRlcCkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgdHJpZ2dlckVmZmVjdHMocmVmLmRlcCwge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiByZWYsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInNldFwiIC8qIFNFVCAqLyxcclxuICAgICAgICAgICAgICAgIGtleTogJ3ZhbHVlJyxcclxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0cmlnZ2VyRWZmZWN0cyhyZWYuZGVwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNSZWYocikge1xyXG4gICAgcmV0dXJuICEhKHIgJiYgci5fX3ZfaXNSZWYgPT09IHRydWUpO1xyXG59XHJcbmZ1bmN0aW9uIHJlZih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJlZih2YWx1ZSwgZmFsc2UpO1xyXG59XHJcbmZ1bmN0aW9uIHNoYWxsb3dSZWYodmFsdWUpIHtcclxuICAgIHJldHVybiBjcmVhdGVSZWYodmFsdWUsIHRydWUpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVJlZihyYXdWYWx1ZSwgc2hhbGxvdykge1xyXG4gICAgaWYgKGlzUmVmKHJhd1ZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiByYXdWYWx1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgUmVmSW1wbChyYXdWYWx1ZSwgc2hhbGxvdyk7XHJcbn1cclxuY2xhc3MgUmVmSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgX192X2lzU2hhbGxvdykge1xyXG4gICAgICAgIHRoaXMuX192X2lzU2hhbGxvdyA9IF9fdl9pc1NoYWxsb3c7XHJcbiAgICAgICAgdGhpcy5kZXAgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX3Jhd1ZhbHVlID0gX192X2lzU2hhbGxvdyA/IHZhbHVlIDogdG9SYXcodmFsdWUpO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gX192X2lzU2hhbGxvdyA/IHZhbHVlIDogdG9SZWFjdGl2ZSh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBnZXQgdmFsdWUoKSB7XHJcbiAgICAgICAgdHJhY2tSZWZWYWx1ZSh0aGlzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZXQgdmFsdWUobmV3VmFsKSB7XHJcbiAgICAgICAgbmV3VmFsID0gdGhpcy5fX3ZfaXNTaGFsbG93ID8gbmV3VmFsIDogdG9SYXcobmV3VmFsKTtcclxuICAgICAgICBpZiAoaGFzQ2hhbmdlZChuZXdWYWwsIHRoaXMuX3Jhd1ZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yYXdWYWx1ZSA9IG5ld1ZhbDtcclxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB0aGlzLl9fdl9pc1NoYWxsb3cgPyBuZXdWYWwgOiB0b1JlYWN0aXZlKG5ld1ZhbCk7XHJcbiAgICAgICAgICAgIHRyaWdnZXJSZWZWYWx1ZSh0aGlzLCBuZXdWYWwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0cmlnZ2VyUmVmKHJlZikge1xyXG4gICAgdHJpZ2dlclJlZlZhbHVlKHJlZiwgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gcmVmLnZhbHVlIDogdm9pZCAwKTtcclxufVxyXG5mdW5jdGlvbiB1bnJlZihyZWYpIHtcclxuICAgIHJldHVybiBpc1JlZihyZWYpID8gcmVmLnZhbHVlIDogcmVmO1xyXG59XHJcbmNvbnN0IHNoYWxsb3dVbndyYXBIYW5kbGVycyA9IHtcclxuICAgIGdldDogKHRhcmdldCwga2V5LCByZWNlaXZlcikgPT4gdW5yZWYoUmVmbGVjdC5nZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSksXHJcbiAgICBzZXQ6ICh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcclxuICAgICAgICBpZiAoaXNSZWYob2xkVmFsdWUpICYmICFpc1JlZih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgb2xkVmFsdWUudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5zZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBwcm94eVJlZnMob2JqZWN0V2l0aFJlZnMpIHtcclxuICAgIHJldHVybiBpc1JlYWN0aXZlKG9iamVjdFdpdGhSZWZzKVxyXG4gICAgICAgID8gb2JqZWN0V2l0aFJlZnNcclxuICAgICAgICA6IG5ldyBQcm94eShvYmplY3RXaXRoUmVmcywgc2hhbGxvd1Vud3JhcEhhbmRsZXJzKTtcclxufVxyXG5jbGFzcyBDdXN0b21SZWZJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKGZhY3RvcnkpIHtcclxuICAgICAgICB0aGlzLmRlcCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XHJcbiAgICAgICAgY29uc3QgeyBnZXQsIHNldCB9ID0gZmFjdG9yeSgoKSA9PiB0cmFja1JlZlZhbHVlKHRoaXMpLCAoKSA9PiB0cmlnZ2VyUmVmVmFsdWUodGhpcykpO1xyXG4gICAgICAgIHRoaXMuX2dldCA9IGdldDtcclxuICAgICAgICB0aGlzLl9zZXQgPSBzZXQ7XHJcbiAgICB9XHJcbiAgICBnZXQgdmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldCgpO1xyXG4gICAgfVxyXG4gICAgc2V0IHZhbHVlKG5ld1ZhbCkge1xyXG4gICAgICAgIHRoaXMuX3NldChuZXdWYWwpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGN1c3RvbVJlZihmYWN0b3J5KSB7XHJcbiAgICByZXR1cm4gbmV3IEN1c3RvbVJlZkltcGwoZmFjdG9yeSk7XHJcbn1cclxuZnVuY3Rpb24gdG9SZWZzKG9iamVjdCkge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNQcm94eShvYmplY3QpKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGB0b1JlZnMoKSBleHBlY3RzIGEgcmVhY3RpdmUgb2JqZWN0IGJ1dCByZWNlaXZlZCBhIHBsYWluIG9uZS5gKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHJldCA9IGlzQXJyYXkob2JqZWN0KSA/IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKSA6IHt9O1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XHJcbiAgICAgICAgcmV0W2tleV0gPSB0b1JlZihvYmplY3QsIGtleSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcbmNsYXNzIE9iamVjdFJlZkltcGwge1xyXG4gICAgY29uc3RydWN0b3IoX29iamVjdCwgX2tleSwgX2RlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX29iamVjdCA9IF9vYmplY3Q7XHJcbiAgICAgICAgdGhpcy5fa2V5ID0gX2tleTtcclxuICAgICAgICB0aGlzLl9kZWZhdWx0VmFsdWUgPSBfZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICBjb25zdCB2YWwgPSB0aGlzLl9vYmplY3RbdGhpcy5fa2V5XTtcclxuICAgICAgICByZXR1cm4gdmFsID09PSB1bmRlZmluZWQgPyB0aGlzLl9kZWZhdWx0VmFsdWUgOiB2YWw7XHJcbiAgICB9XHJcbiAgICBzZXQgdmFsdWUobmV3VmFsKSB7XHJcbiAgICAgICAgdGhpcy5fb2JqZWN0W3RoaXMuX2tleV0gPSBuZXdWYWw7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdG9SZWYob2JqZWN0LCBrZXksIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgY29uc3QgdmFsID0gb2JqZWN0W2tleV07XHJcbiAgICByZXR1cm4gaXNSZWYodmFsKVxyXG4gICAgICAgID8gdmFsXHJcbiAgICAgICAgOiBuZXcgT2JqZWN0UmVmSW1wbChvYmplY3QsIGtleSwgZGVmYXVsdFZhbHVlKTtcclxufVxuXG5jbGFzcyBDb21wdXRlZFJlZkltcGwge1xyXG4gICAgY29uc3RydWN0b3IoZ2V0dGVyLCBfc2V0dGVyLCBpc1JlYWRvbmx5LCBpc1NTUikge1xyXG4gICAgICAgIHRoaXMuX3NldHRlciA9IF9zZXR0ZXI7XHJcbiAgICAgICAgdGhpcy5kZXAgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmVmZmVjdCA9IG5ldyBSZWFjdGl2ZUVmZmVjdChnZXR0ZXIsICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9kaXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdHJpZ2dlclJlZlZhbHVlKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5lZmZlY3QuY29tcHV0ZWQgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuZWZmZWN0LmFjdGl2ZSA9IHRoaXMuX2NhY2hlYWJsZSA9ICFpc1NTUjtcclxuICAgICAgICB0aGlzW1wiX192X2lzUmVhZG9ubHlcIiAvKiBJU19SRUFET05MWSAqL10gPSBpc1JlYWRvbmx5O1xyXG4gICAgfVxyXG4gICAgZ2V0IHZhbHVlKCkge1xyXG4gICAgICAgIC8vIHRoZSBjb21wdXRlZCByZWYgbWF5IGdldCB3cmFwcGVkIGJ5IG90aGVyIHByb3hpZXMgZS5nLiByZWFkb25seSgpICMzMzc2XHJcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRvUmF3KHRoaXMpO1xyXG4gICAgICAgIHRyYWNrUmVmVmFsdWUoc2VsZik7XHJcbiAgICAgICAgaWYgKHNlbGYuX2RpcnR5IHx8ICFzZWxmLl9jYWNoZWFibGUpIHtcclxuICAgICAgICAgICAgc2VsZi5fZGlydHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgc2VsZi5fdmFsdWUgPSBzZWxmLmVmZmVjdC5ydW4oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlbGYuX3ZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2V0IHZhbHVlKG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0dGVyKG5ld1ZhbHVlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjb21wdXRlZChnZXR0ZXJPck9wdGlvbnMsIGRlYnVnT3B0aW9ucywgaXNTU1IgPSBmYWxzZSkge1xyXG4gICAgbGV0IGdldHRlcjtcclxuICAgIGxldCBzZXR0ZXI7XHJcbiAgICBjb25zdCBvbmx5R2V0dGVyID0gaXNGdW5jdGlvbihnZXR0ZXJPck9wdGlvbnMpO1xyXG4gICAgaWYgKG9ubHlHZXR0ZXIpIHtcclxuICAgICAgICBnZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnM7XHJcbiAgICAgICAgc2V0dGVyID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgICAgID8gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdXcml0ZSBvcGVyYXRpb24gZmFpbGVkOiBjb21wdXRlZCB2YWx1ZSBpcyByZWFkb25seScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDogTk9PUDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGdldHRlciA9IGdldHRlck9yT3B0aW9ucy5nZXQ7XHJcbiAgICAgICAgc2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zLnNldDtcclxuICAgIH1cclxuICAgIGNvbnN0IGNSZWYgPSBuZXcgQ29tcHV0ZWRSZWZJbXBsKGdldHRlciwgc2V0dGVyLCBvbmx5R2V0dGVyIHx8ICFzZXR0ZXIsIGlzU1NSKTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgZGVidWdPcHRpb25zICYmICFpc1NTUikge1xyXG4gICAgICAgIGNSZWYuZWZmZWN0Lm9uVHJhY2sgPSBkZWJ1Z09wdGlvbnMub25UcmFjaztcclxuICAgICAgICBjUmVmLmVmZmVjdC5vblRyaWdnZXIgPSBkZWJ1Z09wdGlvbnMub25UcmlnZ2VyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNSZWY7XHJcbn1cblxudmFyIF9hO1xyXG5jb25zdCB0aWNrID0gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbmNvbnN0IHF1ZXVlID0gW107XHJcbmxldCBxdWV1ZWQgPSBmYWxzZTtcclxuY29uc3Qgc2NoZWR1bGVyID0gKGZuKSA9PiB7XHJcbiAgICBxdWV1ZS5wdXNoKGZuKTtcclxuICAgIGlmICghcXVldWVkKSB7XHJcbiAgICAgICAgcXVldWVkID0gdHJ1ZTtcclxuICAgICAgICB0aWNrLnRoZW4oZmx1c2gpO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBmbHVzaCA9ICgpID0+IHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBxdWV1ZVtpXSgpO1xyXG4gICAgfVxyXG4gICAgcXVldWUubGVuZ3RoID0gMDtcclxuICAgIHF1ZXVlZCA9IGZhbHNlO1xyXG59O1xyXG5jbGFzcyBEZWZlcnJlZENvbXB1dGVkUmVmSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihnZXR0ZXIpIHtcclxuICAgICAgICB0aGlzLmRlcCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xyXG4gICAgICAgIHRoaXNbX2FdID0gdHJ1ZTtcclxuICAgICAgICBsZXQgY29tcGFyZVRhcmdldDtcclxuICAgICAgICBsZXQgaGFzQ29tcGFyZVRhcmdldCA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBzY2hlZHVsZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmVmZmVjdCA9IG5ldyBSZWFjdGl2ZUVmZmVjdChnZXR0ZXIsIChjb21wdXRlZFRyaWdnZXIpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGVwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcHV0ZWRUcmlnZ2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcGFyZVRhcmdldCA9IHRoaXMuX3ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc0NvbXBhcmVUYXJnZXQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNjaGVkdWxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlVG9Db21wYXJlID0gaGFzQ29tcGFyZVRhcmdldCA/IGNvbXBhcmVUYXJnZXQgOiB0aGlzLl92YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc0NvbXBhcmVUYXJnZXQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZXIoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5lZmZlY3QuYWN0aXZlICYmIHRoaXMuX2dldCgpICE9PSB2YWx1ZVRvQ29tcGFyZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlclJlZlZhbHVlKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gY2hhaW5lZCB1cHN0cmVhbSBjb21wdXRlZHMgYXJlIG5vdGlmaWVkIHN5bmNocm9ub3VzbHkgdG8gZW5zdXJlXHJcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZSBpbnZhbGlkYXRpb24gaW4gY2FzZSBvZiBzeW5jIGFjY2Vzczsgbm9ybWFsIGVmZmVjdHMgYXJlXHJcbiAgICAgICAgICAgICAgICAvLyBkZWZlcnJlZCB0byBiZSB0cmlnZ2VyZWQgaW4gc2NoZWR1bGVyLlxyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIHRoaXMuZGVwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuY29tcHV0ZWQgaW5zdGFuY2VvZiBEZWZlcnJlZENvbXB1dGVkUmVmSW1wbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNjaGVkdWxlcih0cnVlIC8qIGNvbXB1dGVkVHJpZ2dlciAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmVmZmVjdC5jb21wdXRlZCA9IHRoaXM7XHJcbiAgICB9XHJcbiAgICBfZ2V0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9kaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuX3ZhbHVlID0gdGhpcy5lZmZlY3QucnVuKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XHJcbiAgICB9XHJcbiAgICBnZXQgdmFsdWUoKSB7XHJcbiAgICAgICAgdHJhY2tSZWZWYWx1ZSh0aGlzKTtcclxuICAgICAgICAvLyB0aGUgY29tcHV0ZWQgcmVmIG1heSBnZXQgd3JhcHBlZCBieSBvdGhlciBwcm94aWVzIGUuZy4gcmVhZG9ubHkoKSAjMzM3NlxyXG4gICAgICAgIHJldHVybiB0b1Jhdyh0aGlzKS5fZ2V0KCk7XHJcbiAgICB9XHJcbn1cclxuX2EgPSBcIl9fdl9pc1JlYWRvbmx5XCIgLyogSVNfUkVBRE9OTFkgKi87XHJcbmZ1bmN0aW9uIGRlZmVycmVkQ29tcHV0ZWQoZ2V0dGVyKSB7XHJcbiAgICByZXR1cm4gbmV3IERlZmVycmVkQ29tcHV0ZWRSZWZJbXBsKGdldHRlcik7XHJcbn1cblxuZXhwb3J0IHsgRWZmZWN0U2NvcGUsIElURVJBVEVfS0VZLCBSZWFjdGl2ZUVmZmVjdCwgY29tcHV0ZWQsIGN1c3RvbVJlZiwgZGVmZXJyZWRDb21wdXRlZCwgZWZmZWN0LCBlZmZlY3RTY29wZSwgZW5hYmxlVHJhY2tpbmcsIGdldEN1cnJlbnRTY29wZSwgaXNQcm94eSwgaXNSZWFjdGl2ZSwgaXNSZWFkb25seSwgaXNSZWYsIGlzU2hhbGxvdywgbWFya1Jhdywgb25TY29wZURpc3Bvc2UsIHBhdXNlVHJhY2tpbmcsIHByb3h5UmVmcywgcmVhY3RpdmUsIHJlYWRvbmx5LCByZWYsIHJlc2V0VHJhY2tpbmcsIHNoYWxsb3dSZWFjdGl2ZSwgc2hhbGxvd1JlYWRvbmx5LCBzaGFsbG93UmVmLCBzdG9wLCB0b1JhdywgdG9SZWYsIHRvUmVmcywgdHJhY2ssIHRyaWdnZXIsIHRyaWdnZXJSZWYsIHVucmVmIH07XG4iLCJpbXBvcnQgeyBwYXVzZVRyYWNraW5nLCByZXNldFRyYWNraW5nLCBpc1JlZiwgdG9SYXcsIGlzU2hhbGxvdyBhcyBpc1NoYWxsb3ckMSwgaXNSZWFjdGl2ZSwgUmVhY3RpdmVFZmZlY3QsIHJlZiwgcmVhY3RpdmUsIHNoYWxsb3dSZWFjdGl2ZSwgdHJpZ2dlciwgaXNQcm94eSwgc2hhbGxvd1JlYWRvbmx5LCB0cmFjaywgRWZmZWN0U2NvcGUsIG1hcmtSYXcsIHByb3h5UmVmcywgY29tcHV0ZWQgYXMgY29tcHV0ZWQkMSwgaXNSZWFkb25seSB9IGZyb20gJ0B2dWUvcmVhY3Rpdml0eSc7XG5leHBvcnQgeyBFZmZlY3RTY29wZSwgUmVhY3RpdmVFZmZlY3QsIGN1c3RvbVJlZiwgZWZmZWN0LCBlZmZlY3RTY29wZSwgZ2V0Q3VycmVudFNjb3BlLCBpc1Byb3h5LCBpc1JlYWN0aXZlLCBpc1JlYWRvbmx5LCBpc1JlZiwgaXNTaGFsbG93LCBtYXJrUmF3LCBvblNjb3BlRGlzcG9zZSwgcHJveHlSZWZzLCByZWFjdGl2ZSwgcmVhZG9ubHksIHJlZiwgc2hhbGxvd1JlYWN0aXZlLCBzaGFsbG93UmVhZG9ubHksIHNoYWxsb3dSZWYsIHN0b3AsIHRvUmF3LCB0b1JlZiwgdG9SZWZzLCB0cmlnZ2VyUmVmLCB1bnJlZiB9IGZyb20gJ0B2dWUvcmVhY3Rpdml0eSc7XG5pbXBvcnQgeyBpc1N0cmluZywgaXNGdW5jdGlvbiwgaXNQcm9taXNlLCBpc0FycmF5LCBOT09QLCBnZXRHbG9iYWxUaGlzLCBleHRlbmQsIEVNUFRZX09CSiwgdG9IYW5kbGVyS2V5LCB0b051bWJlciwgaHlwaGVuYXRlLCBjYW1lbGl6ZSwgaXNPbiwgaGFzT3duLCBpc01vZGVsTGlzdGVuZXIsIGhhc0NoYW5nZWQsIHJlbW92ZSwgaXNPYmplY3QsIGlzU2V0LCBpc01hcCwgaXNQbGFpbk9iamVjdCwgaW52b2tlQXJyYXlGbnMsIGRlZiwgaXNSZXNlcnZlZFByb3AsIEVNUFRZX0FSUiwgY2FwaXRhbGl6ZSwgdG9SYXdUeXBlLCBtYWtlTWFwLCBpc0J1aWx0SW5EaXJlY3RpdmUsIE5PLCBub3JtYWxpemVDbGFzcywgbm9ybWFsaXplU3R5bGUsIGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCB9IGZyb20gJ0B2dWUvc2hhcmVkJztcbmV4cG9ydCB7IGNhbWVsaXplLCBjYXBpdGFsaXplLCBub3JtYWxpemVDbGFzcywgbm9ybWFsaXplUHJvcHMsIG5vcm1hbGl6ZVN0eWxlLCB0b0Rpc3BsYXlTdHJpbmcsIHRvSGFuZGxlcktleSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuY29uc3Qgc3RhY2sgPSBbXTtcclxuZnVuY3Rpb24gcHVzaFdhcm5pbmdDb250ZXh0KHZub2RlKSB7XHJcbiAgICBzdGFjay5wdXNoKHZub2RlKTtcclxufVxyXG5mdW5jdGlvbiBwb3BXYXJuaW5nQ29udGV4dCgpIHtcclxuICAgIHN0YWNrLnBvcCgpO1xyXG59XHJcbmZ1bmN0aW9uIHdhcm4obXNnLCAuLi5hcmdzKSB7XHJcbiAgICAvLyBhdm9pZCBwcm9wcyBmb3JtYXR0aW5nIG9yIHdhcm4gaGFuZGxlciB0cmFja2luZyBkZXBzIHRoYXQgbWlnaHQgYmUgbXV0YXRlZFxyXG4gICAgLy8gZHVyaW5nIHBhdGNoLCBsZWFkaW5nIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cclxuICAgIHBhdXNlVHJhY2tpbmcoKTtcclxuICAgIGNvbnN0IGluc3RhbmNlID0gc3RhY2subGVuZ3RoID8gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0uY29tcG9uZW50IDogbnVsbDtcclxuICAgIGNvbnN0IGFwcFdhcm5IYW5kbGVyID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcud2FybkhhbmRsZXI7XHJcbiAgICBjb25zdCB0cmFjZSA9IGdldENvbXBvbmVudFRyYWNlKCk7XHJcbiAgICBpZiAoYXBwV2FybkhhbmRsZXIpIHtcclxuICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoYXBwV2FybkhhbmRsZXIsIGluc3RhbmNlLCAxMSAvKiBBUFBfV0FSTl9IQU5ETEVSICovLCBbXHJcbiAgICAgICAgICAgIG1zZyArIGFyZ3Muam9pbignJyksXHJcbiAgICAgICAgICAgIGluc3RhbmNlICYmIGluc3RhbmNlLnByb3h5LFxyXG4gICAgICAgICAgICB0cmFjZVxyXG4gICAgICAgICAgICAgICAgLm1hcCgoeyB2bm9kZSB9KSA9PiBgYXQgPCR7Zm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgdm5vZGUudHlwZSl9PmApXHJcbiAgICAgICAgICAgICAgICAuam9pbignXFxuJyksXHJcbiAgICAgICAgICAgIHRyYWNlXHJcbiAgICAgICAgXSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCB3YXJuQXJncyA9IFtgW1Z1ZSB3YXJuXTogJHttc2d9YCwgLi4uYXJnc107XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKHRyYWNlLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAvLyBhdm9pZCBzcGFtbWluZyBjb25zb2xlIGR1cmluZyB0ZXN0c1xyXG4gICAgICAgICAgICAhZmFsc2UpIHtcclxuICAgICAgICAgICAgd2FybkFyZ3MucHVzaChgXFxuYCwgLi4uZm9ybWF0VHJhY2UodHJhY2UpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS53YXJuKC4uLndhcm5BcmdzKTtcclxuICAgIH1cclxuICAgIHJlc2V0VHJhY2tpbmcoKTtcclxufVxyXG5mdW5jdGlvbiBnZXRDb21wb25lbnRUcmFjZSgpIHtcclxuICAgIGxldCBjdXJyZW50Vk5vZGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcclxuICAgIGlmICghY3VycmVudFZOb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgLy8gd2UgY2FuJ3QganVzdCB1c2UgdGhlIHN0YWNrIGJlY2F1c2UgaXQgd2lsbCBiZSBpbmNvbXBsZXRlIGR1cmluZyB1cGRhdGVzXHJcbiAgICAvLyB0aGF0IGRpZCBub3Qgc3RhcnQgZnJvbSB0aGUgcm9vdC4gUmUtY29uc3RydWN0IHRoZSBwYXJlbnQgY2hhaW4gdXNpbmdcclxuICAgIC8vIGluc3RhbmNlIHBhcmVudCBwb2ludGVycy5cclxuICAgIGNvbnN0IG5vcm1hbGl6ZWRTdGFjayA9IFtdO1xyXG4gICAgd2hpbGUgKGN1cnJlbnRWTm9kZSkge1xyXG4gICAgICAgIGNvbnN0IGxhc3QgPSBub3JtYWxpemVkU3RhY2tbMF07XHJcbiAgICAgICAgaWYgKGxhc3QgJiYgbGFzdC52bm9kZSA9PT0gY3VycmVudFZOb2RlKSB7XHJcbiAgICAgICAgICAgIGxhc3QucmVjdXJzZUNvdW50Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBub3JtYWxpemVkU3RhY2sucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB2bm9kZTogY3VycmVudFZOb2RlLFxyXG4gICAgICAgICAgICAgICAgcmVjdXJzZUNvdW50OiAwXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwYXJlbnRJbnN0YW5jZSA9IGN1cnJlbnRWTm9kZS5jb21wb25lbnQgJiYgY3VycmVudFZOb2RlLmNvbXBvbmVudC5wYXJlbnQ7XHJcbiAgICAgICAgY3VycmVudFZOb2RlID0gcGFyZW50SW5zdGFuY2UgJiYgcGFyZW50SW5zdGFuY2Uudm5vZGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbm9ybWFsaXplZFN0YWNrO1xyXG59XHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmZ1bmN0aW9uIGZvcm1hdFRyYWNlKHRyYWNlKSB7XHJcbiAgICBjb25zdCBsb2dzID0gW107XHJcbiAgICB0cmFjZS5mb3JFYWNoKChlbnRyeSwgaSkgPT4ge1xyXG4gICAgICAgIGxvZ3MucHVzaCguLi4oaSA9PT0gMCA/IFtdIDogW2BcXG5gXSksIC4uLmZvcm1hdFRyYWNlRW50cnkoZW50cnkpKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGxvZ3M7XHJcbn1cclxuZnVuY3Rpb24gZm9ybWF0VHJhY2VFbnRyeSh7IHZub2RlLCByZWN1cnNlQ291bnQgfSkge1xyXG4gICAgY29uc3QgcG9zdGZpeCA9IHJlY3Vyc2VDb3VudCA+IDAgPyBgLi4uICgke3JlY3Vyc2VDb3VudH0gcmVjdXJzaXZlIGNhbGxzKWAgOiBgYDtcclxuICAgIGNvbnN0IGlzUm9vdCA9IHZub2RlLmNvbXBvbmVudCA/IHZub2RlLmNvbXBvbmVudC5wYXJlbnQgPT0gbnVsbCA6IGZhbHNlO1xyXG4gICAgY29uc3Qgb3BlbiA9IGAgYXQgPCR7Zm9ybWF0Q29tcG9uZW50TmFtZSh2bm9kZS5jb21wb25lbnQsIHZub2RlLnR5cGUsIGlzUm9vdCl9YDtcclxuICAgIGNvbnN0IGNsb3NlID0gYD5gICsgcG9zdGZpeDtcclxuICAgIHJldHVybiB2bm9kZS5wcm9wc1xyXG4gICAgICAgID8gW29wZW4sIC4uLmZvcm1hdFByb3BzKHZub2RlLnByb3BzKSwgY2xvc2VdXHJcbiAgICAgICAgOiBbb3BlbiArIGNsb3NlXTtcclxufVxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBmb3JtYXRQcm9wcyhwcm9wcykge1xyXG4gICAgY29uc3QgcmVzID0gW107XHJcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvcHMpO1xyXG4gICAga2V5cy5zbGljZSgwLCAzKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgcmVzLnB1c2goLi4uZm9ybWF0UHJvcChrZXksIHByb3BzW2tleV0pKTtcclxuICAgIH0pO1xyXG4gICAgaWYgKGtleXMubGVuZ3RoID4gMykge1xyXG4gICAgICAgIHJlcy5wdXNoKGAgLi4uYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmZ1bmN0aW9uIGZvcm1hdFByb3Aoa2V5LCB2YWx1ZSwgcmF3KSB7XHJcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09JHt2YWx1ZX1gXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcclxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fFxyXG4gICAgICAgIHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT0ke3ZhbHVlfWBdO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNSZWYodmFsdWUpKSB7XHJcbiAgICAgICAgdmFsdWUgPSBmb3JtYXRQcm9wKGtleSwgdG9SYXcodmFsdWUudmFsdWUpLCB0cnVlKTtcclxuICAgICAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT1SZWY8YCwgdmFsdWUsIGA+YF07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBbYCR7a2V5fT1mbiR7dmFsdWUubmFtZSA/IGA8JHt2YWx1ZS5uYW1lfT5gIDogYGB9YF07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT1gLCB2YWx1ZV07XHJcbiAgICB9XHJcbn1cblxuY29uc3QgRXJyb3JUeXBlU3RyaW5ncyA9IHtcclxuICAgIFtcInNwXCIgLyogU0VSVkVSX1BSRUZFVENIICovXTogJ3NlcnZlclByZWZldGNoIGhvb2snLFxyXG4gICAgW1wiYmNcIiAvKiBCRUZPUkVfQ1JFQVRFICovXTogJ2JlZm9yZUNyZWF0ZSBob29rJyxcclxuICAgIFtcImNcIiAvKiBDUkVBVEVEICovXTogJ2NyZWF0ZWQgaG9vaycsXHJcbiAgICBbXCJibVwiIC8qIEJFRk9SRV9NT1VOVCAqL106ICdiZWZvcmVNb3VudCBob29rJyxcclxuICAgIFtcIm1cIiAvKiBNT1VOVEVEICovXTogJ21vdW50ZWQgaG9vaycsXHJcbiAgICBbXCJidVwiIC8qIEJFRk9SRV9VUERBVEUgKi9dOiAnYmVmb3JlVXBkYXRlIGhvb2snLFxyXG4gICAgW1widVwiIC8qIFVQREFURUQgKi9dOiAndXBkYXRlZCcsXHJcbiAgICBbXCJidW1cIiAvKiBCRUZPUkVfVU5NT1VOVCAqL106ICdiZWZvcmVVbm1vdW50IGhvb2snLFxyXG4gICAgW1widW1cIiAvKiBVTk1PVU5URUQgKi9dOiAndW5tb3VudGVkIGhvb2snLFxyXG4gICAgW1wiYVwiIC8qIEFDVElWQVRFRCAqL106ICdhY3RpdmF0ZWQgaG9vaycsXHJcbiAgICBbXCJkYVwiIC8qIERFQUNUSVZBVEVEICovXTogJ2RlYWN0aXZhdGVkIGhvb2snLFxyXG4gICAgW1wiZWNcIiAvKiBFUlJPUl9DQVBUVVJFRCAqL106ICdlcnJvckNhcHR1cmVkIGhvb2snLFxyXG4gICAgW1wicnRjXCIgLyogUkVOREVSX1RSQUNLRUQgKi9dOiAncmVuZGVyVHJhY2tlZCBob29rJyxcclxuICAgIFtcInJ0Z1wiIC8qIFJFTkRFUl9UUklHR0VSRUQgKi9dOiAncmVuZGVyVHJpZ2dlcmVkIGhvb2snLFxyXG4gICAgWzAgLyogU0VUVVBfRlVOQ1RJT04gKi9dOiAnc2V0dXAgZnVuY3Rpb24nLFxyXG4gICAgWzEgLyogUkVOREVSX0ZVTkNUSU9OICovXTogJ3JlbmRlciBmdW5jdGlvbicsXHJcbiAgICBbMiAvKiBXQVRDSF9HRVRURVIgKi9dOiAnd2F0Y2hlciBnZXR0ZXInLFxyXG4gICAgWzMgLyogV0FUQ0hfQ0FMTEJBQ0sgKi9dOiAnd2F0Y2hlciBjYWxsYmFjaycsXHJcbiAgICBbNCAvKiBXQVRDSF9DTEVBTlVQICovXTogJ3dhdGNoZXIgY2xlYW51cCBmdW5jdGlvbicsXHJcbiAgICBbNSAvKiBOQVRJVkVfRVZFTlRfSEFORExFUiAqL106ICduYXRpdmUgZXZlbnQgaGFuZGxlcicsXHJcbiAgICBbNiAvKiBDT01QT05FTlRfRVZFTlRfSEFORExFUiAqL106ICdjb21wb25lbnQgZXZlbnQgaGFuZGxlcicsXHJcbiAgICBbNyAvKiBWTk9ERV9IT09LICovXTogJ3Zub2RlIGhvb2snLFxyXG4gICAgWzggLyogRElSRUNUSVZFX0hPT0sgKi9dOiAnZGlyZWN0aXZlIGhvb2snLFxyXG4gICAgWzkgLyogVFJBTlNJVElPTl9IT09LICovXTogJ3RyYW5zaXRpb24gaG9vaycsXHJcbiAgICBbMTAgLyogQVBQX0VSUk9SX0hBTkRMRVIgKi9dOiAnYXBwIGVycm9ySGFuZGxlcicsXHJcbiAgICBbMTEgLyogQVBQX1dBUk5fSEFORExFUiAqL106ICdhcHAgd2FybkhhbmRsZXInLFxyXG4gICAgWzEyIC8qIEZVTkNUSU9OX1JFRiAqL106ICdyZWYgZnVuY3Rpb24nLFxyXG4gICAgWzEzIC8qIEFTWU5DX0NPTVBPTkVOVF9MT0FERVIgKi9dOiAnYXN5bmMgY29tcG9uZW50IGxvYWRlcicsXHJcbiAgICBbMTQgLyogU0NIRURVTEVSICovXTogJ3NjaGVkdWxlciBmbHVzaC4gVGhpcyBpcyBsaWtlbHkgYSBWdWUgaW50ZXJuYWxzIGJ1Zy4gJyArXHJcbiAgICAgICAgJ1BsZWFzZSBvcGVuIGFuIGlzc3VlIGF0IGh0dHBzOi8vbmV3LWlzc3VlLnZ1ZWpzLm9yZy8/cmVwbz12dWVqcy9jb3JlJ1xyXG59O1xyXG5mdW5jdGlvbiBjYWxsV2l0aEVycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKSB7XHJcbiAgICBsZXQgcmVzO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXMgPSBhcmdzID8gZm4oLi4uYXJncykgOiBmbigpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpIHtcclxuICAgIGlmIChpc0Z1bmN0aW9uKGZuKSkge1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IGNhbGxXaXRoRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpO1xyXG4gICAgICAgIGlmIChyZXMgJiYgaXNQcm9taXNlKHJlcykpIHtcclxuICAgICAgICAgICAgcmVzLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCB0eXBlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YWx1ZXMucHVzaChjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhmbltpXSwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZXM7XHJcbn1cclxuZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgdHlwZSwgdGhyb3dJbkRldiA9IHRydWUpIHtcclxuICAgIGNvbnN0IGNvbnRleHRWTm9kZSA9IGluc3RhbmNlID8gaW5zdGFuY2Uudm5vZGUgOiBudWxsO1xyXG4gICAgaWYgKGluc3RhbmNlKSB7XHJcbiAgICAgICAgbGV0IGN1ciA9IGluc3RhbmNlLnBhcmVudDtcclxuICAgICAgICAvLyB0aGUgZXhwb3NlZCBpbnN0YW5jZSBpcyB0aGUgcmVuZGVyIHByb3h5IHRvIGtlZXAgaXQgY29uc2lzdGVudCB3aXRoIDIueFxyXG4gICAgICAgIGNvbnN0IGV4cG9zZWRJbnN0YW5jZSA9IGluc3RhbmNlLnByb3h5O1xyXG4gICAgICAgIC8vIGluIHByb2R1Y3Rpb24gdGhlIGhvb2sgcmVjZWl2ZXMgb25seSB0aGUgZXJyb3IgY29kZVxyXG4gICAgICAgIGNvbnN0IGVycm9ySW5mbyA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IEVycm9yVHlwZVN0cmluZ3NbdHlwZV0gOiB0eXBlO1xyXG4gICAgICAgIHdoaWxlIChjdXIpIHtcclxuICAgICAgICAgICAgY29uc3QgZXJyb3JDYXB0dXJlZEhvb2tzID0gY3VyLmVjO1xyXG4gICAgICAgICAgICBpZiAoZXJyb3JDYXB0dXJlZEhvb2tzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVycm9yQ2FwdHVyZWRIb29rcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvckNhcHR1cmVkSG9va3NbaV0oZXJyLCBleHBvc2VkSW5zdGFuY2UsIGVycm9ySW5mbykgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VyID0gY3VyLnBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYXBwLWxldmVsIGhhbmRsaW5nXHJcbiAgICAgICAgY29uc3QgYXBwRXJyb3JIYW5kbGVyID0gaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcuZXJyb3JIYW5kbGVyO1xyXG4gICAgICAgIGlmIChhcHBFcnJvckhhbmRsZXIpIHtcclxuICAgICAgICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKGFwcEVycm9ySGFuZGxlciwgbnVsbCwgMTAgLyogQVBQX0VSUk9SX0hBTkRMRVIgKi8sIFtlcnIsIGV4cG9zZWRJbnN0YW5jZSwgZXJyb3JJbmZvXSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsb2dFcnJvcihlcnIsIHR5cGUsIGNvbnRleHRWTm9kZSwgdGhyb3dJbkRldik7XHJcbn1cclxuZnVuY3Rpb24gbG9nRXJyb3IoZXJyLCB0eXBlLCBjb250ZXh0Vk5vZGUsIHRocm93SW5EZXYgPSB0cnVlKSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgY29uc3QgaW5mbyA9IEVycm9yVHlwZVN0cmluZ3NbdHlwZV07XHJcbiAgICAgICAgaWYgKGNvbnRleHRWTm9kZSkge1xyXG4gICAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQoY29udGV4dFZOb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2FybihgVW5oYW5kbGVkIGVycm9yJHtpbmZvID8gYCBkdXJpbmcgZXhlY3V0aW9uIG9mICR7aW5mb31gIDogYGB9YCk7XHJcbiAgICAgICAgaWYgKGNvbnRleHRWTm9kZSkge1xyXG4gICAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjcmFzaCBpbiBkZXYgYnkgZGVmYXVsdCBzbyBpdCdzIG1vcmUgbm90aWNlYWJsZVxyXG4gICAgICAgIGlmICh0aHJvd0luRGV2KSB7XHJcbiAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyByZWNvdmVyIGluIHByb2QgdG8gcmVkdWNlIHRoZSBpbXBhY3Qgb24gZW5kLXVzZXJcclxuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICB9XHJcbn1cblxubGV0IGlzRmx1c2hpbmcgPSBmYWxzZTtcclxubGV0IGlzRmx1c2hQZW5kaW5nID0gZmFsc2U7XHJcbmNvbnN0IHF1ZXVlID0gW107XHJcbmxldCBmbHVzaEluZGV4ID0gMDtcclxuY29uc3QgcGVuZGluZ1ByZUZsdXNoQ2JzID0gW107XHJcbmxldCBhY3RpdmVQcmVGbHVzaENicyA9IG51bGw7XHJcbmxldCBwcmVGbHVzaEluZGV4ID0gMDtcclxuY29uc3QgcGVuZGluZ1Bvc3RGbHVzaENicyA9IFtdO1xyXG5sZXQgYWN0aXZlUG9zdEZsdXNoQ2JzID0gbnVsbDtcclxubGV0IHBvc3RGbHVzaEluZGV4ID0gMDtcclxuY29uc3QgcmVzb2x2ZWRQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbmxldCBjdXJyZW50Rmx1c2hQcm9taXNlID0gbnVsbDtcclxubGV0IGN1cnJlbnRQcmVGbHVzaFBhcmVudEpvYiA9IG51bGw7XHJcbmNvbnN0IFJFQ1VSU0lPTl9MSU1JVCA9IDEwMDtcclxuZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcclxuICAgIGNvbnN0IHAgPSBjdXJyZW50Rmx1c2hQcm9taXNlIHx8IHJlc29sdmVkUHJvbWlzZTtcclxuICAgIHJldHVybiBmbiA/IHAudGhlbih0aGlzID8gZm4uYmluZCh0aGlzKSA6IGZuKSA6IHA7XHJcbn1cclxuLy8gIzI3NjhcclxuLy8gVXNlIGJpbmFyeS1zZWFyY2ggdG8gZmluZCBhIHN1aXRhYmxlIHBvc2l0aW9uIGluIHRoZSBxdWV1ZSxcclxuLy8gc28gdGhhdCB0aGUgcXVldWUgbWFpbnRhaW5zIHRoZSBpbmNyZWFzaW5nIG9yZGVyIG9mIGpvYidzIGlkLFxyXG4vLyB3aGljaCBjYW4gcHJldmVudCB0aGUgam9iIGZyb20gYmVpbmcgc2tpcHBlZCBhbmQgYWxzbyBjYW4gYXZvaWQgcmVwZWF0ZWQgcGF0Y2hpbmcuXHJcbmZ1bmN0aW9uIGZpbmRJbnNlcnRpb25JbmRleChpZCkge1xyXG4gICAgLy8gdGhlIHN0YXJ0IGluZGV4IHNob3VsZCBiZSBgZmx1c2hJbmRleCArIDFgXHJcbiAgICBsZXQgc3RhcnQgPSBmbHVzaEluZGV4ICsgMTtcclxuICAgIGxldCBlbmQgPSBxdWV1ZS5sZW5ndGg7XHJcbiAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcclxuICAgICAgICBjb25zdCBtaWRkbGUgPSAoc3RhcnQgKyBlbmQpID4+PiAxO1xyXG4gICAgICAgIGNvbnN0IG1pZGRsZUpvYklkID0gZ2V0SWQocXVldWVbbWlkZGxlXSk7XHJcbiAgICAgICAgbWlkZGxlSm9iSWQgPCBpZCA/IChzdGFydCA9IG1pZGRsZSArIDEpIDogKGVuZCA9IG1pZGRsZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3RhcnQ7XHJcbn1cclxuZnVuY3Rpb24gcXVldWVKb2Ioam9iKSB7XHJcbiAgICAvLyB0aGUgZGVkdXBlIHNlYXJjaCB1c2VzIHRoZSBzdGFydEluZGV4IGFyZ3VtZW50IG9mIEFycmF5LmluY2x1ZGVzKClcclxuICAgIC8vIGJ5IGRlZmF1bHQgdGhlIHNlYXJjaCBpbmRleCBpbmNsdWRlcyB0aGUgY3VycmVudCBqb2IgdGhhdCBpcyBiZWluZyBydW5cclxuICAgIC8vIHNvIGl0IGNhbm5vdCByZWN1cnNpdmVseSB0cmlnZ2VyIGl0c2VsZiBhZ2Fpbi5cclxuICAgIC8vIGlmIHRoZSBqb2IgaXMgYSB3YXRjaCgpIGNhbGxiYWNrLCB0aGUgc2VhcmNoIHdpbGwgc3RhcnQgd2l0aCBhICsxIGluZGV4IHRvXHJcbiAgICAvLyBhbGxvdyBpdCByZWN1cnNpdmVseSB0cmlnZ2VyIGl0c2VsZiAtIGl0IGlzIHRoZSB1c2VyJ3MgcmVzcG9uc2liaWxpdHkgdG9cclxuICAgIC8vIGVuc3VyZSBpdCBkb2Vzbid0IGVuZCB1cCBpbiBhbiBpbmZpbml0ZSBsb29wLlxyXG4gICAgaWYgKCghcXVldWUubGVuZ3RoIHx8XHJcbiAgICAgICAgIXF1ZXVlLmluY2x1ZGVzKGpvYiwgaXNGbHVzaGluZyAmJiBqb2IuYWxsb3dSZWN1cnNlID8gZmx1c2hJbmRleCArIDEgOiBmbHVzaEluZGV4KSkgJiZcclxuICAgICAgICBqb2IgIT09IGN1cnJlbnRQcmVGbHVzaFBhcmVudEpvYikge1xyXG4gICAgICAgIGlmIChqb2IuaWQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGpvYik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBxdWV1ZS5zcGxpY2UoZmluZEluc2VydGlvbkluZGV4KGpvYi5pZCksIDAsIGpvYik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHF1ZXVlRmx1c2goKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBxdWV1ZUZsdXNoKCkge1xyXG4gICAgaWYgKCFpc0ZsdXNoaW5nICYmICFpc0ZsdXNoUGVuZGluZykge1xyXG4gICAgICAgIGlzRmx1c2hQZW5kaW5nID0gdHJ1ZTtcclxuICAgICAgICBjdXJyZW50Rmx1c2hQcm9taXNlID0gcmVzb2x2ZWRQcm9taXNlLnRoZW4oZmx1c2hKb2JzKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpbnZhbGlkYXRlSm9iKGpvYikge1xyXG4gICAgY29uc3QgaSA9IHF1ZXVlLmluZGV4T2Yoam9iKTtcclxuICAgIGlmIChpID4gZmx1c2hJbmRleCkge1xyXG4gICAgICAgIHF1ZXVlLnNwbGljZShpLCAxKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBxdWV1ZUNiKGNiLCBhY3RpdmVRdWV1ZSwgcGVuZGluZ1F1ZXVlLCBpbmRleCkge1xyXG4gICAgaWYgKCFpc0FycmF5KGNiKSkge1xyXG4gICAgICAgIGlmICghYWN0aXZlUXVldWUgfHxcclxuICAgICAgICAgICAgIWFjdGl2ZVF1ZXVlLmluY2x1ZGVzKGNiLCBjYi5hbGxvd1JlY3Vyc2UgPyBpbmRleCArIDEgOiBpbmRleCkpIHtcclxuICAgICAgICAgICAgcGVuZGluZ1F1ZXVlLnB1c2goY2IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGlmIGNiIGlzIGFuIGFycmF5LCBpdCBpcyBhIGNvbXBvbmVudCBsaWZlY3ljbGUgaG9vayB3aGljaCBjYW4gb25seSBiZVxyXG4gICAgICAgIC8vIHRyaWdnZXJlZCBieSBhIGpvYiwgd2hpY2ggaXMgYWxyZWFkeSBkZWR1cGVkIGluIHRoZSBtYWluIHF1ZXVlLCBzb1xyXG4gICAgICAgIC8vIHdlIGNhbiBza2lwIGR1cGxpY2F0ZSBjaGVjayBoZXJlIHRvIGltcHJvdmUgcGVyZlxyXG4gICAgICAgIHBlbmRpbmdRdWV1ZS5wdXNoKC4uLmNiKTtcclxuICAgIH1cclxuICAgIHF1ZXVlRmx1c2goKTtcclxufVxyXG5mdW5jdGlvbiBxdWV1ZVByZUZsdXNoQ2IoY2IpIHtcclxuICAgIHF1ZXVlQ2IoY2IsIGFjdGl2ZVByZUZsdXNoQ2JzLCBwZW5kaW5nUHJlRmx1c2hDYnMsIHByZUZsdXNoSW5kZXgpO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXVlUG9zdEZsdXNoQ2IoY2IpIHtcclxuICAgIHF1ZXVlQ2IoY2IsIGFjdGl2ZVBvc3RGbHVzaENicywgcGVuZGluZ1Bvc3RGbHVzaENicywgcG9zdEZsdXNoSW5kZXgpO1xyXG59XHJcbmZ1bmN0aW9uIGZsdXNoUHJlRmx1c2hDYnMoc2VlbiwgcGFyZW50Sm9iID0gbnVsbCkge1xyXG4gICAgaWYgKHBlbmRpbmdQcmVGbHVzaENicy5sZW5ndGgpIHtcclxuICAgICAgICBjdXJyZW50UHJlRmx1c2hQYXJlbnRKb2IgPSBwYXJlbnRKb2I7XHJcbiAgICAgICAgYWN0aXZlUHJlRmx1c2hDYnMgPSBbLi4ubmV3IFNldChwZW5kaW5nUHJlRmx1c2hDYnMpXTtcclxuICAgICAgICBwZW5kaW5nUHJlRmx1c2hDYnMubGVuZ3RoID0gMDtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHNlZW4gPSBzZWVuIHx8IG5ldyBNYXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChwcmVGbHVzaEluZGV4ID0gMDsgcHJlRmx1c2hJbmRleCA8IGFjdGl2ZVByZUZsdXNoQ2JzLmxlbmd0aDsgcHJlRmx1c2hJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBhY3RpdmVQcmVGbHVzaENic1twcmVGbHVzaEluZGV4XSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjdGl2ZVByZUZsdXNoQ2JzW3ByZUZsdXNoSW5kZXhdKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFjdGl2ZVByZUZsdXNoQ2JzID0gbnVsbDtcclxuICAgICAgICBwcmVGbHVzaEluZGV4ID0gMDtcclxuICAgICAgICBjdXJyZW50UHJlRmx1c2hQYXJlbnRKb2IgPSBudWxsO1xyXG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGZsdXNoIHVudGlsIGl0IGRyYWluc1xyXG4gICAgICAgIGZsdXNoUHJlRmx1c2hDYnMoc2VlbiwgcGFyZW50Sm9iKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBmbHVzaFBvc3RGbHVzaENicyhzZWVuKSB7XHJcbiAgICBpZiAocGVuZGluZ1Bvc3RGbHVzaENicy5sZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBkZWR1cGVkID0gWy4uLm5ldyBTZXQocGVuZGluZ1Bvc3RGbHVzaENicyldO1xyXG4gICAgICAgIHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoID0gMDtcclxuICAgICAgICAvLyAjMTk0NyBhbHJlYWR5IGhhcyBhY3RpdmUgcXVldWUsIG5lc3RlZCBmbHVzaFBvc3RGbHVzaENicyBjYWxsXHJcbiAgICAgICAgaWYgKGFjdGl2ZVBvc3RGbHVzaENicykge1xyXG4gICAgICAgICAgICBhY3RpdmVQb3N0Rmx1c2hDYnMucHVzaCguLi5kZWR1cGVkKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhY3RpdmVQb3N0Rmx1c2hDYnMgPSBkZWR1cGVkO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgc2VlbiA9IHNlZW4gfHwgbmV3IE1hcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhY3RpdmVQb3N0Rmx1c2hDYnMuc29ydCgoYSwgYikgPT4gZ2V0SWQoYSkgLSBnZXRJZChiKSk7XHJcbiAgICAgICAgZm9yIChwb3N0Rmx1c2hJbmRleCA9IDA7IHBvc3RGbHVzaEluZGV4IDwgYWN0aXZlUG9zdEZsdXNoQ2JzLmxlbmd0aDsgcG9zdEZsdXNoSW5kZXgrKykge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2VlbiwgYWN0aXZlUG9zdEZsdXNoQ2JzW3Bvc3RGbHVzaEluZGV4XSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjdGl2ZVBvc3RGbHVzaENic1twb3N0Rmx1c2hJbmRleF0oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzID0gbnVsbDtcclxuICAgICAgICBwb3N0Rmx1c2hJbmRleCA9IDA7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgZ2V0SWQgPSAoam9iKSA9PiBqb2IuaWQgPT0gbnVsbCA/IEluZmluaXR5IDogam9iLmlkO1xyXG5mdW5jdGlvbiBmbHVzaEpvYnMoc2Vlbikge1xyXG4gICAgaXNGbHVzaFBlbmRpbmcgPSBmYWxzZTtcclxuICAgIGlzRmx1c2hpbmcgPSB0cnVlO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHNlZW4gPSBzZWVuIHx8IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIGZsdXNoUHJlRmx1c2hDYnMoc2Vlbik7XHJcbiAgICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cclxuICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxyXG4gICAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xyXG4gICAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkIHNvIGl0cyByZW5kZXIgZWZmZWN0IHdpbGwgaGF2ZSBzbWFsbGVyXHJcbiAgICAvLyAgICBwcmlvcml0eSBudW1iZXIpXHJcbiAgICAvLyAyLiBJZiBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHVwZGF0ZSxcclxuICAgIC8vICAgIGl0cyB1cGRhdGUgY2FuIGJlIHNraXBwZWQuXHJcbiAgICBxdWV1ZS5zb3J0KChhLCBiKSA9PiBnZXRJZChhKSAtIGdldElkKGIpKTtcclxuICAgIC8vIGNvbmRpdGlvbmFsIHVzYWdlIG9mIGNoZWNrUmVjdXJzaXZlVXBkYXRlIG11c3QgYmUgZGV0ZXJtaW5lZCBvdXQgb2ZcclxuICAgIC8vIHRyeSAuLi4gY2F0Y2ggYmxvY2sgc2luY2UgUm9sbHVwIGJ5IGRlZmF1bHQgZGUtb3B0aW1pemVzIHRyZWVzaGFraW5nXHJcbiAgICAvLyBpbnNpZGUgdHJ5LWNhdGNoLiBUaGlzIGNhbiBsZWF2ZSBhbGwgd2FybmluZyBjb2RlIHVuc2hha2VkLiBBbHRob3VnaFxyXG4gICAgLy8gdGhleSB3b3VsZCBnZXQgZXZlbnR1YWxseSBzaGFrZW4gYnkgYSBtaW5pZmllciBsaWtlIHRlcnNlciwgc29tZSBtaW5pZmllcnNcclxuICAgIC8vIHdvdWxkIGZhaWwgdG8gZG8gdGhhdCAoZS5nLiBodHRwczovL2dpdGh1Yi5jb20vZXZhbncvZXNidWlsZC9pc3N1ZXMvMTYxMClcclxuICAgIGNvbnN0IGNoZWNrID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgPyAoam9iKSA9PiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2Vlbiwgam9iKVxyXG4gICAgICAgIDogTk9PUDtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgZm9yIChmbHVzaEluZGV4ID0gMDsgZmx1c2hJbmRleCA8IHF1ZXVlLmxlbmd0aDsgZmx1c2hJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGpvYiA9IHF1ZXVlW2ZsdXNoSW5kZXhdO1xyXG4gICAgICAgICAgICBpZiAoam9iICYmIGpvYi5hY3RpdmUgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNoZWNrKGpvYikpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGBydW5uaW5nOmAsIGpvYi5pZClcclxuICAgICAgICAgICAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhqb2IsIG51bGwsIDE0IC8qIFNDSEVEVUxFUiAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICBmbHVzaEluZGV4ID0gMDtcclxuICAgICAgICBxdWV1ZS5sZW5ndGggPSAwO1xyXG4gICAgICAgIGZsdXNoUG9zdEZsdXNoQ2JzKHNlZW4pO1xyXG4gICAgICAgIGlzRmx1c2hpbmcgPSBmYWxzZTtcclxuICAgICAgICBjdXJyZW50Rmx1c2hQcm9taXNlID0gbnVsbDtcclxuICAgICAgICAvLyBzb21lIHBvc3RGbHVzaENiIHF1ZXVlZCBqb2JzIVxyXG4gICAgICAgIC8vIGtlZXAgZmx1c2hpbmcgdW50aWwgaXQgZHJhaW5zLlxyXG4gICAgICAgIGlmIChxdWV1ZS5sZW5ndGggfHxcclxuICAgICAgICAgICAgcGVuZGluZ1ByZUZsdXNoQ2JzLmxlbmd0aCB8fFxyXG4gICAgICAgICAgICBwZW5kaW5nUG9zdEZsdXNoQ2JzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBmbHVzaEpvYnMoc2Vlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBmbikge1xyXG4gICAgaWYgKCFzZWVuLmhhcyhmbikpIHtcclxuICAgICAgICBzZWVuLnNldChmbiwgMSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBjb3VudCA9IHNlZW4uZ2V0KGZuKTtcclxuICAgICAgICBpZiAoY291bnQgPiBSRUNVUlNJT05fTElNSVQpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBmbi5vd25lckluc3RhbmNlO1xyXG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnROYW1lID0gaW5zdGFuY2UgJiYgZ2V0Q29tcG9uZW50TmFtZShpbnN0YW5jZS50eXBlKTtcclxuICAgICAgICAgICAgd2FybihgTWF4aW11bSByZWN1cnNpdmUgdXBkYXRlcyBleGNlZWRlZCR7Y29tcG9uZW50TmFtZSA/IGAgaW4gY29tcG9uZW50IDwke2NvbXBvbmVudE5hbWV9PmAgOiBgYH0uIGAgK1xyXG4gICAgICAgICAgICAgICAgYFRoaXMgbWVhbnMgeW91IGhhdmUgYSByZWFjdGl2ZSBlZmZlY3QgdGhhdCBpcyBtdXRhdGluZyBpdHMgb3duIGAgK1xyXG4gICAgICAgICAgICAgICAgYGRlcGVuZGVuY2llcyBhbmQgdGh1cyByZWN1cnNpdmVseSB0cmlnZ2VyaW5nIGl0c2VsZi4gUG9zc2libGUgc291cmNlcyBgICtcclxuICAgICAgICAgICAgICAgIGBpbmNsdWRlIGNvbXBvbmVudCB0ZW1wbGF0ZSwgcmVuZGVyIGZ1bmN0aW9uLCB1cGRhdGVkIGhvb2sgb3IgYCArXHJcbiAgICAgICAgICAgICAgICBgd2F0Y2hlciBzb3VyY2UgZnVuY3Rpb24uYCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2Vlbi5zZXQoZm4sIGNvdW50ICsgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xyXG5sZXQgaXNIbXJVcGRhdGluZyA9IGZhbHNlO1xyXG5jb25zdCBobXJEaXJ0eUNvbXBvbmVudHMgPSBuZXcgU2V0KCk7XHJcbi8vIEV4cG9zZSB0aGUgSE1SIHJ1bnRpbWUgb24gdGhlIGdsb2JhbCBvYmplY3RcclxuLy8gVGhpcyBtYWtlcyBpdCBlbnRpcmVseSB0cmVlLXNoYWthYmxlIHdpdGhvdXQgcG9sbHV0aW5nIHRoZSBleHBvcnRzIGFuZCBtYWtlc1xyXG4vLyBpdCBlYXNpZXIgdG8gYmUgdXNlZCBpbiB0b29saW5ncyBsaWtlIHZ1ZS1sb2FkZXJcclxuLy8gTm90ZTogZm9yIGEgY29tcG9uZW50IHRvIGJlIGVsaWdpYmxlIGZvciBITVIgaXQgYWxzbyBuZWVkcyB0aGUgX19obXJJZCBvcHRpb25cclxuLy8gdG8gYmUgc2V0IHNvIHRoYXQgaXRzIGluc3RhbmNlcyBjYW4gYmUgcmVnaXN0ZXJlZCAvIHJlbW92ZWQuXHJcbmlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9ITVJfUlVOVElNRV9fID0ge1xyXG4gICAgICAgIGNyZWF0ZVJlY29yZDogdHJ5V3JhcChjcmVhdGVSZWNvcmQpLFxyXG4gICAgICAgIHJlcmVuZGVyOiB0cnlXcmFwKHJlcmVuZGVyKSxcclxuICAgICAgICByZWxvYWQ6IHRyeVdyYXAocmVsb2FkKVxyXG4gICAgfTtcclxufVxyXG5jb25zdCBtYXAgPSBuZXcgTWFwKCk7XHJcbmZ1bmN0aW9uIHJlZ2lzdGVySE1SKGluc3RhbmNlKSB7XHJcbiAgICBjb25zdCBpZCA9IGluc3RhbmNlLnR5cGUuX19obXJJZDtcclxuICAgIGxldCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcclxuICAgIGlmICghcmVjb3JkKSB7XHJcbiAgICAgICAgY3JlYXRlUmVjb3JkKGlkLCBpbnN0YW5jZS50eXBlKTtcclxuICAgICAgICByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcclxuICAgIH1cclxuICAgIHJlY29yZC5pbnN0YW5jZXMuYWRkKGluc3RhbmNlKTtcclxufVxyXG5mdW5jdGlvbiB1bnJlZ2lzdGVySE1SKGluc3RhbmNlKSB7XHJcbiAgICBtYXAuZ2V0KGluc3RhbmNlLnR5cGUuX19obXJJZCkuaW5zdGFuY2VzLmRlbGV0ZShpbnN0YW5jZSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVjb3JkKGlkLCBpbml0aWFsRGVmKSB7XHJcbiAgICBpZiAobWFwLmhhcyhpZCkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBtYXAuc2V0KGlkLCB7XHJcbiAgICAgICAgaW5pdGlhbERlZjogbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoaW5pdGlhbERlZiksXHJcbiAgICAgICAgaW5zdGFuY2VzOiBuZXcgU2V0KClcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoY29tcG9uZW50KSB7XHJcbiAgICByZXR1cm4gaXNDbGFzc0NvbXBvbmVudChjb21wb25lbnQpID8gY29tcG9uZW50Ll9fdmNjT3B0cyA6IGNvbXBvbmVudDtcclxufVxyXG5mdW5jdGlvbiByZXJlbmRlcihpZCwgbmV3UmVuZGVyKSB7XHJcbiAgICBjb25zdCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcclxuICAgIGlmICghcmVjb3JkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gdXBkYXRlIGluaXRpYWwgcmVjb3JkIChmb3Igbm90LXlldC1yZW5kZXJlZCBjb21wb25lbnQpXHJcbiAgICByZWNvcmQuaW5pdGlhbERlZi5yZW5kZXIgPSBuZXdSZW5kZXI7XHJcbiAgICBbLi4ucmVjb3JkLmluc3RhbmNlc10uZm9yRWFjaChpbnN0YW5jZSA9PiB7XHJcbiAgICAgICAgaWYgKG5ld1JlbmRlcikge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5yZW5kZXIgPSBuZXdSZW5kZXI7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGluc3RhbmNlLnR5cGUpLnJlbmRlciA9IG5ld1JlbmRlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5zdGFuY2UucmVuZGVyQ2FjaGUgPSBbXTtcclxuICAgICAgICAvLyB0aGlzIGZsYWcgZm9yY2VzIGNoaWxkIGNvbXBvbmVudHMgd2l0aCBzbG90IGNvbnRlbnQgdG8gdXBkYXRlXHJcbiAgICAgICAgaXNIbXJVcGRhdGluZyA9IHRydWU7XHJcbiAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XHJcbiAgICAgICAgaXNIbXJVcGRhdGluZyA9IGZhbHNlO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcmVsb2FkKGlkLCBuZXdDb21wKSB7XHJcbiAgICBjb25zdCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcclxuICAgIGlmICghcmVjb3JkKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIG5ld0NvbXAgPSBub3JtYWxpemVDbGFzc0NvbXBvbmVudChuZXdDb21wKTtcclxuICAgIC8vIHVwZGF0ZSBpbml0aWFsIGRlZiAoZm9yIG5vdC15ZXQtcmVuZGVyZWQgY29tcG9uZW50cylcclxuICAgIHVwZGF0ZUNvbXBvbmVudERlZihyZWNvcmQuaW5pdGlhbERlZiwgbmV3Q29tcCk7XHJcbiAgICAvLyBjcmVhdGUgYSBzbmFwc2hvdCB3aGljaCBhdm9pZHMgdGhlIHNldCBiZWluZyBtdXRhdGVkIGR1cmluZyB1cGRhdGVzXHJcbiAgICBjb25zdCBpbnN0YW5jZXMgPSBbLi4ucmVjb3JkLmluc3RhbmNlc107XHJcbiAgICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIGluc3RhbmNlcykge1xyXG4gICAgICAgIGNvbnN0IG9sZENvbXAgPSBub3JtYWxpemVDbGFzc0NvbXBvbmVudChpbnN0YW5jZS50eXBlKTtcclxuICAgICAgICBpZiAoIWhtckRpcnR5Q29tcG9uZW50cy5oYXMob2xkQ29tcCkpIHtcclxuICAgICAgICAgICAgLy8gMS4gVXBkYXRlIGV4aXN0aW5nIGNvbXAgZGVmaW5pdGlvbiB0byBtYXRjaCBuZXcgb25lXHJcbiAgICAgICAgICAgIGlmIChvbGRDb21wICE9PSByZWNvcmQuaW5pdGlhbERlZikge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlQ29tcG9uZW50RGVmKG9sZENvbXAsIG5ld0NvbXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIDIuIG1hcmsgZGVmaW5pdGlvbiBkaXJ0eS4gVGhpcyBmb3JjZXMgdGhlIHJlbmRlcmVyIHRvIHJlcGxhY2UgdGhlXHJcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudCBvbiBwYXRjaC5cclxuICAgICAgICAgICAgaG1yRGlydHlDb21wb25lbnRzLmFkZChvbGRDb21wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gMy4gaW52YWxpZGF0ZSBvcHRpb25zIHJlc29sdXRpb24gY2FjaGVcclxuICAgICAgICBpbnN0YW5jZS5hcHBDb250ZXh0Lm9wdGlvbnNDYWNoZS5kZWxldGUoaW5zdGFuY2UudHlwZSk7XHJcbiAgICAgICAgLy8gNC4gYWN0dWFsbHkgdXBkYXRlXHJcbiAgICAgICAgaWYgKGluc3RhbmNlLmNlUmVsb2FkKSB7XHJcbiAgICAgICAgICAgIC8vIGN1c3RvbSBlbGVtZW50XHJcbiAgICAgICAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5hZGQob2xkQ29tcCk7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLmNlUmVsb2FkKG5ld0NvbXAuc3R5bGVzKTtcclxuICAgICAgICAgICAgaG1yRGlydHlDb21wb25lbnRzLmRlbGV0ZShvbGRDb21wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaW5zdGFuY2UucGFyZW50KSB7XHJcbiAgICAgICAgICAgIC8vIDQuIEZvcmNlIHRoZSBwYXJlbnQgaW5zdGFuY2UgdG8gcmUtcmVuZGVyLiBUaGlzIHdpbGwgY2F1c2UgYWxsIHVwZGF0ZWRcclxuICAgICAgICAgICAgLy8gY29tcG9uZW50cyB0byBiZSB1bm1vdW50ZWQgYW5kIHJlLW1vdW50ZWQuIFF1ZXVlIHRoZSB1cGRhdGUgc28gdGhhdCB3ZVxyXG4gICAgICAgICAgICAvLyBkb24ndCBlbmQgdXAgZm9yY2luZyB0aGUgc2FtZSBwYXJlbnQgdG8gcmUtcmVuZGVyIG11bHRpcGxlIHRpbWVzLlxyXG4gICAgICAgICAgICBxdWV1ZUpvYihpbnN0YW5jZS5wYXJlbnQudXBkYXRlKTtcclxuICAgICAgICAgICAgLy8gaW5zdGFuY2UgaXMgdGhlIGlubmVyIGNvbXBvbmVudCBvZiBhbiBhc3luYyBjdXN0b20gZWxlbWVudFxyXG4gICAgICAgICAgICAvLyBpbnZva2UgdG8gcmVzZXQgc3R5bGVzXHJcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZS5wYXJlbnQudHlwZS5fX2FzeW5jTG9hZGVyICYmXHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5wYXJlbnQuY2VSZWxvYWQpIHtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLnBhcmVudC5jZVJlbG9hZChuZXdDb21wLnN0eWxlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5yZWxvYWQpIHtcclxuICAgICAgICAgICAgLy8gcm9vdCBpbnN0YW5jZSBtb3VudGVkIHZpYSBjcmVhdGVBcHAoKSBoYXMgYSByZWxvYWQgbWV0aG9kXHJcbiAgICAgICAgICAgIGluc3RhbmNlLmFwcENvbnRleHQucmVsb2FkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIC8vIHJvb3QgaW5zdGFuY2UgaW5zaWRlIHRyZWUgY3JlYXRlZCB2aWEgcmF3IHJlbmRlcigpLiBGb3JjZSByZWxvYWQuXHJcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW0hNUl0gUm9vdCBvciBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlIG1vZGlmaWVkLiBGdWxsIHJlbG9hZCByZXF1aXJlZC4nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyA1LiBtYWtlIHN1cmUgdG8gY2xlYW51cCBkaXJ0eSBobXIgY29tcG9uZW50cyBhZnRlciB1cGRhdGVcclxuICAgIHF1ZXVlUG9zdEZsdXNoQ2IoKCkgPT4ge1xyXG4gICAgICAgIGZvciAoY29uc3QgaW5zdGFuY2Ugb2YgaW5zdGFuY2VzKSB7XHJcbiAgICAgICAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5kZWxldGUobm9ybWFsaXplQ2xhc3NDb21wb25lbnQoaW5zdGFuY2UudHlwZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudERlZihvbGRDb21wLCBuZXdDb21wKSB7XHJcbiAgICBleHRlbmQob2xkQ29tcCwgbmV3Q29tcCk7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvbGRDb21wKSB7XHJcbiAgICAgICAgaWYgKGtleSAhPT0gJ19fZmlsZScgJiYgIShrZXkgaW4gbmV3Q29tcCkpIHtcclxuICAgICAgICAgICAgZGVsZXRlIG9sZENvbXBba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdHJ5V3JhcChmbikge1xyXG4gICAgcmV0dXJuIChpZCwgYXJnKSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIGZuKGlkLCBhcmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFtITVJdIFNvbWV0aGluZyB3ZW50IHdyb25nIGR1cmluZyBWdWUgY29tcG9uZW50IGhvdC1yZWxvYWQuIGAgK1xyXG4gICAgICAgICAgICAgICAgYEZ1bGwgcmVsb2FkIHJlcXVpcmVkLmApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cblxubGV0IGRldnRvb2xzO1xyXG5sZXQgYnVmZmVyID0gW107XHJcbmxldCBkZXZ0b29sc05vdEluc3RhbGxlZCA9IGZhbHNlO1xyXG5mdW5jdGlvbiBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XHJcbiAgICBpZiAoZGV2dG9vbHMpIHtcclxuICAgICAgICBkZXZ0b29scy5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFkZXZ0b29sc05vdEluc3RhbGxlZCkge1xyXG4gICAgICAgIGJ1ZmZlci5wdXNoKHsgZXZlbnQsIGFyZ3MgfSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc2V0RGV2dG9vbHNIb29rKGhvb2ssIHRhcmdldCkge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIGRldnRvb2xzID0gaG9vaztcclxuICAgIGlmIChkZXZ0b29scykge1xyXG4gICAgICAgIGRldnRvb2xzLmVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIGJ1ZmZlci5mb3JFYWNoKCh7IGV2ZW50LCBhcmdzIH0pID0+IGRldnRvb2xzLmVtaXQoZXZlbnQsIC4uLmFyZ3MpKTtcclxuICAgICAgICBidWZmZXIgPSBbXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKFxyXG4gICAgLy8gaGFuZGxlIGxhdGUgZGV2dG9vbHMgaW5qZWN0aW9uIC0gb25seSBkbyB0aGlzIGlmIHdlIGFyZSBpbiBhbiBhY3R1YWxcclxuICAgIC8vIGJyb3dzZXIgZW52aXJvbm1lbnQgdG8gYXZvaWQgdGhlIHRpbWVyIGhhbmRsZSBzdGFsbGluZyB0ZXN0IHJ1bm5lciBleGl0XHJcbiAgICAvLyAoIzQ4MTUpXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXHJcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgIC8vIHNvbWUgZW52cyBtb2NrIHdpbmRvdyBidXQgbm90IGZ1bGx5XHJcbiAgICAgICAgd2luZG93LkhUTUxFbGVtZW50ICYmXHJcbiAgICAgICAgLy8gYWxzbyBleGNsdWRlIGpzZG9tXHJcbiAgICAgICAgISgoX2IgPSAoX2EgPSB3aW5kb3cubmF2aWdhdG9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXNlckFnZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaW5jbHVkZXMoJ2pzZG9tJykpKSB7XHJcbiAgICAgICAgY29uc3QgcmVwbGF5ID0gKHRhcmdldC5fX1ZVRV9ERVZUT09MU19IT09LX1JFUExBWV9fID1cclxuICAgICAgICAgICAgdGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18gfHwgW10pO1xyXG4gICAgICAgIHJlcGxheS5wdXNoKChuZXdIb29rKSA9PiB7XHJcbiAgICAgICAgICAgIHNldERldnRvb2xzSG9vayhuZXdIb29rLCB0YXJnZXQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGNsZWFyIGJ1ZmZlciBhZnRlciAzcyAtIHRoZSB1c2VyIHByb2JhYmx5IGRvZXNuJ3QgaGF2ZSBkZXZ0b29scyBpbnN0YWxsZWRcclxuICAgICAgICAvLyBhdCBhbGwsIGFuZCBrZWVwaW5nIHRoZSBidWZmZXIgd2lsbCBjYXVzZSBtZW1vcnkgbGVha3MgKCM0NzM4KVxyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWRldnRvb2xzKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuX19WVUVfREVWVE9PTFNfSE9PS19SRVBMQVlfXyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBkZXZ0b29sc05vdEluc3RhbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIDMwMDApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gbm9uLWJyb3dzZXIgZW52LCBhc3N1bWUgbm90IGluc3RhbGxlZFxyXG4gICAgICAgIGRldnRvb2xzTm90SW5zdGFsbGVkID0gdHJ1ZTtcclxuICAgICAgICBidWZmZXIgPSBbXTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBkZXZ0b29sc0luaXRBcHAoYXBwLCB2ZXJzaW9uKSB7XHJcbiAgICBlbWl0KFwiYXBwOmluaXRcIiAvKiBBUFBfSU5JVCAqLywgYXBwLCB2ZXJzaW9uLCB7XHJcbiAgICAgICAgRnJhZ21lbnQsXHJcbiAgICAgICAgVGV4dCxcclxuICAgICAgICBDb21tZW50LFxyXG4gICAgICAgIFN0YXRpY1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZGV2dG9vbHNVbm1vdW50QXBwKGFwcCkge1xyXG4gICAgZW1pdChcImFwcDp1bm1vdW50XCIgLyogQVBQX1VOTU9VTlQgKi8sIGFwcCk7XHJcbn1cclxuY29uc3QgZGV2dG9vbHNDb21wb25lbnRBZGRlZCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKFwiY29tcG9uZW50OmFkZGVkXCIgLyogQ09NUE9ORU5UX0FEREVEICovKTtcclxuY29uc3QgZGV2dG9vbHNDb21wb25lbnRVcGRhdGVkID0gXHJcbi8qI19fUFVSRV9fKi8gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKFwiY29tcG9uZW50OnVwZGF0ZWRcIiAvKiBDT01QT05FTlRfVVBEQVRFRCAqLyk7XHJcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50UmVtb3ZlZCA9IFxyXG4vKiNfX1BVUkVfXyovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcImNvbXBvbmVudDpyZW1vdmVkXCIgLyogQ09NUE9ORU5UX1JFTU9WRUQgKi8pO1xyXG5mdW5jdGlvbiBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soaG9vaykge1xyXG4gICAgcmV0dXJuIChjb21wb25lbnQpID0+IHtcclxuICAgICAgICBlbWl0KGhvb2ssIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCwgY29tcG9uZW50LnVpZCwgY29tcG9uZW50LnBhcmVudCA/IGNvbXBvbmVudC5wYXJlbnQudWlkIDogdW5kZWZpbmVkLCBjb21wb25lbnQpO1xyXG4gICAgfTtcclxufVxyXG5jb25zdCBkZXZ0b29sc1BlcmZTdGFydCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlRGV2dG9vbHNQZXJmb3JtYW5jZUhvb2soXCJwZXJmOnN0YXJ0XCIgLyogUEVSRk9STUFOQ0VfU1RBUlQgKi8pO1xyXG5jb25zdCBkZXZ0b29sc1BlcmZFbmQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZURldnRvb2xzUGVyZm9ybWFuY2VIb29rKFwicGVyZjplbmRcIiAvKiBQRVJGT1JNQU5DRV9FTkQgKi8pO1xyXG5mdW5jdGlvbiBjcmVhdGVEZXZ0b29sc1BlcmZvcm1hbmNlSG9vayhob29rKSB7XHJcbiAgICByZXR1cm4gKGNvbXBvbmVudCwgdHlwZSwgdGltZSkgPT4ge1xyXG4gICAgICAgIGVtaXQoaG9vaywgY29tcG9uZW50LmFwcENvbnRleHQuYXBwLCBjb21wb25lbnQudWlkLCBjb21wb25lbnQsIHR5cGUsIHRpbWUpO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBkZXZ0b29sc0NvbXBvbmVudEVtaXQoY29tcG9uZW50LCBldmVudCwgcGFyYW1zKSB7XHJcbiAgICBlbWl0KFwiY29tcG9uZW50OmVtaXRcIiAvKiBDT01QT05FTlRfRU1JVCAqLywgY29tcG9uZW50LmFwcENvbnRleHQuYXBwLCBjb21wb25lbnQsIGV2ZW50LCBwYXJhbXMpO1xyXG59XG5cbmZ1bmN0aW9uIGVtaXQkMShpbnN0YW5jZSwgZXZlbnQsIC4uLnJhd0FyZ3MpIHtcclxuICAgIGNvbnN0IHByb3BzID0gaW5zdGFuY2Uudm5vZGUucHJvcHMgfHwgRU1QVFlfT0JKO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNvbnN0IHsgZW1pdHNPcHRpb25zLCBwcm9wc09wdGlvbnM6IFtwcm9wc09wdGlvbnNdIH0gPSBpbnN0YW5jZTtcclxuICAgICAgICBpZiAoZW1pdHNPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGlmICghKGV2ZW50IGluIGVtaXRzT3B0aW9ucykgJiZcclxuICAgICAgICAgICAgICAgICEoZmFsc2UgKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwcm9wc09wdGlvbnMgfHwgISh0b0hhbmRsZXJLZXkoZXZlbnQpIGluIHByb3BzT3B0aW9ucykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBDb21wb25lbnQgZW1pdHRlZCBldmVudCBcIiR7ZXZlbnR9XCIgYnV0IGl0IGlzIG5laXRoZXIgZGVjbGFyZWQgaW4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGB0aGUgZW1pdHMgb3B0aW9uIG5vciBhcyBhbiBcIiR7dG9IYW5kbGVyS2V5KGV2ZW50KX1cIiBwcm9wLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gZW1pdHNPcHRpb25zW2V2ZW50XTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbGlkYXRvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gdmFsaWRhdG9yKC4uLnJhd0FyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBJbnZhbGlkIGV2ZW50IGFyZ3VtZW50czogZXZlbnQgdmFsaWRhdGlvbiBmYWlsZWQgZm9yIGV2ZW50IFwiJHtldmVudH1cIi5gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsZXQgYXJncyA9IHJhd0FyZ3M7XHJcbiAgICBjb25zdCBpc01vZGVsTGlzdGVuZXIgPSBldmVudC5zdGFydHNXaXRoKCd1cGRhdGU6Jyk7XHJcbiAgICAvLyBmb3Igdi1tb2RlbCB1cGRhdGU6eHh4IGV2ZW50cywgYXBwbHkgbW9kaWZpZXJzIG9uIGFyZ3NcclxuICAgIGNvbnN0IG1vZGVsQXJnID0gaXNNb2RlbExpc3RlbmVyICYmIGV2ZW50LnNsaWNlKDcpO1xyXG4gICAgaWYgKG1vZGVsQXJnICYmIG1vZGVsQXJnIGluIHByb3BzKSB7XHJcbiAgICAgICAgY29uc3QgbW9kaWZpZXJzS2V5ID0gYCR7bW9kZWxBcmcgPT09ICdtb2RlbFZhbHVlJyA/ICdtb2RlbCcgOiBtb2RlbEFyZ31Nb2RpZmllcnNgO1xyXG4gICAgICAgIGNvbnN0IHsgbnVtYmVyLCB0cmltIH0gPSBwcm9wc1ttb2RpZmllcnNLZXldIHx8IEVNUFRZX09CSjtcclxuICAgICAgICBpZiAodHJpbSkge1xyXG4gICAgICAgICAgICBhcmdzID0gcmF3QXJncy5tYXAoYSA9PiBhLnRyaW0oKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG51bWJlcikge1xyXG4gICAgICAgICAgICBhcmdzID0gcmF3QXJncy5tYXAodG9OdW1iZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgZGV2dG9vbHNDb21wb25lbnRFbWl0KGluc3RhbmNlLCBldmVudCwgYXJncyk7XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgY29uc3QgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgcHJvcHNbdG9IYW5kbGVyS2V5KGxvd2VyQ2FzZUV2ZW50KV0pIHtcclxuICAgICAgICAgICAgd2FybihgRXZlbnQgXCIke2xvd2VyQ2FzZUV2ZW50fVwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IGAgK1xyXG4gICAgICAgICAgICAgICAgYCR7Zm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgaW5zdGFuY2UudHlwZSl9IGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcIiR7ZXZlbnR9XCIuIGAgK1xyXG4gICAgICAgICAgICAgICAgYE5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIGAgK1xyXG4gICAgICAgICAgICAgICAgYHYtb24gdG8gbGlzdGVuIHRvIGNhbWVsQ2FzZSBldmVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBgICtcclxuICAgICAgICAgICAgICAgIGBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcIiR7aHlwaGVuYXRlKGV2ZW50KX1cIiBpbnN0ZWFkIG9mIFwiJHtldmVudH1cIi5gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsZXQgaGFuZGxlck5hbWU7XHJcbiAgICBsZXQgaGFuZGxlciA9IHByb3BzWyhoYW5kbGVyTmFtZSA9IHRvSGFuZGxlcktleShldmVudCkpXSB8fFxyXG4gICAgICAgIC8vIGFsc28gdHJ5IGNhbWVsQ2FzZSBldmVudCBoYW5kbGVyICgjMjI0OSlcclxuICAgICAgICBwcm9wc1soaGFuZGxlck5hbWUgPSB0b0hhbmRsZXJLZXkoY2FtZWxpemUoZXZlbnQpKSldO1xyXG4gICAgLy8gZm9yIHYtbW9kZWwgdXBkYXRlOnh4eCBldmVudHMsIGFsc28gdHJpZ2dlciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRcclxuICAgIC8vIGZvciBwcm9wcyBwYXNzZWQgdmlhIGtlYmFiLWNhc2VcclxuICAgIGlmICghaGFuZGxlciAmJiBpc01vZGVsTGlzdGVuZXIpIHtcclxuICAgICAgICBoYW5kbGVyID0gcHJvcHNbKGhhbmRsZXJOYW1lID0gdG9IYW5kbGVyS2V5KGh5cGhlbmF0ZShldmVudCkpKV07XHJcbiAgICB9XHJcbiAgICBpZiAoaGFuZGxlcikge1xyXG4gICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhhbmRsZXIsIGluc3RhbmNlLCA2IC8qIENPTVBPTkVOVF9FVkVOVF9IQU5ETEVSICovLCBhcmdzKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG9uY2VIYW5kbGVyID0gcHJvcHNbaGFuZGxlck5hbWUgKyBgT25jZWBdO1xyXG4gICAgaWYgKG9uY2VIYW5kbGVyKSB7XHJcbiAgICAgICAgaWYgKCFpbnN0YW5jZS5lbWl0dGVkKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLmVtaXR0ZWQgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaW5zdGFuY2UuZW1pdHRlZFtoYW5kbGVyTmFtZV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnN0YW5jZS5lbWl0dGVkW2hhbmRsZXJOYW1lXSA9IHRydWU7XHJcbiAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcob25jZUhhbmRsZXIsIGluc3RhbmNlLCA2IC8qIENPTVBPTkVOVF9FVkVOVF9IQU5ETEVSICovLCBhcmdzKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVFbWl0c09wdGlvbnMoY29tcCwgYXBwQ29udGV4dCwgYXNNaXhpbiA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBjYWNoZSA9IGFwcENvbnRleHQuZW1pdHNDYWNoZTtcclxuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChjb21wKTtcclxuICAgIGlmIChjYWNoZWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBjYWNoZWQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCByYXcgPSBjb21wLmVtaXRzO1xyXG4gICAgbGV0IG5vcm1hbGl6ZWQgPSB7fTtcclxuICAgIC8vIGFwcGx5IG1peGluL2V4dGVuZHMgcHJvcHNcclxuICAgIGxldCBoYXNFeHRlbmRzID0gZmFsc2U7XHJcbiAgICBpZiAoX19WVUVfT1BUSU9OU19BUElfXyAmJiAhaXNGdW5jdGlvbihjb21wKSkge1xyXG4gICAgICAgIGNvbnN0IGV4dGVuZEVtaXRzID0gKHJhdykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkRnJvbUV4dGVuZCA9IG5vcm1hbGl6ZUVtaXRzT3B0aW9ucyhyYXcsIGFwcENvbnRleHQsIHRydWUpO1xyXG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZEZyb21FeHRlbmQpIHtcclxuICAgICAgICAgICAgICAgIGhhc0V4dGVuZHMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgZXh0ZW5kKG5vcm1hbGl6ZWQsIG5vcm1hbGl6ZWRGcm9tRXh0ZW5kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKCFhc01peGluICYmIGFwcENvbnRleHQubWl4aW5zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBhcHBDb250ZXh0Lm1peGlucy5mb3JFYWNoKGV4dGVuZEVtaXRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbXAuZXh0ZW5kcykge1xyXG4gICAgICAgICAgICBleHRlbmRFbWl0cyhjb21wLmV4dGVuZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29tcC5taXhpbnMpIHtcclxuICAgICAgICAgICAgY29tcC5taXhpbnMuZm9yRWFjaChleHRlbmRFbWl0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFyYXcgJiYgIWhhc0V4dGVuZHMpIHtcclxuICAgICAgICBjYWNoZS5zZXQoY29tcCwgbnVsbCk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNBcnJheShyYXcpKSB7XHJcbiAgICAgICAgcmF3LmZvckVhY2goa2V5ID0+IChub3JtYWxpemVkW2tleV0gPSBudWxsKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBleHRlbmQobm9ybWFsaXplZCwgcmF3KTtcclxuICAgIH1cclxuICAgIGNhY2hlLnNldChjb21wLCBub3JtYWxpemVkKTtcclxuICAgIHJldHVybiBub3JtYWxpemVkO1xyXG59XHJcbi8vIENoZWNrIGlmIGFuIGluY29taW5nIHByb3Aga2V5IGlzIGEgZGVjbGFyZWQgZW1pdCBldmVudCBsaXN0ZW5lci5cclxuLy8gZS5nLiBXaXRoIGBlbWl0czogeyBjbGljazogbnVsbCB9YCwgcHJvcHMgbmFtZWQgYG9uQ2xpY2tgIGFuZCBgb25jbGlja2AgYXJlXHJcbi8vIGJvdGggY29uc2lkZXJlZCBtYXRjaGVkIGxpc3RlbmVycy5cclxuZnVuY3Rpb24gaXNFbWl0TGlzdGVuZXIob3B0aW9ucywga2V5KSB7XHJcbiAgICBpZiAoIW9wdGlvbnMgfHwgIWlzT24oa2V5KSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGtleSA9IGtleS5zbGljZSgyKS5yZXBsYWNlKC9PbmNlJC8sICcnKTtcclxuICAgIHJldHVybiAoaGFzT3duKG9wdGlvbnMsIGtleVswXS50b0xvd2VyQ2FzZSgpICsga2V5LnNsaWNlKDEpKSB8fFxyXG4gICAgICAgIGhhc093bihvcHRpb25zLCBoeXBoZW5hdGUoa2V5KSkgfHxcclxuICAgICAgICBoYXNPd24ob3B0aW9ucywga2V5KSk7XHJcbn1cblxuLyoqXHJcbiAqIG1hcmsgdGhlIGN1cnJlbnQgcmVuZGVyaW5nIGluc3RhbmNlIGZvciBhc3NldCByZXNvbHV0aW9uIChlLmcuXHJcbiAqIHJlc29sdmVDb21wb25lbnQsIHJlc29sdmVEaXJlY3RpdmUpIGR1cmluZyByZW5kZXJcclxuICovXHJcbmxldCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xyXG5sZXQgY3VycmVudFNjb3BlSWQgPSBudWxsO1xyXG4vKipcclxuICogTm90ZTogcmVuZGVyaW5nIGNhbGxzIG1heWJlIG5lc3RlZC4gVGhlIGZ1bmN0aW9uIHJldHVybnMgdGhlIHBhcmVudCByZW5kZXJpbmdcclxuICogaW5zdGFuY2UgaWYgcHJlc2VudCwgd2hpY2ggc2hvdWxkIGJlIHJlc3RvcmVkIGFmdGVyIHRoZSByZW5kZXIgaXMgZG9uZTpcclxuICpcclxuICogYGBganNcclxuICogY29uc3QgcHJldiA9IHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShpKVxyXG4gKiAvLyAuLi5yZW5kZXJcclxuICogc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKHByZXYpXHJcbiAqIGBgYFxyXG4gKi9cclxuZnVuY3Rpb24gc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKGluc3RhbmNlKSB7XHJcbiAgICBjb25zdCBwcmV2ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xyXG4gICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gaW5zdGFuY2U7XHJcbiAgICBjdXJyZW50U2NvcGVJZCA9IChpbnN0YW5jZSAmJiBpbnN0YW5jZS50eXBlLl9fc2NvcGVJZCkgfHwgbnVsbDtcclxuICAgIHJldHVybiBwcmV2O1xyXG59XHJcbi8qKlxyXG4gKiBTZXQgc2NvcGUgaWQgd2hlbiBjcmVhdGluZyBob2lzdGVkIHZub2Rlcy5cclxuICogQHByaXZhdGUgY29tcGlsZXIgaGVscGVyXHJcbiAqL1xyXG5mdW5jdGlvbiBwdXNoU2NvcGVJZChpZCkge1xyXG4gICAgY3VycmVudFNjb3BlSWQgPSBpZDtcclxufVxyXG4vKipcclxuICogVGVjaG5pY2FsbHkgd2Ugbm8gbG9uZ2VyIG5lZWQgdGhpcyBhZnRlciAzLjAuOCBidXQgd2UgbmVlZCB0byBrZWVwIHRoZSBzYW1lXHJcbiAqIEFQSSBmb3IgYmFja3dhcmRzIGNvbXBhdCB3LyBjb2RlIGdlbmVyYXRlZCBieSBjb21waWxlcnMuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBwb3BTY29wZUlkKCkge1xyXG4gICAgY3VycmVudFNjb3BlSWQgPSBudWxsO1xyXG59XHJcbi8qKlxyXG4gKiBPbmx5IGZvciBiYWNrd2FyZHMgY29tcGF0XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCB3aXRoU2NvcGVJZCA9IChfaWQpID0+IHdpdGhDdHg7XHJcbi8qKlxyXG4gKiBXcmFwIGEgc2xvdCBmdW5jdGlvbiB0byBtZW1vaXplIGN1cnJlbnQgcmVuZGVyaW5nIGluc3RhbmNlXHJcbiAqIEBwcml2YXRlIGNvbXBpbGVyIGhlbHBlclxyXG4gKi9cclxuZnVuY3Rpb24gd2l0aEN0eChmbiwgY3R4ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLCBpc05vblNjb3BlZFNsb3QgLy8gZmFsc2Ugb25seVxyXG4pIHtcclxuICAgIGlmICghY3R4KVxyXG4gICAgICAgIHJldHVybiBmbjtcclxuICAgIC8vIGFscmVhZHkgbm9ybWFsaXplZFxyXG4gICAgaWYgKGZuLl9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGZuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVuZGVyRm5XaXRoQ29udGV4dCA9ICguLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgLy8gSWYgYSB1c2VyIGNhbGxzIGEgY29tcGlsZWQgc2xvdCBpbnNpZGUgYSB0ZW1wbGF0ZSBleHByZXNzaW9uICgjMTc0NSksIGl0XHJcbiAgICAgICAgLy8gY2FuIG1lc3MgdXAgYmxvY2sgdHJhY2tpbmcsIHNvIGJ5IGRlZmF1bHQgd2UgZGlzYWJsZSBibG9jayB0cmFja2luZyBhbmRcclxuICAgICAgICAvLyBmb3JjZSBiYWlsIG91dCB3aGVuIGludm9raW5nIGEgY29tcGlsZWQgc2xvdCAoaW5kaWNhdGVkIGJ5IHRoZSAuX2QgZmxhZykuXHJcbiAgICAgICAgLy8gVGhpcyBpc24ndCBuZWNlc3NhcnkgaWYgcmVuZGVyaW5nIGEgY29tcGlsZWQgYDxzbG90PmAsIHNvIHdlIGZsaXAgdGhlXHJcbiAgICAgICAgLy8gLl9kIGZsYWcgb2ZmIHdoZW4gaW52b2tpbmcgdGhlIHdyYXBwZWQgZm4gaW5zaWRlIGByZW5kZXJTbG90YC5cclxuICAgICAgICBpZiAocmVuZGVyRm5XaXRoQ29udGV4dC5fZCkge1xyXG4gICAgICAgICAgICBzZXRCbG9ja1RyYWNraW5nKC0xKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcHJldkluc3RhbmNlID0gc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKGN0eCk7XHJcbiAgICAgICAgY29uc3QgcmVzID0gZm4oLi4uYXJncyk7XHJcbiAgICAgICAgc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKHByZXZJbnN0YW5jZSk7XHJcbiAgICAgICAgaWYgKHJlbmRlckZuV2l0aENvbnRleHQuX2QpIHtcclxuICAgICAgICAgICAgc2V0QmxvY2tUcmFja2luZygxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRVcGRhdGVkKGN0eCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9O1xyXG4gICAgLy8gbWFyayBub3JtYWxpemVkIHRvIGF2b2lkIGR1cGxpY2F0ZWQgd3JhcHBpbmdcclxuICAgIHJlbmRlckZuV2l0aENvbnRleHQuX24gPSB0cnVlO1xyXG4gICAgLy8gbWFyayB0aGlzIGFzIGNvbXBpbGVkIGJ5IGRlZmF1bHRcclxuICAgIC8vIHRoaXMgaXMgdXNlZCBpbiB2bm9kZS50cyAtPiBub3JtYWxpemVDaGlsZHJlbigpIHRvIHNldCB0aGUgc2xvdFxyXG4gICAgLy8gcmVuZGVyaW5nIGZsYWcuXHJcbiAgICByZW5kZXJGbldpdGhDb250ZXh0Ll9jID0gdHJ1ZTtcclxuICAgIC8vIGRpc2FibGUgYmxvY2sgdHJhY2tpbmcgYnkgZGVmYXVsdFxyXG4gICAgcmVuZGVyRm5XaXRoQ29udGV4dC5fZCA9IHRydWU7XHJcbiAgICByZXR1cm4gcmVuZGVyRm5XaXRoQ29udGV4dDtcclxufVxuXG4vKipcclxuICogZGV2IG9ubHkgZmxhZyB0byB0cmFjayB3aGV0aGVyICRhdHRycyB3YXMgdXNlZCBkdXJpbmcgcmVuZGVyLlxyXG4gKiBJZiAkYXR0cnMgd2FzIHVzZWQgZHVyaW5nIHJlbmRlciB0aGVuIHRoZSB3YXJuaW5nIGZvciBmYWlsZWQgYXR0cnNcclxuICogZmFsbHRocm91Z2ggY2FuIGJlIHN1cHByZXNzZWQuXHJcbiAqL1xyXG5sZXQgYWNjZXNzZWRBdHRycyA9IGZhbHNlO1xyXG5mdW5jdGlvbiBtYXJrQXR0cnNBY2Nlc3NlZCgpIHtcclxuICAgIGFjY2Vzc2VkQXR0cnMgPSB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IHsgdHlwZTogQ29tcG9uZW50LCB2bm9kZSwgcHJveHksIHdpdGhQcm94eSwgcHJvcHMsIHByb3BzT3B0aW9uczogW3Byb3BzT3B0aW9uc10sIHNsb3RzLCBhdHRycywgZW1pdCwgcmVuZGVyLCByZW5kZXJDYWNoZSwgZGF0YSwgc2V0dXBTdGF0ZSwgY3R4LCBpbmhlcml0QXR0cnMgfSA9IGluc3RhbmNlO1xyXG4gICAgbGV0IHJlc3VsdDtcclxuICAgIGxldCBmYWxsdGhyb3VnaEF0dHJzO1xyXG4gICAgY29uc3QgcHJldiA9IHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShpbnN0YW5jZSk7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgYWNjZXNzZWRBdHRycyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNCAvKiBTVEFURUZVTF9DT01QT05FTlQgKi8pIHtcclxuICAgICAgICAgICAgLy8gd2l0aFByb3h5IGlzIGEgcHJveHkgd2l0aCBhIGRpZmZlcmVudCBgaGFzYCB0cmFwIG9ubHkgZm9yXHJcbiAgICAgICAgICAgIC8vIHJ1bnRpbWUtY29tcGlsZWQgcmVuZGVyIGZ1bmN0aW9ucyB1c2luZyBgd2l0aGAgYmxvY2suXHJcbiAgICAgICAgICAgIGNvbnN0IHByb3h5VG9Vc2UgPSB3aXRoUHJveHkgfHwgcHJveHk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVZOb2RlKHJlbmRlci5jYWxsKHByb3h5VG9Vc2UsIHByb3h5VG9Vc2UsIHJlbmRlckNhY2hlLCBwcm9wcywgc2V0dXBTdGF0ZSwgZGF0YSwgY3R4KSk7XHJcbiAgICAgICAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBhdHRycztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uYWxcclxuICAgICAgICAgICAgY29uc3QgcmVuZGVyID0gQ29tcG9uZW50O1xyXG4gICAgICAgICAgICAvLyBpbiBkZXYsIG1hcmsgYXR0cnMgYWNjZXNzZWQgaWYgb3B0aW9uYWwgcHJvcHMgKGF0dHJzID09PSBwcm9wcylcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBhdHRycyA9PT0gcHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0ID0gbm9ybWFsaXplVk5vZGUocmVuZGVyLmxlbmd0aCA+IDFcclxuICAgICAgICAgICAgICAgID8gcmVuZGVyKHByb3BzLCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICAgICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGF0dHJzKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya0F0dHJzQWNjZXNzZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdHRycztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgOiB7IGF0dHJzLCBzbG90cywgZW1pdCB9KVxyXG4gICAgICAgICAgICAgICAgOiByZW5kZXIocHJvcHMsIG51bGwgLyogd2Uga25vdyBpdCBkb2Vzbid0IG5lZWQgaXQgKi8pKTtcclxuICAgICAgICAgICAgZmFsbHRocm91Z2hBdHRycyA9IENvbXBvbmVudC5wcm9wc1xyXG4gICAgICAgICAgICAgICAgPyBhdHRyc1xyXG4gICAgICAgICAgICAgICAgOiBnZXRGdW5jdGlvbmFsRmFsbHRocm91Z2goYXR0cnMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICBibG9ja1N0YWNrLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgMSAvKiBSRU5ERVJfRlVOQ1RJT04gKi8pO1xyXG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xyXG4gICAgfVxyXG4gICAgLy8gYXR0ciBtZXJnaW5nXHJcbiAgICAvLyBpbiBkZXYgbW9kZSwgY29tbWVudHMgYXJlIHByZXNlcnZlZCwgYW5kIGl0J3MgcG9zc2libGUgZm9yIGEgdGVtcGxhdGVcclxuICAgIC8vIHRvIGhhdmUgY29tbWVudHMgYWxvbmcgc2lkZSB0aGUgcm9vdCBlbGVtZW50IHdoaWNoIG1ha2VzIGl0IGEgZnJhZ21lbnRcclxuICAgIGxldCByb290ID0gcmVzdWx0O1xyXG4gICAgbGV0IHNldFJvb3QgPSB1bmRlZmluZWQ7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgcmVzdWx0LnBhdGNoRmxhZyA+IDAgJiZcclxuICAgICAgICByZXN1bHQucGF0Y2hGbGFnICYgMjA0OCAvKiBERVZfUk9PVF9GUkFHTUVOVCAqLykge1xyXG4gICAgICAgIFtyb290LCBzZXRSb290XSA9IGdldENoaWxkUm9vdChyZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgaWYgKGZhbGx0aHJvdWdoQXR0cnMgJiYgaW5oZXJpdEF0dHJzICE9PSBmYWxzZSkge1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhmYWxsdGhyb3VnaEF0dHJzKTtcclxuICAgICAgICBjb25zdCB7IHNoYXBlRmxhZyB9ID0gcm9vdDtcclxuICAgICAgICBpZiAoa2V5cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmICgxIC8qIEVMRU1FTlQgKi8gfCA2IC8qIENPTVBPTkVOVCAqLykpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9wc09wdGlvbnMgJiYga2V5cy5zb21lKGlzTW9kZWxMaXN0ZW5lcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIHYtbW9kZWwgbGlzdGVuZXIgKG9uVXBkYXRlOnh4eCkgaGFzIGEgY29ycmVzcG9uZGluZyBkZWNsYXJlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHByb3AsIGl0IGluZGljYXRlcyB0aGlzIGNvbXBvbmVudCBleHBlY3RzIHRvIGhhbmRsZSB2LW1vZGVsIGFuZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IHNob3VsZCBub3QgZmFsbHRocm91Z2guXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVsYXRlZDogIzE1NDMsICMxNjQzLCAjMTk4OVxyXG4gICAgICAgICAgICAgICAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBmaWx0ZXJNb2RlbExpc3RlbmVycyhmYWxsdGhyb3VnaEF0dHJzLCBwcm9wc09wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcm9vdCA9IGNsb25lVk5vZGUocm9vdCwgZmFsbHRocm91Z2hBdHRycyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFhY2Nlc3NlZEF0dHJzICYmIHJvb3QudHlwZSAhPT0gQ29tbWVudCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYWxsQXR0cnMgPSBPYmplY3Qua2V5cyhhdHRycyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudEF0dHJzID0gW107XHJcbiAgICAgICAgICAgICAgICBjb25zdCBleHRyYUF0dHJzID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGFsbEF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGFsbEF0dHJzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09uKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIHYtbW9kZWwgaGFuZGxlcnMgd2hlbiB0aGV5IGZhaWwgdG8gZmFsbHRocm91Z2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGBvbmAsIGxvd2VyY2FzZSBmaXJzdCBsZXR0ZXIgdG8gcmVmbGVjdCBldmVudCBjYXNpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFjY3VyYXRlbHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50QXR0cnMucHVzaChrZXlbMl0udG9Mb3dlckNhc2UoKSArIGtleS5zbGljZSgzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cnMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChleHRyYUF0dHJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEV4dHJhbmVvdXMgbm9uLXByb3BzIGF0dHJpYnV0ZXMgKGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgJHtleHRyYUF0dHJzLmpvaW4oJywgJyl9KSBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYHdlcmUgcGFzc2VkIHRvIGNvbXBvbmVudCBidXQgY291bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgaW5oZXJpdGVkIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgYmVjYXVzZSBjb21wb25lbnQgcmVuZGVycyBmcmFnbWVudCBvciB0ZXh0IHJvb3Qgbm9kZXMuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRBdHRycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBFeHRyYW5lb3VzIG5vbi1lbWl0cyBldmVudCBsaXN0ZW5lcnMgKGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgJHtldmVudEF0dHJzLmpvaW4oJywgJyl9KSBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYHdlcmUgcGFzc2VkIHRvIGNvbXBvbmVudCBidXQgY291bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgaW5oZXJpdGVkIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgYmVjYXVzZSBjb21wb25lbnQgcmVuZGVycyBmcmFnbWVudCBvciB0ZXh0IHJvb3Qgbm9kZXMuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgSWYgdGhlIGxpc3RlbmVyIGlzIGludGVuZGVkIHRvIGJlIGEgY29tcG9uZW50IGN1c3RvbSBldmVudCBsaXN0ZW5lciBvbmx5LCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYGRlY2xhcmUgaXQgdXNpbmcgdGhlIFwiZW1pdHNcIiBvcHRpb24uYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBpbmhlcml0IGRpcmVjdGl2ZXNcclxuICAgIGlmICh2bm9kZS5kaXJzKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNFbGVtZW50Um9vdChyb290KSkge1xyXG4gICAgICAgICAgICB3YXJuKGBSdW50aW1lIGRpcmVjdGl2ZSB1c2VkIG9uIGNvbXBvbmVudCB3aXRoIG5vbi1lbGVtZW50IHJvb3Qgbm9kZS4gYCArXHJcbiAgICAgICAgICAgICAgICBgVGhlIGRpcmVjdGl2ZXMgd2lsbCBub3QgZnVuY3Rpb24gYXMgaW50ZW5kZWQuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJvb3QuZGlycyA9IHJvb3QuZGlycyA/IHJvb3QuZGlycy5jb25jYXQodm5vZGUuZGlycykgOiB2bm9kZS5kaXJzO1xyXG4gICAgfVxyXG4gICAgLy8gaW5oZXJpdCB0cmFuc2l0aW9uIGRhdGFcclxuICAgIGlmICh2bm9kZS50cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNFbGVtZW50Um9vdChyb290KSkge1xyXG4gICAgICAgICAgICB3YXJuKGBDb21wb25lbnQgaW5zaWRlIDxUcmFuc2l0aW9uPiByZW5kZXJzIG5vbi1lbGVtZW50IHJvb3Qgbm9kZSBgICtcclxuICAgICAgICAgICAgICAgIGB0aGF0IGNhbm5vdCBiZSBhbmltYXRlZC5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcm9vdC50cmFuc2l0aW9uID0gdm5vZGUudHJhbnNpdGlvbjtcclxuICAgIH1cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgc2V0Um9vdCkge1xyXG4gICAgICAgIHNldFJvb3Qocm9vdCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXN1bHQgPSByb290O1xyXG4gICAgfVxyXG4gICAgc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKHByZXYpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vKipcclxuICogZGV2IG9ubHlcclxuICogSW4gZGV2IG1vZGUsIHRlbXBsYXRlIHJvb3QgbGV2ZWwgY29tbWVudHMgYXJlIHJlbmRlcmVkLCB3aGljaCB0dXJucyB0aGVcclxuICogdGVtcGxhdGUgaW50byBhIGZyYWdtZW50IHJvb3QsIGJ1dCB3ZSBuZWVkIHRvIGxvY2F0ZSB0aGUgc2luZ2xlIGVsZW1lbnRcclxuICogcm9vdCBmb3IgYXR0cnMgYW5kIHNjb3BlIGlkIHByb2Nlc3NpbmcuXHJcbiAqL1xyXG5jb25zdCBnZXRDaGlsZFJvb3QgPSAodm5vZGUpID0+IHtcclxuICAgIGNvbnN0IHJhd0NoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XHJcbiAgICBjb25zdCBkeW5hbWljQ2hpbGRyZW4gPSB2bm9kZS5keW5hbWljQ2hpbGRyZW47XHJcbiAgICBjb25zdCBjaGlsZFJvb3QgPSBmaWx0ZXJTaW5nbGVSb290KHJhd0NoaWxkcmVuKTtcclxuICAgIGlmICghY2hpbGRSb290KSB7XHJcbiAgICAgICAgcmV0dXJuIFt2bm9kZSwgdW5kZWZpbmVkXTtcclxuICAgIH1cclxuICAgIGNvbnN0IGluZGV4ID0gcmF3Q2hpbGRyZW4uaW5kZXhPZihjaGlsZFJvb3QpO1xyXG4gICAgY29uc3QgZHluYW1pY0luZGV4ID0gZHluYW1pY0NoaWxkcmVuID8gZHluYW1pY0NoaWxkcmVuLmluZGV4T2YoY2hpbGRSb290KSA6IC0xO1xyXG4gICAgY29uc3Qgc2V0Um9vdCA9ICh1cGRhdGVkUm9vdCkgPT4ge1xyXG4gICAgICAgIHJhd0NoaWxkcmVuW2luZGV4XSA9IHVwZGF0ZWRSb290O1xyXG4gICAgICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgaWYgKGR5bmFtaWNJbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBkeW5hbWljQ2hpbGRyZW5bZHluYW1pY0luZGV4XSA9IHVwZGF0ZWRSb290O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHVwZGF0ZWRSb290LnBhdGNoRmxhZyA+IDApIHtcclxuICAgICAgICAgICAgICAgIHZub2RlLmR5bmFtaWNDaGlsZHJlbiA9IFsuLi5keW5hbWljQ2hpbGRyZW4sIHVwZGF0ZWRSb290XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gW25vcm1hbGl6ZVZOb2RlKGNoaWxkUm9vdCksIHNldFJvb3RdO1xyXG59O1xyXG5mdW5jdGlvbiBmaWx0ZXJTaW5nbGVSb290KGNoaWxkcmVuKSB7XHJcbiAgICBsZXQgc2luZ2xlUm9vdDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgIGlmIChpc1ZOb2RlKGNoaWxkKSkge1xyXG4gICAgICAgICAgICAvLyBpZ25vcmUgdXNlciBjb21tZW50XHJcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9PSBDb21tZW50IHx8IGNoaWxkLmNoaWxkcmVuID09PSAndi1pZicpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVSb290KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFzIG1vcmUgdGhhbiAxIG5vbi1jb21tZW50IGNoaWxkLCByZXR1cm4gbm93XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlUm9vdCA9IGNoaWxkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNpbmdsZVJvb3Q7XHJcbn1cclxuY29uc3QgZ2V0RnVuY3Rpb25hbEZhbGx0aHJvdWdoID0gKGF0dHJzKSA9PiB7XHJcbiAgICBsZXQgcmVzO1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcclxuICAgICAgICBpZiAoa2V5ID09PSAnY2xhc3MnIHx8IGtleSA9PT0gJ3N0eWxlJyB8fCBpc09uKGtleSkpIHtcclxuICAgICAgICAgICAgKHJlcyB8fCAocmVzID0ge30pKVtrZXldID0gYXR0cnNba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59O1xyXG5jb25zdCBmaWx0ZXJNb2RlbExpc3RlbmVycyA9IChhdHRycywgcHJvcHMpID0+IHtcclxuICAgIGNvbnN0IHJlcyA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcclxuICAgICAgICBpZiAoIWlzTW9kZWxMaXN0ZW5lcihrZXkpIHx8ICEoa2V5LnNsaWNlKDkpIGluIHByb3BzKSkge1xyXG4gICAgICAgICAgICByZXNba2V5XSA9IGF0dHJzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufTtcclxuY29uc3QgaXNFbGVtZW50Um9vdCA9ICh2bm9kZSkgPT4ge1xyXG4gICAgcmV0dXJuICh2bm9kZS5zaGFwZUZsYWcgJiAoNiAvKiBDT01QT05FTlQgKi8gfCAxIC8qIEVMRU1FTlQgKi8pIHx8XHJcbiAgICAgICAgdm5vZGUudHlwZSA9PT0gQ29tbWVudCAvLyBwb3RlbnRpYWwgdi1pZiBicmFuY2ggc3dpdGNoXHJcbiAgICApO1xyXG59O1xyXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVDb21wb25lbnQocHJldlZOb2RlLCBuZXh0Vk5vZGUsIG9wdGltaXplZCkge1xyXG4gICAgY29uc3QgeyBwcm9wczogcHJldlByb3BzLCBjaGlsZHJlbjogcHJldkNoaWxkcmVuLCBjb21wb25lbnQgfSA9IHByZXZWTm9kZTtcclxuICAgIGNvbnN0IHsgcHJvcHM6IG5leHRQcm9wcywgY2hpbGRyZW46IG5leHRDaGlsZHJlbiwgcGF0Y2hGbGFnIH0gPSBuZXh0Vk5vZGU7XHJcbiAgICBjb25zdCBlbWl0cyA9IGNvbXBvbmVudC5lbWl0c09wdGlvbnM7XHJcbiAgICAvLyBQYXJlbnQgY29tcG9uZW50J3MgcmVuZGVyIGZ1bmN0aW9uIHdhcyBob3QtdXBkYXRlZC4gU2luY2UgdGhpcyBtYXkgaGF2ZVxyXG4gICAgLy8gY2F1c2VkIHRoZSBjaGlsZCBjb21wb25lbnQncyBzbG90cyBjb250ZW50IHRvIGhhdmUgY2hhbmdlZCwgd2UgbmVlZCB0b1xyXG4gICAgLy8gZm9yY2UgdGhlIGNoaWxkIHRvIHVwZGF0ZSBhcyB3ZWxsLlxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAocHJldkNoaWxkcmVuIHx8IG5leHRDaGlsZHJlbikgJiYgaXNIbXJVcGRhdGluZykge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy8gZm9yY2UgY2hpbGQgdXBkYXRlIGZvciBydW50aW1lIGRpcmVjdGl2ZSBvciB0cmFuc2l0aW9uIG9uIGNvbXBvbmVudCB2bm9kZS5cclxuICAgIGlmIChuZXh0Vk5vZGUuZGlycyB8fCBuZXh0Vk5vZGUudHJhbnNpdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGltaXplZCAmJiBwYXRjaEZsYWcgPj0gMCkge1xyXG4gICAgICAgIGlmIChwYXRjaEZsYWcgJiAxMDI0IC8qIERZTkFNSUNfU0xPVFMgKi8pIHtcclxuICAgICAgICAgICAgLy8gc2xvdCBjb250ZW50IHRoYXQgcmVmZXJlbmNlcyB2YWx1ZXMgdGhhdCBtaWdodCBoYXZlIGNoYW5nZWQsXHJcbiAgICAgICAgICAgIC8vIGUuZy4gaW4gYSB2LWZvclxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDE2IC8qIEZVTExfUFJPUFMgKi8pIHtcclxuICAgICAgICAgICAgaWYgKCFwcmV2UHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhIW5leHRQcm9wcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBwcmVzZW5jZSBvZiB0aGlzIGZsYWcgaW5kaWNhdGVzIHByb3BzIGFyZSBhbHdheXMgbm9uLW51bGxcclxuICAgICAgICAgICAgcmV0dXJuIGhhc1Byb3BzQ2hhbmdlZChwcmV2UHJvcHMsIG5leHRQcm9wcywgZW1pdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwYXRjaEZsYWcgJiA4IC8qIFBST1BTICovKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGR5bmFtaWNQcm9wcyA9IG5leHRWTm9kZS5keW5hbWljUHJvcHM7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHluYW1pY1Byb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBkeW5hbWljUHJvcHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dFByb3BzW2tleV0gIT09IHByZXZQcm9wc1trZXldICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIWlzRW1pdExpc3RlbmVyKGVtaXRzLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyB0aGlzIHBhdGggaXMgb25seSB0YWtlbiBieSBtYW51YWxseSB3cml0dGVuIHJlbmRlciBmdW5jdGlvbnNcclxuICAgICAgICAvLyBzbyBwcmVzZW5jZSBvZiBhbnkgY2hpbGRyZW4gbGVhZHMgdG8gYSBmb3JjZWQgdXBkYXRlXHJcbiAgICAgICAgaWYgKHByZXZDaGlsZHJlbiB8fCBuZXh0Q2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4gfHwgIW5leHRDaGlsZHJlbi4kc3RhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJldlByb3BzID09PSBuZXh0UHJvcHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXByZXZQcm9wcykge1xyXG4gICAgICAgICAgICByZXR1cm4gISFuZXh0UHJvcHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbmV4dFByb3BzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0cyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0c09wdGlvbnMpIHtcclxuICAgIGNvbnN0IG5leHRLZXlzID0gT2JqZWN0LmtleXMobmV4dFByb3BzKTtcclxuICAgIGlmIChuZXh0S2V5cy5sZW5ndGggIT09IE9iamVjdC5rZXlzKHByZXZQcm9wcykubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHRLZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gbmV4dEtleXNbaV07XHJcbiAgICAgICAgaWYgKG5leHRQcm9wc1trZXldICE9PSBwcmV2UHJvcHNba2V5XSAmJlxyXG4gICAgICAgICAgICAhaXNFbWl0TGlzdGVuZXIoZW1pdHNPcHRpb25zLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiB1cGRhdGVIT0NIb3N0RWwoeyB2bm9kZSwgcGFyZW50IH0sIGVsIC8vIEhvc3ROb2RlXHJcbikge1xyXG4gICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQuc3ViVHJlZSA9PT0gdm5vZGUpIHtcclxuICAgICAgICAodm5vZGUgPSBwYXJlbnQudm5vZGUpLmVsID0gZWw7XHJcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcclxuICAgIH1cclxufVxuXG5jb25zdCBpc1N1c3BlbnNlID0gKHR5cGUpID0+IHR5cGUuX19pc1N1c3BlbnNlO1xyXG4vLyBTdXNwZW5zZSBleHBvc2VzIGEgY29tcG9uZW50LWxpa2UgQVBJLCBhbmQgaXMgdHJlYXRlZCBsaWtlIGEgY29tcG9uZW50XHJcbi8vIGluIHRoZSBjb21waWxlciwgYnV0IGludGVybmFsbHkgaXQncyBhIHNwZWNpYWwgYnVpbHQtaW4gdHlwZSB0aGF0IGhvb2tzXHJcbi8vIGRpcmVjdGx5IGludG8gdGhlIHJlbmRlcmVyLlxyXG5jb25zdCBTdXNwZW5zZUltcGwgPSB7XHJcbiAgICBuYW1lOiAnU3VzcGVuc2UnLFxyXG4gICAgLy8gSW4gb3JkZXIgdG8gbWFrZSBTdXNwZW5zZSB0cmVlLXNoYWthYmxlLCB3ZSBuZWVkIHRvIGF2b2lkIGltcG9ydGluZyBpdFxyXG4gICAgLy8gZGlyZWN0bHkgaW4gdGhlIHJlbmRlcmVyLiBUaGUgcmVuZGVyZXIgY2hlY2tzIGZvciB0aGUgX19pc1N1c3BlbnNlIGZsYWdcclxuICAgIC8vIG9uIGEgdm5vZGUncyB0eXBlIGFuZCBjYWxscyB0aGUgYHByb2Nlc3NgIG1ldGhvZCwgcGFzc2luZyBpbiByZW5kZXJlclxyXG4gICAgLy8gaW50ZXJuYWxzLlxyXG4gICAgX19pc1N1c3BlbnNlOiB0cnVlLFxyXG4gICAgcHJvY2VzcyhuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIFxyXG4gICAgLy8gcGxhdGZvcm0tc3BlY2lmaWMgaW1wbCBwYXNzZWQgZnJvbSByZW5kZXJlclxyXG4gICAgcmVuZGVyZXJJbnRlcm5hbHMpIHtcclxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBtb3VudFN1c3BlbnNlKG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXRjaFN1c3BlbnNlKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGh5ZHJhdGU6IGh5ZHJhdGVTdXNwZW5zZSxcclxuICAgIGNyZWF0ZTogY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSxcclxuICAgIG5vcm1hbGl6ZTogbm9ybWFsaXplU3VzcGVuc2VDaGlsZHJlblxyXG59O1xyXG4vLyBGb3JjZS1jYXN0ZWQgcHVibGljIHR5cGluZyBmb3IgaCBhbmQgVFNYIHByb3BzIGluZmVyZW5jZVxyXG5jb25zdCBTdXNwZW5zZSA9IChTdXNwZW5zZUltcGwgKTtcclxuZnVuY3Rpb24gdHJpZ2dlckV2ZW50KHZub2RlLCBuYW1lKSB7XHJcbiAgICBjb25zdCBldmVudExpc3RlbmVyID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHNbbmFtZV07XHJcbiAgICBpZiAoaXNGdW5jdGlvbihldmVudExpc3RlbmVyKSkge1xyXG4gICAgICAgIGV2ZW50TGlzdGVuZXIoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBtb3VudFN1c3BlbnNlKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscykge1xyXG4gICAgY29uc3QgeyBwOiBwYXRjaCwgbzogeyBjcmVhdGVFbGVtZW50IH0gfSA9IHJlbmRlcmVySW50ZXJuYWxzO1xyXG4gICAgY29uc3QgaGlkZGVuQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICBjb25zdCBzdXNwZW5zZSA9ICh2bm9kZS5zdXNwZW5zZSA9IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkodm5vZGUsIHBhcmVudFN1c3BlbnNlLCBwYXJlbnRDb21wb25lbnQsIGNvbnRhaW5lciwgaGlkZGVuQ29udGFpbmVyLCBhbmNob3IsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMpKTtcclxuICAgIC8vIHN0YXJ0IG1vdW50aW5nIHRoZSBjb250ZW50IHN1YnRyZWUgaW4gYW4gb2ZmLWRvbSBjb250YWluZXJcclxuICAgIHBhdGNoKG51bGwsIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gdm5vZGUuc3NDb250ZW50KSwgaGlkZGVuQ29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzKTtcclxuICAgIC8vIG5vdyBjaGVjayBpZiB3ZSBoYXZlIGVuY291bnRlcmVkIGFueSBhc3luYyBkZXBzXHJcbiAgICBpZiAoc3VzcGVuc2UuZGVwcyA+IDApIHtcclxuICAgICAgICAvLyBoYXMgYXN5bmNcclxuICAgICAgICAvLyBpbnZva2UgQGZhbGxiYWNrIGV2ZW50XHJcbiAgICAgICAgdHJpZ2dlckV2ZW50KHZub2RlLCAnb25QZW5kaW5nJyk7XHJcbiAgICAgICAgdHJpZ2dlckV2ZW50KHZub2RlLCAnb25GYWxsYmFjaycpO1xyXG4gICAgICAgIC8vIG1vdW50IHRoZSBmYWxsYmFjayB0cmVlXHJcbiAgICAgICAgcGF0Y2gobnVsbCwgdm5vZGUuc3NGYWxsYmFjaywgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgbnVsbCwgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcclxuICAgICAgICBpc1NWRywgc2xvdFNjb3BlSWRzKTtcclxuICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIHZub2RlLnNzRmFsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gU3VzcGVuc2UgaGFzIG5vIGFzeW5jIGRlcHMuIEp1c3QgcmVzb2x2ZS5cclxuICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcGF0Y2hTdXNwZW5zZShuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgeyBwOiBwYXRjaCwgdW06IHVubW91bnQsIG86IHsgY3JlYXRlRWxlbWVudCB9IH0pIHtcclxuICAgIGNvbnN0IHN1c3BlbnNlID0gKG4yLnN1c3BlbnNlID0gbjEuc3VzcGVuc2UpO1xyXG4gICAgc3VzcGVuc2Uudm5vZGUgPSBuMjtcclxuICAgIG4yLmVsID0gbjEuZWw7XHJcbiAgICBjb25zdCBuZXdCcmFuY2ggPSBuMi5zc0NvbnRlbnQ7XHJcbiAgICBjb25zdCBuZXdGYWxsYmFjayA9IG4yLnNzRmFsbGJhY2s7XHJcbiAgICBjb25zdCB7IGFjdGl2ZUJyYW5jaCwgcGVuZGluZ0JyYW5jaCwgaXNJbkZhbGxiYWNrLCBpc0h5ZHJhdGluZyB9ID0gc3VzcGVuc2U7XHJcbiAgICBpZiAocGVuZGluZ0JyYW5jaCkge1xyXG4gICAgICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSBuZXdCcmFuY2g7XHJcbiAgICAgICAgaWYgKGlzU2FtZVZOb2RlVHlwZShuZXdCcmFuY2gsIHBlbmRpbmdCcmFuY2gpKSB7XHJcbiAgICAgICAgICAgIC8vIHNhbWUgcm9vdCB0eXBlIGJ1dCBjb250ZW50IG1heSBoYXZlIGNoYW5nZWQuXHJcbiAgICAgICAgICAgIHBhdGNoKHBlbmRpbmdCcmFuY2gsIG5ld0JyYW5jaCwgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNJbkZhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRjaChhY3RpdmVCcmFuY2gsIG5ld0ZhbGxiYWNrLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBudWxsLCAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxyXG4gICAgICAgICAgICAgICAgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3RmFsbGJhY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0b2dnbGVkIGJlZm9yZSBwZW5kaW5nIHRyZWUgaXMgcmVzb2x2ZWRcclxuICAgICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0lkKys7XHJcbiAgICAgICAgICAgIGlmIChpc0h5ZHJhdGluZykge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgdG9nZ2xlZCBiZWZvcmUgaHlkcmF0aW9uIGlzIGZpbmlzaGVkLCB0aGUgY3VycmVudCBET00gdHJlZSBpc1xyXG4gICAgICAgICAgICAgICAgLy8gbm8gbG9uZ2VyIHZhbGlkLiBzZXQgaXQgYXMgdGhlIGFjdGl2ZSBicmFuY2ggc28gaXQgd2lsbCBiZSB1bm1vdW50ZWRcclxuICAgICAgICAgICAgICAgIC8vIHdoZW4gcmVzb2x2ZWRcclxuICAgICAgICAgICAgICAgIHN1c3BlbnNlLmlzSHlkcmF0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggPSBwZW5kaW5nQnJhbmNoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdW5tb3VudChwZW5kaW5nQnJhbmNoLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpbmNyZW1lbnQgcGVuZGluZyBJRC4gdGhpcyBpcyB1c2VkIHRvIGludmFsaWRhdGUgYXN5bmMgY2FsbGJhY2tzXHJcbiAgICAgICAgICAgIC8vIHJlc2V0IHN1c3BlbnNlIHN0YXRlXHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmRlcHMgPSAwO1xyXG4gICAgICAgICAgICAvLyBkaXNjYXJkIGVmZmVjdHMgZnJvbSBwZW5kaW5nIGJyYW5jaFxyXG4gICAgICAgICAgICBzdXNwZW5zZS5lZmZlY3RzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIC8vIGRpc2NhcmQgcHJldmlvdXMgY29udGFpbmVyXHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICBpZiAoaXNJbkZhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IGluIGZhbGxiYWNrIHN0YXRlXHJcbiAgICAgICAgICAgICAgICBwYXRjaChudWxsLCBuZXdCcmFuY2gsIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaChhY3RpdmVCcmFuY2gsIG5ld0ZhbGxiYWNrLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBudWxsLCAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxyXG4gICAgICAgICAgICAgICAgICAgIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBuZXdGYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYWN0aXZlQnJhbmNoICYmIGlzU2FtZVZOb2RlVHlwZShuZXdCcmFuY2gsIGFjdGl2ZUJyYW5jaCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIHRvZ2dsZWQgXCJiYWNrXCIgdG8gY3VycmVudCBhY3RpdmUgYnJhbmNoXHJcbiAgICAgICAgICAgICAgICBwYXRjaChhY3RpdmVCcmFuY2gsIG5ld0JyYW5jaCwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICAvLyBmb3JjZSByZXNvbHZlXHJcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gc3dpdGNoZWQgdG8gYSAzcmQgYnJhbmNoXHJcbiAgICAgICAgICAgICAgICBwYXRjaChudWxsLCBuZXdCcmFuY2gsIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoYWN0aXZlQnJhbmNoICYmIGlzU2FtZVZOb2RlVHlwZShuZXdCcmFuY2gsIGFjdGl2ZUJyYW5jaCkpIHtcclxuICAgICAgICAgICAgLy8gcm9vdCBkaWQgbm90IGNoYW5nZSwganVzdCBub3JtYWwgcGF0Y2hcclxuICAgICAgICAgICAgcGF0Y2goYWN0aXZlQnJhbmNoLCBuZXdCcmFuY2gsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIG5ld0JyYW5jaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyByb290IG5vZGUgdG9nZ2xlZFxyXG4gICAgICAgICAgICAvLyBpbnZva2UgQHBlbmRpbmcgZXZlbnRcclxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KG4yLCAnb25QZW5kaW5nJyk7XHJcbiAgICAgICAgICAgIC8vIG1vdW50IHBlbmRpbmcgYnJhbmNoIGluIG9mZi1kb20gY29udGFpbmVyXHJcbiAgICAgICAgICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSBuZXdCcmFuY2g7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLnBlbmRpbmdJZCsrO1xyXG4gICAgICAgICAgICBwYXRjaChudWxsLCBuZXdCcmFuY2gsIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gaW5jb21pbmcgYnJhbmNoIGhhcyBubyBhc3luYyBkZXBzLCByZXNvbHZlIG5vdy5cclxuICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgdGltZW91dCwgcGVuZGluZ0lkIH0gPSBzdXNwZW5zZTtcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VzcGVuc2UucGVuZGluZ0lkID09PSBwZW5kaW5nSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLmZhbGxiYWNrKG5ld0ZhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGltZW91dCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLmZhbGxiYWNrKG5ld0ZhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5sZXQgaGFzV2FybmVkID0gZmFsc2U7XHJcbmZ1bmN0aW9uIGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkodm5vZGUsIHBhcmVudCwgcGFyZW50Q29tcG9uZW50LCBjb250YWluZXIsIGhpZGRlbkNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBpc0h5ZHJhdGluZyA9IGZhbHNlKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWZhbHNlICYmICFoYXNXYXJuZWQpIHtcclxuICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xyXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgYGNvbnNvbGUuaW5mb2AgY2Fubm90IGJlIG51bGwgZXJyb3JcclxuICAgICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShgPFN1c3BlbnNlPiBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZSBhbmQgaXRzIEFQSSB3aWxsIGxpa2VseSBjaGFuZ2UuYCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IHA6IHBhdGNoLCBtOiBtb3ZlLCB1bTogdW5tb3VudCwgbjogbmV4dCwgbzogeyBwYXJlbnROb2RlLCByZW1vdmUgfSB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XHJcbiAgICBjb25zdCB0aW1lb3V0ID0gdG9OdW1iZXIodm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudGltZW91dCk7XHJcbiAgICBjb25zdCBzdXNwZW5zZSA9IHtcclxuICAgICAgICB2bm9kZSxcclxuICAgICAgICBwYXJlbnQsXHJcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgIGlzU1ZHLFxyXG4gICAgICAgIGNvbnRhaW5lcixcclxuICAgICAgICBoaWRkZW5Db250YWluZXIsXHJcbiAgICAgICAgYW5jaG9yLFxyXG4gICAgICAgIGRlcHM6IDAsXHJcbiAgICAgICAgcGVuZGluZ0lkOiAwLFxyXG4gICAgICAgIHRpbWVvdXQ6IHR5cGVvZiB0aW1lb3V0ID09PSAnbnVtYmVyJyA/IHRpbWVvdXQgOiAtMSxcclxuICAgICAgICBhY3RpdmVCcmFuY2g6IG51bGwsXHJcbiAgICAgICAgcGVuZGluZ0JyYW5jaDogbnVsbCxcclxuICAgICAgICBpc0luRmFsbGJhY2s6IHRydWUsXHJcbiAgICAgICAgaXNIeWRyYXRpbmcsXHJcbiAgICAgICAgaXNVbm1vdW50ZWQ6IGZhbHNlLFxyXG4gICAgICAgIGVmZmVjdHM6IFtdLFxyXG4gICAgICAgIHJlc29sdmUocmVzdW1lID0gZmFsc2UpIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bWUgJiYgIXN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN1c3BlbnNlLnJlc29sdmUoKSBpcyBjYWxsZWQgd2l0aG91dCBhIHBlbmRpbmcgYnJhbmNoLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmlzVW5tb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdXNwZW5zZS5yZXNvbHZlKCkgaXMgY2FsbGVkIG9uIGFuIGFscmVhZHkgdW5tb3VudGVkIHN1c3BlbnNlIGJvdW5kYXJ5LmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdm5vZGUsIGFjdGl2ZUJyYW5jaCwgcGVuZGluZ0JyYW5jaCwgcGVuZGluZ0lkLCBlZmZlY3RzLCBwYXJlbnRDb21wb25lbnQsIGNvbnRhaW5lciB9ID0gc3VzcGVuc2U7XHJcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5pc0h5ZHJhdGluZykge1xyXG4gICAgICAgICAgICAgICAgc3VzcGVuc2UuaXNIeWRyYXRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghcmVzdW1lKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkZWxheUVudGVyID0gYWN0aXZlQnJhbmNoICYmXHJcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0JyYW5jaC50cmFuc2l0aW9uICYmXHJcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0JyYW5jaC50cmFuc2l0aW9uLm1vZGUgPT09ICdvdXQtaW4nO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlbGF5RW50ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBhY3RpdmVCcmFuY2gudHJhbnNpdGlvbi5hZnRlckxlYXZlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVuZGluZ0lkID09PSBzdXNwZW5zZS5wZW5kaW5nSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdmUocGVuZGluZ0JyYW5jaCwgY29udGFpbmVyLCBhbmNob3IsIDAgLyogRU5URVIgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgaW5pdGlhbCBhbmNob3Igb24gbW91bnRcclxuICAgICAgICAgICAgICAgIGxldCB7IGFuY2hvciB9ID0gc3VzcGVuc2U7XHJcbiAgICAgICAgICAgICAgICAvLyB1bm1vdW50IGN1cnJlbnQgYWN0aXZlIHRyZWVcclxuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVCcmFuY2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZmFsbGJhY2sgdHJlZSB3YXMgbW91bnRlZCwgaXQgbWF5IGhhdmUgYmVlbiBtb3ZlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIHBhcnQgb2YgYSBwYXJlbnQgc3VzcGVuc2UuIGdldCB0aGUgbGF0ZXN0IGFuY2hvciBmb3IgaW5zZXJ0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yID0gbmV4dChhY3RpdmVCcmFuY2gpO1xyXG4gICAgICAgICAgICAgICAgICAgIHVubW91bnQoYWN0aXZlQnJhbmNoLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghZGVsYXlFbnRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgY29udGVudCBmcm9tIG9mZi1kb20gY29udGFpbmVyIHRvIGFjdHVhbCBjb250YWluZXJcclxuICAgICAgICAgICAgICAgICAgICBtb3ZlKHBlbmRpbmdCcmFuY2gsIGNvbnRhaW5lciwgYW5jaG9yLCAwIC8qIEVOVEVSICovKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIHBlbmRpbmdCcmFuY2gpO1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gbnVsbDtcclxuICAgICAgICAgICAgc3VzcGVuc2UuaXNJbkZhbGxiYWNrID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vIGZsdXNoIGJ1ZmZlcmVkIGVmZmVjdHNcclxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgaXMgYSBwZW5kaW5nIHBhcmVudCBzdXNwZW5zZVxyXG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gc3VzcGVuc2UucGFyZW50O1xyXG4gICAgICAgICAgICBsZXQgaGFzVW5yZXNvbHZlZEFuY2VzdG9yID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQucGVuZGluZ0JyYW5jaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvdW5kIGEgcGVuZGluZyBwYXJlbnQgc3VzcGVuc2UsIG1lcmdlIGJ1ZmZlcmVkIHBvc3Qgam9ic1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGludG8gdGhhdCBwYXJlbnRcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuZWZmZWN0cy5wdXNoKC4uLmVmZmVjdHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc1VucmVzb2x2ZWRBbmNlc3RvciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG5vIHBlbmRpbmcgcGFyZW50IHN1c3BlbnNlLCBmbHVzaCBhbGwgam9ic1xyXG4gICAgICAgICAgICBpZiAoIWhhc1VucmVzb2x2ZWRBbmNlc3Rvcikge1xyXG4gICAgICAgICAgICAgICAgcXVldWVQb3N0Rmx1c2hDYihlZmZlY3RzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdXNwZW5zZS5lZmZlY3RzID0gW107XHJcbiAgICAgICAgICAgIC8vIGludm9rZSBAcmVzb2x2ZSBldmVudFxyXG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQodm5vZGUsICdvblJlc29sdmUnKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZhbGxiYWNrKGZhbGxiYWNrVk5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKCFzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgeyB2bm9kZSwgYWN0aXZlQnJhbmNoLCBwYXJlbnRDb21wb25lbnQsIGNvbnRhaW5lciwgaXNTVkcgfSA9IHN1c3BlbnNlO1xyXG4gICAgICAgICAgICAvLyBpbnZva2UgQGZhbGxiYWNrIGV2ZW50XHJcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudCh2bm9kZSwgJ29uRmFsbGJhY2snKTtcclxuICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gbmV4dChhY3RpdmVCcmFuY2gpO1xyXG4gICAgICAgICAgICBjb25zdCBtb3VudEZhbGxiYWNrID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzdXNwZW5zZS5pc0luRmFsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBtb3VudCB0aGUgZmFsbGJhY2sgdHJlZVxyXG4gICAgICAgICAgICAgICAgcGF0Y2gobnVsbCwgZmFsbGJhY2tWTm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgbnVsbCwgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcclxuICAgICAgICAgICAgICAgIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIGZhbGxiYWNrVk5vZGUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBkZWxheUVudGVyID0gZmFsbGJhY2tWTm9kZS50cmFuc2l0aW9uICYmIGZhbGxiYWNrVk5vZGUudHJhbnNpdGlvbi5tb2RlID09PSAnb3V0LWluJztcclxuICAgICAgICAgICAgaWYgKGRlbGF5RW50ZXIpIHtcclxuICAgICAgICAgICAgICAgIGFjdGl2ZUJyYW5jaC50cmFuc2l0aW9uLmFmdGVyTGVhdmUgPSBtb3VudEZhbGxiYWNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmlzSW5GYWxsYmFjayA9IHRydWU7XHJcbiAgICAgICAgICAgIC8vIHVubW91bnQgY3VycmVudCBhY3RpdmUgYnJhbmNoXHJcbiAgICAgICAgICAgIHVubW91bnQoYWN0aXZlQnJhbmNoLCBwYXJlbnRDb21wb25lbnQsIG51bGwsIC8vIG5vIHN1c3BlbnNlIHNvIHVubW91bnQgaG9va3MgZmlyZSBub3dcclxuICAgICAgICAgICAgdHJ1ZSAvLyBzaG91bGRSZW1vdmVcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgaWYgKCFkZWxheUVudGVyKSB7XHJcbiAgICAgICAgICAgICAgICBtb3VudEZhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG1vdmUoY29udGFpbmVyLCBhbmNob3IsIHR5cGUpIHtcclxuICAgICAgICAgICAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoICYmXHJcbiAgICAgICAgICAgICAgICBtb3ZlKHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCwgY29udGFpbmVyLCBhbmNob3IsIHR5cGUpO1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBuZXh0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VzcGVuc2UuYWN0aXZlQnJhbmNoICYmIG5leHQoc3VzcGVuc2UuYWN0aXZlQnJhbmNoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlZ2lzdGVyRGVwKGluc3RhbmNlLCBzZXR1cFJlbmRlckVmZmVjdCkge1xyXG4gICAgICAgICAgICBjb25zdCBpc0luUGVuZGluZ1N1c3BlbnNlID0gISFzdXNwZW5zZS5wZW5kaW5nQnJhbmNoO1xyXG4gICAgICAgICAgICBpZiAoaXNJblBlbmRpbmdTdXNwZW5zZSkge1xyXG4gICAgICAgICAgICAgICAgc3VzcGVuc2UuZGVwcysrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGh5ZHJhdGVkRWwgPSBpbnN0YW5jZS52bm9kZS5lbDtcclxuICAgICAgICAgICAgaW5zdGFuY2VcclxuICAgICAgICAgICAgICAgIC5hc3luY0RlcC5jYXRjaChlcnIgPT4ge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgMCAvKiBTRVRVUF9GVU5DVElPTiAqLyk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGhlbihhc3luY1NldHVwUmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIHJldHJ5IHdoZW4gdGhlIHNldHVwKCkgcHJvbWlzZSByZXNvbHZlcy5cclxuICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudCBtYXkgaGF2ZSBiZWVuIHVubW91bnRlZCBiZWZvcmUgcmVzb2x2ZS5cclxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5pc1VubW91bnRlZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLmlzVW5tb3VudGVkIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0lkICE9PSBpbnN0YW5jZS5zdXNwZW5zZUlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gcmV0cnkgZnJvbSB0aGlzIGNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuYXN5bmNSZXNvbHZlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZub2RlIH0gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQodm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIGFzeW5jU2V0dXBSZXN1bHQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGlmIChoeWRyYXRlZEVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdm5vZGUgbWF5IGhhdmUgYmVlbiByZXBsYWNlZCBpZiBhbiB1cGRhdGUgaGFwcGVuZWQgYmVmb3JlIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzeW5jIGRlcCBpcyByZXNvbHZlZC5cclxuICAgICAgICAgICAgICAgICAgICB2bm9kZS5lbCA9IGh5ZHJhdGVkRWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9ICFoeWRyYXRlZEVsICYmIGluc3RhbmNlLnN1YlRyZWUuZWw7XHJcbiAgICAgICAgICAgICAgICBzZXR1cFJlbmRlckVmZmVjdChpbnN0YW5jZSwgdm5vZGUsIFxyXG4gICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IG1heSBoYXZlIGJlZW4gbW92ZWQgYmVmb3JlIHJlc29sdmUuXHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGlzIG5vdCBhIGh5ZHJhdGlvbiwgaW5zdGFuY2Uuc3ViVHJlZSB3aWxsIGJlIHRoZSBjb21tZW50XHJcbiAgICAgICAgICAgICAgICAvLyBwbGFjZWhvbGRlci5cclxuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUoaHlkcmF0ZWRFbCB8fCBpbnN0YW5jZS5zdWJUcmVlLmVsKSwgXHJcbiAgICAgICAgICAgICAgICAvLyBhbmNob3Igd2lsbCBub3QgYmUgdXNlZCBpZiB0aGlzIGlzIGh5ZHJhdGlvbiwgc28gb25seSBuZWVkIHRvXHJcbiAgICAgICAgICAgICAgICAvLyBjb25zaWRlciB0aGUgY29tbWVudCBwbGFjZWhvbGRlciBjYXNlLlxyXG4gICAgICAgICAgICAgICAgaHlkcmF0ZWRFbCA/IG51bGwgOiBuZXh0KGluc3RhbmNlLnN1YlRyZWUpLCBzdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocGxhY2Vob2xkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmUocGxhY2Vob2xkZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdXBkYXRlSE9DSG9zdEVsKGluc3RhbmNlLCB2bm9kZS5lbCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG9ubHkgZGVjcmVhc2UgZGVwcyBjb3VudCBpZiBzdXNwZW5zZSBpcyBub3QgYWxyZWFkeSByZXNvbHZlZFxyXG4gICAgICAgICAgICAgICAgaWYgKGlzSW5QZW5kaW5nU3VzcGVuc2UgJiYgLS1zdXNwZW5zZS5kZXBzID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVubW91bnQocGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKSB7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmlzVW5tb3VudGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCkge1xyXG4gICAgICAgICAgICAgICAgdW5tb3VudChzdXNwZW5zZS5hY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xyXG4gICAgICAgICAgICAgICAgdW5tb3VudChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHN1c3BlbnNlO1xyXG59XHJcbmZ1bmN0aW9uIGh5ZHJhdGVTdXNwZW5zZShub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgaHlkcmF0ZU5vZGUpIHtcclxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xyXG4gICAgY29uc3Qgc3VzcGVuc2UgPSAodm5vZGUuc3VzcGVuc2UgPSBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KHZub2RlLCBwYXJlbnRTdXNwZW5zZSwgcGFyZW50Q29tcG9uZW50LCBub2RlLnBhcmVudE5vZGUsIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLCBudWxsLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCB0cnVlIC8qIGh5ZHJhdGluZyAqLykpO1xyXG4gICAgLy8gdGhlcmUgYXJlIHR3byBwb3NzaWJsZSBzY2VuYXJpb3MgZm9yIHNlcnZlci1yZW5kZXJlZCBzdXNwZW5zZTpcclxuICAgIC8vIC0gc3VjY2Vzczogc3NyIGNvbnRlbnQgc2hvdWxkIGJlIGZ1bGx5IHJlc29sdmVkXHJcbiAgICAvLyAtIGZhaWx1cmU6IHNzciBjb250ZW50IHNob3VsZCBiZSB0aGUgZmFsbGJhY2sgYnJhbmNoLlxyXG4gICAgLy8gaG93ZXZlciwgb24gdGhlIGNsaWVudCB3ZSBkb24ndCByZWFsbHkga25vdyBpZiBpdCBoYXMgZmFpbGVkIG9yIG5vdFxyXG4gICAgLy8gYXR0ZW1wdCB0byBoeWRyYXRlIHRoZSBET00gYXNzdW1pbmcgaXQgaGFzIHN1Y2NlZWRlZCwgYnV0IHdlIHN0aWxsXHJcbiAgICAvLyBuZWVkIHRvIGNvbnN0cnVjdCBhIHN1c3BlbnNlIGJvdW5kYXJ5IGZpcnN0XHJcbiAgICBjb25zdCByZXN1bHQgPSBoeWRyYXRlTm9kZShub2RlLCAoc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IHZub2RlLnNzQ29udGVudCksIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgIGlmIChzdXNwZW5zZS5kZXBzID09PSAwKSB7XHJcbiAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIC8qIGVzbGludC1lbmFibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplU3VzcGVuc2VDaGlsZHJlbih2bm9kZSkge1xyXG4gICAgY29uc3QgeyBzaGFwZUZsYWcsIGNoaWxkcmVuIH0gPSB2bm9kZTtcclxuICAgIGNvbnN0IGlzU2xvdENoaWxkcmVuID0gc2hhcGVGbGFnICYgMzIgLyogU0xPVFNfQ0hJTERSRU4gKi87XHJcbiAgICB2bm9kZS5zc0NvbnRlbnQgPSBub3JtYWxpemVTdXNwZW5zZVNsb3QoaXNTbG90Q2hpbGRyZW4gPyBjaGlsZHJlbi5kZWZhdWx0IDogY2hpbGRyZW4pO1xyXG4gICAgdm5vZGUuc3NGYWxsYmFjayA9IGlzU2xvdENoaWxkcmVuXHJcbiAgICAgICAgPyBub3JtYWxpemVTdXNwZW5zZVNsb3QoY2hpbGRyZW4uZmFsbGJhY2spXHJcbiAgICAgICAgOiBjcmVhdGVWTm9kZShDb21tZW50KTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVTdXNwZW5zZVNsb3Qocykge1xyXG4gICAgbGV0IGJsb2NrO1xyXG4gICAgaWYgKGlzRnVuY3Rpb24ocykpIHtcclxuICAgICAgICBjb25zdCB0cmFja0Jsb2NrID0gaXNCbG9ja1RyZWVFbmFibGVkICYmIHMuX2M7XHJcbiAgICAgICAgaWYgKHRyYWNrQmxvY2spIHtcclxuICAgICAgICAgICAgLy8gZGlzYWJsZVRyYWNraW5nOiBmYWxzZVxyXG4gICAgICAgICAgICAvLyBhbGxvdyBibG9jayB0cmFja2luZyBmb3IgY29tcGlsZWQgc2xvdHNcclxuICAgICAgICAgICAgLy8gKHNlZSAuL2NvbXBvbmVudFJlbmRlckNvbnRleHQudHMpXHJcbiAgICAgICAgICAgIHMuX2QgPSBmYWxzZTtcclxuICAgICAgICAgICAgb3BlbkJsb2NrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHMgPSBzKCk7XHJcbiAgICAgICAgaWYgKHRyYWNrQmxvY2spIHtcclxuICAgICAgICAgICAgcy5fZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGJsb2NrID0gY3VycmVudEJsb2NrO1xyXG4gICAgICAgICAgICBjbG9zZUJsb2NrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGlzQXJyYXkocykpIHtcclxuICAgICAgICBjb25zdCBzaW5nbGVDaGlsZCA9IGZpbHRlclNpbmdsZVJvb3Qocyk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhc2luZ2xlQ2hpbGQpIHtcclxuICAgICAgICAgICAgd2FybihgPFN1c3BlbnNlPiBzbG90cyBleHBlY3QgYSBzaW5nbGUgcm9vdCBub2RlLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzID0gc2luZ2xlQ2hpbGQ7XHJcbiAgICB9XHJcbiAgICBzID0gbm9ybWFsaXplVk5vZGUocyk7XHJcbiAgICBpZiAoYmxvY2sgJiYgIXMuZHluYW1pY0NoaWxkcmVuKSB7XHJcbiAgICAgICAgcy5keW5hbWljQ2hpbGRyZW4gPSBibG9jay5maWx0ZXIoYyA9PiBjICE9PSBzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlKGZuLCBzdXNwZW5zZSkge1xyXG4gICAgaWYgKHN1c3BlbnNlICYmIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcclxuICAgICAgICBpZiAoaXNBcnJheShmbikpIHtcclxuICAgICAgICAgICAgc3VzcGVuc2UuZWZmZWN0cy5wdXNoKC4uLmZuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmVmZmVjdHMucHVzaChmbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcXVldWVQb3N0Rmx1c2hDYihmbik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBicmFuY2gpIHtcclxuICAgIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCA9IGJyYW5jaDtcclxuICAgIGNvbnN0IHsgdm5vZGUsIHBhcmVudENvbXBvbmVudCB9ID0gc3VzcGVuc2U7XHJcbiAgICBjb25zdCBlbCA9ICh2bm9kZS5lbCA9IGJyYW5jaC5lbCk7XHJcbiAgICAvLyBpbiBjYXNlIHN1c3BlbnNlIGlzIHRoZSByb290IG5vZGUgb2YgYSBjb21wb25lbnQsXHJcbiAgICAvLyByZWN1cnNpdmVseSB1cGRhdGUgdGhlIEhPQyBlbFxyXG4gICAgaWYgKHBhcmVudENvbXBvbmVudCAmJiBwYXJlbnRDb21wb25lbnQuc3ViVHJlZSA9PT0gdm5vZGUpIHtcclxuICAgICAgICBwYXJlbnRDb21wb25lbnQudm5vZGUuZWwgPSBlbDtcclxuICAgICAgICB1cGRhdGVIT0NIb3N0RWwocGFyZW50Q29tcG9uZW50LCBlbCk7XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gcHJvdmlkZShrZXksIHZhbHVlKSB7XHJcbiAgICBpZiAoIWN1cnJlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgd2FybihgcHJvdmlkZSgpIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHNldHVwKCkuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGV0IHByb3ZpZGVzID0gY3VycmVudEluc3RhbmNlLnByb3ZpZGVzO1xyXG4gICAgICAgIC8vIGJ5IGRlZmF1bHQgYW4gaW5zdGFuY2UgaW5oZXJpdHMgaXRzIHBhcmVudCdzIHByb3ZpZGVzIG9iamVjdFxyXG4gICAgICAgIC8vIGJ1dCB3aGVuIGl0IG5lZWRzIHRvIHByb3ZpZGUgdmFsdWVzIG9mIGl0cyBvd24sIGl0IGNyZWF0ZXMgaXRzXHJcbiAgICAgICAgLy8gb3duIHByb3ZpZGVzIG9iamVjdCB1c2luZyBwYXJlbnQgcHJvdmlkZXMgb2JqZWN0IGFzIHByb3RvdHlwZS5cclxuICAgICAgICAvLyB0aGlzIHdheSBpbiBgaW5qZWN0YCB3ZSBjYW4gc2ltcGx5IGxvb2sgdXAgaW5qZWN0aW9ucyBmcm9tIGRpcmVjdFxyXG4gICAgICAgIC8vIHBhcmVudCBhbmQgbGV0IHRoZSBwcm90b3R5cGUgY2hhaW4gZG8gdGhlIHdvcmsuXHJcbiAgICAgICAgY29uc3QgcGFyZW50UHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucGFyZW50ICYmIGN1cnJlbnRJbnN0YW5jZS5wYXJlbnQucHJvdmlkZXM7XHJcbiAgICAgICAgaWYgKHBhcmVudFByb3ZpZGVzID09PSBwcm92aWRlcykge1xyXG4gICAgICAgICAgICBwcm92aWRlcyA9IGN1cnJlbnRJbnN0YW5jZS5wcm92aWRlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50UHJvdmlkZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUUyBkb2Vzbid0IGFsbG93IHN5bWJvbCBhcyBpbmRleCB0eXBlXHJcbiAgICAgICAgcHJvdmlkZXNba2V5XSA9IHZhbHVlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGluamVjdChrZXksIGRlZmF1bHRWYWx1ZSwgdHJlYXREZWZhdWx0QXNGYWN0b3J5ID0gZmFsc2UpIHtcclxuICAgIC8vIGZhbGxiYWNrIHRvIGBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2VgIHNvIHRoYXQgdGhpcyBjYW4gYmUgY2FsbGVkIGluXHJcbiAgICAvLyBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZSB8fCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XHJcbiAgICBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICAvLyAjMjQwMFxyXG4gICAgICAgIC8vIHRvIHN1cHBvcnQgYGFwcC51c2VgIHBsdWdpbnMsXHJcbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gYXBwQ29udGV4dCdzIGBwcm92aWRlc2AgaWYgdGhlIGluc3RhbmNlIGlzIGF0IHJvb3RcclxuICAgICAgICBjb25zdCBwcm92aWRlcyA9IGluc3RhbmNlLnBhcmVudCA9PSBudWxsXHJcbiAgICAgICAgICAgID8gaW5zdGFuY2Uudm5vZGUuYXBwQ29udGV4dCAmJiBpbnN0YW5jZS52bm9kZS5hcHBDb250ZXh0LnByb3ZpZGVzXHJcbiAgICAgICAgICAgIDogaW5zdGFuY2UucGFyZW50LnByb3ZpZGVzO1xyXG4gICAgICAgIGlmIChwcm92aWRlcyAmJiBrZXkgaW4gcHJvdmlkZXMpIHtcclxuICAgICAgICAgICAgLy8gVFMgZG9lc24ndCBhbGxvdyBzeW1ib2wgYXMgaW5kZXggdHlwZVxyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXNba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSAmJiBpc0Z1bmN0aW9uKGRlZmF1bHRWYWx1ZSlcclxuICAgICAgICAgICAgICAgID8gZGVmYXVsdFZhbHVlLmNhbGwoaW5zdGFuY2UucHJveHkpXHJcbiAgICAgICAgICAgICAgICA6IGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYGluamVjdGlvbiBcIiR7U3RyaW5nKGtleSl9XCIgbm90IGZvdW5kLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm4oYGluamVjdCgpIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHNldHVwKCkgb3IgZnVuY3Rpb25hbCBjb21wb25lbnRzLmApO1xyXG4gICAgfVxyXG59XG5cbi8vIFNpbXBsZSBlZmZlY3QuXHJcbmZ1bmN0aW9uIHdhdGNoRWZmZWN0KGVmZmVjdCwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGRvV2F0Y2goZWZmZWN0LCBudWxsLCBvcHRpb25zKTtcclxufVxyXG5mdW5jdGlvbiB3YXRjaFBvc3RFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gZG9XYXRjaChlZmZlY3QsIG51bGwsICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICA/IE9iamVjdC5hc3NpZ24ob3B0aW9ucyB8fCB7fSwgeyBmbHVzaDogJ3Bvc3QnIH0pXHJcbiAgICAgICAgOiB7IGZsdXNoOiAncG9zdCcgfSkpO1xyXG59XHJcbmZ1bmN0aW9uIHdhdGNoU3luY0VmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBkb1dhdGNoKGVmZmVjdCwgbnVsbCwgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgID8gT2JqZWN0LmFzc2lnbihvcHRpb25zIHx8IHt9LCB7IGZsdXNoOiAnc3luYycgfSlcclxuICAgICAgICA6IHsgZmx1c2g6ICdzeW5jJyB9KSk7XHJcbn1cclxuLy8gaW5pdGlhbCB2YWx1ZSBmb3Igd2F0Y2hlcnMgdG8gdHJpZ2dlciBvbiB1bmRlZmluZWQgaW5pdGlhbCB2YWx1ZXNcclxuY29uc3QgSU5JVElBTF9XQVRDSEVSX1ZBTFVFID0ge307XHJcbi8vIGltcGxlbWVudGF0aW9uXHJcbmZ1bmN0aW9uIHdhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzRnVuY3Rpb24oY2IpKSB7XHJcbiAgICAgICAgd2FybihgXFxgd2F0Y2goZm4sIG9wdGlvbnM/KVxcYCBzaWduYXR1cmUgaGFzIGJlZW4gbW92ZWQgdG8gYSBzZXBhcmF0ZSBBUEkuIGAgK1xyXG4gICAgICAgICAgICBgVXNlIFxcYHdhdGNoRWZmZWN0KGZuLCBvcHRpb25zPylcXGAgaW5zdGVhZC4gXFxgd2F0Y2hcXGAgbm93IG9ubHkgYCArXHJcbiAgICAgICAgICAgIGBzdXBwb3J0cyBcXGB3YXRjaChzb3VyY2UsIGNiLCBvcHRpb25zPykgc2lnbmF0dXJlLmApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRvV2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gZG9XYXRjaChzb3VyY2UsIGNiLCB7IGltbWVkaWF0ZSwgZGVlcCwgZmx1c2gsIG9uVHJhY2ssIG9uVHJpZ2dlciB9ID0gRU1QVFlfT0JKKSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFjYikge1xyXG4gICAgICAgIGlmIChpbW1lZGlhdGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB3YXJuKGB3YXRjaCgpIFwiaW1tZWRpYXRlXCIgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgdGhlIGAgK1xyXG4gICAgICAgICAgICAgICAgYHdhdGNoKHNvdXJjZSwgY2FsbGJhY2ssIG9wdGlvbnM/KSBzaWduYXR1cmUuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZWVwICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgd2Fybihgd2F0Y2goKSBcImRlZXBcIiBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyB0aGUgYCArXHJcbiAgICAgICAgICAgICAgICBgd2F0Y2goc291cmNlLCBjYWxsYmFjaywgb3B0aW9ucz8pIHNpZ25hdHVyZS5gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCB3YXJuSW52YWxpZFNvdXJjZSA9IChzKSA9PiB7XHJcbiAgICAgICAgd2FybihgSW52YWxpZCB3YXRjaCBzb3VyY2U6IGAsIHMsIGBBIHdhdGNoIHNvdXJjZSBjYW4gb25seSBiZSBhIGdldHRlci9lZmZlY3QgZnVuY3Rpb24sIGEgcmVmLCBgICtcclxuICAgICAgICAgICAgYGEgcmVhY3RpdmUgb2JqZWN0LCBvciBhbiBhcnJheSBvZiB0aGVzZSB0eXBlcy5gKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZTtcclxuICAgIGxldCBnZXR0ZXI7XHJcbiAgICBsZXQgZm9yY2VUcmlnZ2VyID0gZmFsc2U7XHJcbiAgICBsZXQgaXNNdWx0aVNvdXJjZSA9IGZhbHNlO1xyXG4gICAgaWYgKGlzUmVmKHNvdXJjZSkpIHtcclxuICAgICAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2UudmFsdWU7XHJcbiAgICAgICAgZm9yY2VUcmlnZ2VyID0gaXNTaGFsbG93JDEoc291cmNlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzUmVhY3RpdmUoc291cmNlKSkge1xyXG4gICAgICAgIGdldHRlciA9ICgpID0+IHNvdXJjZTtcclxuICAgICAgICBkZWVwID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzQXJyYXkoc291cmNlKSkge1xyXG4gICAgICAgIGlzTXVsdGlTb3VyY2UgPSB0cnVlO1xyXG4gICAgICAgIGZvcmNlVHJpZ2dlciA9IHNvdXJjZS5zb21lKGlzUmVhY3RpdmUpO1xyXG4gICAgICAgIGdldHRlciA9ICgpID0+IHNvdXJjZS5tYXAocyA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpc1JlZihzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHMudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWFjdGl2ZShzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYXZlcnNlKHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24ocykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsV2l0aEVycm9ySGFuZGxpbmcocywgaW5zdGFuY2UsIDIgLyogV0FUQ0hfR0VUVEVSICovKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuSW52YWxpZFNvdXJjZShzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihzb3VyY2UpKSB7XHJcbiAgICAgICAgaWYgKGNiKSB7XHJcbiAgICAgICAgICAgIC8vIGdldHRlciB3aXRoIGNiXHJcbiAgICAgICAgICAgIGdldHRlciA9ICgpID0+IGNhbGxXaXRoRXJyb3JIYW5kbGluZyhzb3VyY2UsIGluc3RhbmNlLCAyIC8qIFdBVENIX0dFVFRFUiAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBubyBjYiAtPiBzaW1wbGUgZWZmZWN0XHJcbiAgICAgICAgICAgIGdldHRlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5pc1VubW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjbGVhbnVwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKHNvdXJjZSwgaW5zdGFuY2UsIDMgLyogV0FUQ0hfQ0FMTEJBQ0sgKi8sIFtvbkNsZWFudXBdKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBnZXR0ZXIgPSBOT09QO1xyXG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuSW52YWxpZFNvdXJjZShzb3VyY2UpO1xyXG4gICAgfVxyXG4gICAgaWYgKGNiICYmIGRlZXApIHtcclxuICAgICAgICBjb25zdCBiYXNlR2V0dGVyID0gZ2V0dGVyO1xyXG4gICAgICAgIGdldHRlciA9ICgpID0+IHRyYXZlcnNlKGJhc2VHZXR0ZXIoKSk7XHJcbiAgICB9XHJcbiAgICBsZXQgY2xlYW51cDtcclxuICAgIGxldCBvbkNsZWFudXAgPSAoZm4pID0+IHtcclxuICAgICAgICBjbGVhbnVwID0gZWZmZWN0Lm9uU3RvcCA9ICgpID0+IHtcclxuICAgICAgICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgNCAvKiBXQVRDSF9DTEVBTlVQICovKTtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIC8vIGluIFNTUiB0aGVyZSBpcyBubyBuZWVkIHRvIHNldHVwIGFuIGFjdHVhbCBlZmZlY3QsIGFuZCBpdCBzaG91bGQgYmUgbm9vcFxyXG4gICAgLy8gdW5sZXNzIGl0J3MgZWFnZXJcclxuICAgIGlmIChpc0luU1NSQ29tcG9uZW50U2V0dXApIHtcclxuICAgICAgICAvLyB3ZSB3aWxsIGFsc28gbm90IGNhbGwgdGhlIGludmFsaWRhdGUgY2FsbGJhY2sgKCsgcnVubmVyIGlzIG5vdCBzZXQgdXApXHJcbiAgICAgICAgb25DbGVhbnVwID0gTk9PUDtcclxuICAgICAgICBpZiAoIWNiKSB7XHJcbiAgICAgICAgICAgIGdldHRlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpbW1lZGlhdGUpIHtcclxuICAgICAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoY2IsIGluc3RhbmNlLCAzIC8qIFdBVENIX0NBTExCQUNLICovLCBbXHJcbiAgICAgICAgICAgICAgICBnZXR0ZXIoKSxcclxuICAgICAgICAgICAgICAgIGlzTXVsdGlTb3VyY2UgPyBbXSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIG9uQ2xlYW51cFxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE5PT1A7XHJcbiAgICB9XHJcbiAgICBsZXQgb2xkVmFsdWUgPSBpc011bHRpU291cmNlID8gW10gOiBJTklUSUFMX1dBVENIRVJfVkFMVUU7XHJcbiAgICBjb25zdCBqb2IgPSAoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFlZmZlY3QuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNiKSB7XHJcbiAgICAgICAgICAgIC8vIHdhdGNoKHNvdXJjZSwgY2IpXHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gZWZmZWN0LnJ1bigpO1xyXG4gICAgICAgICAgICBpZiAoZGVlcCB8fFxyXG4gICAgICAgICAgICAgICAgZm9yY2VUcmlnZ2VyIHx8XHJcbiAgICAgICAgICAgICAgICAoaXNNdWx0aVNvdXJjZVxyXG4gICAgICAgICAgICAgICAgICAgID8gbmV3VmFsdWUuc29tZSgodiwgaSkgPT4gaGFzQ2hhbmdlZCh2LCBvbGRWYWx1ZVtpXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBoYXNDaGFuZ2VkKG5ld1ZhbHVlLCBvbGRWYWx1ZSkpIHx8XHJcbiAgICAgICAgICAgICAgICAoZmFsc2UgICkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNsZWFudXAgYmVmb3JlIHJ1bm5pbmcgY2IgYWdhaW5cclxuICAgICAgICAgICAgICAgIGlmIChjbGVhbnVwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoY2IsIGluc3RhbmNlLCAzIC8qIFdBVENIX0NBTExCQUNLICovLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFzcyB1bmRlZmluZWQgYXMgdGhlIG9sZCB2YWx1ZSB3aGVuIGl0J3MgY2hhbmdlZCBmb3IgdGhlIGZpcnN0IHRpbWVcclxuICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9PT0gSU5JVElBTF9XQVRDSEVSX1ZBTFVFID8gdW5kZWZpbmVkIDogb2xkVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgb25DbGVhbnVwXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gbmV3VmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHdhdGNoRWZmZWN0XHJcbiAgICAgICAgICAgIGVmZmVjdC5ydW4oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gaW1wb3J0YW50OiBtYXJrIHRoZSBqb2IgYXMgYSB3YXRjaGVyIGNhbGxiYWNrIHNvIHRoYXQgc2NoZWR1bGVyIGtub3dzXHJcbiAgICAvLyBpdCBpcyBhbGxvd2VkIHRvIHNlbGYtdHJpZ2dlciAoIzE3MjcpXHJcbiAgICBqb2IuYWxsb3dSZWN1cnNlID0gISFjYjtcclxuICAgIGxldCBzY2hlZHVsZXI7XHJcbiAgICBpZiAoZmx1c2ggPT09ICdzeW5jJykge1xyXG4gICAgICAgIHNjaGVkdWxlciA9IGpvYjsgLy8gdGhlIHNjaGVkdWxlciBmdW5jdGlvbiBnZXRzIGNhbGxlZCBkaXJlY3RseVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZmx1c2ggPT09ICdwb3N0Jykge1xyXG4gICAgICAgIHNjaGVkdWxlciA9ICgpID0+IHF1ZXVlUG9zdFJlbmRlckVmZmVjdChqb2IsIGluc3RhbmNlICYmIGluc3RhbmNlLnN1c3BlbnNlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGRlZmF1bHQ6ICdwcmUnXHJcbiAgICAgICAgc2NoZWR1bGVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWluc3RhbmNlIHx8IGluc3RhbmNlLmlzTW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgcXVldWVQcmVGbHVzaENiKGpvYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyB3aXRoICdwcmUnIG9wdGlvbiwgdGhlIGZpcnN0IGNhbGwgbXVzdCBoYXBwZW4gYmVmb3JlXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQgc28gaXQgaXMgY2FsbGVkIHN5bmNocm9ub3VzbHkuXHJcbiAgICAgICAgICAgICAgICBqb2IoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjb25zdCBlZmZlY3QgPSBuZXcgUmVhY3RpdmVFZmZlY3QoZ2V0dGVyLCBzY2hlZHVsZXIpO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGVmZmVjdC5vblRyYWNrID0gb25UcmFjaztcclxuICAgICAgICBlZmZlY3Qub25UcmlnZ2VyID0gb25UcmlnZ2VyO1xyXG4gICAgfVxyXG4gICAgLy8gaW5pdGlhbCBydW5cclxuICAgIGlmIChjYikge1xyXG4gICAgICAgIGlmIChpbW1lZGlhdGUpIHtcclxuICAgICAgICAgICAgam9iKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvbGRWYWx1ZSA9IGVmZmVjdC5ydW4oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChmbHVzaCA9PT0gJ3Bvc3QnKSB7XHJcbiAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGVmZmVjdC5ydW4uYmluZChlZmZlY3QpLCBpbnN0YW5jZSAmJiBpbnN0YW5jZS5zdXNwZW5zZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBlZmZlY3QucnVuKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIGVmZmVjdC5zdG9wKCk7XHJcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLnNjb3BlKSB7XHJcbiAgICAgICAgICAgIHJlbW92ZShpbnN0YW5jZS5zY29wZS5lZmZlY3RzLCBlZmZlY3QpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuLy8gdGhpcy4kd2F0Y2hcclxuZnVuY3Rpb24gaW5zdGFuY2VXYXRjaChzb3VyY2UsIHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCBwdWJsaWNUaGlzID0gdGhpcy5wcm94eTtcclxuICAgIGNvbnN0IGdldHRlciA9IGlzU3RyaW5nKHNvdXJjZSlcclxuICAgICAgICA/IHNvdXJjZS5pbmNsdWRlcygnLicpXHJcbiAgICAgICAgICAgID8gY3JlYXRlUGF0aEdldHRlcihwdWJsaWNUaGlzLCBzb3VyY2UpXHJcbiAgICAgICAgICAgIDogKCkgPT4gcHVibGljVGhpc1tzb3VyY2VdXHJcbiAgICAgICAgOiBzb3VyY2UuYmluZChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKTtcclxuICAgIGxldCBjYjtcclxuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xyXG4gICAgICAgIGNiID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjYiA9IHZhbHVlLmhhbmRsZXI7XHJcbiAgICAgICAgb3B0aW9ucyA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY3VyID0gY3VycmVudEluc3RhbmNlO1xyXG4gICAgc2V0Q3VycmVudEluc3RhbmNlKHRoaXMpO1xyXG4gICAgY29uc3QgcmVzID0gZG9XYXRjaChnZXR0ZXIsIGNiLmJpbmQocHVibGljVGhpcyksIG9wdGlvbnMpO1xyXG4gICAgaWYgKGN1cikge1xyXG4gICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShjdXIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdW5zZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUGF0aEdldHRlcihjdHgsIHBhdGgpIHtcclxuICAgIGNvbnN0IHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICBsZXQgY3VyID0gY3R4O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoICYmIGN1cjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGN1ciA9IGN1cltzZWdtZW50c1tpXV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjdXI7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHRyYXZlcnNlKHZhbHVlLCBzZWVuKSB7XHJcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZVtcIl9fdl9za2lwXCIgLyogU0tJUCAqL10pIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZWVuID0gc2VlbiB8fCBuZXcgU2V0KCk7XHJcbiAgICBpZiAoc2Vlbi5oYXModmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2Vlbi5hZGQodmFsdWUpO1xyXG4gICAgaWYgKGlzUmVmKHZhbHVlKSkge1xyXG4gICAgICAgIHRyYXZlcnNlKHZhbHVlLnZhbHVlLCBzZWVuKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0cmF2ZXJzZSh2YWx1ZVtpXSwgc2Vlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNTZXQodmFsdWUpIHx8IGlzTWFwKHZhbHVlKSkge1xyXG4gICAgICAgIHZhbHVlLmZvckVhY2goKHYpID0+IHtcclxuICAgICAgICAgICAgdHJhdmVyc2Uodiwgc2Vlbik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRyYXZlcnNlKHZhbHVlW2tleV0sIHNlZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxuXG5mdW5jdGlvbiB1c2VUcmFuc2l0aW9uU3RhdGUoKSB7XHJcbiAgICBjb25zdCBzdGF0ZSA9IHtcclxuICAgICAgICBpc01vdW50ZWQ6IGZhbHNlLFxyXG4gICAgICAgIGlzTGVhdmluZzogZmFsc2UsXHJcbiAgICAgICAgaXNVbm1vdW50aW5nOiBmYWxzZSxcclxuICAgICAgICBsZWF2aW5nVk5vZGVzOiBuZXcgTWFwKClcclxuICAgIH07XHJcbiAgICBvbk1vdW50ZWQoKCkgPT4ge1xyXG4gICAgICAgIHN0YXRlLmlzTW91bnRlZCA9IHRydWU7XHJcbiAgICB9KTtcclxuICAgIG9uQmVmb3JlVW5tb3VudCgoKSA9PiB7XHJcbiAgICAgICAgc3RhdGUuaXNVbm1vdW50aW5nID0gdHJ1ZTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbmNvbnN0IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yID0gW0Z1bmN0aW9uLCBBcnJheV07XHJcbmNvbnN0IEJhc2VUcmFuc2l0aW9uSW1wbCA9IHtcclxuICAgIG5hbWU6IGBCYXNlVHJhbnNpdGlvbmAsXHJcbiAgICBwcm9wczoge1xyXG4gICAgICAgIG1vZGU6IFN0cmluZyxcclxuICAgICAgICBhcHBlYXI6IEJvb2xlYW4sXHJcbiAgICAgICAgcGVyc2lzdGVkOiBCb29sZWFuLFxyXG4gICAgICAgIC8vIGVudGVyXHJcbiAgICAgICAgb25CZWZvcmVFbnRlcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25FbnRlcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25BZnRlckVudGVyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkVudGVyQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICAvLyBsZWF2ZVxyXG4gICAgICAgIG9uQmVmb3JlTGVhdmU6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uTGVhdmU6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uQWZ0ZXJMZWF2ZTogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25MZWF2ZUNhbmNlbGxlZDogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgLy8gYXBwZWFyXHJcbiAgICAgICAgb25CZWZvcmVBcHBlYXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uQXBwZWFyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkFmdGVyQXBwZWFyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkFwcGVhckNhbmNlbGxlZDogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3JcclxuICAgIH0sXHJcbiAgICBzZXR1cChwcm9wcywgeyBzbG90cyB9KSB7XHJcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgICAgICBjb25zdCBzdGF0ZSA9IHVzZVRyYW5zaXRpb25TdGF0ZSgpO1xyXG4gICAgICAgIGxldCBwcmV2VHJhbnNpdGlvbktleTtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgJiYgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKHNsb3RzLmRlZmF1bHQoKSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHdhcm4gbXVsdGlwbGUgZWxlbWVudHNcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjaGlsZHJlbi5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKCc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50IG9yIGNvbXBvbmVudC4gVXNlICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHRoZXJlJ3Mgbm8gbmVlZCB0byB0cmFjayByZWFjdGl2aXR5IGZvciB0aGVzZSBwcm9wcyBzbyB1c2UgdGhlIHJhd1xyXG4gICAgICAgICAgICAvLyBwcm9wcyBmb3IgYSBiaXQgYmV0dGVyIHBlcmZcclxuICAgICAgICAgICAgY29uc3QgcmF3UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgbW9kZSB9ID0gcmF3UHJvcHM7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIG1vZGVcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgbW9kZSAmJlxyXG4gICAgICAgICAgICAgICAgbW9kZSAhPT0gJ2luLW91dCcgJiYgbW9kZSAhPT0gJ291dC1pbicgJiYgbW9kZSAhPT0gJ2RlZmF1bHQnKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAke21vZGV9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYXQgdGhpcyBwb2ludCBjaGlsZHJlbiBoYXMgYSBndWFyYW50ZWVkIGxlbmd0aCBvZiAxLlxyXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuWzBdO1xyXG4gICAgICAgICAgICBpZiAoc3RhdGUuaXNMZWF2aW5nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlQbGFjZWhvbGRlcihjaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaW4gdGhlIGNhc2Ugb2YgPHRyYW5zaXRpb24+PGtlZXAtYWxpdmUvPjwvdHJhbnNpdGlvbj4sIHdlIG5lZWQgdG9cclxuICAgICAgICAgICAgLy8gY29tcGFyZSB0aGUgdHlwZSBvZiB0aGUga2VwdC1hbGl2ZSBjaGlsZHJlbi5cclxuICAgICAgICAgICAgY29uc3QgaW5uZXJDaGlsZCA9IGdldEtlZXBBbGl2ZUNoaWxkKGNoaWxkKTtcclxuICAgICAgICAgICAgaWYgKCFpbm5lckNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlQbGFjZWhvbGRlcihjaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZW50ZXJIb29rcyA9IHJlc29sdmVUcmFuc2l0aW9uSG9va3MoaW5uZXJDaGlsZCwgcmF3UHJvcHMsIHN0YXRlLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhpbm5lckNoaWxkLCBlbnRlckhvb2tzKTtcclxuICAgICAgICAgICAgY29uc3Qgb2xkQ2hpbGQgPSBpbnN0YW5jZS5zdWJUcmVlO1xyXG4gICAgICAgICAgICBjb25zdCBvbGRJbm5lckNoaWxkID0gb2xkQ2hpbGQgJiYgZ2V0S2VlcEFsaXZlQ2hpbGQob2xkQ2hpbGQpO1xyXG4gICAgICAgICAgICBsZXQgdHJhbnNpdGlvbktleUNoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgY29uc3QgeyBnZXRUcmFuc2l0aW9uS2V5IH0gPSBpbm5lckNoaWxkLnR5cGU7XHJcbiAgICAgICAgICAgIGlmIChnZXRUcmFuc2l0aW9uS2V5KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBnZXRUcmFuc2l0aW9uS2V5KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldlRyYW5zaXRpb25LZXkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXZUcmFuc2l0aW9uS2V5ID0ga2V5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSBwcmV2VHJhbnNpdGlvbktleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXZUcmFuc2l0aW9uS2V5ID0ga2V5O1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25LZXlDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBoYW5kbGUgbW9kZVxyXG4gICAgICAgICAgICBpZiAob2xkSW5uZXJDaGlsZCAmJlxyXG4gICAgICAgICAgICAgICAgb2xkSW5uZXJDaGlsZC50eXBlICE9PSBDb21tZW50ICYmXHJcbiAgICAgICAgICAgICAgICAoIWlzU2FtZVZOb2RlVHlwZShpbm5lckNoaWxkLCBvbGRJbm5lckNoaWxkKSB8fCB0cmFuc2l0aW9uS2V5Q2hhbmdlZCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxlYXZpbmdIb29rcyA9IHJlc29sdmVUcmFuc2l0aW9uSG9va3Mob2xkSW5uZXJDaGlsZCwgcmF3UHJvcHMsIHN0YXRlLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgb2xkIHRyZWUncyBob29rcyBpbiBjYXNlIG9mIGR5bmFtaWMgdHJhbnNpdGlvblxyXG4gICAgICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKG9sZElubmVyQ2hpbGQsIGxlYXZpbmdIb29rcyk7XHJcbiAgICAgICAgICAgICAgICAvLyBzd2l0Y2hpbmcgYmV0d2VlbiBkaWZmZXJlbnQgdmlld3NcclxuICAgICAgICAgICAgICAgIGlmIChtb2RlID09PSAnb3V0LWluJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmlzTGVhdmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXHJcbiAgICAgICAgICAgICAgICAgICAgbGVhdmluZ0hvb2tzLmFmdGVyTGVhdmUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmlzTGVhdmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS51cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnICYmIGlubmVyQ2hpbGQudHlwZSAhPT0gQ29tbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlYXZpbmdIb29rcy5kZWxheUxlYXZlID0gKGVsLCBlYXJseVJlbW92ZSwgZGVsYXllZExlYXZlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlYXZpbmdWTm9kZXNDYWNoZSA9IGdldExlYXZpbmdOb2Rlc0ZvclR5cGUoc3RhdGUsIG9sZElubmVyQ2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWF2aW5nVk5vZGVzQ2FjaGVbU3RyaW5nKG9sZElubmVyQ2hpbGQua2V5KV0gPSBvbGRJbm5lckNoaWxkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlYXJseSByZW1vdmFsIGNhbGxiYWNrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLl9sZWF2ZUNiID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWFybHlSZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLl9sZWF2ZUNiID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGVudGVySG9va3MuZGVsYXllZExlYXZlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRlckhvb2tzLmRlbGF5ZWRMZWF2ZSA9IGRlbGF5ZWRMZWF2ZTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59O1xyXG4vLyBleHBvcnQgdGhlIHB1YmxpYyB0eXBlIGZvciBoL3RzeCBpbmZlcmVuY2VcclxuLy8gYWxzbyB0byBhdm9pZCBpbmxpbmUgaW1wb3J0KCkgaW4gZ2VuZXJhdGVkIGQudHMgZmlsZXNcclxuY29uc3QgQmFzZVRyYW5zaXRpb24gPSBCYXNlVHJhbnNpdGlvbkltcGw7XHJcbmZ1bmN0aW9uIGdldExlYXZpbmdOb2Rlc0ZvclR5cGUoc3RhdGUsIHZub2RlKSB7XHJcbiAgICBjb25zdCB7IGxlYXZpbmdWTm9kZXMgfSA9IHN0YXRlO1xyXG4gICAgbGV0IGxlYXZpbmdWTm9kZXNDYWNoZSA9IGxlYXZpbmdWTm9kZXMuZ2V0KHZub2RlLnR5cGUpO1xyXG4gICAgaWYgKCFsZWF2aW5nVk5vZGVzQ2FjaGUpIHtcclxuICAgICAgICBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgICAgIGxlYXZpbmdWTm9kZXMuc2V0KHZub2RlLnR5cGUsIGxlYXZpbmdWTm9kZXNDYWNoZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVhdmluZ1ZOb2Rlc0NhY2hlO1xyXG59XHJcbi8vIFRoZSB0cmFuc2l0aW9uIGhvb2tzIGFyZSBhdHRhY2hlZCB0byB0aGUgdm5vZGUgYXMgdm5vZGUudHJhbnNpdGlvblxyXG4vLyBhbmQgd2lsbCBiZSBjYWxsZWQgYXQgYXBwcm9wcmlhdGUgdGltaW5nIGluIHRoZSByZW5kZXJlci5cclxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyh2bm9kZSwgcHJvcHMsIHN0YXRlLCBpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgeyBhcHBlYXIsIG1vZGUsIHBlcnNpc3RlZCA9IGZhbHNlLCBvbkJlZm9yZUVudGVyLCBvbkVudGVyLCBvbkFmdGVyRW50ZXIsIG9uRW50ZXJDYW5jZWxsZWQsIG9uQmVmb3JlTGVhdmUsIG9uTGVhdmUsIG9uQWZ0ZXJMZWF2ZSwgb25MZWF2ZUNhbmNlbGxlZCwgb25CZWZvcmVBcHBlYXIsIG9uQXBwZWFyLCBvbkFmdGVyQXBwZWFyLCBvbkFwcGVhckNhbmNlbGxlZCB9ID0gcHJvcHM7XHJcbiAgICBjb25zdCBrZXkgPSBTdHJpbmcodm5vZGUua2V5KTtcclxuICAgIGNvbnN0IGxlYXZpbmdWTm9kZXNDYWNoZSA9IGdldExlYXZpbmdOb2Rlc0ZvclR5cGUoc3RhdGUsIHZub2RlKTtcclxuICAgIGNvbnN0IGNhbGxIb29rID0gKGhvb2ssIGFyZ3MpID0+IHtcclxuICAgICAgICBob29rICYmXHJcbiAgICAgICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIGluc3RhbmNlLCA5IC8qIFRSQU5TSVRJT05fSE9PSyAqLywgYXJncyk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaG9va3MgPSB7XHJcbiAgICAgICAgbW9kZSxcclxuICAgICAgICBwZXJzaXN0ZWQsXHJcbiAgICAgICAgYmVmb3JlRW50ZXIoZWwpIHtcclxuICAgICAgICAgICAgbGV0IGhvb2sgPSBvbkJlZm9yZUVudGVyO1xyXG4gICAgICAgICAgICBpZiAoIXN0YXRlLmlzTW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFwcGVhcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvb2sgPSBvbkJlZm9yZUFwcGVhciB8fCBvbkJlZm9yZUVudGVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGZvciBzYW1lIGVsZW1lbnQgKHYtc2hvdylcclxuICAgICAgICAgICAgaWYgKGVsLl9sZWF2ZUNiKSB7XHJcbiAgICAgICAgICAgICAgICBlbC5fbGVhdmVDYih0cnVlIC8qIGNhbmNlbGxlZCAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZm9yIHRvZ2dsZWQgZWxlbWVudCB3aXRoIHNhbWUga2V5ICh2LWlmKVxyXG4gICAgICAgICAgICBjb25zdCBsZWF2aW5nVk5vZGUgPSBsZWF2aW5nVk5vZGVzQ2FjaGVba2V5XTtcclxuICAgICAgICAgICAgaWYgKGxlYXZpbmdWTm9kZSAmJlxyXG4gICAgICAgICAgICAgICAgaXNTYW1lVk5vZGVUeXBlKHZub2RlLCBsZWF2aW5nVk5vZGUpICYmXHJcbiAgICAgICAgICAgICAgICBsZWF2aW5nVk5vZGUuZWwuX2xlYXZlQ2IpIHtcclxuICAgICAgICAgICAgICAgIC8vIGZvcmNlIGVhcmx5IHJlbW92YWwgKG5vdCBjYW5jZWxsZWQpXHJcbiAgICAgICAgICAgICAgICBsZWF2aW5nVk5vZGUuZWwuX2xlYXZlQ2IoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYWxsSG9vayhob29rLCBbZWxdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudGVyKGVsKSB7XHJcbiAgICAgICAgICAgIGxldCBob29rID0gb25FbnRlcjtcclxuICAgICAgICAgICAgbGV0IGFmdGVySG9vayA9IG9uQWZ0ZXJFbnRlcjtcclxuICAgICAgICAgICAgbGV0IGNhbmNlbEhvb2sgPSBvbkVudGVyQ2FuY2VsbGVkO1xyXG4gICAgICAgICAgICBpZiAoIXN0YXRlLmlzTW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFwcGVhcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvb2sgPSBvbkFwcGVhciB8fCBvbkVudGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIGFmdGVySG9vayA9IG9uQWZ0ZXJBcHBlYXIgfHwgb25BZnRlckVudGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbEhvb2sgPSBvbkFwcGVhckNhbmNlbGxlZCB8fCBvbkVudGVyQ2FuY2VsbGVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgY29uc3QgZG9uZSA9IChlbC5fZW50ZXJDYiA9IChjYW5jZWxsZWQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChjYWxsZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsSG9vayhjYW5jZWxIb29rLCBbZWxdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxIb29rKGFmdGVySG9vaywgW2VsXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaG9va3MuZGVsYXllZExlYXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9va3MuZGVsYXllZExlYXZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbC5fZW50ZXJDYiA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChob29rKSB7XHJcbiAgICAgICAgICAgICAgICBob29rKGVsLCBkb25lKTtcclxuICAgICAgICAgICAgICAgIGlmIChob29rLmxlbmd0aCA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsZWF2ZShlbCwgcmVtb3ZlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IFN0cmluZyh2bm9kZS5rZXkpO1xyXG4gICAgICAgICAgICBpZiAoZWwuX2VudGVyQ2IpIHtcclxuICAgICAgICAgICAgICAgIGVsLl9lbnRlckNiKHRydWUgLyogY2FuY2VsbGVkICovKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3RhdGUuaXNVbm1vdW50aW5nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FsbEhvb2sob25CZWZvcmVMZWF2ZSwgW2VsXSk7XHJcbiAgICAgICAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgY29uc3QgZG9uZSA9IChlbC5fbGVhdmVDYiA9IChjYW5jZWxsZWQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChjYWxsZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxIb29rKG9uTGVhdmVDYW5jZWxsZWQsIFtlbF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbEhvb2sob25BZnRlckxlYXZlLCBbZWxdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsLl9sZWF2ZUNiID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxlYXZpbmdWTm9kZXNDYWNoZVtrZXldID09PSB2bm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsZWF2aW5nVk5vZGVzQ2FjaGVba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxlYXZpbmdWTm9kZXNDYWNoZVtrZXldID0gdm5vZGU7XHJcbiAgICAgICAgICAgIGlmIChvbkxlYXZlKSB7XHJcbiAgICAgICAgICAgICAgICBvbkxlYXZlKGVsLCBkb25lKTtcclxuICAgICAgICAgICAgICAgIGlmIChvbkxlYXZlLmxlbmd0aCA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbG9uZSh2bm9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyh2bm9kZSwgcHJvcHMsIHN0YXRlLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBob29rcztcclxufVxyXG4vLyB0aGUgcGxhY2Vob2xkZXIgcmVhbGx5IG9ubHkgaGFuZGxlcyBvbmUgc3BlY2lhbCBjYXNlOiBLZWVwQWxpdmVcclxuLy8gaW4gdGhlIGNhc2Ugb2YgYSBLZWVwQWxpdmUgaW4gYSBsZWF2ZSBwaGFzZSB3ZSBuZWVkIHRvIHJldHVybiBhIEtlZXBBbGl2ZVxyXG4vLyBwbGFjZWhvbGRlciB3aXRoIGVtcHR5IGNvbnRlbnQgdG8gYXZvaWQgdGhlIEtlZXBBbGl2ZSBpbnN0YW5jZSBmcm9tIGJlaW5nXHJcbi8vIHVubW91bnRlZC5cclxuZnVuY3Rpb24gZW1wdHlQbGFjZWhvbGRlcih2bm9kZSkge1xyXG4gICAgaWYgKGlzS2VlcEFsaXZlKHZub2RlKSkge1xyXG4gICAgICAgIHZub2RlID0gY2xvbmVWTm9kZSh2bm9kZSk7XHJcbiAgICAgICAgdm5vZGUuY2hpbGRyZW4gPSBudWxsO1xyXG4gICAgICAgIHJldHVybiB2bm9kZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRLZWVwQWxpdmVDaGlsZCh2bm9kZSkge1xyXG4gICAgcmV0dXJuIGlzS2VlcEFsaXZlKHZub2RlKVxyXG4gICAgICAgID8gdm5vZGUuY2hpbGRyZW5cclxuICAgICAgICAgICAgPyB2bm9kZS5jaGlsZHJlblswXVxyXG4gICAgICAgICAgICA6IHVuZGVmaW5lZFxyXG4gICAgICAgIDogdm5vZGU7XHJcbn1cclxuZnVuY3Rpb24gc2V0VHJhbnNpdGlvbkhvb2tzKHZub2RlLCBob29rcykge1xyXG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovICYmIHZub2RlLmNvbXBvbmVudCkge1xyXG4gICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZS5jb21wb25lbnQuc3ViVHJlZSwgaG9va3MpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgdm5vZGUuc3NDb250ZW50LnRyYW5zaXRpb24gPSBob29rcy5jbG9uZSh2bm9kZS5zc0NvbnRlbnQpO1xyXG4gICAgICAgIHZub2RlLnNzRmFsbGJhY2sudHJhbnNpdGlvbiA9IGhvb2tzLmNsb25lKHZub2RlLnNzRmFsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdm5vZGUudHJhbnNpdGlvbiA9IGhvb2tzO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihjaGlsZHJlbiwga2VlcENvbW1lbnQgPSBmYWxzZSkge1xyXG4gICAgbGV0IHJldCA9IFtdO1xyXG4gICAgbGV0IGtleWVkRnJhZ21lbnRDb3VudCA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAvLyBoYW5kbGUgZnJhZ21lbnQgY2hpbGRyZW4gY2FzZSwgZS5nLiB2LWZvclxyXG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSBGcmFnbWVudCkge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQucGF0Y2hGbGFnICYgMTI4IC8qIEtFWUVEX0ZSQUdNRU5UICovKVxyXG4gICAgICAgICAgICAgICAga2V5ZWRGcmFnbWVudENvdW50Kys7XHJcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKGNoaWxkLmNoaWxkcmVuLCBrZWVwQ29tbWVudCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb21tZW50IHBsYWNlaG9sZGVycyBzaG91bGQgYmUgc2tpcHBlZCwgZS5nLiB2LWlmXHJcbiAgICAgICAgZWxzZSBpZiAoa2VlcENvbW1lbnQgfHwgY2hpbGQudHlwZSAhPT0gQ29tbWVudCkge1xyXG4gICAgICAgICAgICByZXQucHVzaChjaGlsZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gIzExMjYgaWYgYSB0cmFuc2l0aW9uIGNoaWxkcmVuIGxpc3QgY29udGFpbnMgbXVsdGlwbGUgc3ViIGZyYWdtZW50cywgdGhlc2VcclxuICAgIC8vIGZyYWdtZW50cyB3aWxsIGJlIG1lcmdlZCBpbnRvIGEgZmxhdCBjaGlsZHJlbiBhcnJheS4gU2luY2UgZWFjaCB2LWZvclxyXG4gICAgLy8gZnJhZ21lbnQgbWF5IGNvbnRhaW4gZGlmZmVyZW50IHN0YXRpYyBiaW5kaW5ncyBpbnNpZGUsIHdlIG5lZWQgdG8gZGUtb3BcclxuICAgIC8vIHRoZXNlIGNoaWxkcmVuIHRvIGZvcmNlIGZ1bGwgZGlmZnMgdG8gZW5zdXJlIGNvcnJlY3QgYmVoYXZpb3IuXHJcbiAgICBpZiAoa2V5ZWRGcmFnbWVudENvdW50ID4gMSkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJldFtpXS5wYXRjaEZsYWcgPSAtMiAvKiBCQUlMICovO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbn1cblxuLy8gaW1wbGVtZW50YXRpb24sIGNsb3NlIHRvIG5vLW9wXHJcbmZ1bmN0aW9uIGRlZmluZUNvbXBvbmVudChvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gaXNGdW5jdGlvbihvcHRpb25zKSA/IHsgc2V0dXA6IG9wdGlvbnMsIG5hbWU6IG9wdGlvbnMubmFtZSB9IDogb3B0aW9ucztcclxufVxuXG5jb25zdCBpc0FzeW5jV3JhcHBlciA9IChpKSA9PiAhIWkudHlwZS5fX2FzeW5jTG9hZGVyO1xyXG5mdW5jdGlvbiBkZWZpbmVBc3luY0NvbXBvbmVudChzb3VyY2UpIHtcclxuICAgIGlmIChpc0Z1bmN0aW9uKHNvdXJjZSkpIHtcclxuICAgICAgICBzb3VyY2UgPSB7IGxvYWRlcjogc291cmNlIH07XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IGxvYWRlciwgbG9hZGluZ0NvbXBvbmVudCwgZXJyb3JDb21wb25lbnQsIGRlbGF5ID0gMjAwLCB0aW1lb3V0LCAvLyB1bmRlZmluZWQgPSBuZXZlciB0aW1lcyBvdXRcclxuICAgIHN1c3BlbnNpYmxlID0gdHJ1ZSwgb25FcnJvcjogdXNlck9uRXJyb3IgfSA9IHNvdXJjZTtcclxuICAgIGxldCBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XHJcbiAgICBsZXQgcmVzb2x2ZWRDb21wO1xyXG4gICAgbGV0IHJldHJpZXMgPSAwO1xyXG4gICAgY29uc3QgcmV0cnkgPSAoKSA9PiB7XHJcbiAgICAgICAgcmV0cmllcysrO1xyXG4gICAgICAgIHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gbG9hZCgpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgbGV0IHRoaXNSZXF1ZXN0O1xyXG4gICAgICAgIHJldHVybiAocGVuZGluZ1JlcXVlc3QgfHxcclxuICAgICAgICAgICAgKHRoaXNSZXF1ZXN0ID0gcGVuZGluZ1JlcXVlc3QgPVxyXG4gICAgICAgICAgICAgICAgbG9hZGVyKClcclxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBlcnIgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXJPbkVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VyUmV0cnkgPSAoKSA9PiByZXNvbHZlKHJldHJ5KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlckZhaWwgPSAoKSA9PiByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJPbkVycm9yKGVyciwgdXNlclJldHJ5LCB1c2VyRmFpbCwgcmV0cmllcyArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChjb21wKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNSZXF1ZXN0ICE9PSBwZW5kaW5nUmVxdWVzdCAmJiBwZW5kaW5nUmVxdWVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGVuZGluZ1JlcXVlc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWNvbXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgQXN5bmMgY29tcG9uZW50IGxvYWRlciByZXNvbHZlZCB0byB1bmRlZmluZWQuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYElmIHlvdSBhcmUgdXNpbmcgcmV0cnkoKSwgbWFrZSBzdXJlIHRvIHJldHVybiBpdHMgcmV0dXJuIHZhbHVlLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBpbnRlcm9wIG1vZHVsZSBkZWZhdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXAgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGNvbXAuX19lc01vZHVsZSB8fCBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wID0gY29tcC5kZWZhdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNvbXAgJiYgIWlzT2JqZWN0KGNvbXApICYmICFpc0Z1bmN0aW9uKGNvbXApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhc3luYyBjb21wb25lbnQgbG9hZCByZXN1bHQ6ICR7Y29tcH1gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRDb21wID0gY29tcDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcDtcclxuICAgICAgICAgICAgICAgIH0pKSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGRlZmluZUNvbXBvbmVudCh7XHJcbiAgICAgICAgbmFtZTogJ0FzeW5jQ29tcG9uZW50V3JhcHBlcicsXHJcbiAgICAgICAgX19hc3luY0xvYWRlcjogbG9hZCxcclxuICAgICAgICBnZXQgX19hc3luY1Jlc29sdmVkKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRDb21wO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0dXAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlO1xyXG4gICAgICAgICAgICAvLyBhbHJlYWR5IHJlc29sdmVkXHJcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZENvbXApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBjcmVhdGVJbm5lckNvbXAocmVzb2x2ZWRDb21wLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgb25FcnJvciA9IChlcnIpID0+IHtcclxuICAgICAgICAgICAgICAgIHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIDEzIC8qIEFTWU5DX0NPTVBPTkVOVF9MT0FERVIgKi8sICFlcnJvckNvbXBvbmVudCAvKiBkbyBub3QgdGhyb3cgaW4gZGV2IGlmIHVzZXIgcHJvdmlkZWQgZXJyb3IgY29tcG9uZW50ICovKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLy8gc3VzcGVuc2UtY29udHJvbGxlZCBvciBTU1IuXHJcbiAgICAgICAgICAgIGlmICgoc3VzcGVuc2libGUgJiYgaW5zdGFuY2Uuc3VzcGVuc2UpIHx8XHJcbiAgICAgICAgICAgICAgICAoaXNJblNTUkNvbXBvbmVudFNldHVwKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWQoKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGNvbXAgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBjcmVhdGVJbm5lckNvbXAoY29tcCwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGVycm9yQ29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY3JlYXRlVk5vZGUoZXJyb3JDb21wb25lbnQsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbG9hZGVkID0gcmVmKGZhbHNlKTtcclxuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSByZWYoKTtcclxuICAgICAgICAgICAgY29uc3QgZGVsYXllZCA9IHJlZighIWRlbGF5KTtcclxuICAgICAgICAgICAgaWYgKGRlbGF5KSB7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxheWVkLnZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9LCBkZWxheSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2FkZWQudmFsdWUgJiYgIWVycm9yLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgQXN5bmMgY29tcG9uZW50IHRpbWVkIG91dCBhZnRlciAke3RpbWVvdXR9bXMuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IudmFsdWUgPSBlcnI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbG9hZCgpXHJcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsb2FkZWQudmFsdWUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnBhcmVudCAmJiBpc0tlZXBBbGl2ZShpbnN0YW5jZS5wYXJlbnQudm5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFyZW50IGlzIGtlZXAtYWxpdmUsIGZvcmNlIHVwZGF0ZSBzbyB0aGUgbG9hZGVkIGNvbXBvbmVudCdzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbmFtZSBpcyB0YWtlbiBpbnRvIGFjY291bnRcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZUpvYihpbnN0YW5jZS5wYXJlbnQudXBkYXRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xyXG4gICAgICAgICAgICAgICAgb25FcnJvcihlcnIpO1xyXG4gICAgICAgICAgICAgICAgZXJyb3IudmFsdWUgPSBlcnI7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxvYWRlZC52YWx1ZSAmJiByZXNvbHZlZENvbXApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW5uZXJDb21wKHJlc29sdmVkQ29tcCwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IudmFsdWUgJiYgZXJyb3JDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUoZXJyb3JDb21wb25lbnQsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsb2FkaW5nQ29tcG9uZW50ICYmICFkZWxheWVkLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKGxvYWRpbmdDb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUlubmVyQ29tcChjb21wLCB7IHZub2RlOiB7IHJlZiwgcHJvcHMsIGNoaWxkcmVuIH0gfSkge1xyXG4gICAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZShjb21wLCBwcm9wcywgY2hpbGRyZW4pO1xyXG4gICAgLy8gZW5zdXJlIGlubmVyIGNvbXBvbmVudCBpbmhlcml0cyB0aGUgYXN5bmMgd3JhcHBlcidzIHJlZiBvd25lclxyXG4gICAgdm5vZGUucmVmID0gcmVmO1xyXG4gICAgcmV0dXJuIHZub2RlO1xyXG59XG5cbmNvbnN0IGlzS2VlcEFsaXZlID0gKHZub2RlKSA9PiB2bm9kZS50eXBlLl9faXNLZWVwQWxpdmU7XHJcbmNvbnN0IEtlZXBBbGl2ZUltcGwgPSB7XHJcbiAgICBuYW1lOiBgS2VlcEFsaXZlYCxcclxuICAgIC8vIE1hcmtlciBmb3Igc3BlY2lhbCBoYW5kbGluZyBpbnNpZGUgdGhlIHJlbmRlcmVyLiBXZSBhcmUgbm90IHVzaW5nIGEgPT09XHJcbiAgICAvLyBjaGVjayBkaXJlY3RseSBvbiBLZWVwQWxpdmUgaW4gdGhlIHJlbmRlcmVyLCBiZWNhdXNlIGltcG9ydGluZyBpdCBkaXJlY3RseVxyXG4gICAgLy8gd291bGQgcHJldmVudCBpdCBmcm9tIGJlaW5nIHRyZWUtc2hha2VuLlxyXG4gICAgX19pc0tlZXBBbGl2ZTogdHJ1ZSxcclxuICAgIHByb3BzOiB7XHJcbiAgICAgICAgaW5jbHVkZTogW1N0cmluZywgUmVnRXhwLCBBcnJheV0sXHJcbiAgICAgICAgZXhjbHVkZTogW1N0cmluZywgUmVnRXhwLCBBcnJheV0sXHJcbiAgICAgICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXHJcbiAgICB9LFxyXG4gICAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xyXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICAgICAgLy8gS2VlcEFsaXZlIGNvbW11bmljYXRlcyB3aXRoIHRoZSBpbnN0YW50aWF0ZWQgcmVuZGVyZXIgdmlhIHRoZVxyXG4gICAgICAgIC8vIGN0eCB3aGVyZSB0aGUgcmVuZGVyZXIgcGFzc2VzIGluIGl0cyBpbnRlcm5hbHMsXHJcbiAgICAgICAgLy8gYW5kIHRoZSBLZWVwQWxpdmUgaW5zdGFuY2UgZXhwb3NlcyBhY3RpdmF0ZS9kZWFjdGl2YXRlIGltcGxlbWVudGF0aW9ucy5cclxuICAgICAgICAvLyBUaGUgd2hvbGUgcG9pbnQgb2YgdGhpcyBpcyB0byBhdm9pZCBpbXBvcnRpbmcgS2VlcEFsaXZlIGRpcmVjdGx5IGluIHRoZVxyXG4gICAgICAgIC8vIHJlbmRlcmVyIHRvIGZhY2lsaXRhdGUgdHJlZS1zaGFraW5nLlxyXG4gICAgICAgIGNvbnN0IHNoYXJlZENvbnRleHQgPSBpbnN0YW5jZS5jdHg7XHJcbiAgICAgICAgLy8gaWYgdGhlIGludGVybmFsIHJlbmRlcmVyIGlzIG5vdCByZWdpc3RlcmVkLCBpdCBpbmRpY2F0ZXMgdGhhdCB0aGlzIGlzIHNlcnZlci1zaWRlIHJlbmRlcmluZyxcclxuICAgICAgICAvLyBmb3IgS2VlcEFsaXZlLCB3ZSBqdXN0IG5lZWQgdG8gcmVuZGVyIGl0cyBjaGlsZHJlblxyXG4gICAgICAgIGlmICghc2hhcmVkQ29udGV4dC5yZW5kZXJlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gc2xvdHMuZGVmYXVsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2FjaGUgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IG5ldyBTZXQoKTtcclxuICAgICAgICBsZXQgY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UuX192X2NhY2hlID0gY2FjaGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBhcmVudFN1c3BlbnNlID0gaW5zdGFuY2Uuc3VzcGVuc2U7XHJcbiAgICAgICAgY29uc3QgeyByZW5kZXJlcjogeyBwOiBwYXRjaCwgbTogbW92ZSwgdW06IF91bm1vdW50LCBvOiB7IGNyZWF0ZUVsZW1lbnQgfSB9IH0gPSBzaGFyZWRDb250ZXh0O1xyXG4gICAgICAgIGNvbnN0IHN0b3JhZ2VDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBzaGFyZWRDb250ZXh0LmFjdGl2YXRlID0gKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgaXNTVkcsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgbW92ZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIDAgLyogRU5URVIgKi8sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgLy8gaW4gY2FzZSBwcm9wcyBoYXZlIGNoYW5nZWRcclxuICAgICAgICAgICAgcGF0Y2goaW5zdGFuY2Uudm5vZGUsIHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgdm5vZGUuc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuaXNEZWFjdGl2YXRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5hKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHZub2RlSG9vayA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLm9uVm5vZGVNb3VudGVkO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZub2RlSG9vaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIGluc3RhbmNlLnBhcmVudCwgdm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgY29tcG9uZW50cyB0cmVlXHJcbiAgICAgICAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgc2hhcmVkQ29udGV4dC5kZWFjdGl2YXRlID0gKHZub2RlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50O1xyXG4gICAgICAgICAgICBtb3ZlKHZub2RlLCBzdG9yYWdlQ29udGFpbmVyLCBudWxsLCAxIC8qIExFQVZFICovLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuZGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5kYSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2bm9kZUhvb2sgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy5vblZub2RlVW5tb3VudGVkO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZub2RlSG9vaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIGluc3RhbmNlLnBhcmVudCwgdm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuaXNEZWFjdGl2YXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBjb21wb25lbnRzIHRyZWVcclxuICAgICAgICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50QWRkZWQoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBmdW5jdGlvbiB1bm1vdW50KHZub2RlKSB7XHJcbiAgICAgICAgICAgIC8vIHJlc2V0IHRoZSBzaGFwZUZsYWcgc28gaXQgY2FuIGJlIHByb3Blcmx5IHVubW91bnRlZFxyXG4gICAgICAgICAgICByZXNldFNoYXBlRmxhZyh2bm9kZSk7XHJcbiAgICAgICAgICAgIF91bm1vdW50KHZub2RlLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBwcnVuZUNhY2hlKGZpbHRlcikge1xyXG4gICAgICAgICAgICBjYWNoZS5mb3JFYWNoKCh2bm9kZSwga2V5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh2bm9kZS50eXBlKTtcclxuICAgICAgICAgICAgICAgIGlmIChuYW1lICYmICghZmlsdGVyIHx8ICFmaWx0ZXIobmFtZSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkoa2V5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChrZXkpO1xyXG4gICAgICAgICAgICBpZiAoIWN1cnJlbnQgfHwgY2FjaGVkLnR5cGUgIT09IGN1cnJlbnQudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgdW5tb3VudChjYWNoZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgYWN0aXZlIGluc3RhbmNlIHNob3VsZCBubyBsb25nZXIgYmUga2VwdC1hbGl2ZS5cclxuICAgICAgICAgICAgICAgIC8vIHdlIGNhbid0IHVubW91bnQgaXQgbm93IGJ1dCBpdCBtaWdodCBiZSBsYXRlciwgc28gcmVzZXQgaXRzIGZsYWcgbm93LlxyXG4gICAgICAgICAgICAgICAgcmVzZXRTaGFwZUZsYWcoY3VycmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FjaGUuZGVsZXRlKGtleSk7XHJcbiAgICAgICAgICAgIGtleXMuZGVsZXRlKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHBydW5lIGNhY2hlIG9uIGluY2x1ZGUvZXhjbHVkZSBwcm9wIGNoYW5nZVxyXG4gICAgICAgIHdhdGNoKCgpID0+IFtwcm9wcy5pbmNsdWRlLCBwcm9wcy5leGNsdWRlXSwgKFtpbmNsdWRlLCBleGNsdWRlXSkgPT4ge1xyXG4gICAgICAgICAgICBpbmNsdWRlICYmIHBydW5lQ2FjaGUobmFtZSA9PiBtYXRjaGVzKGluY2x1ZGUsIG5hbWUpKTtcclxuICAgICAgICAgICAgZXhjbHVkZSAmJiBwcnVuZUNhY2hlKG5hbWUgPT4gIW1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpO1xyXG4gICAgICAgIH0sIFxyXG4gICAgICAgIC8vIHBydW5lIHBvc3QtcmVuZGVyIGFmdGVyIGBjdXJyZW50YCBoYXMgYmVlbiB1cGRhdGVkXHJcbiAgICAgICAgeyBmbHVzaDogJ3Bvc3QnLCBkZWVwOiB0cnVlIH0pO1xyXG4gICAgICAgIC8vIGNhY2hlIHN1YiB0cmVlIGFmdGVyIHJlbmRlclxyXG4gICAgICAgIGxldCBwZW5kaW5nQ2FjaGVLZXkgPSBudWxsO1xyXG4gICAgICAgIGNvbnN0IGNhY2hlU3VidHJlZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgLy8gZml4ICMxNjIxLCB0aGUgcGVuZGluZ0NhY2hlS2V5IGNvdWxkIGJlIDBcclxuICAgICAgICAgICAgaWYgKHBlbmRpbmdDYWNoZUtleSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjYWNoZS5zZXQocGVuZGluZ0NhY2hlS2V5LCBnZXRJbm5lckNoaWxkKGluc3RhbmNlLnN1YlRyZWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgb25Nb3VudGVkKGNhY2hlU3VidHJlZSk7XHJcbiAgICAgICAgb25VcGRhdGVkKGNhY2hlU3VidHJlZSk7XHJcbiAgICAgICAgb25CZWZvcmVVbm1vdW50KCgpID0+IHtcclxuICAgICAgICAgICAgY2FjaGUuZm9yRWFjaChjYWNoZWQgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBzdWJUcmVlLCBzdXNwZW5zZSB9ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2bm9kZSA9IGdldElubmVyQ2hpbGQoc3ViVHJlZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkLnR5cGUgPT09IHZub2RlLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjdXJyZW50IGluc3RhbmNlIHdpbGwgYmUgdW5tb3VudGVkIGFzIHBhcnQgb2Yga2VlcC1hbGl2ZSdzIHVubW91bnRcclxuICAgICAgICAgICAgICAgICAgICByZXNldFNoYXBlRmxhZyh2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGludm9rZSBpdHMgZGVhY3RpdmF0ZWQgaG9vayBoZXJlXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGEgPSB2bm9kZS5jb21wb25lbnQuZGE7XHJcbiAgICAgICAgICAgICAgICAgICAgZGEgJiYgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGRhLCBzdXNwZW5zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdW5tb3VudChjYWNoZWQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBwZW5kaW5nQ2FjaGVLZXkgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoIXNsb3RzLmRlZmF1bHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gc2xvdHMuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBjb25zdCByYXdWTm9kZSA9IGNoaWxkcmVuWzBdO1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEtlZXBBbGl2ZSBzaG91bGQgY29udGFpbiBleGFjdGx5IG9uZSBjb21wb25lbnQgY2hpbGQuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghaXNWTm9kZShyYXdWTm9kZSkgfHxcclxuICAgICAgICAgICAgICAgICghKHJhd1ZOb2RlLnNoYXBlRmxhZyAmIDQgLyogU1RBVEVGVUxfQ09NUE9ORU5UICovKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICEocmF3Vk5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSkpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhd1ZOb2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCB2bm9kZSA9IGdldElubmVyQ2hpbGQocmF3Vk5vZGUpO1xyXG4gICAgICAgICAgICBjb25zdCBjb21wID0gdm5vZGUudHlwZTtcclxuICAgICAgICAgICAgLy8gZm9yIGFzeW5jIGNvbXBvbmVudHMsIG5hbWUgY2hlY2sgc2hvdWxkIGJlIGJhc2VkIGluIGl0cyBsb2FkZWRcclxuICAgICAgICAgICAgLy8gaW5uZXIgY29tcG9uZW50IGlmIGF2YWlsYWJsZVxyXG4gICAgICAgICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShpc0FzeW5jV3JhcHBlcih2bm9kZSlcclxuICAgICAgICAgICAgICAgID8gdm5vZGUudHlwZS5fX2FzeW5jUmVzb2x2ZWQgfHwge31cclxuICAgICAgICAgICAgICAgIDogY29tcCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgaW5jbHVkZSwgZXhjbHVkZSwgbWF4IH0gPSBwcm9wcztcclxuICAgICAgICAgICAgaWYgKChpbmNsdWRlICYmICghbmFtZSB8fCAhbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSkpIHx8XHJcbiAgICAgICAgICAgICAgICAoZXhjbHVkZSAmJiBuYW1lICYmIG1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gdm5vZGU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmF3Vk5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gdm5vZGUua2V5ID09IG51bGwgPyBjb21wIDogdm5vZGUua2V5O1xyXG4gICAgICAgICAgICBjb25zdCBjYWNoZWRWTm9kZSA9IGNhY2hlLmdldChrZXkpO1xyXG4gICAgICAgICAgICAvLyBjbG9uZSB2bm9kZSBpZiBpdCdzIHJldXNlZCBiZWNhdXNlIHdlIGFyZSBnb2luZyB0byBtdXRhdGUgaXRcclxuICAgICAgICAgICAgaWYgKHZub2RlLmVsKSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZSA9IGNsb25lVk5vZGUodm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJhd1ZOb2RlLnNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJhd1ZOb2RlLnNzQ29udGVudCA9IHZub2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vICMxNTEzIGl0J3MgcG9zc2libGUgZm9yIHRoZSByZXR1cm5lZCB2bm9kZSB0byBiZSBjbG9uZWQgZHVlIHRvIGF0dHJcclxuICAgICAgICAgICAgLy8gZmFsbHRocm91Z2ggb3Igc2NvcGVJZCwgc28gdGhlIHZub2RlIGhlcmUgbWF5IG5vdCBiZSB0aGUgZmluYWwgdm5vZGVcclxuICAgICAgICAgICAgLy8gdGhhdCBpcyBtb3VudGVkLiBJbnN0ZWFkIG9mIGNhY2hpbmcgaXQgZGlyZWN0bHksIHdlIHN0b3JlIHRoZSBwZW5kaW5nXHJcbiAgICAgICAgICAgIC8vIGtleSBhbmQgY2FjaGUgYGluc3RhbmNlLnN1YlRyZWVgICh0aGUgbm9ybWFsaXplZCB2bm9kZSkgaW5cclxuICAgICAgICAgICAgLy8gYmVmb3JlTW91bnQvYmVmb3JlVXBkYXRlIGhvb2tzLlxyXG4gICAgICAgICAgICBwZW5kaW5nQ2FjaGVLZXkgPSBrZXk7XHJcbiAgICAgICAgICAgIGlmIChjYWNoZWRWTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gY29weSBvdmVyIG1vdW50ZWQgc3RhdGVcclxuICAgICAgICAgICAgICAgIHZub2RlLmVsID0gY2FjaGVkVk5vZGUuZWw7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS5jb21wb25lbnQgPSBjYWNoZWRWTm9kZS5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodm5vZGUudHJhbnNpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IHVwZGF0ZSB0cmFuc2l0aW9uIGhvb2tzIG9uIHN1YlRyZWVcclxuICAgICAgICAgICAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3Modm5vZGUsIHZub2RlLnRyYW5zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gYXZvaWQgdm5vZGUgYmVpbmcgbW91bnRlZCBhcyBmcmVzaFxyXG4gICAgICAgICAgICAgICAgdm5vZGUuc2hhcGVGbGFnIHw9IDUxMiAvKiBDT01QT05FTlRfS0VQVF9BTElWRSAqLztcclxuICAgICAgICAgICAgICAgIC8vIG1ha2UgdGhpcyBrZXkgdGhlIGZyZXNoZXN0XHJcbiAgICAgICAgICAgICAgICBrZXlzLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgICAgICAgICAga2V5cy5hZGQoa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGtleXMuYWRkKGtleSk7XHJcbiAgICAgICAgICAgICAgICAvLyBwcnVuZSBvbGRlc3QgZW50cnlcclxuICAgICAgICAgICAgICAgIGlmIChtYXggJiYga2V5cy5zaXplID4gcGFyc2VJbnQobWF4LCAxMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoa2V5cy52YWx1ZXMoKS5uZXh0KCkudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGF2b2lkIHZub2RlIGJlaW5nIHVubW91bnRlZFxyXG4gICAgICAgICAgICB2bm9kZS5zaGFwZUZsYWcgfD0gMjU2IC8qIENPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRSAqLztcclxuICAgICAgICAgICAgY3VycmVudCA9IHZub2RlO1xyXG4gICAgICAgICAgICByZXR1cm4gcmF3Vk5vZGU7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufTtcclxuLy8gZXhwb3J0IHRoZSBwdWJsaWMgdHlwZSBmb3IgaC90c3ggaW5mZXJlbmNlXHJcbi8vIGFsc28gdG8gYXZvaWQgaW5saW5lIGltcG9ydCgpIGluIGdlbmVyYXRlZCBkLnRzIGZpbGVzXHJcbmNvbnN0IEtlZXBBbGl2ZSA9IEtlZXBBbGl2ZUltcGw7XHJcbmZ1bmN0aW9uIG1hdGNoZXMocGF0dGVybiwgbmFtZSkge1xyXG4gICAgaWYgKGlzQXJyYXkocGF0dGVybikpIHtcclxuICAgICAgICByZXR1cm4gcGF0dGVybi5zb21lKChwKSA9PiBtYXRjaGVzKHAsIG5hbWUpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzU3RyaW5nKHBhdHRlcm4pKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmNsdWRlcyhuYW1lKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHBhdHRlcm4udGVzdCkge1xyXG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSk7XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIG9uQWN0aXZhdGVkKGhvb2ssIHRhcmdldCkge1xyXG4gICAgcmVnaXN0ZXJLZWVwQWxpdmVIb29rKGhvb2ssIFwiYVwiIC8qIEFDVElWQVRFRCAqLywgdGFyZ2V0KTtcclxufVxyXG5mdW5jdGlvbiBvbkRlYWN0aXZhdGVkKGhvb2ssIHRhcmdldCkge1xyXG4gICAgcmVnaXN0ZXJLZWVwQWxpdmVIb29rKGhvb2ssIFwiZGFcIiAvKiBERUFDVElWQVRFRCAqLywgdGFyZ2V0KTtcclxufVxyXG5mdW5jdGlvbiByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgdHlwZSwgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlKSB7XHJcbiAgICAvLyBjYWNoZSB0aGUgZGVhY3RpdmF0ZSBicmFuY2ggY2hlY2sgd3JhcHBlciBmb3IgaW5qZWN0ZWQgaG9va3Mgc28gdGhlIHNhbWVcclxuICAgIC8vIGhvb2sgY2FuIGJlIHByb3Blcmx5IGRlZHVwZWQgYnkgdGhlIHNjaGVkdWxlci4gXCJfX3dkY1wiIHN0YW5kcyBmb3IgXCJ3aXRoXHJcbiAgICAvLyBkZWFjdGl2YXRpb24gY2hlY2tcIi5cclxuICAgIGNvbnN0IHdyYXBwZWRIb29rID0gaG9vay5fX3dkYyB8fFxyXG4gICAgICAgIChob29rLl9fd2RjID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBvbmx5IGZpcmUgdGhlIGhvb2sgaWYgdGhlIHRhcmdldCBpbnN0YW5jZSBpcyBOT1QgaW4gYSBkZWFjdGl2YXRlZCBicmFuY2guXHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQuaXNEZWFjdGl2YXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gaG9vaygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgaW5qZWN0SG9vayh0eXBlLCB3cmFwcGVkSG9vaywgdGFyZ2V0KTtcclxuICAgIC8vIEluIGFkZGl0aW9uIHRvIHJlZ2lzdGVyaW5nIGl0IG9uIHRoZSB0YXJnZXQgaW5zdGFuY2UsIHdlIHdhbGsgdXAgdGhlIHBhcmVudFxyXG4gICAgLy8gY2hhaW4gYW5kIHJlZ2lzdGVyIGl0IG9uIGFsbCBhbmNlc3RvciBpbnN0YW5jZXMgdGhhdCBhcmUga2VlcC1hbGl2ZSByb290cy5cclxuICAgIC8vIFRoaXMgYXZvaWRzIHRoZSBuZWVkIHRvIHdhbGsgdGhlIGVudGlyZSBjb21wb25lbnQgdHJlZSB3aGVuIGludm9raW5nIHRoZXNlXHJcbiAgICAvLyBob29rcywgYW5kIG1vcmUgaW1wb3J0YW50bHksIGF2b2lkcyB0aGUgbmVlZCB0byB0cmFjayBjaGlsZCBjb21wb25lbnRzIGluXHJcbiAgICAvLyBhcnJheXMuXHJcbiAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0YXJnZXQucGFyZW50O1xyXG4gICAgICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQucGFyZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChpc0tlZXBBbGl2ZShjdXJyZW50LnBhcmVudC52bm9kZSkpIHtcclxuICAgICAgICAgICAgICAgIGluamVjdFRvS2VlcEFsaXZlUm9vdCh3cmFwcGVkSG9vaywgdHlwZSwgdGFyZ2V0LCBjdXJyZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGluamVjdFRvS2VlcEFsaXZlUm9vdChob29rLCB0eXBlLCB0YXJnZXQsIGtlZXBBbGl2ZVJvb3QpIHtcclxuICAgIC8vIGluamVjdEhvb2sgd3JhcHMgdGhlIG9yaWdpbmFsIGZvciBlcnJvciBoYW5kbGluZywgc28gbWFrZSBzdXJlIHRvIHJlbW92ZVxyXG4gICAgLy8gdGhlIHdyYXBwZWQgdmVyc2lvbi5cclxuICAgIGNvbnN0IGluamVjdGVkID0gaW5qZWN0SG9vayh0eXBlLCBob29rLCBrZWVwQWxpdmVSb290LCB0cnVlIC8qIHByZXBlbmQgKi8pO1xyXG4gICAgb25Vbm1vdW50ZWQoKCkgPT4ge1xyXG4gICAgICAgIHJlbW92ZShrZWVwQWxpdmVSb290W3R5cGVdLCBpbmplY3RlZCk7XHJcbiAgICB9LCB0YXJnZXQpO1xyXG59XHJcbmZ1bmN0aW9uIHJlc2V0U2hhcGVGbGFnKHZub2RlKSB7XHJcbiAgICBsZXQgc2hhcGVGbGFnID0gdm5vZGUuc2hhcGVGbGFnO1xyXG4gICAgaWYgKHNoYXBlRmxhZyAmIDI1NiAvKiBDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi8pIHtcclxuICAgICAgICBzaGFwZUZsYWcgLT0gMjU2IC8qIENPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRSAqLztcclxuICAgIH1cclxuICAgIGlmIChzaGFwZUZsYWcgJiA1MTIgLyogQ09NUE9ORU5UX0tFUFRfQUxJVkUgKi8pIHtcclxuICAgICAgICBzaGFwZUZsYWcgLT0gNTEyIC8qIENPTVBPTkVOVF9LRVBUX0FMSVZFICovO1xyXG4gICAgfVxyXG4gICAgdm5vZGUuc2hhcGVGbGFnID0gc2hhcGVGbGFnO1xyXG59XHJcbmZ1bmN0aW9uIGdldElubmVyQ2hpbGQodm5vZGUpIHtcclxuICAgIHJldHVybiB2bm9kZS5zaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8gPyB2bm9kZS5zc0NvbnRlbnQgOiB2bm9kZTtcclxufVxuXG5mdW5jdGlvbiBpbmplY3RIb29rKHR5cGUsIGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSwgcHJlcGVuZCA9IGZhbHNlKSB7XHJcbiAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgY29uc3QgaG9va3MgPSB0YXJnZXRbdHlwZV0gfHwgKHRhcmdldFt0eXBlXSA9IFtdKTtcclxuICAgICAgICAvLyBjYWNoZSB0aGUgZXJyb3IgaGFuZGxpbmcgd3JhcHBlciBmb3IgaW5qZWN0ZWQgaG9va3Mgc28gdGhlIHNhbWUgaG9va1xyXG4gICAgICAgIC8vIGNhbiBiZSBwcm9wZXJseSBkZWR1cGVkIGJ5IHRoZSBzY2hlZHVsZXIuIFwiX193ZWhcIiBzdGFuZHMgZm9yIFwid2l0aCBlcnJvclxyXG4gICAgICAgIC8vIGhhbmRsaW5nXCIuXHJcbiAgICAgICAgY29uc3Qgd3JhcHBlZEhvb2sgPSBob29rLl9fd2VoIHx8XHJcbiAgICAgICAgICAgIChob29rLl9fd2VoID0gKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuaXNVbm1vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBkaXNhYmxlIHRyYWNraW5nIGluc2lkZSBhbGwgbGlmZWN5Y2xlIGhvb2tzXHJcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGV5IGNhbiBwb3RlbnRpYWxseSBiZSBjYWxsZWQgaW5zaWRlIGVmZmVjdHMuXHJcbiAgICAgICAgICAgICAgICBwYXVzZVRyYWNraW5nKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBTZXQgY3VycmVudEluc3RhbmNlIGR1cmluZyBob29rIGludm9jYXRpb24uXHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGFzc3VtZXMgdGhlIGhvb2sgZG9lcyBub3Qgc3luY2hyb25vdXNseSB0cmlnZ2VyIG90aGVyIGhvb2tzLCB3aGljaFxyXG4gICAgICAgICAgICAgICAgLy8gY2FuIG9ubHkgYmUgZmFsc2Ugd2hlbiB0aGUgdXNlciBkb2VzIHNvbWV0aGluZyByZWFsbHkgZnVua3kuXHJcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2UodGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIHRhcmdldCwgdHlwZSwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICB1bnNldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICAgICAgcmVzZXRUcmFja2luZygpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHByZXBlbmQpIHtcclxuICAgICAgICAgICAgaG9va3MudW5zaGlmdCh3cmFwcGVkSG9vayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBob29rcy5wdXNoKHdyYXBwZWRIb29rKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHdyYXBwZWRIb29rO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgY29uc3QgYXBpTmFtZSA9IHRvSGFuZGxlcktleShFcnJvclR5cGVTdHJpbmdzW3R5cGVdLnJlcGxhY2UoLyBob29rJC8sICcnKSk7XHJcbiAgICAgICAgd2FybihgJHthcGlOYW1lfSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlIHRvIGJlIGAgK1xyXG4gICAgICAgICAgICBgYXNzb2NpYXRlZCB3aXRoLiBgICtcclxuICAgICAgICAgICAgYExpZmVjeWNsZSBpbmplY3Rpb24gQVBJcyBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBleGVjdXRpb24gb2Ygc2V0dXAoKS5gICtcclxuICAgICAgICAgICAgKGAgSWYgeW91IGFyZSB1c2luZyBhc3luYyBzZXR1cCgpLCBtYWtlIHN1cmUgdG8gcmVnaXN0ZXIgbGlmZWN5Y2xlIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBob29rcyBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0IHN0YXRlbWVudC5gXHJcbiAgICAgICAgICAgICAgICApKTtcclxuICAgIH1cclxufVxyXG5jb25zdCBjcmVhdGVIb29rID0gKGxpZmVjeWNsZSkgPT4gKGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkgPT4gXHJcbi8vIHBvc3QtY3JlYXRlIGxpZmVjeWNsZSByZWdpc3RyYXRpb25zIGFyZSBub29wcyBkdXJpbmcgU1NSIChleGNlcHQgZm9yIHNlcnZlclByZWZldGNoKVxyXG4oIWlzSW5TU1JDb21wb25lbnRTZXR1cCB8fCBsaWZlY3ljbGUgPT09IFwic3BcIiAvKiBTRVJWRVJfUFJFRkVUQ0ggKi8pICYmXHJcbiAgICBpbmplY3RIb29rKGxpZmVjeWNsZSwgaG9vaywgdGFyZ2V0KTtcclxuY29uc3Qgb25CZWZvcmVNb3VudCA9IGNyZWF0ZUhvb2soXCJibVwiIC8qIEJFRk9SRV9NT1VOVCAqLyk7XHJcbmNvbnN0IG9uTW91bnRlZCA9IGNyZWF0ZUhvb2soXCJtXCIgLyogTU9VTlRFRCAqLyk7XHJcbmNvbnN0IG9uQmVmb3JlVXBkYXRlID0gY3JlYXRlSG9vayhcImJ1XCIgLyogQkVGT1JFX1VQREFURSAqLyk7XHJcbmNvbnN0IG9uVXBkYXRlZCA9IGNyZWF0ZUhvb2soXCJ1XCIgLyogVVBEQVRFRCAqLyk7XHJcbmNvbnN0IG9uQmVmb3JlVW5tb3VudCA9IGNyZWF0ZUhvb2soXCJidW1cIiAvKiBCRUZPUkVfVU5NT1VOVCAqLyk7XHJcbmNvbnN0IG9uVW5tb3VudGVkID0gY3JlYXRlSG9vayhcInVtXCIgLyogVU5NT1VOVEVEICovKTtcclxuY29uc3Qgb25TZXJ2ZXJQcmVmZXRjaCA9IGNyZWF0ZUhvb2soXCJzcFwiIC8qIFNFUlZFUl9QUkVGRVRDSCAqLyk7XHJcbmNvbnN0IG9uUmVuZGVyVHJpZ2dlcmVkID0gY3JlYXRlSG9vayhcInJ0Z1wiIC8qIFJFTkRFUl9UUklHR0VSRUQgKi8pO1xyXG5jb25zdCBvblJlbmRlclRyYWNrZWQgPSBjcmVhdGVIb29rKFwicnRjXCIgLyogUkVOREVSX1RSQUNLRUQgKi8pO1xyXG5mdW5jdGlvbiBvbkVycm9yQ2FwdHVyZWQoaG9vaywgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlKSB7XHJcbiAgICBpbmplY3RIb29rKFwiZWNcIiAvKiBFUlJPUl9DQVBUVVJFRCAqLywgaG9vaywgdGFyZ2V0KTtcclxufVxuXG5mdW5jdGlvbiBjcmVhdGVEdXBsaWNhdGVDaGVja2VyKCkge1xyXG4gICAgY29uc3QgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgcmV0dXJuICh0eXBlLCBrZXkpID0+IHtcclxuICAgICAgICBpZiAoY2FjaGVba2V5XSkge1xyXG4gICAgICAgICAgICB3YXJuKGAke3R5cGV9IHByb3BlcnR5IFwiJHtrZXl9XCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluICR7Y2FjaGVba2V5XX0uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjYWNoZVtrZXldID0gdHlwZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmxldCBzaG91bGRDYWNoZUFjY2VzcyA9IHRydWU7XHJcbmZ1bmN0aW9uIGFwcGx5T3B0aW9ucyhpbnN0YW5jZSkge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHJlc29sdmVNZXJnZWRPcHRpb25zKGluc3RhbmNlKTtcclxuICAgIGNvbnN0IHB1YmxpY1RoaXMgPSBpbnN0YW5jZS5wcm94eTtcclxuICAgIGNvbnN0IGN0eCA9IGluc3RhbmNlLmN0eDtcclxuICAgIC8vIGRvIG5vdCBjYWNoZSBwcm9wZXJ0eSBhY2Nlc3Mgb24gcHVibGljIHByb3h5IGR1cmluZyBzdGF0ZSBpbml0aWFsaXphdGlvblxyXG4gICAgc2hvdWxkQ2FjaGVBY2Nlc3MgPSBmYWxzZTtcclxuICAgIC8vIGNhbGwgYmVmb3JlQ3JlYXRlIGZpcnN0IGJlZm9yZSBhY2Nlc3Npbmcgb3RoZXIgb3B0aW9ucyBzaW5jZVxyXG4gICAgLy8gdGhlIGhvb2sgbWF5IG11dGF0ZSByZXNvbHZlZCBvcHRpb25zICgjMjc5MSlcclxuICAgIGlmIChvcHRpb25zLmJlZm9yZUNyZWF0ZSkge1xyXG4gICAgICAgIGNhbGxIb29rKG9wdGlvbnMuYmVmb3JlQ3JlYXRlLCBpbnN0YW5jZSwgXCJiY1wiIC8qIEJFRk9SRV9DUkVBVEUgKi8pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBcclxuICAgIC8vIHN0YXRlXHJcbiAgICBkYXRhOiBkYXRhT3B0aW9ucywgY29tcHV0ZWQ6IGNvbXB1dGVkT3B0aW9ucywgbWV0aG9kcywgd2F0Y2g6IHdhdGNoT3B0aW9ucywgcHJvdmlkZTogcHJvdmlkZU9wdGlvbnMsIGluamVjdDogaW5qZWN0T3B0aW9ucywgXHJcbiAgICAvLyBsaWZlY3ljbGVcclxuICAgIGNyZWF0ZWQsIGJlZm9yZU1vdW50LCBtb3VudGVkLCBiZWZvcmVVcGRhdGUsIHVwZGF0ZWQsIGFjdGl2YXRlZCwgZGVhY3RpdmF0ZWQsIGJlZm9yZURlc3Ryb3ksIGJlZm9yZVVubW91bnQsIGRlc3Ryb3llZCwgdW5tb3VudGVkLCByZW5kZXIsIHJlbmRlclRyYWNrZWQsIHJlbmRlclRyaWdnZXJlZCwgZXJyb3JDYXB0dXJlZCwgc2VydmVyUHJlZmV0Y2gsIFxyXG4gICAgLy8gcHVibGljIEFQSVxyXG4gICAgZXhwb3NlLCBpbmhlcml0QXR0cnMsIFxyXG4gICAgLy8gYXNzZXRzXHJcbiAgICBjb21wb25lbnRzLCBkaXJlY3RpdmVzLCBmaWx0ZXJzIH0gPSBvcHRpb25zO1xyXG4gICAgY29uc3QgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gY3JlYXRlRHVwbGljYXRlQ2hlY2tlcigpIDogbnVsbDtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBjb25zdCBbcHJvcHNPcHRpb25zXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcclxuICAgICAgICBpZiAocHJvcHNPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzT3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiUHJvcHNcIiAvKiBQUk9QUyAqLywga2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIG9wdGlvbnMgaW5pdGlhbGl6YXRpb24gb3JkZXIgKHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBWdWUgMik6XHJcbiAgICAvLyAtIHByb3BzIChhbHJlYWR5IGRvbmUgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uKVxyXG4gICAgLy8gLSBpbmplY3RcclxuICAgIC8vIC0gbWV0aG9kc1xyXG4gICAgLy8gLSBkYXRhIChkZWZlcnJlZCBzaW5jZSBpdCByZWxpZXMgb24gYHRoaXNgIGFjY2VzcylcclxuICAgIC8vIC0gY29tcHV0ZWRcclxuICAgIC8vIC0gd2F0Y2ggKGRlZmVycmVkIHNpbmNlIGl0IHJlbGllcyBvbiBgdGhpc2AgYWNjZXNzKVxyXG4gICAgaWYgKGluamVjdE9wdGlvbnMpIHtcclxuICAgICAgICByZXNvbHZlSW5qZWN0aW9ucyhpbmplY3RPcHRpb25zLCBjdHgsIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcywgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcudW53cmFwSW5qZWN0ZWRSZWYpO1xyXG4gICAgfVxyXG4gICAgaWYgKG1ldGhvZHMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBtZXRob2RzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZEhhbmRsZXIgPSBtZXRob2RzW2tleV07XHJcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKG1ldGhvZEhhbmRsZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJbiBkZXYgbW9kZSwgd2UgdXNlIHRoZSBgY3JlYXRlUmVuZGVyQ29udGV4dGAgZnVuY3Rpb24gdG8gZGVmaW5lXHJcbiAgICAgICAgICAgICAgICAvLyBtZXRob2RzIHRvIHRoZSBwcm94eSB0YXJnZXQsIGFuZCB0aG9zZSBhcmUgcmVhZC1vbmx5IGJ1dFxyXG4gICAgICAgICAgICAgICAgLy8gcmVjb25maWd1cmFibGUsIHNvIGl0IG5lZWRzIHRvIGJlIHJlZGVmaW5lZCBoZXJlXHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtZXRob2RIYW5kbGVyLmJpbmQocHVibGljVGhpcyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eFtrZXldID0gbWV0aG9kSGFuZGxlci5iaW5kKHB1YmxpY1RoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIk1ldGhvZHNcIiAvKiBNRVRIT0RTICovLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgTWV0aG9kIFwiJHtrZXl9XCIgaGFzIHR5cGUgXCIke3R5cGVvZiBtZXRob2RIYW5kbGVyfVwiIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYERpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoZGF0YU9wdGlvbnMpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc0Z1bmN0aW9uKGRhdGFPcHRpb25zKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBUaGUgZGF0YSBvcHRpb24gbXVzdCBiZSBhIGZ1bmN0aW9uLiBgICtcclxuICAgICAgICAgICAgICAgIGBQbGFpbiBvYmplY3QgdXNhZ2UgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IGRhdGFPcHRpb25zLmNhbGwocHVibGljVGhpcywgcHVibGljVGhpcyk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpc1Byb21pc2UoZGF0YSkpIHtcclxuICAgICAgICAgICAgd2FybihgZGF0YSgpIHJldHVybmVkIGEgUHJvbWlzZSAtIG5vdGUgZGF0YSgpIGNhbm5vdCBiZSBhc3luYzsgSWYgeW91IGAgK1xyXG4gICAgICAgICAgICAgICAgYGludGVuZCB0byBwZXJmb3JtIGRhdGEgZmV0Y2hpbmcgYmVmb3JlIGNvbXBvbmVudCByZW5kZXJzLCB1c2UgYCArXHJcbiAgICAgICAgICAgICAgICBgYXN5bmMgc2V0dXAoKSArIDxTdXNwZW5zZT4uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4oYGRhdGEoKSBzaG91bGQgcmV0dXJuIGFuIG9iamVjdC5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLmRhdGEgPSByZWFjdGl2ZShkYXRhKTtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIkRhdGFcIiAvKiBEQVRBICovLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGV4cG9zZSBkYXRhIG9uIGN0eCBkdXJpbmcgZGV2XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleVswXSAhPT0gJyQnICYmIGtleVswXSAhPT0gJ18nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldDogKCkgPT4gZGF0YVtrZXldLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0OiBOT09QXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHN0YXRlIGluaXRpYWxpemF0aW9uIGNvbXBsZXRlIGF0IHRoaXMgcG9pbnQgLSBzdGFydCBjYWNoaW5nIGFjY2Vzc1xyXG4gICAgc2hvdWxkQ2FjaGVBY2Nlc3MgPSB0cnVlO1xyXG4gICAgaWYgKGNvbXB1dGVkT3B0aW9ucykge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNvbXB1dGVkT3B0aW9ucykge1xyXG4gICAgICAgICAgICBjb25zdCBvcHQgPSBjb21wdXRlZE9wdGlvbnNba2V5XTtcclxuICAgICAgICAgICAgY29uc3QgZ2V0ID0gaXNGdW5jdGlvbihvcHQpXHJcbiAgICAgICAgICAgICAgICA/IG9wdC5iaW5kKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpXHJcbiAgICAgICAgICAgICAgICA6IGlzRnVuY3Rpb24ob3B0LmdldClcclxuICAgICAgICAgICAgICAgICAgICA/IG9wdC5nZXQuYmluZChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKVxyXG4gICAgICAgICAgICAgICAgICAgIDogTk9PUDtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBnZXQgPT09IE5PT1ApIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYENvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgaGFzIG5vIGdldHRlci5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBzZXQgPSAhaXNGdW5jdGlvbihvcHQpICYmIGlzRnVuY3Rpb24ob3B0LnNldClcclxuICAgICAgICAgICAgICAgID8gb3B0LnNldC5iaW5kKHB1YmxpY1RoaXMpXHJcbiAgICAgICAgICAgICAgICA6IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgICAgICAgICAgICAgID8gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBXcml0ZSBvcGVyYXRpb24gZmFpbGVkOiBjb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIHJlYWRvbmx5LmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICA6IE5PT1A7XHJcbiAgICAgICAgICAgIGNvbnN0IGMgPSBjb21wdXRlZCh7XHJcbiAgICAgICAgICAgICAgICBnZXQsXHJcbiAgICAgICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGdldDogKCkgPT4gYy52YWx1ZSxcclxuICAgICAgICAgICAgICAgIHNldDogdiA9PiAoYy52YWx1ZSA9IHYpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJDb21wdXRlZFwiIC8qIENPTVBVVEVEICovLCBrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHdhdGNoT3B0aW9ucykge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHdhdGNoT3B0aW9ucykge1xyXG4gICAgICAgICAgICBjcmVhdGVXYXRjaGVyKHdhdGNoT3B0aW9uc1trZXldLCBjdHgsIHB1YmxpY1RoaXMsIGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHByb3ZpZGVPcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXMgPSBpc0Z1bmN0aW9uKHByb3ZpZGVPcHRpb25zKVxyXG4gICAgICAgICAgICA/IHByb3ZpZGVPcHRpb25zLmNhbGwocHVibGljVGhpcylcclxuICAgICAgICAgICAgOiBwcm92aWRlT3B0aW9ucztcclxuICAgICAgICBSZWZsZWN0Lm93bktleXMocHJvdmlkZXMpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgcHJvdmlkZShrZXksIHByb3ZpZGVzW2tleV0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKGNyZWF0ZWQpIHtcclxuICAgICAgICBjYWxsSG9vayhjcmVhdGVkLCBpbnN0YW5jZSwgXCJjXCIgLyogQ1JFQVRFRCAqLyk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZWdpc3RlckxpZmVjeWNsZUhvb2socmVnaXN0ZXIsIGhvb2spIHtcclxuICAgICAgICBpZiAoaXNBcnJheShob29rKSkge1xyXG4gICAgICAgICAgICBob29rLmZvckVhY2goX2hvb2sgPT4gcmVnaXN0ZXIoX2hvb2suYmluZChwdWJsaWNUaGlzKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChob29rKSB7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyKGhvb2suYmluZChwdWJsaWNUaGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQmVmb3JlTW91bnQsIGJlZm9yZU1vdW50KTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbk1vdW50ZWQsIG1vdW50ZWQpO1xyXG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQmVmb3JlVXBkYXRlLCBiZWZvcmVVcGRhdGUpO1xyXG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uVXBkYXRlZCwgdXBkYXRlZCk7XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25BY3RpdmF0ZWQsIGFjdGl2YXRlZCk7XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25EZWFjdGl2YXRlZCwgZGVhY3RpdmF0ZWQpO1xyXG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uRXJyb3JDYXB0dXJlZCwgZXJyb3JDYXB0dXJlZCk7XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25SZW5kZXJUcmFja2VkLCByZW5kZXJUcmFja2VkKTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblJlbmRlclRyaWdnZXJlZCwgcmVuZGVyVHJpZ2dlcmVkKTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkJlZm9yZVVubW91bnQsIGJlZm9yZVVubW91bnQpO1xyXG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uVW5tb3VudGVkLCB1bm1vdW50ZWQpO1xyXG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uU2VydmVyUHJlZmV0Y2gsIHNlcnZlclByZWZldGNoKTtcclxuICAgIGlmIChpc0FycmF5KGV4cG9zZSkpIHtcclxuICAgICAgICBpZiAoZXhwb3NlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjb25zdCBleHBvc2VkID0gaW5zdGFuY2UuZXhwb3NlZCB8fCAoaW5zdGFuY2UuZXhwb3NlZCA9IHt9KTtcclxuICAgICAgICAgICAgZXhwb3NlLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvc2VkLCBrZXksIHtcclxuICAgICAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHB1YmxpY1RoaXNba2V5XSxcclxuICAgICAgICAgICAgICAgICAgICBzZXQ6IHZhbCA9PiAocHVibGljVGhpc1trZXldID0gdmFsKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghaW5zdGFuY2UuZXhwb3NlZCkge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5leHBvc2VkID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gb3B0aW9ucyB0aGF0IGFyZSBoYW5kbGVkIHdoZW4gY3JlYXRpbmcgdGhlIGluc3RhbmNlIGJ1dCBhbHNvIG5lZWQgdG8gYmVcclxuICAgIC8vIGFwcGxpZWQgZnJvbSBtaXhpbnNcclxuICAgIGlmIChyZW5kZXIgJiYgaW5zdGFuY2UucmVuZGVyID09PSBOT09QKSB7XHJcbiAgICAgICAgaW5zdGFuY2UucmVuZGVyID0gcmVuZGVyO1xyXG4gICAgfVxyXG4gICAgaWYgKGluaGVyaXRBdHRycyAhPSBudWxsKSB7XHJcbiAgICAgICAgaW5zdGFuY2UuaW5oZXJpdEF0dHJzID0gaW5oZXJpdEF0dHJzO1xyXG4gICAgfVxyXG4gICAgLy8gYXNzZXQgb3B0aW9ucy5cclxuICAgIGlmIChjb21wb25lbnRzKVxyXG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudHMgPSBjb21wb25lbnRzO1xyXG4gICAgaWYgKGRpcmVjdGl2ZXMpXHJcbiAgICAgICAgaW5zdGFuY2UuZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XHJcbn1cclxuZnVuY3Rpb24gcmVzb2x2ZUluamVjdGlvbnMoaW5qZWN0T3B0aW9ucywgY3R4LCBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMgPSBOT09QLCB1bndyYXBSZWYgPSBmYWxzZSkge1xyXG4gICAgaWYgKGlzQXJyYXkoaW5qZWN0T3B0aW9ucykpIHtcclxuICAgICAgICBpbmplY3RPcHRpb25zID0gbm9ybWFsaXplSW5qZWN0KGluamVjdE9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gaW5qZWN0T3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IG9wdCA9IGluamVjdE9wdGlvbnNba2V5XTtcclxuICAgICAgICBsZXQgaW5qZWN0ZWQ7XHJcbiAgICAgICAgaWYgKGlzT2JqZWN0KG9wdCkpIHtcclxuICAgICAgICAgICAgaWYgKCdkZWZhdWx0JyBpbiBvcHQpIHtcclxuICAgICAgICAgICAgICAgIGluamVjdGVkID0gaW5qZWN0KG9wdC5mcm9tIHx8IGtleSwgb3B0LmRlZmF1bHQsIHRydWUgLyogdHJlYXQgZGVmYXVsdCBmdW5jdGlvbiBhcyBmYWN0b3J5ICovKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGluamVjdGVkID0gaW5qZWN0KG9wdC5mcm9tIHx8IGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGluamVjdGVkID0gaW5qZWN0KG9wdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1JlZihpbmplY3RlZCkpIHtcclxuICAgICAgICAgICAgLy8gVE9ETyByZW1vdmUgdGhlIGNoZWNrIGluIDMuM1xyXG4gICAgICAgICAgICBpZiAodW53cmFwUmVmKSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcclxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IGluamVjdGVkLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHNldDogdiA9PiAoaW5qZWN0ZWQudmFsdWUgPSB2KVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgaW5qZWN0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBpcyBhIHJlZiBhbmQgd2lsbCBiZSBhdXRvLXVud3JhcHBlZCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYGFuZCBubyBsb25nZXIgbmVlZHMgXFxgLnZhbHVlXFxgIGluIHRoZSBuZXh0IG1pbm9yIHJlbGVhc2UuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgVG8gb3B0LWluIHRvIHRoZSBuZXcgYmVoYXZpb3Igbm93LCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYHNldCBcXGBhcHAuY29uZmlnLnVud3JhcEluamVjdGVkUmVmID0gdHJ1ZVxcYCAodGhpcyBjb25maWcgaXMgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGB0ZW1wb3JhcnkgYW5kIHdpbGwgbm90IGJlIG5lZWRlZCBpbiB0aGUgZnV0dXJlLilgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN0eFtrZXldID0gaW5qZWN0ZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGN0eFtrZXldID0gaW5qZWN0ZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiSW5qZWN0XCIgLyogSU5KRUNUICovLCBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjYWxsSG9vayhob29rLCBpbnN0YW5jZSwgdHlwZSkge1xyXG4gICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaXNBcnJheShob29rKVxyXG4gICAgICAgID8gaG9vay5tYXAoaCA9PiBoLmJpbmQoaW5zdGFuY2UucHJveHkpKVxyXG4gICAgICAgIDogaG9vay5iaW5kKGluc3RhbmNlLnByb3h5KSwgaW5zdGFuY2UsIHR5cGUpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIocmF3LCBjdHgsIHB1YmxpY1RoaXMsIGtleSkge1xyXG4gICAgY29uc3QgZ2V0dGVyID0ga2V5LmluY2x1ZGVzKCcuJylcclxuICAgICAgICA/IGNyZWF0ZVBhdGhHZXR0ZXIocHVibGljVGhpcywga2V5KVxyXG4gICAgICAgIDogKCkgPT4gcHVibGljVGhpc1trZXldO1xyXG4gICAgaWYgKGlzU3RyaW5nKHJhdykpIHtcclxuICAgICAgICBjb25zdCBoYW5kbGVyID0gY3R4W3Jhd107XHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcclxuICAgICAgICAgICAgd2F0Y2goZ2V0dGVyLCBoYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEludmFsaWQgd2F0Y2ggaGFuZGxlciBzcGVjaWZpZWQgYnkga2V5IFwiJHtyYXd9XCJgLCBoYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHJhdykpIHtcclxuICAgICAgICB3YXRjaChnZXR0ZXIsIHJhdy5iaW5kKHB1YmxpY1RoaXMpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHJhdykpIHtcclxuICAgICAgICBpZiAoaXNBcnJheShyYXcpKSB7XHJcbiAgICAgICAgICAgIHJhdy5mb3JFYWNoKHIgPT4gY3JlYXRlV2F0Y2hlcihyLCBjdHgsIHB1YmxpY1RoaXMsIGtleSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IGlzRnVuY3Rpb24ocmF3LmhhbmRsZXIpXHJcbiAgICAgICAgICAgICAgICA/IHJhdy5oYW5kbGVyLmJpbmQocHVibGljVGhpcylcclxuICAgICAgICAgICAgICAgIDogY3R4W3Jhdy5oYW5kbGVyXTtcclxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcclxuICAgICAgICAgICAgICAgIHdhdGNoKGdldHRlciwgaGFuZGxlciwgcmF3KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYEludmFsaWQgd2F0Y2ggaGFuZGxlciBzcGVjaWZpZWQgYnkga2V5IFwiJHtyYXcuaGFuZGxlcn1cImAsIGhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgd2FybihgSW52YWxpZCB3YXRjaCBvcHRpb246IFwiJHtrZXl9XCJgLCByYXcpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXNvbHZlIG1lcmdlZCBvcHRpb25zIGFuZCBjYWNoZSBpdCBvbiB0aGUgY29tcG9uZW50LlxyXG4gKiBUaGlzIGlzIGRvbmUgb25seSBvbmNlIHBlci1jb21wb25lbnQgc2luY2UgdGhlIG1lcmdpbmcgZG9lcyBub3QgaW52b2x2ZVxyXG4gKiBpbnN0YW5jZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgYmFzZSA9IGluc3RhbmNlLnR5cGU7XHJcbiAgICBjb25zdCB7IG1peGlucywgZXh0ZW5kczogZXh0ZW5kc09wdGlvbnMgfSA9IGJhc2U7XHJcbiAgICBjb25zdCB7IG1peGluczogZ2xvYmFsTWl4aW5zLCBvcHRpb25zQ2FjaGU6IGNhY2hlLCBjb25maWc6IHsgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzIH0gfSA9IGluc3RhbmNlLmFwcENvbnRleHQ7XHJcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoYmFzZSk7XHJcbiAgICBsZXQgcmVzb2x2ZWQ7XHJcbiAgICBpZiAoY2FjaGVkKSB7XHJcbiAgICAgICAgcmVzb2x2ZWQgPSBjYWNoZWQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghZ2xvYmFsTWl4aW5zLmxlbmd0aCAmJiAhbWl4aW5zICYmICFleHRlbmRzT3B0aW9ucykge1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmVzb2x2ZWQgPSBiYXNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJlc29sdmVkID0ge307XHJcbiAgICAgICAgaWYgKGdsb2JhbE1peGlucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgZ2xvYmFsTWl4aW5zLmZvckVhY2gobSA9PiBtZXJnZU9wdGlvbnMocmVzb2x2ZWQsIG0sIG9wdGlvbk1lcmdlU3RyYXRlZ2llcywgdHJ1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtZXJnZU9wdGlvbnMocmVzb2x2ZWQsIGJhc2UsIG9wdGlvbk1lcmdlU3RyYXRlZ2llcyk7XHJcbiAgICB9XHJcbiAgICBjYWNoZS5zZXQoYmFzZSwgcmVzb2x2ZWQpO1xyXG4gICAgcmV0dXJuIHJlc29sdmVkO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyh0bywgZnJvbSwgc3RyYXRzLCBhc01peGluID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IHsgbWl4aW5zLCBleHRlbmRzOiBleHRlbmRzT3B0aW9ucyB9ID0gZnJvbTtcclxuICAgIGlmIChleHRlbmRzT3B0aW9ucykge1xyXG4gICAgICAgIG1lcmdlT3B0aW9ucyh0bywgZXh0ZW5kc09wdGlvbnMsIHN0cmF0cywgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBpZiAobWl4aW5zKSB7XHJcbiAgICAgICAgbWl4aW5zLmZvckVhY2goKG0pID0+IG1lcmdlT3B0aW9ucyh0bywgbSwgc3RyYXRzLCB0cnVlKSk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmcm9tKSB7XHJcbiAgICAgICAgaWYgKGFzTWl4aW4gJiYga2V5ID09PSAnZXhwb3NlJykge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIHdhcm4oYFwiZXhwb3NlXCIgb3B0aW9uIGlzIGlnbm9yZWQgd2hlbiBkZWNsYXJlZCBpbiBtaXhpbnMgb3IgZXh0ZW5kcy4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYEl0IHNob3VsZCBvbmx5IGJlIGRlY2xhcmVkIGluIHRoZSBiYXNlIGNvbXBvbmVudCBpdHNlbGYuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBzdHJhdCA9IGludGVybmFsT3B0aW9uTWVyZ2VTdHJhdHNba2V5XSB8fCAoc3RyYXRzICYmIHN0cmF0c1trZXldKTtcclxuICAgICAgICAgICAgdG9ba2V5XSA9IHN0cmF0ID8gc3RyYXQodG9ba2V5XSwgZnJvbVtrZXldKSA6IGZyb21ba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG87XHJcbn1cclxuY29uc3QgaW50ZXJuYWxPcHRpb25NZXJnZVN0cmF0cyA9IHtcclxuICAgIGRhdGE6IG1lcmdlRGF0YUZuLFxyXG4gICAgcHJvcHM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcclxuICAgIGVtaXRzOiBtZXJnZU9iamVjdE9wdGlvbnMsXHJcbiAgICAvLyBvYmplY3RzXHJcbiAgICBtZXRob2RzOiBtZXJnZU9iamVjdE9wdGlvbnMsXHJcbiAgICBjb21wdXRlZDogbWVyZ2VPYmplY3RPcHRpb25zLFxyXG4gICAgLy8gbGlmZWN5Y2xlXHJcbiAgICBiZWZvcmVDcmVhdGU6IG1lcmdlQXNBcnJheSxcclxuICAgIGNyZWF0ZWQ6IG1lcmdlQXNBcnJheSxcclxuICAgIGJlZm9yZU1vdW50OiBtZXJnZUFzQXJyYXksXHJcbiAgICBtb3VudGVkOiBtZXJnZUFzQXJyYXksXHJcbiAgICBiZWZvcmVVcGRhdGU6IG1lcmdlQXNBcnJheSxcclxuICAgIHVwZGF0ZWQ6IG1lcmdlQXNBcnJheSxcclxuICAgIGJlZm9yZURlc3Ryb3k6IG1lcmdlQXNBcnJheSxcclxuICAgIGJlZm9yZVVubW91bnQ6IG1lcmdlQXNBcnJheSxcclxuICAgIGRlc3Ryb3llZDogbWVyZ2VBc0FycmF5LFxyXG4gICAgdW5tb3VudGVkOiBtZXJnZUFzQXJyYXksXHJcbiAgICBhY3RpdmF0ZWQ6IG1lcmdlQXNBcnJheSxcclxuICAgIGRlYWN0aXZhdGVkOiBtZXJnZUFzQXJyYXksXHJcbiAgICBlcnJvckNhcHR1cmVkOiBtZXJnZUFzQXJyYXksXHJcbiAgICBzZXJ2ZXJQcmVmZXRjaDogbWVyZ2VBc0FycmF5LFxyXG4gICAgLy8gYXNzZXRzXHJcbiAgICBjb21wb25lbnRzOiBtZXJnZU9iamVjdE9wdGlvbnMsXHJcbiAgICBkaXJlY3RpdmVzOiBtZXJnZU9iamVjdE9wdGlvbnMsXHJcbiAgICAvLyB3YXRjaFxyXG4gICAgd2F0Y2g6IG1lcmdlV2F0Y2hPcHRpb25zLFxyXG4gICAgLy8gcHJvdmlkZSAvIGluamVjdFxyXG4gICAgcHJvdmlkZTogbWVyZ2VEYXRhRm4sXHJcbiAgICBpbmplY3Q6IG1lcmdlSW5qZWN0XHJcbn07XHJcbmZ1bmN0aW9uIG1lcmdlRGF0YUZuKHRvLCBmcm9tKSB7XHJcbiAgICBpZiAoIWZyb20pIHtcclxuICAgICAgICByZXR1cm4gdG87XHJcbiAgICB9XHJcbiAgICBpZiAoIXRvKSB7XHJcbiAgICAgICAgcmV0dXJuIGZyb207XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuKCkge1xyXG4gICAgICAgIHJldHVybiAoZXh0ZW5kKShpc0Z1bmN0aW9uKHRvKSA/IHRvLmNhbGwodGhpcywgdGhpcykgOiB0bywgaXNGdW5jdGlvbihmcm9tKSA/IGZyb20uY2FsbCh0aGlzLCB0aGlzKSA6IGZyb20pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBtZXJnZUluamVjdCh0bywgZnJvbSkge1xyXG4gICAgcmV0dXJuIG1lcmdlT2JqZWN0T3B0aW9ucyhub3JtYWxpemVJbmplY3QodG8pLCBub3JtYWxpemVJbmplY3QoZnJvbSkpO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUluamVjdChyYXcpIHtcclxuICAgIGlmIChpc0FycmF5KHJhdykpIHtcclxuICAgICAgICBjb25zdCByZXMgPSB7fTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhdy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICByZXNbcmF3W2ldXSA9IHJhd1tpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHJldHVybiByYXc7XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VBc0FycmF5KHRvLCBmcm9tKSB7XHJcbiAgICByZXR1cm4gdG8gPyBbLi4ubmV3IFNldChbXS5jb25jYXQodG8sIGZyb20pKV0gOiBmcm9tO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlT2JqZWN0T3B0aW9ucyh0bywgZnJvbSkge1xyXG4gICAgcmV0dXJuIHRvID8gZXh0ZW5kKGV4dGVuZChPYmplY3QuY3JlYXRlKG51bGwpLCB0byksIGZyb20pIDogZnJvbTtcclxufVxyXG5mdW5jdGlvbiBtZXJnZVdhdGNoT3B0aW9ucyh0bywgZnJvbSkge1xyXG4gICAgaWYgKCF0bylcclxuICAgICAgICByZXR1cm4gZnJvbTtcclxuICAgIGlmICghZnJvbSlcclxuICAgICAgICByZXR1cm4gdG87XHJcbiAgICBjb25zdCBtZXJnZWQgPSBleHRlbmQoT2JqZWN0LmNyZWF0ZShudWxsKSwgdG8pO1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gZnJvbSkge1xyXG4gICAgICAgIG1lcmdlZFtrZXldID0gbWVyZ2VBc0FycmF5KHRvW2tleV0sIGZyb21ba2V5XSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWVyZ2VkO1xyXG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIGlzU3RhdGVmdWwsIC8vIHJlc3VsdCBvZiBiaXR3aXNlIGZsYWcgY29tcGFyaXNvblxyXG5pc1NTUiA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBwcm9wcyA9IHt9O1xyXG4gICAgY29uc3QgYXR0cnMgPSB7fTtcclxuICAgIGRlZihhdHRycywgSW50ZXJuYWxPYmplY3RLZXksIDEpO1xyXG4gICAgaW5zdGFuY2UucHJvcHNEZWZhdWx0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICBzZXRGdWxsUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBwcm9wcywgYXR0cnMpO1xyXG4gICAgLy8gZW5zdXJlIGFsbCBkZWNsYXJlZCBwcm9wIGtleXMgYXJlIHByZXNlbnRcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGluc3RhbmNlLnByb3BzT3B0aW9uc1swXSkge1xyXG4gICAgICAgIGlmICghKGtleSBpbiBwcm9wcykpIHtcclxuICAgICAgICAgICAgcHJvcHNba2V5XSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyB2YWxpZGF0aW9uXHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgdmFsaWRhdGVQcm9wcyhyYXdQcm9wcyB8fCB7fSwgcHJvcHMsIGluc3RhbmNlKTtcclxuICAgIH1cclxuICAgIGlmIChpc1N0YXRlZnVsKSB7XHJcbiAgICAgICAgLy8gc3RhdGVmdWxcclxuICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGlzU1NSID8gcHJvcHMgOiBzaGFsbG93UmVhY3RpdmUocHJvcHMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKCFpbnN0YW5jZS50eXBlLnByb3BzKSB7XHJcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uYWwgdy8gb3B0aW9uYWwgcHJvcHMsIHByb3BzID09PSBhdHRyc1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGF0dHJzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZnVuY3Rpb25hbCB3LyBkZWNsYXJlZCBwcm9wc1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IHByb3BzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGluc3RhbmNlLmF0dHJzID0gYXR0cnM7XHJcbn1cclxuZnVuY3Rpb24gdXBkYXRlUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCByYXdQcmV2UHJvcHMsIG9wdGltaXplZCkge1xyXG4gICAgY29uc3QgeyBwcm9wcywgYXR0cnMsIHZub2RlOiB7IHBhdGNoRmxhZyB9IH0gPSBpbnN0YW5jZTtcclxuICAgIGNvbnN0IHJhd0N1cnJlbnRQcm9wcyA9IHRvUmF3KHByb3BzKTtcclxuICAgIGNvbnN0IFtvcHRpb25zXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcclxuICAgIGxldCBoYXNBdHRyc0NoYW5nZWQgPSBmYWxzZTtcclxuICAgIGlmIChcclxuICAgIC8vIGFsd2F5cyBmb3JjZSBmdWxsIGRpZmYgaW4gZGV2XHJcbiAgICAvLyAtICMxOTQyIGlmIGhtciBpcyBlbmFibGVkIHdpdGggc2ZjIGNvbXBvbmVudFxyXG4gICAgLy8gLSB2aXRlIzg3MiBub24tc2ZjIGNvbXBvbmVudCB1c2VkIGJ5IHNmYyBjb21wb25lbnRcclxuICAgICEoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgKGluc3RhbmNlLnR5cGUuX19obXJJZCB8fFxyXG4gICAgICAgICAgICAoaW5zdGFuY2UucGFyZW50ICYmIGluc3RhbmNlLnBhcmVudC50eXBlLl9faG1ySWQpKSkgJiZcclxuICAgICAgICAob3B0aW1pemVkIHx8IHBhdGNoRmxhZyA+IDApICYmXHJcbiAgICAgICAgIShwYXRjaEZsYWcgJiAxNiAvKiBGVUxMX1BST1BTICovKSkge1xyXG4gICAgICAgIGlmIChwYXRjaEZsYWcgJiA4IC8qIFBST1BTICovKSB7XHJcbiAgICAgICAgICAgIC8vIENvbXBpbGVyLWdlbmVyYXRlZCBwcm9wcyAmIG5vIGtleXMgY2hhbmdlLCBqdXN0IHNldCB0aGUgdXBkYXRlZFxyXG4gICAgICAgICAgICAvLyB0aGUgcHJvcHMuXHJcbiAgICAgICAgICAgIGNvbnN0IHByb3BzVG9VcGRhdGUgPSBpbnN0YW5jZS52bm9kZS5keW5hbWljUHJvcHM7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHNUb1VwZGF0ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGtleSA9IHByb3BzVG9VcGRhdGVbaV07XHJcbiAgICAgICAgICAgICAgICAvLyBQUk9QUyBmbGFnIGd1YXJhbnRlZXMgcmF3UHJvcHMgdG8gYmUgbm9uLW51bGxcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmF3UHJvcHNba2V5XTtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXR0ciAvIHByb3BzIHNlcGFyYXRpb24gd2FzIGRvbmUgb24gaW5pdCBhbmQgd2lsbCBiZSBjb25zaXN0ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhpcyBjb2RlIHBhdGgsIHNvIGp1c3QgY2hlY2sgaWYgYXR0cnMgaGF2ZSBpdC5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3duKGF0dHJzLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gYXR0cnNba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FtZWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbY2FtZWxpemVkS2V5XSA9IHJlc29sdmVQcm9wVmFsdWUob3B0aW9ucywgcmF3Q3VycmVudFByb3BzLCBjYW1lbGl6ZWRLZXksIHZhbHVlLCBpbnN0YW5jZSwgZmFsc2UgLyogaXNBYnNlbnQgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gYXR0cnNba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gZnVsbCBwcm9wcyB1cGRhdGUuXHJcbiAgICAgICAgaWYgKHNldEZ1bGxQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHByb3BzLCBhdHRycykpIHtcclxuICAgICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaW4gY2FzZSBvZiBkeW5hbWljIHByb3BzLCBjaGVjayBpZiB3ZSBuZWVkIHRvIGRlbGV0ZSBrZXlzIGZyb21cclxuICAgICAgICAvLyB0aGUgcHJvcHMgb2JqZWN0XHJcbiAgICAgICAgbGV0IGtlYmFiS2V5O1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJhd0N1cnJlbnRQcm9wcykge1xyXG4gICAgICAgICAgICBpZiAoIXJhd1Byb3BzIHx8XHJcbiAgICAgICAgICAgICAgICAvLyBmb3IgY2FtZWxDYXNlXHJcbiAgICAgICAgICAgICAgICAoIWhhc093bihyYXdQcm9wcywga2V5KSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhlIG9yaWdpbmFsIHByb3BzIHdhcyBwYXNzZWQgaW4gYXMga2ViYWItY2FzZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBjb252ZXJ0ZWQgdG8gY2FtZWxDYXNlICgjOTU1KVxyXG4gICAgICAgICAgICAgICAgICAgICgoa2ViYWJLZXkgPSBoeXBoZW5hdGUoa2V5KSkgPT09IGtleSB8fCAhaGFzT3duKHJhd1Byb3BzLCBrZWJhYktleSkpKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmF3UHJldlByb3BzICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBjYW1lbENhc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHJhd1ByZXZQcm9wc1trZXldICE9PSB1bmRlZmluZWQgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBrZWJhYi1jYXNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXdQcmV2UHJvcHNba2ViYWJLZXldICE9PSB1bmRlZmluZWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzW2tleV0gPSByZXNvbHZlUHJvcFZhbHVlKG9wdGlvbnMsIHJhd0N1cnJlbnRQcm9wcywga2V5LCB1bmRlZmluZWQsIGluc3RhbmNlLCB0cnVlIC8qIGlzQWJzZW50ICovKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcHJvcHNba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbiB0aGUgY2FzZSBvZiBmdW5jdGlvbmFsIGNvbXBvbmVudCB3L28gcHJvcHMgZGVjbGFyYXRpb24sIHByb3BzIGFuZFxyXG4gICAgICAgIC8vIGF0dHJzIHBvaW50IHRvIHRoZSBzYW1lIG9iamVjdCBzbyBpdCBzaG91bGQgYWxyZWFkeSBoYXZlIGJlZW4gdXBkYXRlZC5cclxuICAgICAgICBpZiAoYXR0cnMgIT09IHJhd0N1cnJlbnRQcm9wcykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyYXdQcm9wcyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICghaGFzT3duKHJhd1Byb3BzLCBrZXkpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICghZmFsc2UgKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXR0cnNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gdHJpZ2dlciB1cGRhdGVzIGZvciAkYXR0cnMgaW4gY2FzZSBpdCdzIHVzZWQgaW4gY29tcG9uZW50IHNsb3RzXHJcbiAgICBpZiAoaGFzQXR0cnNDaGFuZ2VkKSB7XHJcbiAgICAgICAgdHJpZ2dlcihpbnN0YW5jZSwgXCJzZXRcIiAvKiBTRVQgKi8sICckYXR0cnMnKTtcclxuICAgIH1cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB2YWxpZGF0ZVByb3BzKHJhd1Byb3BzIHx8IHt9LCBwcm9wcywgaW5zdGFuY2UpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNldEZ1bGxQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHByb3BzLCBhdHRycykge1xyXG4gICAgY29uc3QgW29wdGlvbnMsIG5lZWRDYXN0S2V5c10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XHJcbiAgICBsZXQgaGFzQXR0cnNDaGFuZ2VkID0gZmFsc2U7XHJcbiAgICBsZXQgcmF3Q2FzdFZhbHVlcztcclxuICAgIGlmIChyYXdQcm9wcykge1xyXG4gICAgICAgIGZvciAobGV0IGtleSBpbiByYXdQcm9wcykge1xyXG4gICAgICAgICAgICAvLyBrZXksIHJlZiBhcmUgcmVzZXJ2ZWQgYW5kIG5ldmVyIHBhc3NlZCBkb3duXHJcbiAgICAgICAgICAgIGlmIChpc1Jlc2VydmVkUHJvcChrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJhd1Byb3BzW2tleV07XHJcbiAgICAgICAgICAgIC8vIHByb3Agb3B0aW9uIG5hbWVzIGFyZSBjYW1lbGl6ZWQgZHVyaW5nIG5vcm1hbGl6YXRpb24sIHNvIHRvIHN1cHBvcnRcclxuICAgICAgICAgICAgLy8ga2ViYWIgLT4gY2FtZWwgY29udmVyc2lvbiBoZXJlIHdlIG5lZWQgdG8gY2FtZWxpemUgdGhlIGtleS5cclxuICAgICAgICAgICAgbGV0IGNhbWVsS2V5O1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBoYXNPd24ob3B0aW9ucywgKGNhbWVsS2V5ID0gY2FtZWxpemUoa2V5KSkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW5lZWRDYXN0S2V5cyB8fCAhbmVlZENhc3RLZXlzLmluY2x1ZGVzKGNhbWVsS2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzW2NhbWVsS2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKHJhd0Nhc3RWYWx1ZXMgfHwgKHJhd0Nhc3RWYWx1ZXMgPSB7fSkpW2NhbWVsS2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc0VtaXRMaXN0ZW5lcihpbnN0YW5jZS5lbWl0c09wdGlvbnMsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiBhdHRycykgfHwgdmFsdWUgIT09IGF0dHJzW2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChuZWVkQ2FzdEtleXMpIHtcclxuICAgICAgICBjb25zdCByYXdDdXJyZW50UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XHJcbiAgICAgICAgY29uc3QgY2FzdFZhbHVlcyA9IHJhd0Nhc3RWYWx1ZXMgfHwgRU1QVFlfT0JKO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmVlZENhc3RLZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IG5lZWRDYXN0S2V5c1tpXTtcclxuICAgICAgICAgICAgcHJvcHNba2V5XSA9IHJlc29sdmVQcm9wVmFsdWUob3B0aW9ucywgcmF3Q3VycmVudFByb3BzLCBrZXksIGNhc3RWYWx1ZXNba2V5XSwgaW5zdGFuY2UsICFoYXNPd24oY2FzdFZhbHVlcywga2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhhc0F0dHJzQ2hhbmdlZDtcclxufVxyXG5mdW5jdGlvbiByZXNvbHZlUHJvcFZhbHVlKG9wdGlvbnMsIHByb3BzLCBrZXksIHZhbHVlLCBpbnN0YW5jZSwgaXNBYnNlbnQpIHtcclxuICAgIGNvbnN0IG9wdCA9IG9wdGlvbnNba2V5XTtcclxuICAgIGlmIChvcHQgIT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnN0IGhhc0RlZmF1bHQgPSBoYXNPd24ob3B0LCAnZGVmYXVsdCcpO1xyXG4gICAgICAgIC8vIGRlZmF1bHQgdmFsdWVzXHJcbiAgICAgICAgaWYgKGhhc0RlZmF1bHQgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBvcHQuZGVmYXVsdDtcclxuICAgICAgICAgICAgaWYgKG9wdC50eXBlICE9PSBGdW5jdGlvbiAmJiBpc0Z1bmN0aW9uKGRlZmF1bHRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcHJvcHNEZWZhdWx0cyB9ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5IGluIHByb3BzRGVmYXVsdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHByb3BzRGVmYXVsdHNba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcm9wc0RlZmF1bHRzW2tleV0gPSBkZWZhdWx0VmFsdWUuY2FsbChudWxsLCBwcm9wcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5zZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGJvb2xlYW4gY2FzdGluZ1xyXG4gICAgICAgIGlmIChvcHRbMCAvKiBzaG91bGRDYXN0ICovXSkge1xyXG4gICAgICAgICAgICBpZiAoaXNBYnNlbnQgJiYgIWhhc0RlZmF1bHQpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3B0WzEgLyogc2hvdWxkQ2FzdFRydWUgKi9dICYmXHJcbiAgICAgICAgICAgICAgICAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wc09wdGlvbnMoY29tcCwgYXBwQ29udGV4dCwgYXNNaXhpbiA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBjYWNoZSA9IGFwcENvbnRleHQucHJvcHNDYWNoZTtcclxuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChjb21wKTtcclxuICAgIGlmIChjYWNoZWQpIHtcclxuICAgICAgICByZXR1cm4gY2FjaGVkO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmF3ID0gY29tcC5wcm9wcztcclxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSB7fTtcclxuICAgIGNvbnN0IG5lZWRDYXN0S2V5cyA9IFtdO1xyXG4gICAgLy8gYXBwbHkgbWl4aW4vZXh0ZW5kcyBwcm9wc1xyXG4gICAgbGV0IGhhc0V4dGVuZHMgPSBmYWxzZTtcclxuICAgIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fICYmICFpc0Z1bmN0aW9uKGNvbXApKSB7XHJcbiAgICAgICAgY29uc3QgZXh0ZW5kUHJvcHMgPSAocmF3KSA9PiB7XHJcbiAgICAgICAgICAgIGhhc0V4dGVuZHMgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb25zdCBbcHJvcHMsIGtleXNdID0gbm9ybWFsaXplUHJvcHNPcHRpb25zKHJhdywgYXBwQ29udGV4dCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGV4dGVuZChub3JtYWxpemVkLCBwcm9wcyk7XHJcbiAgICAgICAgICAgIGlmIChrZXlzKVxyXG4gICAgICAgICAgICAgICAgbmVlZENhc3RLZXlzLnB1c2goLi4ua2V5cyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoIWFzTWl4aW4gJiYgYXBwQ29udGV4dC5taXhpbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGFwcENvbnRleHQubWl4aW5zLmZvckVhY2goZXh0ZW5kUHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29tcC5leHRlbmRzKSB7XHJcbiAgICAgICAgICAgIGV4dGVuZFByb3BzKGNvbXAuZXh0ZW5kcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb21wLm1peGlucykge1xyXG4gICAgICAgICAgICBjb21wLm1peGlucy5mb3JFYWNoKGV4dGVuZFByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIXJhdyAmJiAhaGFzRXh0ZW5kcykge1xyXG4gICAgICAgIGNhY2hlLnNldChjb21wLCBFTVBUWV9BUlIpO1xyXG4gICAgICAgIHJldHVybiBFTVBUWV9BUlI7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNBcnJheShyYXcpKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNTdHJpbmcocmF3W2ldKSkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgcHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LmAsIHJhd1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGNhbWVsaXplKHJhd1tpXSk7XHJcbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZVByb3BOYW1lKG5vcm1hbGl6ZWRLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkW25vcm1hbGl6ZWRLZXldID0gRU1QVFlfT0JKO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocmF3KSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNPYmplY3QocmF3KSkge1xyXG4gICAgICAgICAgICB3YXJuKGBpbnZhbGlkIHByb3BzIG9wdGlvbnNgLCByYXcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByYXcpIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGNhbWVsaXplKGtleSk7XHJcbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZVByb3BOYW1lKG5vcm1hbGl6ZWRLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcHQgPSByYXdba2V5XTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3AgPSAobm9ybWFsaXplZFtub3JtYWxpemVkS2V5XSA9XHJcbiAgICAgICAgICAgICAgICAgICAgaXNBcnJheShvcHQpIHx8IGlzRnVuY3Rpb24ob3B0KSA/IHsgdHlwZTogb3B0IH0gOiBvcHQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb3ApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBib29sZWFuSW5kZXggPSBnZXRUeXBlSW5kZXgoQm9vbGVhbiwgcHJvcC50eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdJbmRleCA9IGdldFR5cGVJbmRleChTdHJpbmcsIHByb3AudHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcFswIC8qIHNob3VsZENhc3QgKi9dID0gYm9vbGVhbkluZGV4ID4gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcFsxIC8qIHNob3VsZENhc3RUcnVlICovXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ0luZGV4IDwgMCB8fCBib29sZWFuSW5kZXggPCBzdHJpbmdJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcHJvcCBuZWVkcyBib29sZWFuIGNhc3Rpbmcgb3IgZGVmYXVsdCB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChib29sZWFuSW5kZXggPiAtMSB8fCBoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZWVkQ2FzdEtleXMucHVzaChub3JtYWxpemVkS2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXMgPSBbbm9ybWFsaXplZCwgbmVlZENhc3RLZXlzXTtcclxuICAgIGNhY2hlLnNldChjb21wLCByZXMpO1xyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BOYW1lKGtleSkge1xyXG4gICAgaWYgKGtleVswXSAhPT0gJyQnKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuKGBJbnZhbGlkIHByb3AgbmFtZTogXCIke2tleX1cIiBpcyBhIHJlc2VydmVkIHByb3BlcnR5LmApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbi8vIHVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayB0eXBlIGNvbnN0cnVjdG9yc1xyXG4vLyBzbyB0aGF0IGl0IHdvcmtzIGFjcm9zcyB2bXMgLyBpZnJhbWVzLlxyXG5mdW5jdGlvbiBnZXRUeXBlKGN0b3IpIHtcclxuICAgIGNvbnN0IG1hdGNoID0gY3RvciAmJiBjdG9yLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqZnVuY3Rpb24gKFxcdyspLyk7XHJcbiAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6IGN0b3IgPT09IG51bGwgPyAnbnVsbCcgOiAnJztcclxufVxyXG5mdW5jdGlvbiBpc1NhbWVUeXBlKGEsIGIpIHtcclxuICAgIHJldHVybiBnZXRUeXBlKGEpID09PSBnZXRUeXBlKGIpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFR5cGVJbmRleCh0eXBlLCBleHBlY3RlZFR5cGVzKSB7XHJcbiAgICBpZiAoaXNBcnJheShleHBlY3RlZFR5cGVzKSkge1xyXG4gICAgICAgIHJldHVybiBleHBlY3RlZFR5cGVzLmZpbmRJbmRleCh0ID0+IGlzU2FtZVR5cGUodCwgdHlwZSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihleHBlY3RlZFR5cGVzKSkge1xyXG4gICAgICAgIHJldHVybiBpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXMsIHR5cGUpID8gMCA6IC0xO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIC0xO1xyXG59XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhyYXdQcm9wcywgcHJvcHMsIGluc3RhbmNlKSB7XHJcbiAgICBjb25zdCByZXNvbHZlZFZhbHVlcyA9IHRvUmF3KHByb3BzKTtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSBpbnN0YW5jZS5wcm9wc09wdGlvbnNbMF07XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgbGV0IG9wdCA9IG9wdGlvbnNba2V5XTtcclxuICAgICAgICBpZiAob3B0ID09IG51bGwpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIHZhbGlkYXRlUHJvcChrZXksIHJlc29sdmVkVmFsdWVzW2tleV0sIG9wdCwgIWhhc093bihyYXdQcm9wcywga2V5KSAmJiAhaGFzT3duKHJhd1Byb3BzLCBoeXBoZW5hdGUoa2V5KSkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wKG5hbWUsIHZhbHVlLCBwcm9wLCBpc0Fic2VudCkge1xyXG4gICAgY29uc3QgeyB0eXBlLCByZXF1aXJlZCwgdmFsaWRhdG9yIH0gPSBwcm9wO1xyXG4gICAgLy8gcmVxdWlyZWQhXHJcbiAgICBpZiAocmVxdWlyZWQgJiYgaXNBYnNlbnQpIHtcclxuICAgICAgICB3YXJuKCdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBtaXNzaW5nIGJ1dCBvcHRpb25hbFxyXG4gICAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyB0eXBlIGNoZWNrXHJcbiAgICBpZiAodHlwZSAhPSBudWxsICYmIHR5cGUgIT09IHRydWUpIHtcclxuICAgICAgICBsZXQgaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IHR5cGVzID0gaXNBcnJheSh0eXBlKSA/IHR5cGUgOiBbdHlwZV07XHJcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRUeXBlcyA9IFtdO1xyXG4gICAgICAgIC8vIHZhbHVlIGlzIHZhbGlkIGFzIGxvbmcgYXMgb25lIG9mIHRoZSBzcGVjaWZpZWQgdHlwZXMgbWF0Y2hcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aCAmJiAhaXNWYWxpZDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdmFsaWQsIGV4cGVjdGVkVHlwZSB9ID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZXNbaV0pO1xyXG4gICAgICAgICAgICBleHBlY3RlZFR5cGVzLnB1c2goZXhwZWN0ZWRUeXBlIHx8ICcnKTtcclxuICAgICAgICAgICAgaXNWYWxpZCA9IHZhbGlkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzVmFsaWQpIHtcclxuICAgICAgICAgICAgd2FybihnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGN1c3RvbSB2YWxpZGF0b3JcclxuICAgIGlmICh2YWxpZGF0b3IgJiYgIXZhbGlkYXRvcih2YWx1ZSkpIHtcclxuICAgICAgICB3YXJuKCdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgaXNTaW1wbGVUeXBlID0gLyojX19QVVJFX18qLyBtYWtlTWFwKCdTdHJpbmcsTnVtYmVyLEJvb2xlYW4sRnVuY3Rpb24sU3ltYm9sLEJpZ0ludCcpO1xyXG4vKipcclxuICogZGV2IG9ubHlcclxuICovXHJcbmZ1bmN0aW9uIGFzc2VydFR5cGUodmFsdWUsIHR5cGUpIHtcclxuICAgIGxldCB2YWxpZDtcclxuICAgIGNvbnN0IGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XHJcbiAgICBpZiAoaXNTaW1wbGVUeXBlKGV4cGVjdGVkVHlwZSkpIHtcclxuICAgICAgICBjb25zdCB0ID0gdHlwZW9mIHZhbHVlO1xyXG4gICAgICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcclxuICAgICAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcclxuICAgICAgICB2YWxpZCA9IGlzT2JqZWN0KHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xyXG4gICAgICAgIHZhbGlkID0gaXNBcnJheSh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdudWxsJykge1xyXG4gICAgICAgIHZhbGlkID0gdmFsdWUgPT09IG51bGw7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdmFsaWQsXHJcbiAgICAgICAgZXhwZWN0ZWRUeXBlXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSB7XHJcbiAgICBsZXQgbWVzc2FnZSA9IGBJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJHtuYW1lfVwiLmAgK1xyXG4gICAgICAgIGAgRXhwZWN0ZWQgJHtleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcgfCAnKX1gO1xyXG4gICAgY29uc3QgZXhwZWN0ZWRUeXBlID0gZXhwZWN0ZWRUeXBlc1swXTtcclxuICAgIGNvbnN0IHJlY2VpdmVkVHlwZSA9IHRvUmF3VHlwZSh2YWx1ZSk7XHJcbiAgICBjb25zdCBleHBlY3RlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgZXhwZWN0ZWRUeXBlKTtcclxuICAgIGNvbnN0IHJlY2VpdmVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCByZWNlaXZlZFR5cGUpO1xyXG4gICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IGV4cGVjdGVkIHZhbHVlXHJcbiAgICBpZiAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPT09IDEgJiZcclxuICAgICAgICBpc0V4cGxpY2FibGUoZXhwZWN0ZWRUeXBlKSAmJlxyXG4gICAgICAgICFpc0Jvb2xlYW4oZXhwZWN0ZWRUeXBlLCByZWNlaXZlZFR5cGUpKSB7XHJcbiAgICAgICAgbWVzc2FnZSArPSBgIHdpdGggdmFsdWUgJHtleHBlY3RlZFZhbHVlfWA7XHJcbiAgICB9XHJcbiAgICBtZXNzYWdlICs9IGAsIGdvdCAke3JlY2VpdmVkVHlwZX0gYDtcclxuICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSByZWNlaXZlZCB2YWx1ZVxyXG4gICAgaWYgKGlzRXhwbGljYWJsZShyZWNlaXZlZFR5cGUpKSB7XHJcbiAgICAgICAgbWVzc2FnZSArPSBgd2l0aCB2YWx1ZSAke3JlY2VpdmVkVmFsdWV9LmA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWVzc2FnZTtcclxufVxyXG4vKipcclxuICogZGV2IG9ubHlcclxuICovXHJcbmZ1bmN0aW9uIHN0eWxlVmFsdWUodmFsdWUsIHR5cGUpIHtcclxuICAgIGlmICh0eXBlID09PSAnU3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBgXCIke3ZhbHVlfVwiYDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdOdW1iZXInKSB7XHJcbiAgICAgICAgcmV0dXJuIGAke051bWJlcih2YWx1ZSl9YDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBgJHt2YWx1ZX1gO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKi9cclxuZnVuY3Rpb24gaXNFeHBsaWNhYmxlKHR5cGUpIHtcclxuICAgIGNvbnN0IGV4cGxpY2l0VHlwZXMgPSBbJ3N0cmluZycsICdudW1iZXInLCAnYm9vbGVhbiddO1xyXG4gICAgcmV0dXJuIGV4cGxpY2l0VHlwZXMuc29tZShlbGVtID0+IHR5cGUudG9Mb3dlckNhc2UoKSA9PT0gZWxlbSk7XHJcbn1cclxuLyoqXHJcbiAqIGRldiBvbmx5XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0Jvb2xlYW4oLi4uYXJncykge1xyXG4gICAgcmV0dXJuIGFyZ3Muc29tZShlbGVtID0+IGVsZW0udG9Mb3dlckNhc2UoKSA9PT0gJ2Jvb2xlYW4nKTtcclxufVxuXG5jb25zdCBpc0ludGVybmFsS2V5ID0gKGtleSkgPT4ga2V5WzBdID09PSAnXycgfHwga2V5ID09PSAnJHN0YWJsZSc7XHJcbmNvbnN0IG5vcm1hbGl6ZVNsb3RWYWx1ZSA9ICh2YWx1ZSkgPT4gaXNBcnJheSh2YWx1ZSlcclxuICAgID8gdmFsdWUubWFwKG5vcm1hbGl6ZVZOb2RlKVxyXG4gICAgOiBbbm9ybWFsaXplVk5vZGUodmFsdWUpXTtcclxuY29uc3Qgbm9ybWFsaXplU2xvdCA9IChrZXksIHJhd1Nsb3QsIGN0eCkgPT4ge1xyXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHdpdGhDdHgoKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGN1cnJlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB3YXJuKGBTbG90IFwiJHtrZXl9XCIgaW52b2tlZCBvdXRzaWRlIG9mIHRoZSByZW5kZXIgZnVuY3Rpb246IGAgK1xyXG4gICAgICAgICAgICAgICAgYHRoaXMgd2lsbCBub3QgdHJhY2sgZGVwZW5kZW5jaWVzIHVzZWQgaW4gdGhlIHNsb3QuIGAgK1xyXG4gICAgICAgICAgICAgICAgYEludm9rZSB0aGUgc2xvdCBmdW5jdGlvbiBpbnNpZGUgdGhlIHJlbmRlciBmdW5jdGlvbiBpbnN0ZWFkLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9ybWFsaXplU2xvdFZhbHVlKHJhd1Nsb3QoLi4uYXJncykpO1xyXG4gICAgfSwgY3R4KTtcclxuICAgIG5vcm1hbGl6ZWQuX2MgPSBmYWxzZTtcclxuICAgIHJldHVybiBub3JtYWxpemVkO1xyXG59O1xyXG5jb25zdCBub3JtYWxpemVPYmplY3RTbG90cyA9IChyYXdTbG90cywgc2xvdHMsIGluc3RhbmNlKSA9PiB7XHJcbiAgICBjb25zdCBjdHggPSByYXdTbG90cy5fY3R4O1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmF3U2xvdHMpIHtcclxuICAgICAgICBpZiAoaXNJbnRlcm5hbEtleShrZXkpKVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHJhd1Nsb3RzW2tleV07XHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHNsb3RzW2tleV0gPSBub3JtYWxpemVTbG90KGtleSwgdmFsdWUsIGN0eCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgIShmYWxzZSApKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBOb24tZnVuY3Rpb24gdmFsdWUgZW5jb3VudGVyZWQgZm9yIHNsb3QgXCIke2tleX1cIi4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYFByZWZlciBmdW5jdGlvbiBzbG90cyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVTbG90VmFsdWUodmFsdWUpO1xyXG4gICAgICAgICAgICBzbG90c1trZXldID0gKCkgPT4gbm9ybWFsaXplZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IG5vcm1hbGl6ZVZOb2RlU2xvdHMgPSAoaW5zdGFuY2UsIGNoaWxkcmVuKSA9PiB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgIWlzS2VlcEFsaXZlKGluc3RhbmNlLnZub2RlKSAmJlxyXG4gICAgICAgICEoZmFsc2UgKSkge1xyXG4gICAgICAgIHdhcm4oYE5vbi1mdW5jdGlvbiB2YWx1ZSBlbmNvdW50ZXJlZCBmb3IgZGVmYXVsdCBzbG90LiBgICtcclxuICAgICAgICAgICAgYFByZWZlciBmdW5jdGlvbiBzbG90cyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLmApO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVNsb3RWYWx1ZShjaGlsZHJlbik7XHJcbiAgICBpbnN0YW5jZS5zbG90cy5kZWZhdWx0ID0gKCkgPT4gbm9ybWFsaXplZDtcclxufTtcclxuY29uc3QgaW5pdFNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbikgPT4ge1xyXG4gICAgaWYgKGluc3RhbmNlLnZub2RlLnNoYXBlRmxhZyAmIDMyIC8qIFNMT1RTX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IGNoaWxkcmVuLl87XHJcbiAgICAgICAgaWYgKHR5cGUpIHtcclxuICAgICAgICAgICAgLy8gdXNlcnMgY2FuIGdldCB0aGUgc2hhbGxvdyByZWFkb25seSB2ZXJzaW9uIG9mIHRoZSBzbG90cyBvYmplY3QgdGhyb3VnaCBgdGhpcy4kc2xvdHNgLFxyXG4gICAgICAgICAgICAvLyB3ZSBzaG91bGQgYXZvaWQgdGhlIHByb3h5IG9iamVjdCBwb2xsdXRpbmcgdGhlIHNsb3RzIG9mIHRoZSBpbnRlcm5hbCBpbnN0YW5jZVxyXG4gICAgICAgICAgICBpbnN0YW5jZS5zbG90cyA9IHRvUmF3KGNoaWxkcmVuKTtcclxuICAgICAgICAgICAgLy8gbWFrZSBjb21waWxlciBtYXJrZXIgbm9uLWVudW1lcmFibGVcclxuICAgICAgICAgICAgZGVmKGNoaWxkcmVuLCAnXycsIHR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplT2JqZWN0U2xvdHMoY2hpbGRyZW4sIChpbnN0YW5jZS5zbG90cyA9IHt9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaW5zdGFuY2Uuc2xvdHMgPSB7fTtcclxuICAgICAgICBpZiAoY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplVk5vZGVTbG90cyhpbnN0YW5jZSwgY2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRlZihpbnN0YW5jZS5zbG90cywgSW50ZXJuYWxPYmplY3RLZXksIDEpO1xyXG59O1xyXG5jb25zdCB1cGRhdGVTbG90cyA9IChpbnN0YW5jZSwgY2hpbGRyZW4sIG9wdGltaXplZCkgPT4ge1xyXG4gICAgY29uc3QgeyB2bm9kZSwgc2xvdHMgfSA9IGluc3RhbmNlO1xyXG4gICAgbGV0IG5lZWREZWxldGlvbkNoZWNrID0gdHJ1ZTtcclxuICAgIGxldCBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSBFTVBUWV9PQko7XHJcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMzIgLyogU0xPVFNfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICBjb25zdCB0eXBlID0gY2hpbGRyZW4uXztcclxuICAgICAgICBpZiAodHlwZSkge1xyXG4gICAgICAgICAgICAvLyBjb21waWxlZCBzbG90cy5cclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpc0htclVwZGF0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBQYXJlbnQgd2FzIEhNUiB1cGRhdGVkIHNvIHNsb3QgY29udGVudCBtYXkgaGF2ZSBjaGFuZ2VkLlxyXG4gICAgICAgICAgICAgICAgLy8gZm9yY2UgdXBkYXRlIHNsb3RzIGFuZCBtYXJrIGluc3RhbmNlIGZvciBobXIgYXMgd2VsbFxyXG4gICAgICAgICAgICAgICAgZXh0ZW5kKHNsb3RzLCBjaGlsZHJlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW1pemVkICYmIHR5cGUgPT09IDEgLyogU1RBQkxFICovKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb21waWxlZCBBTkQgc3RhYmxlLlxyXG4gICAgICAgICAgICAgICAgLy8gbm8gbmVlZCB0byB1cGRhdGUsIGFuZCBza2lwIHN0YWxlIHNsb3RzIHJlbW92YWwuXHJcbiAgICAgICAgICAgICAgICBuZWVkRGVsZXRpb25DaGVjayA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gY29tcGlsZWQgYnV0IGR5bmFtaWMgKHYtaWYvdi1mb3Igb24gc2xvdHMpIC0gdXBkYXRlIHNsb3RzLCBidXQgc2tpcFxyXG4gICAgICAgICAgICAgICAgLy8gbm9ybWFsaXphdGlvbi5cclxuICAgICAgICAgICAgICAgIGV4dGVuZChzbG90cywgY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgLy8gIzI4OTNcclxuICAgICAgICAgICAgICAgIC8vIHdoZW4gcmVuZGVyaW5nIHRoZSBvcHRpbWl6ZWQgc2xvdHMgYnkgbWFudWFsbHkgd3JpdHRlbiByZW5kZXIgZnVuY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGUgYHNsb3RzLl9gIGZsYWcgaWYgbmVjZXNzYXJ5IHRvIG1ha2Ugc3Vic2VxdWVudCB1cGRhdGVzIHJlbGlhYmxlLFxyXG4gICAgICAgICAgICAgICAgLy8gaS5lLiBsZXQgdGhlIGByZW5kZXJTbG90YCBjcmVhdGUgdGhlIGJhaWxlZCBGcmFnbWVudFxyXG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpbWl6ZWQgJiYgdHlwZSA9PT0gMSAvKiBTVEFCTEUgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2xvdHMuXztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbmVlZERlbGV0aW9uQ2hlY2sgPSAhY2hpbGRyZW4uJHN0YWJsZTtcclxuICAgICAgICAgICAgbm9ybWFsaXplT2JqZWN0U2xvdHMoY2hpbGRyZW4sIHNsb3RzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0ID0gY2hpbGRyZW47XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjaGlsZHJlbikge1xyXG4gICAgICAgIC8vIG5vbiBzbG90IG9iamVjdCBjaGlsZHJlbiAoZGlyZWN0IHZhbHVlKSBwYXNzZWQgdG8gYSBjb21wb25lbnRcclxuICAgICAgICBub3JtYWxpemVWTm9kZVNsb3RzKGluc3RhbmNlLCBjaGlsZHJlbik7XHJcbiAgICAgICAgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0ID0geyBkZWZhdWx0OiAxIH07XHJcbiAgICB9XHJcbiAgICAvLyBkZWxldGUgc3RhbGUgc2xvdHNcclxuICAgIGlmIChuZWVkRGVsZXRpb25DaGVjaykge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNsb3RzKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNJbnRlcm5hbEtleShrZXkpICYmICEoa2V5IGluIGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBzbG90c1trZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xuXG4vKipcclxuUnVudGltZSBoZWxwZXIgZm9yIGFwcGx5aW5nIGRpcmVjdGl2ZXMgdG8gYSB2bm9kZS4gRXhhbXBsZSB1c2FnZTpcclxuXG5jb25zdCBjb21wID0gcmVzb2x2ZUNvbXBvbmVudCgnY29tcCcpXHJcbmNvbnN0IGZvbyA9IHJlc29sdmVEaXJlY3RpdmUoJ2ZvbycpXHJcbmNvbnN0IGJhciA9IHJlc29sdmVEaXJlY3RpdmUoJ2JhcicpXHJcblxucmV0dXJuIHdpdGhEaXJlY3RpdmVzKGgoY29tcCksIFtcclxuICBbZm9vLCB0aGlzLnhdLFxyXG4gIFtiYXIsIHRoaXMueV1cclxuXSlcclxuKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVEaXJlY3RpdmVOYW1lKG5hbWUpIHtcclxuICAgIGlmIChpc0J1aWx0SW5EaXJlY3RpdmUobmFtZSkpIHtcclxuICAgICAgICB3YXJuKCdEbyBub3QgdXNlIGJ1aWx0LWluIGRpcmVjdGl2ZSBpZHMgYXMgY3VzdG9tIGRpcmVjdGl2ZSBpZDogJyArIG5hbWUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBZGRzIGRpcmVjdGl2ZXMgdG8gYSBWTm9kZS5cclxuICovXHJcbmZ1bmN0aW9uIHdpdGhEaXJlY3RpdmVzKHZub2RlLCBkaXJlY3RpdmVzKSB7XHJcbiAgICBjb25zdCBpbnRlcm5hbEluc3RhbmNlID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xyXG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UgPT09IG51bGwpIHtcclxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2Fybihgd2l0aERpcmVjdGl2ZXMgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgcmVuZGVyIGZ1bmN0aW9ucy5gKTtcclxuICAgICAgICByZXR1cm4gdm5vZGU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IGludGVybmFsSW5zdGFuY2UucHJveHk7XHJcbiAgICBjb25zdCBiaW5kaW5ncyA9IHZub2RlLmRpcnMgfHwgKHZub2RlLmRpcnMgPSBbXSk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpcmVjdGl2ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgW2RpciwgdmFsdWUsIGFyZywgbW9kaWZpZXJzID0gRU1QVFlfT0JKXSA9IGRpcmVjdGl2ZXNbaV07XHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oZGlyKSkge1xyXG4gICAgICAgICAgICBkaXIgPSB7XHJcbiAgICAgICAgICAgICAgICBtb3VudGVkOiBkaXIsXHJcbiAgICAgICAgICAgICAgICB1cGRhdGVkOiBkaXJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRpci5kZWVwKSB7XHJcbiAgICAgICAgICAgIHRyYXZlcnNlKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYmluZGluZ3MucHVzaCh7XHJcbiAgICAgICAgICAgIGRpcixcclxuICAgICAgICAgICAgaW5zdGFuY2UsXHJcbiAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgICBvbGRWYWx1ZTogdm9pZCAwLFxyXG4gICAgICAgICAgICBhcmcsXHJcbiAgICAgICAgICAgIG1vZGlmaWVyc1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZub2RlO1xyXG59XHJcbmZ1bmN0aW9uIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIHByZXZWTm9kZSwgaW5zdGFuY2UsIG5hbWUpIHtcclxuICAgIGNvbnN0IGJpbmRpbmdzID0gdm5vZGUuZGlycztcclxuICAgIGNvbnN0IG9sZEJpbmRpbmdzID0gcHJldlZOb2RlICYmIHByZXZWTm9kZS5kaXJzO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5kaW5ncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGJpbmRpbmcgPSBiaW5kaW5nc1tpXTtcclxuICAgICAgICBpZiAob2xkQmluZGluZ3MpIHtcclxuICAgICAgICAgICAgYmluZGluZy5vbGRWYWx1ZSA9IG9sZEJpbmRpbmdzW2ldLnZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgaG9vayA9IGJpbmRpbmcuZGlyW25hbWVdO1xyXG4gICAgICAgIGlmIChob29rKSB7XHJcbiAgICAgICAgICAgIC8vIGRpc2FibGUgdHJhY2tpbmcgaW5zaWRlIGFsbCBsaWZlY3ljbGUgaG9va3NcclxuICAgICAgICAgICAgLy8gc2luY2UgdGhleSBjYW4gcG90ZW50aWFsbHkgYmUgY2FsbGVkIGluc2lkZSBlZmZlY3RzLlxyXG4gICAgICAgICAgICBwYXVzZVRyYWNraW5nKCk7XHJcbiAgICAgICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIGluc3RhbmNlLCA4IC8qIERJUkVDVElWRV9IT09LICovLCBbXHJcbiAgICAgICAgICAgICAgICB2bm9kZS5lbCxcclxuICAgICAgICAgICAgICAgIGJpbmRpbmcsXHJcbiAgICAgICAgICAgICAgICB2bm9kZSxcclxuICAgICAgICAgICAgICAgIHByZXZWTm9kZVxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgcmVzZXRUcmFja2luZygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBjcmVhdGVBcHBDb250ZXh0KCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBhcHA6IG51bGwsXHJcbiAgICAgICAgY29uZmlnOiB7XHJcbiAgICAgICAgICAgIGlzTmF0aXZlVGFnOiBOTyxcclxuICAgICAgICAgICAgcGVyZm9ybWFuY2U6IGZhbHNlLFxyXG4gICAgICAgICAgICBnbG9iYWxQcm9wZXJ0aWVzOiB7fSxcclxuICAgICAgICAgICAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiB7fSxcclxuICAgICAgICAgICAgZXJyb3JIYW5kbGVyOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHdhcm5IYW5kbGVyOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGNvbXBpbGVyT3B0aW9uczoge31cclxuICAgICAgICB9LFxyXG4gICAgICAgIG1peGluczogW10sXHJcbiAgICAgICAgY29tcG9uZW50czoge30sXHJcbiAgICAgICAgZGlyZWN0aXZlczoge30sXHJcbiAgICAgICAgcHJvdmlkZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXHJcbiAgICAgICAgb3B0aW9uc0NhY2hlOiBuZXcgV2Vha01hcCgpLFxyXG4gICAgICAgIHByb3BzQ2FjaGU6IG5ldyBXZWFrTWFwKCksXHJcbiAgICAgICAgZW1pdHNDYWNoZTogbmV3IFdlYWtNYXAoKVxyXG4gICAgfTtcclxufVxyXG5sZXQgdWlkID0gMDtcclxuZnVuY3Rpb24gY3JlYXRlQXBwQVBJKHJlbmRlciwgaHlkcmF0ZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUFwcChyb290Q29tcG9uZW50LCByb290UHJvcHMgPSBudWxsKSB7XHJcbiAgICAgICAgaWYgKHJvb3RQcm9wcyAhPSBudWxsICYmICFpc09iamVjdChyb290UHJvcHMpKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGByb290IHByb3BzIHBhc3NlZCB0byBhcHAubW91bnQoKSBtdXN0IGJlIGFuIG9iamVjdC5gKTtcclxuICAgICAgICAgICAgcm9vdFByb3BzID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUFwcENvbnRleHQoKTtcclxuICAgICAgICBjb25zdCBpbnN0YWxsZWRQbHVnaW5zID0gbmV3IFNldCgpO1xyXG4gICAgICAgIGxldCBpc01vdW50ZWQgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCBhcHAgPSAoY29udGV4dC5hcHAgPSB7XHJcbiAgICAgICAgICAgIF91aWQ6IHVpZCsrLFxyXG4gICAgICAgICAgICBfY29tcG9uZW50OiByb290Q29tcG9uZW50LFxyXG4gICAgICAgICAgICBfcHJvcHM6IHJvb3RQcm9wcyxcclxuICAgICAgICAgICAgX2NvbnRhaW5lcjogbnVsbCxcclxuICAgICAgICAgICAgX2NvbnRleHQ6IGNvbnRleHQsXHJcbiAgICAgICAgICAgIF9pbnN0YW5jZTogbnVsbCxcclxuICAgICAgICAgICAgdmVyc2lvbixcclxuICAgICAgICAgICAgZ2V0IGNvbmZpZygpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbmZpZztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0IGNvbmZpZyh2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgYXBwLmNvbmZpZyBjYW5ub3QgYmUgcmVwbGFjZWQuIE1vZGlmeSBpbmRpdmlkdWFsIG9wdGlvbnMgaW5zdGVhZC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdXNlKHBsdWdpbiwgLi4ub3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaGFzKHBsdWdpbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybihgUGx1Z2luIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCB0byB0YXJnZXQgYXBwLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGx1Z2luICYmIGlzRnVuY3Rpb24ocGx1Z2luLmluc3RhbGwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFsbGVkUGx1Z2lucy5hZGQocGx1Z2luKTtcclxuICAgICAgICAgICAgICAgICAgICBwbHVnaW4uaW5zdGFsbChhcHAsIC4uLm9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihwbHVnaW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFsbGVkUGx1Z2lucy5hZGQocGx1Z2luKTtcclxuICAgICAgICAgICAgICAgICAgICBwbHVnaW4oYXBwLCAuLi5vcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEEgcGx1Z2luIG11c3QgZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0IHdpdGggYW4gXCJpbnN0YWxsXCIgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBmdW5jdGlvbi5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBhcHA7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG1peGluKG1peGluKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX19WVUVfT1BUSU9OU19BUElfXykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udGV4dC5taXhpbnMuaW5jbHVkZXMobWl4aW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubWl4aW5zLnB1c2gobWl4aW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybignTWl4aW4gaGFzIGFscmVhZHkgYmVlbiBhcHBsaWVkIHRvIHRhcmdldCBhcHAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtaXhpbi5uYW1lID8gYDogJHttaXhpbi5uYW1lfWAgOiAnJykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ01peGlucyBhcmUgb25seSBhdmFpbGFibGUgaW4gYnVpbGRzIHN1cHBvcnRpbmcgT3B0aW9ucyBBUEknKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBhcHA7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNvbXBvbmVudChuYW1lLCBjb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSwgY29udGV4dC5jb25maWcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5jb21wb25lbnRzW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjb250ZXh0LmNvbXBvbmVudHNbbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBDb21wb25lbnQgXCIke25hbWV9XCIgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIGluIHRhcmdldCBhcHAuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNvbXBvbmVudHNbbmFtZV0gPSBjb21wb25lbnQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkaXJlY3RpdmUobmFtZSwgZGlyZWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVEaXJlY3RpdmVOYW1lKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFkaXJlY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5kaXJlY3RpdmVzW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjb250ZXh0LmRpcmVjdGl2ZXNbbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBEaXJlY3RpdmUgXCIke25hbWV9XCIgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIGluIHRhcmdldCBhcHAuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRpcmVjdGl2ZXNbbmFtZV0gPSBkaXJlY3RpdmU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBtb3VudChyb290Q29udGFpbmVyLCBpc0h5ZHJhdGUsIGlzU1ZHKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUocm9vdENvbXBvbmVudCwgcm9vdFByb3BzKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSBhcHAgY29udGV4dCBvbiB0aGUgcm9vdCBWTm9kZS5cclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgYmUgc2V0IG9uIHRoZSByb290IGluc3RhbmNlIG9uIGluaXRpYWwgbW91bnQuXHJcbiAgICAgICAgICAgICAgICAgICAgdm5vZGUuYXBwQ29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSE1SIHJvb3QgcmVsb2FkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlbG9hZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcihjbG9uZVZOb2RlKHZub2RlKSwgcm9vdENvbnRhaW5lciwgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNIeWRyYXRlICYmIGh5ZHJhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHlkcmF0ZSh2bm9kZSwgcm9vdENvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXIodm5vZGUsIHJvb3RDb250YWluZXIsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaXNNb3VudGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBhcHAuX2NvbnRhaW5lciA9IHJvb3RDb250YWluZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdENvbnRhaW5lci5fX3Z1ZV9hcHBfXyA9IGFwcDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHAuX2luc3RhbmNlID0gdm5vZGUuY29tcG9uZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXZ0b29sc0luaXRBcHAoYXBwLCB2ZXJzaW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEV4cG9zZVByb3h5KHZub2RlLmNvbXBvbmVudCkgfHwgdm5vZGUuY29tcG9uZW50LnByb3h5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQXBwIGhhcyBhbHJlYWR5IGJlZW4gbW91bnRlZC5cXG5gICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYElmIHlvdSB3YW50IHRvIHJlbW91bnQgdGhlIHNhbWUgYXBwLCBtb3ZlIHlvdXIgYXBwIGNyZWF0aW9uIGxvZ2ljIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgaW50byBhIGZhY3RvcnkgZnVuY3Rpb24gYW5kIGNyZWF0ZSBmcmVzaCBhcHAgaW5zdGFuY2VzIGZvciBlYWNoIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgbW91bnQgLSBlLmcuIFxcYGNvbnN0IGNyZWF0ZU15QXBwID0gKCkgPT4gY3JlYXRlQXBwKEFwcClcXGBgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdW5tb3VudCgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc01vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXIobnVsbCwgYXBwLl9jb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcC5faW5zdGFuY2UgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXZ0b29sc1VubW91bnRBcHAoYXBwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGFwcC5fY29udGFpbmVyLl9fdnVlX2FwcF9fO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQ2Fubm90IHVubW91bnQgYW4gYXBwIHRoYXQgaXMgbm90IG1vdW50ZWQuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHByb3ZpZGUoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBrZXkgaW4gY29udGV4dC5wcm92aWRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEFwcCBhbHJlYWR5IHByb3ZpZGVzIHByb3BlcnR5IHdpdGgga2V5IFwiJHtTdHJpbmcoa2V5KX1cIi4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBJdCB3aWxsIGJlIG92ZXJ3cml0dGVuIHdpdGggdGhlIG5ldyB2YWx1ZS5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFR5cGVTY3JpcHQgZG9lc24ndCBhbGxvdyBzeW1ib2xzIGFzIGluZGV4IHR5cGVcclxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMjQ1ODdcclxuICAgICAgICAgICAgICAgIGNvbnRleHQucHJvdmlkZXNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBhcHA7XHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBGdW5jdGlvbiBmb3IgaGFuZGxpbmcgYSB0ZW1wbGF0ZSByZWZcclxuICovXHJcbmZ1bmN0aW9uIHNldFJlZihyYXdSZWYsIG9sZFJhd1JlZiwgcGFyZW50U3VzcGVuc2UsIHZub2RlLCBpc1VubW91bnQgPSBmYWxzZSkge1xyXG4gICAgaWYgKGlzQXJyYXkocmF3UmVmKSkge1xyXG4gICAgICAgIHJhd1JlZi5mb3JFYWNoKChyLCBpKSA9PiBzZXRSZWYociwgb2xkUmF3UmVmICYmIChpc0FycmF5KG9sZFJhd1JlZikgPyBvbGRSYXdSZWZbaV0gOiBvbGRSYXdSZWYpLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUsIGlzVW5tb3VudCkpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChpc0FzeW5jV3JhcHBlcih2bm9kZSkgJiYgIWlzVW5tb3VudCkge1xyXG4gICAgICAgIC8vIHdoZW4gbW91bnRpbmcgYXN5bmMgY29tcG9uZW50cywgbm90aGluZyBuZWVkcyB0byBiZSBkb25lLFxyXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIHRlbXBsYXRlIHJlZiBpcyBmb3J3YXJkZWQgdG8gaW5uZXIgY29tcG9uZW50XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVmVmFsdWUgPSB2bm9kZS5zaGFwZUZsYWcgJiA0IC8qIFNUQVRFRlVMX0NPTVBPTkVOVCAqL1xyXG4gICAgICAgID8gZ2V0RXhwb3NlUHJveHkodm5vZGUuY29tcG9uZW50KSB8fCB2bm9kZS5jb21wb25lbnQucHJveHlcclxuICAgICAgICA6IHZub2RlLmVsO1xyXG4gICAgY29uc3QgdmFsdWUgPSBpc1VubW91bnQgPyBudWxsIDogcmVmVmFsdWU7XHJcbiAgICBjb25zdCB7IGk6IG93bmVyLCByOiByZWYgfSA9IHJhd1JlZjtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIW93bmVyKSB7XHJcbiAgICAgICAgd2FybihgTWlzc2luZyByZWYgb3duZXIgY29udGV4dC4gcmVmIGNhbm5vdCBiZSB1c2VkIG9uIGhvaXN0ZWQgdm5vZGVzLiBgICtcclxuICAgICAgICAgICAgYEEgdm5vZGUgd2l0aCByZWYgbXVzdCBiZSBjcmVhdGVkIGluc2lkZSB0aGUgcmVuZGVyIGZ1bmN0aW9uLmApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IG9sZFJlZiA9IG9sZFJhd1JlZiAmJiBvbGRSYXdSZWYucjtcclxuICAgIGNvbnN0IHJlZnMgPSBvd25lci5yZWZzID09PSBFTVBUWV9PQkogPyAob3duZXIucmVmcyA9IHt9KSA6IG93bmVyLnJlZnM7XHJcbiAgICBjb25zdCBzZXR1cFN0YXRlID0gb3duZXIuc2V0dXBTdGF0ZTtcclxuICAgIC8vIGR5bmFtaWMgcmVmIGNoYW5nZWQuIHVuc2V0IG9sZCByZWZcclxuICAgIGlmIChvbGRSZWYgIT0gbnVsbCAmJiBvbGRSZWYgIT09IHJlZikge1xyXG4gICAgICAgIGlmIChpc1N0cmluZyhvbGRSZWYpKSB7XHJcbiAgICAgICAgICAgIHJlZnNbb2xkUmVmXSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChoYXNPd24oc2V0dXBTdGF0ZSwgb2xkUmVmKSkge1xyXG4gICAgICAgICAgICAgICAgc2V0dXBTdGF0ZVtvbGRSZWZdID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc1JlZihvbGRSZWYpKSB7XHJcbiAgICAgICAgICAgIG9sZFJlZi52YWx1ZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGlzRnVuY3Rpb24ocmVmKSkge1xyXG4gICAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhyZWYsIG93bmVyLCAxMiAvKiBGVU5DVElPTl9SRUYgKi8sIFt2YWx1ZSwgcmVmc10pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgX2lzU3RyaW5nID0gaXNTdHJpbmcocmVmKTtcclxuICAgICAgICBjb25zdCBfaXNSZWYgPSBpc1JlZihyZWYpO1xyXG4gICAgICAgIGlmIChfaXNTdHJpbmcgfHwgX2lzUmVmKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvU2V0ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJhd1JlZi5mKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBfaXNTdHJpbmcgPyByZWZzW3JlZl0gOiByZWYudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5tb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FycmF5KGV4aXN0aW5nKSAmJiByZW1vdmUoZXhpc3RpbmcsIHJlZlZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNBcnJheShleGlzdGluZykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNTdHJpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZzW3JlZl0gPSBbcmVmVmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmLnZhbHVlID0gW3JlZlZhbHVlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmF3UmVmLmspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnNbcmF3UmVmLmtdID0gcmVmLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFleGlzdGluZy5pbmNsdWRlcyhyZWZWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLnB1c2gocmVmVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoX2lzU3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVmc1tyZWZdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc093bihzZXR1cFN0YXRlLCByZWYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHVwU3RhdGVbcmVmXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVmKHJlZikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWYudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmF3UmVmLmspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnNbcmF3UmVmLmtdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKCdJbnZhbGlkIHRlbXBsYXRlIHJlZiB0eXBlOicsIHJlZiwgYCgke3R5cGVvZiByZWZ9KWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGRvU2V0LmlkID0gLTE7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoZG9TZXQsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRvU2V0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oJ0ludmFsaWQgdGVtcGxhdGUgcmVmIHR5cGU6JywgcmVmLCBgKCR7dHlwZW9mIHJlZn0pYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmxldCBoYXNNaXNtYXRjaCA9IGZhbHNlO1xyXG5jb25zdCBpc1NWR0NvbnRhaW5lciA9IChjb250YWluZXIpID0+IC9zdmcvLnRlc3QoY29udGFpbmVyLm5hbWVzcGFjZVVSSSkgJiYgY29udGFpbmVyLnRhZ05hbWUgIT09ICdmb3JlaWduT2JqZWN0JztcclxuY29uc3QgaXNDb21tZW50ID0gKG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IDggLyogQ09NTUVOVCAqLztcclxuLy8gTm90ZTogaHlkcmF0aW9uIGlzIERPTS1zcGVjaWZpY1xyXG4vLyBCdXQgd2UgaGF2ZSB0byBwbGFjZSBpdCBpbiBjb3JlIGR1ZSB0byB0aWdodCBjb3VwbGluZyB3aXRoIGNvcmUgLSBzcGxpdHRpbmdcclxuLy8gaXQgb3V0IGNyZWF0ZXMgYSB0b24gb2YgdW5uZWNlc3NhcnkgY29tcGxleGl0eS5cclxuLy8gSHlkcmF0aW9uIGFsc28gZGVwZW5kcyBvbiBzb21lIHJlbmRlcmVyIGludGVybmFsIGxvZ2ljIHdoaWNoIG5lZWRzIHRvIGJlXHJcbi8vIHBhc3NlZCBpbiB2aWEgYXJndW1lbnRzLlxyXG5mdW5jdGlvbiBjcmVhdGVIeWRyYXRpb25GdW5jdGlvbnMocmVuZGVyZXJJbnRlcm5hbHMpIHtcclxuICAgIGNvbnN0IHsgbXQ6IG1vdW50Q29tcG9uZW50LCBwOiBwYXRjaCwgbzogeyBwYXRjaFByb3AsIG5leHRTaWJsaW5nLCBwYXJlbnROb2RlLCByZW1vdmUsIGluc2VydCwgY3JlYXRlQ29tbWVudCB9IH0gPSByZW5kZXJlckludGVybmFscztcclxuICAgIGNvbnN0IGh5ZHJhdGUgPSAodm5vZGUsIGNvbnRhaW5lcikgPT4ge1xyXG4gICAgICAgIGlmICghY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIHdhcm4oYEF0dGVtcHRpbmcgdG8gaHlkcmF0ZSBleGlzdGluZyBtYXJrdXAgYnV0IGNvbnRhaW5lciBpcyBlbXB0eS4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYFBlcmZvcm1pbmcgZnVsbCBtb3VudCBpbnN0ZWFkLmApO1xyXG4gICAgICAgICAgICBwYXRjaChudWxsLCB2bm9kZSwgY29udGFpbmVyKTtcclxuICAgICAgICAgICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBoYXNNaXNtYXRjaCA9IGZhbHNlO1xyXG4gICAgICAgIGh5ZHJhdGVOb2RlKGNvbnRhaW5lci5maXJzdENoaWxkLCB2bm9kZSwgbnVsbCwgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcclxuICAgICAgICBpZiAoaGFzTWlzbWF0Y2ggJiYgIWZhbHNlKSB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgZXJyb3Igc2hvdWxkIHNob3cgdXAgaW4gcHJvZHVjdGlvblxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBIeWRyYXRpb24gY29tcGxldGVkIGJ1dCBjb250YWlucyBtaXNtYXRjaGVzLmApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBoeWRyYXRlTm9kZSA9IChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQgPSBmYWxzZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGlzRnJhZ21lbnRTdGFydCA9IGlzQ29tbWVudChub2RlKSAmJiBub2RlLmRhdGEgPT09ICdbJztcclxuICAgICAgICBjb25zdCBvbk1pc21hdGNoID0gKCkgPT4gaGFuZGxlTWlzbWF0Y2gobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgaXNGcmFnbWVudFN0YXJ0KTtcclxuICAgICAgICBjb25zdCB7IHR5cGUsIHJlZiwgc2hhcGVGbGFnIH0gPSB2bm9kZTtcclxuICAgICAgICBjb25zdCBkb21UeXBlID0gbm9kZS5ub2RlVHlwZTtcclxuICAgICAgICB2bm9kZS5lbCA9IG5vZGU7XHJcbiAgICAgICAgbGV0IG5leHROb2RlID0gbnVsbDtcclxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBUZXh0OlxyXG4gICAgICAgICAgICAgICAgaWYgKGRvbVR5cGUgIT09IDMgLyogVEVYVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZGF0YSAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEh5ZHJhdGlvbiB0ZXh0IG1pc21hdGNoOmAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcXG4tIENsaWVudDogJHtKU09OLnN0cmluZ2lmeShub2RlLmRhdGEpfWAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcXG4tIFNlcnZlcjogJHtKU09OLnN0cmluZ2lmeSh2bm9kZS5jaGlsZHJlbil9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZub2RlLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWVudDpcclxuICAgICAgICAgICAgICAgIGlmIChkb21UeXBlICE9PSA4IC8qIENPTU1FTlQgKi8gfHwgaXNGcmFnbWVudFN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgU3RhdGljOlxyXG4gICAgICAgICAgICAgICAgaWYgKGRvbVR5cGUgIT09IDEgLyogRUxFTUVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGFuY2hvciwgYWRvcHQgY29udGVudFxyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gbm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc3RhdGljIHZub2RlIGhhcyBpdHMgY29udGVudCBzdHJpcHBlZCBkdXJpbmcgYnVpbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRvcHQgaXQgZnJvbSB0aGUgc2VydmVyLXJlbmRlcmVkIEhUTUwuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmVlZFRvQWRvcHRDb250ZW50ID0gIXZub2RlLmNoaWxkcmVuLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZub2RlLnN0YXRpY0NvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5lZWRUb0Fkb3B0Q29udGVudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlLmNoaWxkcmVuICs9IG5leHROb2RlLm91dGVySFRNTDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IHZub2RlLnN0YXRpY0NvdW50IC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm5vZGUuYW5jaG9yID0gbmV4dE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhuZXh0Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0Tm9kZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEZyYWdtZW50OlxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0ZyYWdtZW50U3RhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gaHlkcmF0ZUZyYWdtZW50KG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gMSAvKiBFTEVNRU5UICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlLnR5cGUudG9Mb3dlckNhc2UoKSAhPT1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBoeWRyYXRlRWxlbWVudChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBzZXR0aW5nIHVwIHRoZSByZW5kZXIgZWZmZWN0LCBpZiB0aGUgaW5pdGlhbCB2bm9kZSBhbHJlYWR5XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFzIC5lbCBzZXQsIHRoZSBjb21wb25lbnQgd2lsbCBwZXJmb3JtIGh5ZHJhdGlvbiBpbnN0ZWFkIG9mIG1vdW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gaXRzIHN1Yi10cmVlLlxyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLnNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkcztcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vdW50Q29tcG9uZW50KHZub2RlLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHQ29udGFpbmVyKGNvbnRhaW5lciksIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IG1heSBiZSBhc3luYywgc28gaW4gdGhlIGNhc2Ugb2YgZnJhZ21lbnRzIHdlIGNhbm5vdCByZWx5XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gY29tcG9uZW50J3MgcmVuZGVyZWQgb3V0cHV0IHRvIGRldGVybWluZSB0aGUgZW5kIG9mIHRoZSBmcmFnbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGluc3RlYWQsIHdlIGRvIGEgbG9va2FoZWFkIHRvIGZpbmQgdGhlIGVuZCBhbmNob3Igbm9kZS5cclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IGlzRnJhZ21lbnRTdGFydFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGxvY2F0ZUNsb3NpbmdBc3luY0FuY2hvcihub2RlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG5leHRTaWJsaW5nKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICMzNzg3XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgY29tcG9uZW50IGlzIGFzeW5jLCBpdCBtYXkgZ2V0IG1vdmVkIC8gdW5tb3VudGVkIGJlZm9yZSBpdHNcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbm5lciBjb21wb25lbnQgaXMgbG9hZGVkLCBzbyB3ZSBuZWVkIHRvIGdpdmUgaXQgYSBwbGFjZWhvbGRlclxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHZub2RlIHRoYXQgbWF0Y2hlcyBpdHMgYWRvcHRlZCBET00uXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXN5bmNXcmFwcGVyKHZub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3ViVHJlZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnJhZ21lbnRTdGFydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZSA9IGNyZWF0ZVZOb2RlKEZyYWdtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YlRyZWUuYW5jaG9yID0gbmV4dE5vZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG5leHROb2RlLnByZXZpb3VzU2libGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY29udGFpbmVyLmxhc3RDaGlsZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YlRyZWUgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubm9kZVR5cGUgPT09IDMgPyBjcmVhdGVUZXh0Vk5vZGUoJycpIDogY3JlYXRlVk5vZGUoJ2RpdicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YlRyZWUuZWwgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2bm9kZS5jb21wb25lbnQuc3ViVHJlZSA9IHN1YlRyZWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgNjQgLyogVEVMRVBPUlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gOCAvKiBDT01NRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSB2bm9kZS50eXBlLmh5ZHJhdGUobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgaHlkcmF0ZUNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IHZub2RlLnR5cGUuaHlkcmF0ZShub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkdDb250YWluZXIocGFyZW50Tm9kZShub2RlKSksIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgaHlkcmF0ZU5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBIb3N0Vk5vZGUgdHlwZTonLCB0eXBlLCBgKCR7dHlwZW9mIHR5cGV9KWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVmICE9IG51bGwpIHtcclxuICAgICAgICAgICAgc2V0UmVmKHJlZiwgbnVsbCwgcGFyZW50U3VzcGVuc2UsIHZub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5leHROb2RlO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGh5ZHJhdGVFbGVtZW50ID0gKGVsLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBvcHRpbWl6ZWQgPSBvcHRpbWl6ZWQgfHwgISF2bm9kZS5keW5hbWljQ2hpbGRyZW47XHJcbiAgICAgICAgY29uc3QgeyB0eXBlLCBwcm9wcywgcGF0Y2hGbGFnLCBzaGFwZUZsYWcsIGRpcnMgfSA9IHZub2RlO1xyXG4gICAgICAgIC8vICM0MDA2IGZvciBmb3JtIGVsZW1lbnRzIHdpdGggbm9uLXN0cmluZyB2LW1vZGVsIHZhbHVlIGJpbmRpbmdzXHJcbiAgICAgICAgLy8gZS5nLiA8b3B0aW9uIDp2YWx1ZT1cIm9ialwiPiwgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIDp0cnVlLXZhbHVlPVwiMVwiPlxyXG4gICAgICAgIGNvbnN0IGZvcmNlUGF0Y2hWYWx1ZSA9ICh0eXBlID09PSAnaW5wdXQnICYmIGRpcnMpIHx8IHR5cGUgPT09ICdvcHRpb24nO1xyXG4gICAgICAgIC8vIHNraXAgcHJvcHMgJiBjaGlsZHJlbiBpZiB0aGlzIGlzIGhvaXN0ZWQgc3RhdGljIG5vZGVzXHJcbiAgICAgICAgLy8gIzU0MDUgaW4gZGV2LCBhbHdheXMgaHlkcmF0ZSBjaGlsZHJlbiBmb3IgSE1SXHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBmb3JjZVBhdGNoVmFsdWUgfHwgcGF0Y2hGbGFnICE9PSAtMSAvKiBIT0lTVEVEICovKSB7XHJcbiAgICAgICAgICAgIGlmIChkaXJzKSB7XHJcbiAgICAgICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdjcmVhdGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcHJvcHNcclxuICAgICAgICAgICAgaWYgKHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZm9yY2VQYXRjaFZhbHVlIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgIW9wdGltaXplZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoRmxhZyAmICgxNiAvKiBGVUxMX1BST1BTICovIHwgMzIgLyogSFlEUkFURV9FVkVOVFMgKi8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChmb3JjZVBhdGNoVmFsdWUgJiYga2V5LmVuZHNXaXRoKCd2YWx1ZScpKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGlzT24oa2V5KSAmJiAhaXNSZXNlcnZlZFByb3Aoa2V5KSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoUHJvcChlbCwga2V5LCBudWxsLCBwcm9wc1trZXldLCBmYWxzZSwgdW5kZWZpbmVkLCBwYXJlbnRDb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvcHMub25DbGljaykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZhc3QgcGF0aCBmb3IgY2xpY2sgbGlzdGVuZXJzICh3aGljaCBpcyBtb3N0IG9mdGVuKSB0byBhdm9pZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGluZyB0aHJvdWdoIHByb3BzLlxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoUHJvcChlbCwgJ29uQ2xpY2snLCBudWxsLCBwcm9wcy5vbkNsaWNrLCBmYWxzZSwgdW5kZWZpbmVkLCBwYXJlbnRDb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHZub2RlIC8gZGlyZWN0aXZlIGhvb2tzXHJcbiAgICAgICAgICAgIGxldCB2bm9kZUhvb2tzO1xyXG4gICAgICAgICAgICBpZiAoKHZub2RlSG9va3MgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpKSB7XHJcbiAgICAgICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rcywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRpcnMpIHtcclxuICAgICAgICAgICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ2JlZm9yZU1vdW50Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCh2bm9kZUhvb2tzID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZU1vdW50ZWQpIHx8IGRpcnMpIHtcclxuICAgICAgICAgICAgICAgIHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB2bm9kZUhvb2tzICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2tzLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ21vdW50ZWQnKTtcclxuICAgICAgICAgICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjaGlsZHJlblxyXG4gICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8gJiZcclxuICAgICAgICAgICAgICAgIC8vIHNraXAgaWYgZWxlbWVudCBoYXMgaW5uZXJIVE1MIC8gdGV4dENvbnRlbnRcclxuICAgICAgICAgICAgICAgICEocHJvcHMgJiYgKHByb3BzLmlubmVySFRNTCB8fCBwcm9wcy50ZXh0Q29udGVudCkpKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGh5ZHJhdGVDaGlsZHJlbihlbC5maXJzdENoaWxkLCB2bm9kZSwgZWwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIGxldCBoYXNXYXJuZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWhhc1dhcm5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBIeWRyYXRpb24gY2hpbGRyZW4gbWlzbWF0Y2ggaW4gPCR7dm5vZGUudHlwZX0+OiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBzZXJ2ZXIgcmVuZGVyZWQgZWxlbWVudCBjb250YWlucyBtb3JlIGNoaWxkIG5vZGVzIHRoYW4gY2xpZW50IHZkb20uYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1dhcm5lZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBTU1JlZCBET00gY29udGFpbnMgbW9yZSBub2RlcyB0aGFuIGl0IHNob3VsZC4gUmVtb3ZlIHRoZW0uXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VyID0gbmV4dDtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gbmV4dC5uZXh0U2libGluZztcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmUoY3VyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiA4IC8qIFRFWFRfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbC50ZXh0Q29udGVudCAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEh5ZHJhdGlvbiB0ZXh0IGNvbnRlbnQgbWlzbWF0Y2ggaW4gPCR7dm5vZGUudHlwZX0+OlxcbmAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYC0gQ2xpZW50OiAke2VsLnRleHRDb250ZW50fVxcbmAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYC0gU2VydmVyOiAke3Zub2RlLmNoaWxkcmVufWApO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsLnRleHRDb250ZW50ID0gdm5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVsLm5leHRTaWJsaW5nO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGh5ZHJhdGVDaGlsZHJlbiA9IChub2RlLCBwYXJlbnRWTm9kZSwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIG9wdGltaXplZCA9IG9wdGltaXplZCB8fCAhIXBhcmVudFZOb2RlLmR5bmFtaWNDaGlsZHJlbjtcclxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFZOb2RlLmNoaWxkcmVuO1xyXG4gICAgICAgIGNvbnN0IGwgPSBjaGlsZHJlbi5sZW5ndGg7XHJcbiAgICAgICAgbGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZub2RlID0gb3B0aW1pemVkXHJcbiAgICAgICAgICAgICAgICA/IGNoaWxkcmVuW2ldXHJcbiAgICAgICAgICAgICAgICA6IChjaGlsZHJlbltpXSA9IG5vcm1hbGl6ZVZOb2RlKGNoaWxkcmVuW2ldKSk7XHJcbiAgICAgICAgICAgIGlmIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gaHlkcmF0ZU5vZGUobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh2bm9kZS50eXBlID09PSBUZXh0ICYmICF2bm9kZS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFoYXNXYXJuZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBIeWRyYXRpb24gY2hpbGRyZW4gbWlzbWF0Y2ggaW4gPCR7Y29udGFpbmVyLnRhZ05hbWUudG9Mb3dlckNhc2UoKX0+OiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYHNlcnZlciByZW5kZXJlZCBlbGVtZW50IGNvbnRhaW5zIGZld2VyIGNoaWxkIG5vZGVzIHRoYW4gY2xpZW50IHZkb20uYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzV2FybmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHRoZSBTU1JlZCBET00gZGlkbid0IGNvbnRhaW4gZW5vdWdoIG5vZGVzLiBNb3VudCB0aGUgbWlzc2luZyBvbmVzLlxyXG4gICAgICAgICAgICAgICAgcGF0Y2gobnVsbCwgdm5vZGUsIGNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkdDb250YWluZXIoY29udGFpbmVyKSwgc2xvdFNjb3BlSWRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH07XHJcbiAgICBjb25zdCBoeWRyYXRlRnJhZ21lbnQgPSAobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBzbG90U2NvcGVJZHM6IGZyYWdtZW50U2xvdFNjb3BlSWRzIH0gPSB2bm9kZTtcclxuICAgICAgICBpZiAoZnJhZ21lbnRTbG90U2NvcGVJZHMpIHtcclxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzXHJcbiAgICAgICAgICAgICAgICA/IHNsb3RTY29wZUlkcy5jb25jYXQoZnJhZ21lbnRTbG90U2NvcGVJZHMpXHJcbiAgICAgICAgICAgICAgICA6IGZyYWdtZW50U2xvdFNjb3BlSWRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xyXG4gICAgICAgIGNvbnN0IG5leHQgPSBoeWRyYXRlQ2hpbGRyZW4obmV4dFNpYmxpbmcobm9kZSksIHZub2RlLCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICBpZiAobmV4dCAmJiBpc0NvbW1lbnQobmV4dCkgJiYgbmV4dC5kYXRhID09PSAnXScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5leHRTaWJsaW5nKCh2bm9kZS5hbmNob3IgPSBuZXh0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBmcmFnbWVudCBkaWRuJ3QgaHlkcmF0ZSBzdWNjZXNzZnVsbHksIHNpbmNlIHdlIGRpZG4ndCBnZXQgYSBlbmQgYW5jaG9yXHJcbiAgICAgICAgICAgIC8vIGJhY2suIFRoaXMgc2hvdWxkIGhhdmUgbGVkIHRvIG5vZGUvY2hpbGRyZW4gbWlzbWF0Y2ggd2FybmluZ3MuXHJcbiAgICAgICAgICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgLy8gc2luY2UgdGhlIGFuY2hvciBpcyBtaXNzaW5nLCB3ZSBuZWVkIHRvIGNyZWF0ZSBvbmUgYW5kIGluc2VydCBpdFxyXG4gICAgICAgICAgICBpbnNlcnQoKHZub2RlLmFuY2hvciA9IGNyZWF0ZUNvbW1lbnQoYF1gKSksIGNvbnRhaW5lciwgbmV4dCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXh0O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBoYW5kbGVNaXNtYXRjaCA9IChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBpc0ZyYWdtZW50KSA9PiB7XHJcbiAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICB3YXJuKGBIeWRyYXRpb24gbm9kZSBtaXNtYXRjaDpcXG4tIENsaWVudCB2bm9kZTpgLCB2bm9kZS50eXBlLCBgXFxuLSBTZXJ2ZXIgcmVuZGVyZWQgRE9NOmAsIG5vZGUsIG5vZGUubm9kZVR5cGUgPT09IDMgLyogVEVYVCAqL1xyXG4gICAgICAgICAgICAgICAgPyBgKHRleHQpYFxyXG4gICAgICAgICAgICAgICAgOiBpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSAnWydcclxuICAgICAgICAgICAgICAgICAgICA/IGAoc3RhcnQgb2YgZnJhZ21lbnQpYFxyXG4gICAgICAgICAgICAgICAgICAgIDogYGApO1xyXG4gICAgICAgIHZub2RlLmVsID0gbnVsbDtcclxuICAgICAgICBpZiAoaXNGcmFnbWVudCkge1xyXG4gICAgICAgICAgICAvLyByZW1vdmUgZXhjZXNzaXZlIGZyYWdtZW50IG5vZGVzXHJcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IGxvY2F0ZUNsb3NpbmdBc3luY0FuY2hvcihub2RlKTtcclxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQgIT09IGVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZShuZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5leHQgPSBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xyXG4gICAgICAgIHJlbW92ZShub2RlKTtcclxuICAgICAgICBwYXRjaChudWxsLCB2bm9kZSwgY29udGFpbmVyLCBuZXh0LCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWR0NvbnRhaW5lcihjb250YWluZXIpLCBzbG90U2NvcGVJZHMpO1xyXG4gICAgICAgIHJldHVybiBuZXh0O1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGxvY2F0ZUNsb3NpbmdBc3luY0FuY2hvciA9IChub2RlKSA9PiB7XHJcbiAgICAgICAgbGV0IG1hdGNoID0gMDtcclxuICAgICAgICB3aGlsZSAobm9kZSkge1xyXG4gICAgICAgICAgICBub2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgICAgIGlmIChub2RlICYmIGlzQ29tbWVudChub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZGF0YSA9PT0gJ1snKVxyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoKys7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5kYXRhID09PSAnXScpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHRTaWJsaW5nKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2gtLTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFtoeWRyYXRlLCBoeWRyYXRlTm9kZV07XHJcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXHJcbmxldCBzdXBwb3J0ZWQ7XHJcbmxldCBwZXJmO1xyXG5mdW5jdGlvbiBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIHR5cGUpIHtcclxuICAgIGlmIChpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy5wZXJmb3JtYW5jZSAmJiBpc1N1cHBvcnRlZCgpKSB7XHJcbiAgICAgICAgcGVyZi5tYXJrKGB2dWUtJHt0eXBlfS0ke2luc3RhbmNlLnVpZH1gKTtcclxuICAgIH1cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgZGV2dG9vbHNQZXJmU3RhcnQoaW5zdGFuY2UsIHR5cGUsIHN1cHBvcnRlZCA/IHBlcmYubm93KCkgOiBEYXRlLm5vdygpKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBlbmRNZWFzdXJlKGluc3RhbmNlLCB0eXBlKSB7XHJcbiAgICBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcucGVyZm9ybWFuY2UgJiYgaXNTdXBwb3J0ZWQoKSkge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0VGFnID0gYHZ1ZS0ke3R5cGV9LSR7aW5zdGFuY2UudWlkfWA7XHJcbiAgICAgICAgY29uc3QgZW5kVGFnID0gc3RhcnRUYWcgKyBgOmVuZGA7XHJcbiAgICAgICAgcGVyZi5tYXJrKGVuZFRhZyk7XHJcbiAgICAgICAgcGVyZi5tZWFzdXJlKGA8JHtmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCBpbnN0YW5jZS50eXBlKX0+ICR7dHlwZX1gLCBzdGFydFRhZywgZW5kVGFnKTtcclxuICAgICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xyXG4gICAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xyXG4gICAgfVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICBkZXZ0b29sc1BlcmZFbmQoaW5zdGFuY2UsIHR5cGUsIHN1cHBvcnRlZCA/IHBlcmYubm93KCkgOiBEYXRlLm5vdygpKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc1N1cHBvcnRlZCgpIHtcclxuICAgIGlmIChzdXBwb3J0ZWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBzdXBwb3J0ZWQ7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBlcmZvcm1hbmNlKSB7XHJcbiAgICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcclxuICAgICAgICBwZXJmID0gd2luZG93LnBlcmZvcm1hbmNlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc3VwcG9ydGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3VwcG9ydGVkO1xyXG59XG5cbi8qKlxyXG4gKiBUaGlzIGlzIG9ubHkgY2FsbGVkIGluIGVzbS1idW5kbGVyIGJ1aWxkcy5cclxuICogSXQgaXMgY2FsbGVkIHdoZW4gYSByZW5kZXJlciBpcyBjcmVhdGVkLCBpbiBgYmFzZUNyZWF0ZVJlbmRlcmVyYCBzbyB0aGF0XHJcbiAqIGltcG9ydGluZyBydW50aW1lLWNvcmUgaXMgc2lkZS1lZmZlY3RzIGZyZWUuXHJcbiAqXHJcbiAqIGlzdGFuYnVsLWlnbm9yZS1uZXh0XHJcbiAqL1xyXG5mdW5jdGlvbiBpbml0RmVhdHVyZUZsYWdzKCkge1xyXG4gICAgY29uc3QgbmVlZFdhcm4gPSBbXTtcclxuICAgIGlmICh0eXBlb2YgX19WVUVfT1BUSU9OU19BUElfXyAhPT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIG5lZWRXYXJuLnB1c2goYF9fVlVFX09QVElPTlNfQVBJX19gKTtcclxuICAgICAgICBnZXRHbG9iYWxUaGlzKCkuX19WVUVfT1BUSU9OU19BUElfXyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIF9fVlVFX1BST0RfREVWVE9PTFNfXyAhPT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIG5lZWRXYXJuLnB1c2goYF9fVlVFX1BST0RfREVWVE9PTFNfX2ApO1xyXG4gICAgICAgIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9QUk9EX0RFVlRPT0xTX18gPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgbmVlZFdhcm4ubGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgbXVsdGkgPSBuZWVkV2Fybi5sZW5ndGggPiAxO1xyXG4gICAgICAgIGNvbnNvbGUud2FybihgRmVhdHVyZSBmbGFnJHttdWx0aSA/IGBzYCA6IGBgfSAke25lZWRXYXJuLmpvaW4oJywgJyl9ICR7bXVsdGkgPyBgYXJlYCA6IGBpc2B9IG5vdCBleHBsaWNpdGx5IGRlZmluZWQuIFlvdSBhcmUgcnVubmluZyB0aGUgZXNtLWJ1bmRsZXIgYnVpbGQgb2YgVnVlLCBgICtcclxuICAgICAgICAgICAgYHdoaWNoIGV4cGVjdHMgdGhlc2UgY29tcGlsZS10aW1lIGZlYXR1cmUgZmxhZ3MgdG8gYmUgZ2xvYmFsbHkgaW5qZWN0ZWQgYCArXHJcbiAgICAgICAgICAgIGB2aWEgdGhlIGJ1bmRsZXIgY29uZmlnIGluIG9yZGVyIHRvIGdldCBiZXR0ZXIgdHJlZS1zaGFraW5nIGluIHRoZSBgICtcclxuICAgICAgICAgICAgYHByb2R1Y3Rpb24gYnVuZGxlLlxcblxcbmAgK1xyXG4gICAgICAgICAgICBgRm9yIG1vcmUgZGV0YWlscywgc2VlIGh0dHBzOi8vbGluay52dWVqcy5vcmcvZmVhdHVyZS1mbGFncy5gKTtcclxuICAgIH1cclxufVxuXG5jb25zdCBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QgPSBxdWV1ZUVmZmVjdFdpdGhTdXNwZW5zZVxyXG4gICAgO1xyXG4vKipcclxuICogVGhlIGNyZWF0ZVJlbmRlcmVyIGZ1bmN0aW9uIGFjY2VwdHMgdHdvIGdlbmVyaWMgYXJndW1lbnRzOlxyXG4gKiBIb3N0Tm9kZSBhbmQgSG9zdEVsZW1lbnQsIGNvcnJlc3BvbmRpbmcgdG8gTm9kZSBhbmQgRWxlbWVudCB0eXBlcyBpbiB0aGVcclxuICogaG9zdCBlbnZpcm9ubWVudC4gRm9yIGV4YW1wbGUsIGZvciBydW50aW1lLWRvbSwgSG9zdE5vZGUgd291bGQgYmUgdGhlIERPTVxyXG4gKiBgTm9kZWAgaW50ZXJmYWNlIGFuZCBIb3N0RWxlbWVudCB3b3VsZCBiZSB0aGUgRE9NIGBFbGVtZW50YCBpbnRlcmZhY2UuXHJcbiAqXHJcbiAqIEN1c3RvbSByZW5kZXJlcnMgY2FuIHBhc3MgaW4gdGhlIHBsYXRmb3JtIHNwZWNpZmljIHR5cGVzIGxpa2UgdGhpczpcclxuICpcclxuICogYGBgIGpzXHJcbiAqIGNvbnN0IHsgcmVuZGVyLCBjcmVhdGVBcHAgfSA9IGNyZWF0ZVJlbmRlcmVyPE5vZGUsIEVsZW1lbnQ+KHtcclxuICogICBwYXRjaFByb3AsXHJcbiAqICAgLi4ubm9kZU9wc1xyXG4gKiB9KVxyXG4gKiBgYGBcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBiYXNlQ3JlYXRlUmVuZGVyZXIob3B0aW9ucyk7XHJcbn1cclxuLy8gU2VwYXJhdGUgQVBJIGZvciBjcmVhdGluZyBoeWRyYXRpb24tZW5hYmxlZCByZW5kZXJlci5cclxuLy8gSHlkcmF0aW9uIGxvZ2ljIGlzIG9ubHkgdXNlZCB3aGVuIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiwgbWFraW5nIGl0XHJcbi8vIHRyZWUtc2hha2FibGUuXHJcbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyKG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBiYXNlQ3JlYXRlUmVuZGVyZXIob3B0aW9ucywgY3JlYXRlSHlkcmF0aW9uRnVuY3Rpb25zKTtcclxufVxyXG4vLyBpbXBsZW1lbnRhdGlvblxyXG5mdW5jdGlvbiBiYXNlQ3JlYXRlUmVuZGVyZXIob3B0aW9ucywgY3JlYXRlSHlkcmF0aW9uRm5zKSB7XHJcbiAgICAvLyBjb21waWxlLXRpbWUgZmVhdHVyZSBmbGFncyBjaGVja1xyXG4gICAge1xyXG4gICAgICAgIGluaXRGZWF0dXJlRmxhZ3MoKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHRhcmdldCA9IGdldEdsb2JhbFRoaXMoKTtcclxuICAgIHRhcmdldC5fX1ZVRV9fID0gdHJ1ZTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgc2V0RGV2dG9vbHNIb29rKHRhcmdldC5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fLCB0YXJnZXQpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBpbnNlcnQ6IGhvc3RJbnNlcnQsIHJlbW92ZTogaG9zdFJlbW92ZSwgcGF0Y2hQcm9wOiBob3N0UGF0Y2hQcm9wLCBjcmVhdGVFbGVtZW50OiBob3N0Q3JlYXRlRWxlbWVudCwgY3JlYXRlVGV4dDogaG9zdENyZWF0ZVRleHQsIGNyZWF0ZUNvbW1lbnQ6IGhvc3RDcmVhdGVDb21tZW50LCBzZXRUZXh0OiBob3N0U2V0VGV4dCwgc2V0RWxlbWVudFRleHQ6IGhvc3RTZXRFbGVtZW50VGV4dCwgcGFyZW50Tm9kZTogaG9zdFBhcmVudE5vZGUsIG5leHRTaWJsaW5nOiBob3N0TmV4dFNpYmxpbmcsIHNldFNjb3BlSWQ6IGhvc3RTZXRTY29wZUlkID0gTk9PUCwgY2xvbmVOb2RlOiBob3N0Q2xvbmVOb2RlLCBpbnNlcnRTdGF0aWNDb250ZW50OiBob3N0SW5zZXJ0U3RhdGljQ29udGVudCB9ID0gb3B0aW9ucztcclxuICAgIC8vIE5vdGU6IGZ1bmN0aW9ucyBpbnNpZGUgdGhpcyBjbG9zdXJlIHNob3VsZCB1c2UgYGNvbnN0IHh4eCA9ICgpID0+IHt9YFxyXG4gICAgLy8gc3R5bGUgaW4gb3JkZXIgdG8gcHJldmVudCBiZWluZyBpbmxpbmVkIGJ5IG1pbmlmaWVycy5cclxuICAgIGNvbnN0IHBhdGNoID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IgPSBudWxsLCBwYXJlbnRDb21wb25lbnQgPSBudWxsLCBwYXJlbnRTdXNwZW5zZSA9IG51bGwsIGlzU1ZHID0gZmFsc2UsIHNsb3RTY29wZUlkcyA9IG51bGwsIG9wdGltaXplZCA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpc0htclVwZGF0aW5nID8gZmFsc2UgOiAhIW4yLmR5bmFtaWNDaGlsZHJlbikgPT4ge1xyXG4gICAgICAgIGlmIChuMSA9PT0gbjIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBwYXRjaGluZyAmIG5vdCBzYW1lIHR5cGUsIHVubW91bnQgb2xkIHRyZWVcclxuICAgICAgICBpZiAobjEgJiYgIWlzU2FtZVZOb2RlVHlwZShuMSwgbjIpKSB7XHJcbiAgICAgICAgICAgIGFuY2hvciA9IGdldE5leHRIb3N0Tm9kZShuMSk7XHJcbiAgICAgICAgICAgIHVubW91bnQobjEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xyXG4gICAgICAgICAgICBuMSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuMi5wYXRjaEZsYWcgPT09IC0yIC8qIEJBSUwgKi8pIHtcclxuICAgICAgICAgICAgb3B0aW1pemVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIG4yLmR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgdHlwZSwgcmVmLCBzaGFwZUZsYWcgfSA9IG4yO1xyXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIFRleHQ6XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzVGV4dChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIENvbW1lbnQ6XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzQ29tbWVudE5vZGUobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBTdGF0aWM6XHJcbiAgICAgICAgICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1vdW50U3RhdGljTm9kZShuMiwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoU3RhdGljTm9kZShuMSwgbjIsIGNvbnRhaW5lciwgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgRnJhZ21lbnQ6XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzRnJhZ21lbnQobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEgLyogRUxFTUVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NFbGVtZW50KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NDb21wb25lbnQobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDY0IC8qIFRFTEVQT1JUICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZS5wcm9jZXNzKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgaW50ZXJuYWxzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUucHJvY2VzcyhuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIGludGVybmFscyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKCdJbnZhbGlkIFZOb2RlIHR5cGU6JywgdHlwZSwgYCgke3R5cGVvZiB0eXBlfSlgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc2V0IHJlZlxyXG4gICAgICAgIGlmIChyZWYgIT0gbnVsbCAmJiBwYXJlbnRDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgc2V0UmVmKHJlZiwgbjEgJiYgbjEucmVmLCBwYXJlbnRTdXNwZW5zZSwgbjIgfHwgbjEsICFuMik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHByb2Nlc3NUZXh0ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpID0+IHtcclxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBob3N0SW5zZXJ0KChuMi5lbCA9IGhvc3RDcmVhdGVUZXh0KG4yLmNoaWxkcmVuKSksIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsID0gKG4yLmVsID0gbjEuZWwpO1xyXG4gICAgICAgICAgICBpZiAobjIuY2hpbGRyZW4gIT09IG4xLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICBob3N0U2V0VGV4dChlbCwgbjIuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHByb2Nlc3NDb21tZW50Tm9kZSA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKSA9PiB7XHJcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgICAgICAgaG9zdEluc2VydCgobjIuZWwgPSBob3N0Q3JlYXRlQ29tbWVudChuMi5jaGlsZHJlbiB8fCAnJykpLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0aGVyZSdzIG5vIHN1cHBvcnQgZm9yIGR5bmFtaWMgY29tbWVudHNcclxuICAgICAgICAgICAgbjIuZWwgPSBuMS5lbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbW91bnRTdGF0aWNOb2RlID0gKG4yLCBjb250YWluZXIsIGFuY2hvciwgaXNTVkcpID0+IHtcclxuICAgICAgICBbbjIuZWwsIG4yLmFuY2hvcl0gPSBob3N0SW5zZXJ0U3RhdGljQ29udGVudChuMi5jaGlsZHJlbiwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHLCBuMi5lbCwgbjIuYW5jaG9yKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERldiAvIEhNUiBvbmx5XHJcbiAgICAgKi9cclxuICAgIGNvbnN0IHBhdGNoU3RhdGljTm9kZSA9IChuMSwgbjIsIGNvbnRhaW5lciwgaXNTVkcpID0+IHtcclxuICAgICAgICAvLyBzdGF0aWMgbm9kZXMgYXJlIG9ubHkgcGF0Y2hlZCBkdXJpbmcgZGV2IGZvciBITVJcclxuICAgICAgICBpZiAobjIuY2hpbGRyZW4gIT09IG4xLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IGhvc3ROZXh0U2libGluZyhuMS5hbmNob3IpO1xyXG4gICAgICAgICAgICAvLyByZW1vdmUgZXhpc3RpbmdcclxuICAgICAgICAgICAgcmVtb3ZlU3RhdGljTm9kZShuMSk7XHJcbiAgICAgICAgICAgIFtuMi5lbCwgbjIuYW5jaG9yXSA9IGhvc3RJbnNlcnRTdGF0aWNDb250ZW50KG4yLmNoaWxkcmVuLCBjb250YWluZXIsIGFuY2hvciwgaXNTVkcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbjIuZWwgPSBuMS5lbDtcclxuICAgICAgICAgICAgbjIuYW5jaG9yID0gbjEuYW5jaG9yO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBtb3ZlU3RhdGljTm9kZSA9ICh7IGVsLCBhbmNob3IgfSwgY29udGFpbmVyLCBuZXh0U2libGluZykgPT4ge1xyXG4gICAgICAgIGxldCBuZXh0O1xyXG4gICAgICAgIHdoaWxlIChlbCAmJiBlbCAhPT0gYW5jaG9yKSB7XHJcbiAgICAgICAgICAgIG5leHQgPSBob3N0TmV4dFNpYmxpbmcoZWwpO1xyXG4gICAgICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIG5leHRTaWJsaW5nKTtcclxuICAgICAgICAgICAgZWwgPSBuZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBob3N0SW5zZXJ0KGFuY2hvciwgY29udGFpbmVyLCBuZXh0U2libGluZyk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmVtb3ZlU3RhdGljTm9kZSA9ICh7IGVsLCBhbmNob3IgfSkgPT4ge1xyXG4gICAgICAgIGxldCBuZXh0O1xyXG4gICAgICAgIHdoaWxlIChlbCAmJiBlbCAhPT0gYW5jaG9yKSB7XHJcbiAgICAgICAgICAgIG5leHQgPSBob3N0TmV4dFNpYmxpbmcoZWwpO1xyXG4gICAgICAgICAgICBob3N0UmVtb3ZlKGVsKTtcclxuICAgICAgICAgICAgZWwgPSBuZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBob3N0UmVtb3ZlKGFuY2hvcik7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcHJvY2Vzc0VsZW1lbnQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgaXNTVkcgPSBpc1NWRyB8fCBuMi50eXBlID09PSAnc3ZnJztcclxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBtb3VudEVsZW1lbnQobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcGF0Y2hFbGVtZW50KG4xLCBuMiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbW91bnRFbGVtZW50ID0gKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgbGV0IGVsO1xyXG4gICAgICAgIGxldCB2bm9kZUhvb2s7XHJcbiAgICAgICAgY29uc3QgeyB0eXBlLCBwcm9wcywgc2hhcGVGbGFnLCB0cmFuc2l0aW9uLCBwYXRjaEZsYWcsIGRpcnMgfSA9IHZub2RlO1xyXG4gICAgICAgIGlmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgIHZub2RlLmVsICYmXHJcbiAgICAgICAgICAgIGhvc3RDbG9uZU5vZGUgIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgICBwYXRjaEZsYWcgPT09IC0xIC8qIEhPSVNURUQgKi8pIHtcclxuICAgICAgICAgICAgLy8gSWYgYSB2bm9kZSBoYXMgbm9uLW51bGwgZWwsIGl0IG1lYW5zIGl0J3MgYmVpbmcgcmV1c2VkLlxyXG4gICAgICAgICAgICAvLyBPbmx5IHN0YXRpYyB2bm9kZXMgY2FuIGJlIHJldXNlZCwgc28gaXRzIG1vdW50ZWQgRE9NIG5vZGVzIHNob3VsZCBiZVxyXG4gICAgICAgICAgICAvLyBleGFjdGx5IHRoZSBzYW1lLCBhbmQgd2UgY2FuIHNpbXBseSBkbyBhIGNsb25lIGhlcmUuXHJcbiAgICAgICAgICAgIC8vIG9ubHkgZG8gdGhpcyBpbiBwcm9kdWN0aW9uIHNpbmNlIGNsb25lZCB0cmVlcyBjYW5ub3QgYmUgSE1SIHVwZGF0ZWQuXHJcbiAgICAgICAgICAgIGVsID0gdm5vZGUuZWwgPSBob3N0Q2xvbmVOb2RlKHZub2RlLmVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVsID0gdm5vZGUuZWwgPSBob3N0Q3JlYXRlRWxlbWVudCh2bm9kZS50eXBlLCBpc1NWRywgcHJvcHMgJiYgcHJvcHMuaXMsIHByb3BzKTtcclxuICAgICAgICAgICAgLy8gbW91bnQgY2hpbGRyZW4gZmlyc3QsIHNpbmNlIHNvbWUgcHJvcHMgbWF5IHJlbHkgb24gY2hpbGQgY29udGVudFxyXG4gICAgICAgICAgICAvLyBiZWluZyBhbHJlYWR5IHJlbmRlcmVkLCBlLmcuIGA8c2VsZWN0IHZhbHVlPmBcclxuICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDggLyogVEVYVF9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGVsLCB2bm9kZS5jaGlsZHJlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgIG1vdW50Q2hpbGRyZW4odm5vZGUuY2hpbGRyZW4sIGVsLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRyAmJiB0eXBlICE9PSAnZm9yZWlnbk9iamVjdCcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGlycykge1xyXG4gICAgICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnY3JlYXRlZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHByb3BzXHJcbiAgICAgICAgICAgIGlmIChwcm9wcykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAndmFsdWUnICYmICFpc1Jlc2VydmVkUHJvcChrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIGtleSwgbnVsbCwgcHJvcHNba2V5XSwgaXNTVkcsIHZub2RlLmNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogU3BlY2lhbCBjYXNlIGZvciBzZXR0aW5nIHZhbHVlIG9uIERPTSBlbGVtZW50czpcclxuICAgICAgICAgICAgICAgICAqIC0gaXQgY2FuIGJlIG9yZGVyLXNlbnNpdGl2ZSAoZS5nLiBzaG91bGQgYmUgc2V0ICphZnRlciogbWluL21heCwgIzIzMjUsICM0MDI0KVxyXG4gICAgICAgICAgICAgICAgICogLSBpdCBuZWVkcyB0byBiZSBmb3JjZWQgKCMxNDcxKVxyXG4gICAgICAgICAgICAgICAgICogIzIzNTMgcHJvcG9zZXMgYWRkaW5nIGFub3RoZXIgcmVuZGVyZXIgb3B0aW9uIHRvIGNvbmZpZ3VyZSB0aGlzLCBidXRcclxuICAgICAgICAgICAgICAgICAqIHRoZSBwcm9wZXJ0aWVzIGFmZmVjdHMgYXJlIHNvIGZpbml0ZSBpdCBpcyB3b3J0aCBzcGVjaWFsIGNhc2luZyBpdFxyXG4gICAgICAgICAgICAgICAgICogaGVyZSB0byByZWR1Y2UgdGhlIGNvbXBsZXhpdHkuIChTcGVjaWFsIGNhc2luZyBpdCBhbHNvIHNob3VsZCBub3RcclxuICAgICAgICAgICAgICAgICAqIGFmZmVjdCBub24tRE9NIHJlbmRlcmVycylcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgaWYgKCd2YWx1ZScgaW4gcHJvcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCAndmFsdWUnLCBudWxsLCBwcm9wcy52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoKHZub2RlSG9vayA9IHByb3BzLm9uVm5vZGVCZWZvcmVNb3VudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBzY29wZUlkXHJcbiAgICAgICAgICAgIHNldFNjb3BlSWQoZWwsIHZub2RlLCB2bm9kZS5zY29wZUlkLCBzbG90U2NvcGVJZHMsIHBhcmVudENvbXBvbmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbCwgJ19fdm5vZGUnLCB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdm5vZGUsXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsLCAnX192dWVQYXJlbnRDb21wb25lbnQnLCB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogcGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaXJzKSB7XHJcbiAgICAgICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ2JlZm9yZU1vdW50Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vICMxNTgzIEZvciBpbnNpZGUgc3VzcGVuc2UgKyBzdXNwZW5zZSBub3QgcmVzb2x2ZWQgY2FzZSwgZW50ZXIgaG9vayBzaG91bGQgY2FsbCB3aGVuIHN1c3BlbnNlIHJlc29sdmVkXHJcbiAgICAgICAgLy8gIzE2ODkgRm9yIGluc2lkZSBzdXNwZW5zZSArIHN1c3BlbnNlIHJlc29sdmVkIGNhc2UsIGp1c3QgY2FsbCBpdFxyXG4gICAgICAgIGNvbnN0IG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzID0gKCFwYXJlbnRTdXNwZW5zZSB8fCAocGFyZW50U3VzcGVuc2UgJiYgIXBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpKSAmJlxyXG4gICAgICAgICAgICB0cmFuc2l0aW9uICYmXHJcbiAgICAgICAgICAgICF0cmFuc2l0aW9uLnBlcnNpc3RlZDtcclxuICAgICAgICBpZiAobmVlZENhbGxUcmFuc2l0aW9uSG9va3MpIHtcclxuICAgICAgICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICBpZiAoKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSB8fFxyXG4gICAgICAgICAgICBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyB8fFxyXG4gICAgICAgICAgICBkaXJzKSB7XHJcbiAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZUhvb2sgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyAmJiB0cmFuc2l0aW9uLmVudGVyKGVsKTtcclxuICAgICAgICAgICAgICAgIGRpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnbW91bnRlZCcpO1xyXG4gICAgICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHNldFNjb3BlSWQgPSAoZWwsIHZub2RlLCBzY29wZUlkLCBzbG90U2NvcGVJZHMsIHBhcmVudENvbXBvbmVudCkgPT4ge1xyXG4gICAgICAgIGlmIChzY29wZUlkKSB7XHJcbiAgICAgICAgICAgIGhvc3RTZXRTY29wZUlkKGVsLCBzY29wZUlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNsb3RTY29wZUlkcykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsb3RTY29wZUlkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaG9zdFNldFNjb3BlSWQoZWwsIHNsb3RTY29wZUlkc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhcmVudENvbXBvbmVudCkge1xyXG4gICAgICAgICAgICBsZXQgc3ViVHJlZSA9IHBhcmVudENvbXBvbmVudC5zdWJUcmVlO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICBzdWJUcmVlLnBhdGNoRmxhZyA+IDAgJiZcclxuICAgICAgICAgICAgICAgIHN1YlRyZWUucGF0Y2hGbGFnICYgMjA0OCAvKiBERVZfUk9PVF9GUkFHTUVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgc3ViVHJlZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyU2luZ2xlUm9vdChzdWJUcmVlLmNoaWxkcmVuKSB8fCBzdWJUcmVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2bm9kZSA9PT0gc3ViVHJlZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50Vk5vZGUgPSBwYXJlbnRDb21wb25lbnQudm5vZGU7XHJcbiAgICAgICAgICAgICAgICBzZXRTY29wZUlkKGVsLCBwYXJlbnRWTm9kZSwgcGFyZW50Vk5vZGUuc2NvcGVJZCwgcGFyZW50Vk5vZGUuc2xvdFNjb3BlSWRzLCBwYXJlbnRDb21wb25lbnQucGFyZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBtb3VudENoaWxkcmVuID0gKGNoaWxkcmVuLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBzdGFydCA9IDApID0+IHtcclxuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IChjaGlsZHJlbltpXSA9IG9wdGltaXplZFxyXG4gICAgICAgICAgICAgICAgPyBjbG9uZUlmTW91bnRlZChjaGlsZHJlbltpXSlcclxuICAgICAgICAgICAgICAgIDogbm9ybWFsaXplVk5vZGUoY2hpbGRyZW5baV0pKTtcclxuICAgICAgICAgICAgcGF0Y2gobnVsbCwgY2hpbGQsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBwYXRjaEVsZW1lbnQgPSAobjEsIG4yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBjb25zdCBlbCA9IChuMi5lbCA9IG4xLmVsKTtcclxuICAgICAgICBsZXQgeyBwYXRjaEZsYWcsIGR5bmFtaWNDaGlsZHJlbiwgZGlycyB9ID0gbjI7XHJcbiAgICAgICAgLy8gIzE0MjYgdGFrZSB0aGUgb2xkIHZub2RlJ3MgcGF0Y2ggZmxhZyBpbnRvIGFjY291bnQgc2luY2UgdXNlciBtYXkgY2xvbmUgYVxyXG4gICAgICAgIC8vIGNvbXBpbGVyLWdlbmVyYXRlZCB2bm9kZSwgd2hpY2ggZGUtb3B0cyB0byBGVUxMX1BST1BTXHJcbiAgICAgICAgcGF0Y2hGbGFnIHw9IG4xLnBhdGNoRmxhZyAmIDE2IC8qIEZVTExfUFJPUFMgKi87XHJcbiAgICAgICAgY29uc3Qgb2xkUHJvcHMgPSBuMS5wcm9wcyB8fCBFTVBUWV9PQko7XHJcbiAgICAgICAgY29uc3QgbmV3UHJvcHMgPSBuMi5wcm9wcyB8fCBFTVBUWV9PQko7XHJcbiAgICAgICAgbGV0IHZub2RlSG9vaztcclxuICAgICAgICAvLyBkaXNhYmxlIHJlY3Vyc2UgaW4gYmVmb3JlVXBkYXRlIGhvb2tzXHJcbiAgICAgICAgcGFyZW50Q29tcG9uZW50ICYmIHRvZ2dsZVJlY3Vyc2UocGFyZW50Q29tcG9uZW50LCBmYWxzZSk7XHJcbiAgICAgICAgaWYgKCh2bm9kZUhvb2sgPSBuZXdQcm9wcy5vblZub2RlQmVmb3JlVXBkYXRlKSkge1xyXG4gICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIG4yLCBuMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaXJzKSB7XHJcbiAgICAgICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sobjIsIG4xLCBwYXJlbnRDb21wb25lbnQsICdiZWZvcmVVcGRhdGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGFyZW50Q29tcG9uZW50ICYmIHRvZ2dsZVJlY3Vyc2UocGFyZW50Q29tcG9uZW50LCB0cnVlKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGlzSG1yVXBkYXRpbmcpIHtcclxuICAgICAgICAgICAgLy8gSE1SIHVwZGF0ZWQsIGZvcmNlIGZ1bGwgZGlmZlxyXG4gICAgICAgICAgICBwYXRjaEZsYWcgPSAwO1xyXG4gICAgICAgICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYXJlQ2hpbGRyZW5TVkcgPSBpc1NWRyAmJiBuMi50eXBlICE9PSAnZm9yZWlnbk9iamVjdCc7XHJcbiAgICAgICAgaWYgKGR5bmFtaWNDaGlsZHJlbikge1xyXG4gICAgICAgICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4objEuZHluYW1pY0NoaWxkcmVuLCBkeW5hbWljQ2hpbGRyZW4sIGVsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBhcmVDaGlsZHJlblNWRywgc2xvdFNjb3BlSWRzKTtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBwYXJlbnRDb21wb25lbnQgJiYgcGFyZW50Q29tcG9uZW50LnR5cGUuX19obXJJZCkge1xyXG4gICAgICAgICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFvcHRpbWl6ZWQpIHtcclxuICAgICAgICAgICAgLy8gZnVsbCBkaWZmXHJcbiAgICAgICAgICAgIHBhdGNoQ2hpbGRyZW4objEsIG4yLCBlbCwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgYXJlQ2hpbGRyZW5TVkcsIHNsb3RTY29wZUlkcywgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGF0Y2hGbGFnID4gMCkge1xyXG4gICAgICAgICAgICAvLyB0aGUgcHJlc2VuY2Ugb2YgYSBwYXRjaEZsYWcgbWVhbnMgdGhpcyBlbGVtZW50J3MgcmVuZGVyIGNvZGUgd2FzXHJcbiAgICAgICAgICAgIC8vIGdlbmVyYXRlZCBieSB0aGUgY29tcGlsZXIgYW5kIGNhbiB0YWtlIHRoZSBmYXN0IHBhdGguXHJcbiAgICAgICAgICAgIC8vIGluIHRoaXMgcGF0aCBvbGQgbm9kZSBhbmQgbmV3IG5vZGUgYXJlIGd1YXJhbnRlZWQgdG8gaGF2ZSB0aGUgc2FtZSBzaGFwZVxyXG4gICAgICAgICAgICAvLyAoaS5lLiBhdCB0aGUgZXhhY3Qgc2FtZSBwb3NpdGlvbiBpbiB0aGUgc291cmNlIHRlbXBsYXRlKVxyXG4gICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgMTYgLyogRlVMTF9QUk9QUyAqLykge1xyXG4gICAgICAgICAgICAgICAgLy8gZWxlbWVudCBwcm9wcyBjb250YWluIGR5bmFtaWMga2V5cywgZnVsbCBkaWZmIG5lZWRlZFxyXG4gICAgICAgICAgICAgICAgcGF0Y2hQcm9wcyhlbCwgbjIsIG9sZFByb3BzLCBuZXdQcm9wcywgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gY2xhc3NcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgZmxhZyBpcyBtYXRjaGVkIHdoZW4gdGhlIGVsZW1lbnQgaGFzIGR5bmFtaWMgY2xhc3MgYmluZGluZ3MuXHJcbiAgICAgICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgMiAvKiBDTEFTUyAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRQcm9wcy5jbGFzcyAhPT0gbmV3UHJvcHMuY2xhc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgJ2NsYXNzJywgbnVsbCwgbmV3UHJvcHMuY2xhc3MsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBzdHlsZVxyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBmbGFnIGlzIG1hdGNoZWQgd2hlbiB0aGUgZWxlbWVudCBoYXMgZHluYW1pYyBzdHlsZSBiaW5kaW5nc1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDQgLyogU1RZTEUgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCAnc3R5bGUnLCBvbGRQcm9wcy5zdHlsZSwgbmV3UHJvcHMuc3R5bGUsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHByb3BzXHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGZsYWcgaXMgbWF0Y2hlZCB3aGVuIHRoZSBlbGVtZW50IGhhcyBkeW5hbWljIHByb3AvYXR0ciBiaW5kaW5nc1xyXG4gICAgICAgICAgICAgICAgLy8gb3RoZXIgdGhhbiBjbGFzcyBhbmQgc3R5bGUuIFRoZSBrZXlzIG9mIGR5bmFtaWMgcHJvcC9hdHRycyBhcmUgc2F2ZWQgZm9yXHJcbiAgICAgICAgICAgICAgICAvLyBmYXN0ZXIgaXRlcmF0aW9uLlxyXG4gICAgICAgICAgICAgICAgLy8gTm90ZSBkeW5hbWljIGtleXMgbGlrZSA6W2Zvb109XCJiYXJcIiB3aWxsIGNhdXNlIHRoaXMgb3B0aW1pemF0aW9uIHRvXHJcbiAgICAgICAgICAgICAgICAvLyBiYWlsIG91dCBhbmQgZ28gdGhyb3VnaCBhIGZ1bGwgZGlmZiBiZWNhdXNlIHdlIG5lZWQgdG8gdW5zZXQgdGhlIG9sZCBrZXlcclxuICAgICAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgJiA4IC8qIFBST1BTICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGZsYWcgaXMgcHJlc2VudCB0aGVuIGR5bmFtaWNQcm9wcyBtdXN0IGJlIG5vbi1udWxsXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcHNUb1VwZGF0ZSA9IG4yLmR5bmFtaWNQcm9wcztcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzVG9VcGRhdGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcHJvcHNUb1VwZGF0ZVtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IG9sZFByb3BzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBuZXdQcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAjMTQ3MSBmb3JjZSBwYXRjaCB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCAhPT0gcHJldiB8fCBrZXkgPT09ICd2YWx1ZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIGtleSwgcHJldiwgbmV4dCwgaXNTVkcsIG4xLmNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHRleHRcclxuICAgICAgICAgICAgLy8gVGhpcyBmbGFnIGlzIG1hdGNoZWQgd2hlbiB0aGUgZWxlbWVudCBoYXMgb25seSBkeW5hbWljIHRleHQgY2hpbGRyZW4uXHJcbiAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgJiAxIC8qIFRFWFQgKi8pIHtcclxuICAgICAgICAgICAgICAgIGlmIChuMS5jaGlsZHJlbiAhPT0gbjIuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBob3N0U2V0RWxlbWVudFRleHQoZWwsIG4yLmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghb3B0aW1pemVkICYmIGR5bmFtaWNDaGlsZHJlbiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIHVub3B0aW1pemVkLCBmdWxsIGRpZmZcclxuICAgICAgICAgICAgcGF0Y2hQcm9wcyhlbCwgbjIsIG9sZFByb3BzLCBuZXdQcm9wcywgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHZub2RlSG9vayA9IG5ld1Byb3BzLm9uVm5vZGVVcGRhdGVkKSB8fCBkaXJzKSB7XHJcbiAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZUhvb2sgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCBuMiwgbjEpO1xyXG4gICAgICAgICAgICAgICAgZGlycyAmJiBpbnZva2VEaXJlY3RpdmVIb29rKG4yLCBuMSwgcGFyZW50Q29tcG9uZW50LCAndXBkYXRlZCcpO1xyXG4gICAgICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFRoZSBmYXN0IHBhdGggZm9yIGJsb2Nrcy5cclxuICAgIGNvbnN0IHBhdGNoQmxvY2tDaGlsZHJlbiA9IChvbGRDaGlsZHJlbiwgbmV3Q2hpbGRyZW4sIGZhbGxiYWNrQ29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzKSA9PiB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBvbGRWTm9kZSA9IG9sZENoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdWTm9kZSA9IG5ld0NoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGNvbnRhaW5lciAocGFyZW50IGVsZW1lbnQpIGZvciB0aGUgcGF0Y2guXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IFxyXG4gICAgICAgICAgICAvLyBvbGRWTm9kZSBtYXkgYmUgYW4gZXJyb3JlZCBhc3luYyBzZXR1cCgpIGNvbXBvbmVudCBpbnNpZGUgU3VzcGVuc2VcclxuICAgICAgICAgICAgLy8gd2hpY2ggd2lsbCBub3QgaGF2ZSBhIG1vdW50ZWQgZWxlbWVudFxyXG4gICAgICAgICAgICBvbGRWTm9kZS5lbCAmJlxyXG4gICAgICAgICAgICAgICAgLy8gLSBJbiB0aGUgY2FzZSBvZiBhIEZyYWdtZW50LCB3ZSBuZWVkIHRvIHByb3ZpZGUgdGhlIGFjdHVhbCBwYXJlbnRcclxuICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBGcmFnbWVudCBpdHNlbGYgc28gaXQgY2FuIG1vdmUgaXRzIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICAgICAgKG9sZFZOb2RlLnR5cGUgPT09IEZyYWdtZW50IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gLSBJbiB0aGUgY2FzZSBvZiBkaWZmZXJlbnQgbm9kZXMsIHRoZXJlIGlzIGdvaW5nIHRvIGJlIGEgcmVwbGFjZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCBhbHNvIHJlcXVpcmVzIHRoZSBjb3JyZWN0IHBhcmVudCBjb250YWluZXJcclxuICAgICAgICAgICAgICAgICAgICAhaXNTYW1lVk5vZGVUeXBlKG9sZFZOb2RlLCBuZXdWTm9kZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAvLyAtIEluIHRoZSBjYXNlIG9mIGEgY29tcG9uZW50LCBpdCBjb3VsZCBjb250YWluIGFueXRoaW5nLlxyXG4gICAgICAgICAgICAgICAgICAgIG9sZFZOb2RlLnNoYXBlRmxhZyAmICg2IC8qIENPTVBPTkVOVCAqLyB8IDY0IC8qIFRFTEVQT1JUICovKSlcclxuICAgICAgICAgICAgICAgID8gaG9zdFBhcmVudE5vZGUob2xkVk5vZGUuZWwpXHJcbiAgICAgICAgICAgICAgICA6IC8vIEluIG90aGVyIGNhc2VzLCB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBub3QgYWN0dWFsbHkgdXNlZCBzbyB3ZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgcGFzcyB0aGUgYmxvY2sgZWxlbWVudCBoZXJlIHRvIGF2b2lkIGEgRE9NIHBhcmVudE5vZGUgY2FsbC5cclxuICAgICAgICAgICAgICAgICAgICBmYWxsYmFja0NvbnRhaW5lcjtcclxuICAgICAgICAgICAgcGF0Y2gob2xkVk5vZGUsIG5ld1ZOb2RlLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBwYXRjaFByb3BzID0gKGVsLCB2bm9kZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRykgPT4ge1xyXG4gICAgICAgIGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmV3UHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIC8vIGVtcHR5IHN0cmluZyBpcyBub3QgdmFsaWQgcHJvcFxyXG4gICAgICAgICAgICAgICAgaWYgKGlzUmVzZXJ2ZWRQcm9wKGtleSkpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gbmV3UHJvcHNba2V5XTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBvbGRQcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgLy8gZGVmZXIgcGF0Y2hpbmcgdmFsdWVcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9PSBwcmV2ICYmIGtleSAhPT0gJ3ZhbHVlJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIGtleSwgcHJldiwgbmV4dCwgaXNTVkcsIHZub2RlLmNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvbGRQcm9wcyAhPT0gRU1QVFlfT0JKKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvbGRQcm9wcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNSZXNlcnZlZFByb3Aoa2V5KSAmJiAhKGtleSBpbiBuZXdQcm9wcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwga2V5LCBvbGRQcm9wc1trZXldLCBudWxsLCBpc1NWRywgdm5vZGUuY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgndmFsdWUnIGluIG5ld1Byb3BzKSB7XHJcbiAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCAndmFsdWUnLCBvbGRQcm9wcy52YWx1ZSwgbmV3UHJvcHMudmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHByb2Nlc3NGcmFnbWVudCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBjb25zdCBmcmFnbWVudFN0YXJ0QW5jaG9yID0gKG4yLmVsID0gbjEgPyBuMS5lbCA6IGhvc3RDcmVhdGVUZXh0KCcnKSk7XHJcbiAgICAgICAgY29uc3QgZnJhZ21lbnRFbmRBbmNob3IgPSAobjIuYW5jaG9yID0gbjEgPyBuMS5hbmNob3IgOiBob3N0Q3JlYXRlVGV4dCgnJykpO1xyXG4gICAgICAgIGxldCB7IHBhdGNoRmxhZywgZHluYW1pY0NoaWxkcmVuLCBzbG90U2NvcGVJZHM6IGZyYWdtZW50U2xvdFNjb3BlSWRzIH0gPSBuMjtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGlzSG1yVXBkYXRpbmcpIHtcclxuICAgICAgICAgICAgLy8gSE1SIHVwZGF0ZWQsIGZvcmNlIGZ1bGwgZGlmZlxyXG4gICAgICAgICAgICBwYXRjaEZsYWcgPSAwO1xyXG4gICAgICAgICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBhIHNsb3QgZnJhZ21lbnQgd2l0aCA6c2xvdHRlZCBzY29wZSBpZHNcclxuICAgICAgICBpZiAoZnJhZ21lbnRTbG90U2NvcGVJZHMpIHtcclxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzXHJcbiAgICAgICAgICAgICAgICA/IHNsb3RTY29wZUlkcy5jb25jYXQoZnJhZ21lbnRTbG90U2NvcGVJZHMpXHJcbiAgICAgICAgICAgICAgICA6IGZyYWdtZW50U2xvdFNjb3BlSWRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBob3N0SW5zZXJ0KGZyYWdtZW50U3RhcnRBbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgaG9zdEluc2VydChmcmFnbWVudEVuZEFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICAvLyBhIGZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYXJyYXkgY2hpbGRyZW5cclxuICAgICAgICAgICAgLy8gc2luY2UgdGhleSBhcmUgZWl0aGVyIGdlbmVyYXRlZCBieSB0aGUgY29tcGlsZXIsIG9yIGltcGxpY2l0bHkgY3JlYXRlZFxyXG4gICAgICAgICAgICAvLyBmcm9tIGFycmF5cy5cclxuICAgICAgICAgICAgbW91bnRDaGlsZHJlbihuMi5jaGlsZHJlbiwgY29udGFpbmVyLCBmcmFnbWVudEVuZEFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgPiAwICYmXHJcbiAgICAgICAgICAgICAgICBwYXRjaEZsYWcgJiA2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi8gJiZcclxuICAgICAgICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbiAmJlxyXG4gICAgICAgICAgICAgICAgLy8gIzI3MTUgdGhlIHByZXZpb3VzIGZyYWdtZW50IGNvdWxkJ3ZlIGJlZW4gYSBCQUlMZWQgb25lIGFzIGEgcmVzdWx0XHJcbiAgICAgICAgICAgICAgICAvLyBvZiByZW5kZXJTbG90KCkgd2l0aCBubyB2YWxpZCBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgbjEuZHluYW1pY0NoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhIHN0YWJsZSBmcmFnbWVudCAodGVtcGxhdGUgcm9vdCBvciA8dGVtcGxhdGUgdi1mb3I+KSBkb2Vzbid0IG5lZWQgdG9cclxuICAgICAgICAgICAgICAgIC8vIHBhdGNoIGNoaWxkcmVuIG9yZGVyLCBidXQgaXQgbWF5IGNvbnRhaW4gZHluYW1pY0NoaWxkcmVuLlxyXG4gICAgICAgICAgICAgICAgcGF0Y2hCbG9ja0NoaWxkcmVuKG4xLmR5bmFtaWNDaGlsZHJlbiwgZHluYW1pY0NoaWxkcmVuLCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBwYXJlbnRDb21wb25lbnQgJiYgcGFyZW50Q29tcG9uZW50LnR5cGUuX19obXJJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFxyXG4gICAgICAgICAgICAgICAgLy8gIzIwODAgaWYgdGhlIHN0YWJsZSBmcmFnbWVudCBoYXMgYSBrZXksIGl0J3MgYSA8dGVtcGxhdGUgdi1mb3I+IHRoYXQgbWF5XHJcbiAgICAgICAgICAgICAgICAvLyAgZ2V0IG1vdmVkIGFyb3VuZC4gTWFrZSBzdXJlIGFsbCByb290IGxldmVsIHZub2RlcyBpbmhlcml0IGVsLlxyXG4gICAgICAgICAgICAgICAgLy8gIzIxMzQgb3IgaWYgaXQncyBhIGNvbXBvbmVudCByb290LCBpdCBtYXkgYWxzbyBnZXQgbW92ZWQgYXJvdW5kXHJcbiAgICAgICAgICAgICAgICAvLyBhcyB0aGUgY29tcG9uZW50IGlzIGJlaW5nIG1vdmVkLlxyXG4gICAgICAgICAgICAgICAgbjIua2V5ICE9IG51bGwgfHxcclxuICAgICAgICAgICAgICAgICAgICAocGFyZW50Q29tcG9uZW50ICYmIG4yID09PSBwYXJlbnRDb21wb25lbnQuc3ViVHJlZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMiwgdHJ1ZSAvKiBzaGFsbG93ICovKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGtleWVkIC8gdW5rZXllZCwgb3IgbWFudWFsIGZyYWdtZW50cy5cclxuICAgICAgICAgICAgICAgIC8vIGZvciBrZXllZCAmIHVua2V5ZWQsIHNpbmNlIHRoZXkgYXJlIGNvbXBpbGVyIGdlbmVyYXRlZCBmcm9tIHYtZm9yLFxyXG4gICAgICAgICAgICAgICAgLy8gZWFjaCBjaGlsZCBpcyBndWFyYW50ZWVkIHRvIGJlIGEgYmxvY2sgc28gdGhlIGZyYWdtZW50IHdpbGwgbmV2ZXJcclxuICAgICAgICAgICAgICAgIC8vIGhhdmUgZHluYW1pY0NoaWxkcmVuLlxyXG4gICAgICAgICAgICAgICAgcGF0Y2hDaGlsZHJlbihuMSwgbjIsIGNvbnRhaW5lciwgZnJhZ21lbnRFbmRBbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcHJvY2Vzc0NvbXBvbmVudCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBuMi5zbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHM7XHJcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKG4yLnNoYXBlRmxhZyAmIDUxMiAvKiBDT01QT05FTlRfS0VQVF9BTElWRSAqLykge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LmN0eC5hY3RpdmF0ZShuMiwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbW91bnRDb21wb25lbnQobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdXBkYXRlQ29tcG9uZW50KG4xLCBuMiwgb3B0aW1pemVkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbW91bnRDb21wb25lbnQgPSAoaW5pdGlhbFZOb2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gKGluaXRpYWxWTm9kZS5jb21wb25lbnQgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZShpbml0aWFsVk5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UpKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGluc3RhbmNlLnR5cGUuX19obXJJZCkge1xyXG4gICAgICAgICAgICByZWdpc3RlckhNUihpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KGluaXRpYWxWTm9kZSk7XHJcbiAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYG1vdW50YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluamVjdCByZW5kZXJlciBpbnRlcm5hbHMgZm9yIGtlZXBBbGl2ZVxyXG4gICAgICAgIGlmIChpc0tlZXBBbGl2ZShpbml0aWFsVk5vZGUpKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLmN0eC5yZW5kZXJlciA9IGludGVybmFscztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmVzb2x2ZSBwcm9wcyBhbmQgc2xvdHMgZm9yIHNldHVwIGNvbnRleHRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYGluaXRgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZXR1cENvbXBvbmVudChpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBpbml0YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc2V0dXAoKSBpcyBhc3luYy4gVGhpcyBjb21wb25lbnQgcmVsaWVzIG9uIGFzeW5jIGxvZ2ljIHRvIGJlIHJlc29sdmVkXHJcbiAgICAgICAgLy8gYmVmb3JlIHByb2NlZWRpbmdcclxuICAgICAgICBpZiAoaW5zdGFuY2UuYXN5bmNEZXApIHtcclxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UgJiYgcGFyZW50U3VzcGVuc2UucmVnaXN0ZXJEZXAoaW5zdGFuY2UsIHNldHVwUmVuZGVyRWZmZWN0KTtcclxuICAgICAgICAgICAgLy8gR2l2ZSBpdCBhIHBsYWNlaG9sZGVyIGlmIHRoaXMgaXMgbm90IGh5ZHJhdGlvblxyXG4gICAgICAgICAgICAvLyBUT0RPIGhhbmRsZSBzZWxmLWRlZmluZWQgZmFsbGJhY2tcclxuICAgICAgICAgICAgaWYgKCFpbml0aWFsVk5vZGUuZWwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gKGluc3RhbmNlLnN1YlRyZWUgPSBjcmVhdGVWTm9kZShDb21tZW50KSk7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzQ29tbWVudE5vZGUobnVsbCwgcGxhY2Vob2xkZXIsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldHVwUmVuZGVyRWZmZWN0KGluc3RhbmNlLCBpbml0aWFsVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xyXG4gICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgbW91bnRgKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgdXBkYXRlQ29tcG9uZW50ID0gKG4xLCBuMiwgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSAobjIuY29tcG9uZW50ID0gbjEuY29tcG9uZW50KTtcclxuICAgICAgICBpZiAoc2hvdWxkVXBkYXRlQ29tcG9uZW50KG4xLCBuMiwgb3B0aW1pemVkKSkge1xyXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UuYXN5bmNEZXAgJiZcclxuICAgICAgICAgICAgICAgICFpbnN0YW5jZS5hc3luY1Jlc29sdmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhc3luYyAmIHN0aWxsIHBlbmRpbmcgLSBqdXN0IHVwZGF0ZSBwcm9wcyBhbmQgc2xvdHNcclxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBjb21wb25lbnQncyByZWFjdGl2ZSBlZmZlY3QgZm9yIHJlbmRlciBpc24ndCBzZXQtdXAgeWV0XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KG4yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlcihpbnN0YW5jZSwgbjIsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIG5vcm1hbCB1cGRhdGVcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLm5leHQgPSBuMjtcclxuICAgICAgICAgICAgICAgIC8vIGluIGNhc2UgdGhlIGNoaWxkIGNvbXBvbmVudCBpcyBhbHNvIHF1ZXVlZCwgcmVtb3ZlIGl0IHRvIGF2b2lkXHJcbiAgICAgICAgICAgICAgICAvLyBkb3VibGUgdXBkYXRpbmcgdGhlIHNhbWUgY2hpbGQgY29tcG9uZW50IGluIHRoZSBzYW1lIGZsdXNoLlxyXG4gICAgICAgICAgICAgICAgaW52YWxpZGF0ZUpvYihpbnN0YW5jZS51cGRhdGUpO1xyXG4gICAgICAgICAgICAgICAgLy8gaW5zdGFuY2UudXBkYXRlIGlzIHRoZSByZWFjdGl2ZSBlZmZlY3QuXHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS51cGRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gbm8gdXBkYXRlIG5lZWRlZC4ganVzdCBjb3B5IG92ZXIgcHJvcGVydGllc1xyXG4gICAgICAgICAgICBuMi5jb21wb25lbnQgPSBuMS5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgIG4yLmVsID0gbjEuZWw7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLnZub2RlID0gbjI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHNldHVwUmVuZGVyRWZmZWN0ID0gKGluc3RhbmNlLCBpbml0aWFsVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNvbXBvbmVudFVwZGF0ZUZuID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWluc3RhbmNlLmlzTW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHZub2RlSG9vaztcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZWwsIHByb3BzIH0gPSBpbml0aWFsVk5vZGU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGJtLCBtLCBwYXJlbnQgfSA9IGluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaXNBc3luY1dyYXBwZXJWTm9kZSA9IGlzQXN5bmNXcmFwcGVyKGluaXRpYWxWTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBiZWZvcmVNb3VudCBob29rXHJcbiAgICAgICAgICAgICAgICBpZiAoYm0pIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VBcnJheUZucyhibSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBvblZub2RlQmVmb3JlTW91bnRcclxuICAgICAgICAgICAgICAgIGlmICghaXNBc3luY1dyYXBwZXJWTm9kZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBpbml0aWFsVk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwgJiYgaHlkcmF0ZU5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB2bm9kZSBoYXMgYWRvcHRlZCBob3N0IG5vZGUgLSBwZXJmb3JtIGh5ZHJhdGlvbiBpbnN0ZWFkIG9mIG1vdW50LlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGh5ZHJhdGVTdWJUcmVlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5zdWJUcmVlID0gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBoeWRyYXRlYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaHlkcmF0ZU5vZGUoZWwsIGluc3RhbmNlLnN1YlRyZWUsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBoeWRyYXRlYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FzeW5jV3JhcHBlclZOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxWTm9kZS50eXBlLl9fYXN5bmNMb2FkZXIoKS50aGVuKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3RlOiB3ZSBhcmUgbW92aW5nIHRoZSByZW5kZXIgY2FsbCBpbnRvIGFuIGFzeW5jIGNhbGxiYWNrLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCBtZWFucyBpdCB3b24ndCB0cmFjayBkZXBlbmRlbmNpZXMgLSBidXQgaXQncyBvayBiZWNhdXNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgc2VydmVyLXJlbmRlcmVkIGFzeW5jIHdyYXBwZXIgaXMgYWxyZWFkeSBpbiByZXNvbHZlZCBzdGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgaXQgd2lsbCBuZXZlciBuZWVkIHRvIGNoYW5nZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgKCkgPT4gIWluc3RhbmNlLmlzVW5tb3VudGVkICYmIGh5ZHJhdGVTdWJUcmVlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHlkcmF0ZVN1YlRyZWUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJUcmVlID0gKGluc3RhbmNlLnN1YlRyZWUgPSByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2gobnVsbCwgc3ViVHJlZSwgY29udGFpbmVyLCBhbmNob3IsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxWTm9kZS5lbCA9IHN1YlRyZWUuZWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBtb3VudGVkIGhvb2tcclxuICAgICAgICAgICAgICAgIGlmIChtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KG0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG9uVm5vZGVNb3VudGVkXHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXN5bmNXcmFwcGVyVk5vZGUgJiZcclxuICAgICAgICAgICAgICAgICAgICAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZU1vdW50ZWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NvcGVkSW5pdGlhbFZOb2RlID0gaW5pdGlhbFZOb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIHNjb3BlZEluaXRpYWxWTm9kZSksIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGFjdGl2YXRlZCBob29rIGZvciBrZWVwLWFsaXZlIHJvb3RzLlxyXG4gICAgICAgICAgICAgICAgLy8gIzE3NDIgYWN0aXZhdGVkIGhvb2sgbXVzdCBiZSBhY2Nlc3NlZCBhZnRlciBmaXJzdCByZW5kZXJcclxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBob29rIG1heSBiZSBpbmplY3RlZCBieSBhIGNoaWxkIGtlZXAtYWxpdmVcclxuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsVk5vZGUuc2hhcGVGbGFnICYgMjU2IC8qIENPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRSAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmEgJiYgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGluc3RhbmNlLmEsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmlzTW91bnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50QWRkZWQoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gIzI0NTg6IGRlZmVyZW5jZSBtb3VudC1vbmx5IG9iamVjdCBwYXJhbWV0ZXJzIHRvIHByZXZlbnQgbWVtbGVha3NcclxuICAgICAgICAgICAgICAgIGluaXRpYWxWTm9kZSA9IGNvbnRhaW5lciA9IGFuY2hvciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGVDb21wb25lbnRcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdHJpZ2dlcmVkIGJ5IG11dGF0aW9uIG9mIGNvbXBvbmVudCdzIG93biBzdGF0ZSAobmV4dDogbnVsbClcclxuICAgICAgICAgICAgICAgIC8vIE9SIHBhcmVudCBjYWxsaW5nIHByb2Nlc3NDb21wb25lbnQgKG5leHQ6IFZOb2RlKVxyXG4gICAgICAgICAgICAgICAgbGV0IHsgbmV4dCwgYnUsIHUsIHBhcmVudCwgdm5vZGUgfSA9IGluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgbGV0IG9yaWdpbk5leHQgPSBuZXh0O1xyXG4gICAgICAgICAgICAgICAgbGV0IHZub2RlSG9vaztcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQobmV4dCB8fCBpbnN0YW5jZS52bm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBEaXNhbGxvdyBjb21wb25lbnQgZWZmZWN0IHJlY3Vyc2lvbiBkdXJpbmcgcHJlLWxpZmVjeWNsZSBob29rcy5cclxuICAgICAgICAgICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5lbCA9IHZub2RlLmVsO1xyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlcihpbnN0YW5jZSwgbmV4dCwgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSB2bm9kZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGJlZm9yZVVwZGF0ZSBob29rXHJcbiAgICAgICAgICAgICAgICBpZiAoYnUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VBcnJheUZucyhidSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBvblZub2RlQmVmb3JlVXBkYXRlXHJcbiAgICAgICAgICAgICAgICBpZiAoKHZub2RlSG9vayA9IG5leHQucHJvcHMgJiYgbmV4dC5wcm9wcy5vblZub2RlQmVmb3JlVXBkYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgbmV4dCwgdm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAvLyByZW5kZXJcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRUcmVlID0gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldlRyZWUgPSBpbnN0YW5jZS5zdWJUcmVlO1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uuc3ViVHJlZSA9IG5leHRUcmVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwYXRjaChwcmV2VHJlZSwgbmV4dFRyZWUsIFxyXG4gICAgICAgICAgICAgICAgLy8gcGFyZW50IG1heSBoYXZlIGNoYW5nZWQgaWYgaXQncyBpbiBhIHRlbGVwb3J0XHJcbiAgICAgICAgICAgICAgICBob3N0UGFyZW50Tm9kZShwcmV2VHJlZS5lbCksIFxyXG4gICAgICAgICAgICAgICAgLy8gYW5jaG9yIG1heSBoYXZlIGNoYW5nZWQgaWYgaXQncyBpbiBhIGZyYWdtZW50XHJcbiAgICAgICAgICAgICAgICBnZXROZXh0SG9zdE5vZGUocHJldlRyZWUpLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5leHQuZWwgPSBuZXh0VHJlZS5lbDtcclxuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5OZXh0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VsZi10cmlnZ2VyZWQgdXBkYXRlLiBJbiBjYXNlIG9mIEhPQywgdXBkYXRlIHBhcmVudCBjb21wb25lbnRcclxuICAgICAgICAgICAgICAgICAgICAvLyB2bm9kZSBlbC4gSE9DIGlzIGluZGljYXRlZCBieSBwYXJlbnQgaW5zdGFuY2UncyBzdWJUcmVlIHBvaW50aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gY2hpbGQgY29tcG9uZW50J3Mgdm5vZGVcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVIT0NIb3N0RWwoaW5zdGFuY2UsIG5leHRUcmVlLmVsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZWQgaG9va1xyXG4gICAgICAgICAgICAgICAgaWYgKHUpIHtcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QodSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb25Wbm9kZVVwZGF0ZWRcclxuICAgICAgICAgICAgICAgIGlmICgodm5vZGVIb29rID0gbmV4dC5wcm9wcyAmJiBuZXh0LnByb3BzLm9uVm5vZGVVcGRhdGVkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIG5leHQsIHZub2RlKSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudFVwZGF0ZWQoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIGNyZWF0ZSByZWFjdGl2ZSBlZmZlY3QgZm9yIHJlbmRlcmluZ1xyXG4gICAgICAgIGNvbnN0IGVmZmVjdCA9IChpbnN0YW5jZS5lZmZlY3QgPSBuZXcgUmVhY3RpdmVFZmZlY3QoY29tcG9uZW50VXBkYXRlRm4sICgpID0+IHF1ZXVlSm9iKGluc3RhbmNlLnVwZGF0ZSksIGluc3RhbmNlLnNjb3BlIC8vIHRyYWNrIGl0IGluIGNvbXBvbmVudCdzIGVmZmVjdCBzY29wZVxyXG4gICAgICAgICkpO1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZSA9IChpbnN0YW5jZS51cGRhdGUgPSBlZmZlY3QucnVuLmJpbmQoZWZmZWN0KSk7XHJcbiAgICAgICAgdXBkYXRlLmlkID0gaW5zdGFuY2UudWlkO1xyXG4gICAgICAgIC8vIGFsbG93UmVjdXJzZVxyXG4gICAgICAgIC8vICMxODAxLCAjMjA0MyBjb21wb25lbnQgcmVuZGVyIGVmZmVjdHMgc2hvdWxkIGFsbG93IHJlY3Vyc2l2ZSB1cGRhdGVzXHJcbiAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgdHJ1ZSk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBlZmZlY3Qub25UcmFjayA9IGluc3RhbmNlLnJ0Y1xyXG4gICAgICAgICAgICAgICAgPyBlID0+IGludm9rZUFycmF5Rm5zKGluc3RhbmNlLnJ0YywgZSlcclxuICAgICAgICAgICAgICAgIDogdm9pZCAwO1xyXG4gICAgICAgICAgICBlZmZlY3Qub25UcmlnZ2VyID0gaW5zdGFuY2UucnRnXHJcbiAgICAgICAgICAgICAgICA/IGUgPT4gaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UucnRnLCBlKVxyXG4gICAgICAgICAgICAgICAgOiB2b2lkIDA7XHJcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgKGZvciBzY2hlZHVsZXIpXHJcbiAgICAgICAgICAgIHVwZGF0ZS5vd25lckluc3RhbmNlID0gaW5zdGFuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlciA9IChpbnN0YW5jZSwgbmV4dFZOb2RlLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBuZXh0Vk5vZGUuY29tcG9uZW50ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgY29uc3QgcHJldlByb3BzID0gaW5zdGFuY2Uudm5vZGUucHJvcHM7XHJcbiAgICAgICAgaW5zdGFuY2Uudm5vZGUgPSBuZXh0Vk5vZGU7XHJcbiAgICAgICAgaW5zdGFuY2UubmV4dCA9IG51bGw7XHJcbiAgICAgICAgdXBkYXRlUHJvcHMoaW5zdGFuY2UsIG5leHRWTm9kZS5wcm9wcywgcHJldlByb3BzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIHVwZGF0ZVNsb3RzKGluc3RhbmNlLCBuZXh0Vk5vZGUuY2hpbGRyZW4sIG9wdGltaXplZCk7XHJcbiAgICAgICAgcGF1c2VUcmFja2luZygpO1xyXG4gICAgICAgIC8vIHByb3BzIHVwZGF0ZSBtYXkgaGF2ZSB0cmlnZ2VyZWQgcHJlLWZsdXNoIHdhdGNoZXJzLlxyXG4gICAgICAgIC8vIGZsdXNoIHRoZW0gYmVmb3JlIHRoZSByZW5kZXIgdXBkYXRlLlxyXG4gICAgICAgIGZsdXNoUHJlRmx1c2hDYnModW5kZWZpbmVkLCBpbnN0YW5jZS51cGRhdGUpO1xyXG4gICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBwYXRjaENoaWxkcmVuID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCA9IGZhbHNlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgYzEgPSBuMSAmJiBuMS5jaGlsZHJlbjtcclxuICAgICAgICBjb25zdCBwcmV2U2hhcGVGbGFnID0gbjEgPyBuMS5zaGFwZUZsYWcgOiAwO1xyXG4gICAgICAgIGNvbnN0IGMyID0gbjIuY2hpbGRyZW47XHJcbiAgICAgICAgY29uc3QgeyBwYXRjaEZsYWcsIHNoYXBlRmxhZyB9ID0gbjI7XHJcbiAgICAgICAgLy8gZmFzdCBwYXRoXHJcbiAgICAgICAgaWYgKHBhdGNoRmxhZyA+IDApIHtcclxuICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDEyOCAvKiBLRVlFRF9GUkFHTUVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjb3VsZCBiZSBlaXRoZXIgZnVsbHkta2V5ZWQgb3IgbWl4ZWQgKHNvbWUga2V5ZWQgc29tZSBub3QpXHJcbiAgICAgICAgICAgICAgICAvLyBwcmVzZW5jZSBvZiBwYXRjaEZsYWcgbWVhbnMgY2hpbGRyZW4gYXJlIGd1YXJhbnRlZWQgdG8gYmUgYXJyYXlzXHJcbiAgICAgICAgICAgICAgICBwYXRjaEtleWVkQ2hpbGRyZW4oYzEsIGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwYXRjaEZsYWcgJiAyNTYgLyogVU5LRVlFRF9GUkFHTUVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgLy8gdW5rZXllZFxyXG4gICAgICAgICAgICAgICAgcGF0Y2hVbmtleWVkQ2hpbGRyZW4oYzEsIGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjaGlsZHJlbiBoYXMgMyBwb3NzaWJpbGl0aWVzOiB0ZXh0LCBhcnJheSBvciBubyBjaGlsZHJlbi5cclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgOCAvKiBURVhUX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgIC8vIHRleHQgY2hpbGRyZW4gZmFzdCBwYXRoXHJcbiAgICAgICAgICAgIGlmIChwcmV2U2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgIHVubW91bnRDaGlsZHJlbihjMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGMyICE9PSBjMSkge1xyXG4gICAgICAgICAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGNvbnRhaW5lciwgYzIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBwcmV2IGNoaWxkcmVuIHdhcyBhcnJheVxyXG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdHdvIGFycmF5cywgY2Fubm90IGFzc3VtZSBhbnl0aGluZywgZG8gZnVsbCBkaWZmXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hLZXllZENoaWxkcmVuKGMxLCBjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBubyBuZXcgY2hpbGRyZW4sIGp1c3QgdW5tb3VudCBvbGRcclxuICAgICAgICAgICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oYzEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gcHJldiBjaGlsZHJlbiB3YXMgdGV4dCBPUiBudWxsXHJcbiAgICAgICAgICAgICAgICAvLyBuZXcgY2hpbGRyZW4gaXMgYXJyYXkgT1IgbnVsbFxyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZTaGFwZUZsYWcgJiA4IC8qIFRFWFRfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBob3N0U2V0RWxlbWVudFRleHQoY29udGFpbmVyLCAnJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBtb3VudCBuZXcgaWYgYXJyYXlcclxuICAgICAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIG1vdW50Q2hpbGRyZW4oYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHBhdGNoVW5rZXllZENoaWxkcmVuID0gKGMxLCBjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGMxID0gYzEgfHwgRU1QVFlfQVJSO1xyXG4gICAgICAgIGMyID0gYzIgfHwgRU1QVFlfQVJSO1xyXG4gICAgICAgIGNvbnN0IG9sZExlbmd0aCA9IGMxLmxlbmd0aDtcclxuICAgICAgICBjb25zdCBuZXdMZW5ndGggPSBjMi5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgY29tbW9uTGVuZ3RoID0gTWF0aC5taW4ob2xkTGVuZ3RoLCBuZXdMZW5ndGgpO1xyXG4gICAgICAgIGxldCBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb21tb25MZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBuZXh0Q2hpbGQgPSAoYzJbaV0gPSBvcHRpbWl6ZWRcclxuICAgICAgICAgICAgICAgID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pXHJcbiAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKSk7XHJcbiAgICAgICAgICAgIHBhdGNoKGMxW2ldLCBuZXh0Q2hpbGQsIGNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9sZExlbmd0aCA+IG5ld0xlbmd0aCkge1xyXG4gICAgICAgICAgICAvLyByZW1vdmUgb2xkXHJcbiAgICAgICAgICAgIHVubW91bnRDaGlsZHJlbihjMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSwgZmFsc2UsIGNvbW1vbkxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBtb3VudCBuZXdcclxuICAgICAgICAgICAgbW91bnRDaGlsZHJlbihjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgY29tbW9uTGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gY2FuIGJlIGFsbC1rZXllZCBvciBtaXhlZFxyXG4gICAgY29uc3QgcGF0Y2hLZXllZENoaWxkcmVuID0gKGMxLCBjMiwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICBjb25zdCBsMiA9IGMyLmxlbmd0aDtcclxuICAgICAgICBsZXQgZTEgPSBjMS5sZW5ndGggLSAxOyAvLyBwcmV2IGVuZGluZyBpbmRleFxyXG4gICAgICAgIGxldCBlMiA9IGwyIC0gMTsgLy8gbmV4dCBlbmRpbmcgaW5kZXhcclxuICAgICAgICAvLyAxLiBzeW5jIGZyb20gc3RhcnRcclxuICAgICAgICAvLyAoYSBiKSBjXHJcbiAgICAgICAgLy8gKGEgYikgZCBlXHJcbiAgICAgICAgd2hpbGUgKGkgPD0gZTEgJiYgaSA8PSBlMikge1xyXG4gICAgICAgICAgICBjb25zdCBuMSA9IGMxW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBuMiA9IChjMltpXSA9IG9wdGltaXplZFxyXG4gICAgICAgICAgICAgICAgPyBjbG9uZUlmTW91bnRlZChjMltpXSlcclxuICAgICAgICAgICAgICAgIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pKTtcclxuICAgICAgICAgICAgaWYgKGlzU2FtZVZOb2RlVHlwZShuMSwgbjIpKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRjaChuMSwgbjIsIGNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gMi4gc3luYyBmcm9tIGVuZFxyXG4gICAgICAgIC8vIGEgKGIgYylcclxuICAgICAgICAvLyBkIGUgKGIgYylcclxuICAgICAgICB3aGlsZSAoaSA8PSBlMSAmJiBpIDw9IGUyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG4xID0gYzFbZTFdO1xyXG4gICAgICAgICAgICBjb25zdCBuMiA9IChjMltlMl0gPSBvcHRpbWl6ZWRcclxuICAgICAgICAgICAgICAgID8gY2xvbmVJZk1vdW50ZWQoYzJbZTJdKVxyXG4gICAgICAgICAgICAgICAgOiBub3JtYWxpemVWTm9kZShjMltlMl0pKTtcclxuICAgICAgICAgICAgaWYgKGlzU2FtZVZOb2RlVHlwZShuMSwgbjIpKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRjaChuMSwgbjIsIGNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGUxLS07XHJcbiAgICAgICAgICAgIGUyLS07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDMuIGNvbW1vbiBzZXF1ZW5jZSArIG1vdW50XHJcbiAgICAgICAgLy8gKGEgYilcclxuICAgICAgICAvLyAoYSBiKSBjXHJcbiAgICAgICAgLy8gaSA9IDIsIGUxID0gMSwgZTIgPSAyXHJcbiAgICAgICAgLy8gKGEgYilcclxuICAgICAgICAvLyBjIChhIGIpXHJcbiAgICAgICAgLy8gaSA9IDAsIGUxID0gLTEsIGUyID0gMFxyXG4gICAgICAgIGlmIChpID4gZTEpIHtcclxuICAgICAgICAgICAgaWYgKGkgPD0gZTIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRQb3MgPSBlMiArIDE7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhbmNob3IgPSBuZXh0UG9zIDwgbDIgPyBjMltuZXh0UG9zXS5lbCA6IHBhcmVudEFuY2hvcjtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChpIDw9IGUyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2gobnVsbCwgKGMyW2ldID0gb3B0aW1pemVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pKSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDQuIGNvbW1vbiBzZXF1ZW5jZSArIHVubW91bnRcclxuICAgICAgICAvLyAoYSBiKSBjXHJcbiAgICAgICAgLy8gKGEgYilcclxuICAgICAgICAvLyBpID0gMiwgZTEgPSAyLCBlMiA9IDFcclxuICAgICAgICAvLyBhIChiIGMpXHJcbiAgICAgICAgLy8gKGIgYylcclxuICAgICAgICAvLyBpID0gMCwgZTEgPSAwLCBlMiA9IC0xXHJcbiAgICAgICAgZWxzZSBpZiAoaSA+IGUyKSB7XHJcbiAgICAgICAgICAgIHdoaWxlIChpIDw9IGUxKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KGMxW2ldLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA1LiB1bmtub3duIHNlcXVlbmNlXHJcbiAgICAgICAgLy8gW2kgLi4uIGUxICsgMV06IGEgYiBbYyBkIGVdIGYgZ1xyXG4gICAgICAgIC8vIFtpIC4uLiBlMiArIDFdOiBhIGIgW2UgZCBjIGhdIGYgZ1xyXG4gICAgICAgIC8vIGkgPSAyLCBlMSA9IDQsIGUyID0gNVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBzMSA9IGk7IC8vIHByZXYgc3RhcnRpbmcgaW5kZXhcclxuICAgICAgICAgICAgY29uc3QgczIgPSBpOyAvLyBuZXh0IHN0YXJ0aW5nIGluZGV4XHJcbiAgICAgICAgICAgIC8vIDUuMSBidWlsZCBrZXk6aW5kZXggbWFwIGZvciBuZXdDaGlsZHJlblxyXG4gICAgICAgICAgICBjb25zdCBrZXlUb05ld0luZGV4TWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSBzMjsgaSA8PSBlMjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q2hpbGQgPSAoYzJbaV0gPSBvcHRpbWl6ZWRcclxuICAgICAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGMyW2ldKVxyXG4gICAgICAgICAgICAgICAgICAgIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pKTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hpbGQua2V5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGtleVRvTmV3SW5kZXhNYXAuaGFzKG5leHRDaGlsZC5rZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYER1cGxpY2F0ZSBrZXlzIGZvdW5kIGR1cmluZyB1cGRhdGU6YCwgSlNPTi5zdHJpbmdpZnkobmV4dENoaWxkLmtleSksIGBNYWtlIHN1cmUga2V5cyBhcmUgdW5pcXVlLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBrZXlUb05ld0luZGV4TWFwLnNldChuZXh0Q2hpbGQua2V5LCBpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyA1LjIgbG9vcCB0aHJvdWdoIG9sZCBjaGlsZHJlbiBsZWZ0IHRvIGJlIHBhdGNoZWQgYW5kIHRyeSB0byBwYXRjaFxyXG4gICAgICAgICAgICAvLyBtYXRjaGluZyBub2RlcyAmIHJlbW92ZSBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudFxyXG4gICAgICAgICAgICBsZXQgajtcclxuICAgICAgICAgICAgbGV0IHBhdGNoZWQgPSAwO1xyXG4gICAgICAgICAgICBjb25zdCB0b0JlUGF0Y2hlZCA9IGUyIC0gczIgKyAxO1xyXG4gICAgICAgICAgICBsZXQgbW92ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgLy8gdXNlZCB0byB0cmFjayB3aGV0aGVyIGFueSBub2RlIGhhcyBtb3ZlZFxyXG4gICAgICAgICAgICBsZXQgbWF4TmV3SW5kZXhTb0ZhciA9IDA7XHJcbiAgICAgICAgICAgIC8vIHdvcmtzIGFzIE1hcDxuZXdJbmRleCwgb2xkSW5kZXg+XHJcbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBvbGRJbmRleCBpcyBvZmZzZXQgYnkgKzFcclxuICAgICAgICAgICAgLy8gYW5kIG9sZEluZGV4ID0gMCBpcyBhIHNwZWNpYWwgdmFsdWUgaW5kaWNhdGluZyB0aGUgbmV3IG5vZGUgaGFzXHJcbiAgICAgICAgICAgIC8vIG5vIGNvcnJlc3BvbmRpbmcgb2xkIG5vZGUuXHJcbiAgICAgICAgICAgIC8vIHVzZWQgZm9yIGRldGVybWluaW5nIGxvbmdlc3Qgc3RhYmxlIHN1YnNlcXVlbmNlXHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0luZGV4VG9PbGRJbmRleE1hcCA9IG5ldyBBcnJheSh0b0JlUGF0Y2hlZCk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b0JlUGF0Y2hlZDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgbmV3SW5kZXhUb09sZEluZGV4TWFwW2ldID0gMDtcclxuICAgICAgICAgICAgZm9yIChpID0gczE7IGkgPD0gZTE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkNoaWxkID0gYzFbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAocGF0Y2hlZCA+PSB0b0JlUGF0Y2hlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbCBuZXcgY2hpbGRyZW4gaGF2ZSBiZWVuIHBhdGNoZWQgc28gdGhpcyBjYW4gb25seSBiZSBhIHJlbW92YWxcclxuICAgICAgICAgICAgICAgICAgICB1bm1vdW50KHByZXZDaGlsZCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3SW5kZXg7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldkNoaWxkLmtleSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3SW5kZXggPSBrZXlUb05ld0luZGV4TWFwLmdldChwcmV2Q2hpbGQua2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGtleS1sZXNzIG5vZGUsIHRyeSB0byBsb2NhdGUgYSBrZXktbGVzcyBub2RlIG9mIHRoZSBzYW1lIHR5cGVcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSBzMjsgaiA8PSBlMjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdJbmRleFRvT2xkSW5kZXhNYXBbaiAtIHMyXSA9PT0gMCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTYW1lVk5vZGVUeXBlKHByZXZDaGlsZCwgYzJbal0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdJbmRleCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChuZXdJbmRleCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5tb3VudChwcmV2Q2hpbGQsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3SW5kZXhUb09sZEluZGV4TWFwW25ld0luZGV4IC0gczJdID0gaSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0luZGV4ID49IG1heE5ld0luZGV4U29GYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4TmV3SW5kZXhTb0ZhciA9IG5ld0luZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwYXRjaChwcmV2Q2hpbGQsIGMyW25ld0luZGV4XSwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoZWQrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyA1LjMgbW92ZSBhbmQgbW91bnRcclxuICAgICAgICAgICAgLy8gZ2VuZXJhdGUgbG9uZ2VzdCBzdGFibGUgc3Vic2VxdWVuY2Ugb25seSB3aGVuIG5vZGVzIGhhdmUgbW92ZWRcclxuICAgICAgICAgICAgY29uc3QgaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2UgPSBtb3ZlZFxyXG4gICAgICAgICAgICAgICAgPyBnZXRTZXF1ZW5jZShuZXdJbmRleFRvT2xkSW5kZXhNYXApXHJcbiAgICAgICAgICAgICAgICA6IEVNUFRZX0FSUjtcclxuICAgICAgICAgICAgaiA9IGluY3JlYXNpbmdOZXdJbmRleFNlcXVlbmNlLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgIC8vIGxvb3BpbmcgYmFja3dhcmRzIHNvIHRoYXQgd2UgY2FuIHVzZSBsYXN0IHBhdGNoZWQgbm9kZSBhcyBhbmNob3JcclxuICAgICAgICAgICAgZm9yIChpID0gdG9CZVBhdGNoZWQgLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gczIgKyBpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoaWxkID0gYzJbbmV4dEluZGV4XTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IG5leHRJbmRleCArIDEgPCBsMiA/IGMyW25leHRJbmRleCArIDFdLmVsIDogcGFyZW50QW5jaG9yO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld0luZGV4VG9PbGRJbmRleE1hcFtpXSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdW50IG5ld1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIG5leHRDaGlsZCwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtb3ZlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgaWY6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gc3RhYmxlIHN1YnNlcXVlbmNlIChlLmcuIGEgcmV2ZXJzZSlcclxuICAgICAgICAgICAgICAgICAgICAvLyBPUiBjdXJyZW50IG5vZGUgaXMgbm90IGFtb25nIHRoZSBzdGFibGUgc2VxdWVuY2VcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaiA8IDAgfHwgaSAhPT0gaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2Vbal0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZShuZXh0Q2hpbGQsIGNvbnRhaW5lciwgYW5jaG9yLCAyIC8qIFJFT1JERVIgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgai0tO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBtb3ZlID0gKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUsIHBhcmVudFN1c3BlbnNlID0gbnVsbCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgZWwsIHR5cGUsIHRyYW5zaXRpb24sIGNoaWxkcmVuLCBzaGFwZUZsYWcgfSA9IHZub2RlO1xyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLykge1xyXG4gICAgICAgICAgICBtb3ZlKHZub2RlLmNvbXBvbmVudC5zdWJUcmVlLCBjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICAgICAgdm5vZGUuc3VzcGVuc2UubW92ZShjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiA2NCAvKiBURUxFUE9SVCAqLykge1xyXG4gICAgICAgICAgICB0eXBlLm1vdmUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBpbnRlcm5hbHMpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlID09PSBGcmFnbWVudCkge1xyXG4gICAgICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIG1vdmUoY2hpbGRyZW5baV0sIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaG9zdEluc2VydCh2bm9kZS5hbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZSA9PT0gU3RhdGljKSB7XHJcbiAgICAgICAgICAgIG1vdmVTdGF0aWNOb2RlKHZub2RlLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc2luZ2xlIG5vZGVzXHJcbiAgICAgICAgY29uc3QgbmVlZFRyYW5zaXRpb24gPSBtb3ZlVHlwZSAhPT0gMiAvKiBSRU9SREVSICovICYmXHJcbiAgICAgICAgICAgIHNoYXBlRmxhZyAmIDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgICAgICB0cmFuc2l0aW9uO1xyXG4gICAgICAgIGlmIChuZWVkVHJhbnNpdGlvbikge1xyXG4gICAgICAgICAgICBpZiAobW92ZVR5cGUgPT09IDAgLyogRU5URVIgKi8pIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xyXG4gICAgICAgICAgICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHRyYW5zaXRpb24uZW50ZXIoZWwpLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGxlYXZlLCBkZWxheUxlYXZlLCBhZnRlckxlYXZlIH0gPSB0cmFuc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVtb3ZlID0gKCkgPT4gaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGVyZm9ybUxlYXZlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlYXZlKGVsLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVsYXlMZWF2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5TGVhdmUoZWwsIHJlbW92ZSwgcGVyZm9ybUxlYXZlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBlcmZvcm1MZWF2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHVubW91bnQgPSAodm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlID0gZmFsc2UsIG9wdGltaXplZCA9IGZhbHNlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB0eXBlLCBwcm9wcywgcmVmLCBjaGlsZHJlbiwgZHluYW1pY0NoaWxkcmVuLCBzaGFwZUZsYWcsIHBhdGNoRmxhZywgZGlycyB9ID0gdm5vZGU7XHJcbiAgICAgICAgLy8gdW5zZXQgcmVmXHJcbiAgICAgICAgaWYgKHJlZiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHNldFJlZihyZWYsIG51bGwsIHBhcmVudFN1c3BlbnNlLCB2bm9kZSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAyNTYgLyogQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFICovKSB7XHJcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudC5jdHguZGVhY3RpdmF0ZSh2bm9kZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2hvdWxkSW52b2tlRGlycyA9IHNoYXBlRmxhZyAmIDEgLyogRUxFTUVOVCAqLyAmJiBkaXJzO1xyXG4gICAgICAgIGNvbnN0IHNob3VsZEludm9rZVZub2RlSG9vayA9ICFpc0FzeW5jV3JhcHBlcih2bm9kZSk7XHJcbiAgICAgICAgbGV0IHZub2RlSG9vaztcclxuICAgICAgICBpZiAoc2hvdWxkSW52b2tlVm5vZGVIb29rICYmXHJcbiAgICAgICAgICAgICh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlQmVmb3JlVW5tb3VudCkpIHtcclxuICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLykge1xyXG4gICAgICAgICAgICB1bm1vdW50Q29tcG9uZW50KHZub2RlLmNvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICAgICAgICAgIHZub2RlLnN1c3BlbnNlLnVubW91bnQocGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc2hvdWxkSW52b2tlRGlycykge1xyXG4gICAgICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnYmVmb3JlVW5tb3VudCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiA2NCAvKiBURUxFUE9SVCAqLykge1xyXG4gICAgICAgICAgICAgICAgdm5vZGUudHlwZS5yZW1vdmUodm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG9wdGltaXplZCwgaW50ZXJuYWxzLCBkb1JlbW92ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZHluYW1pY0NoaWxkcmVuICYmXHJcbiAgICAgICAgICAgICAgICAvLyAjMTE1MzogZmFzdCBwYXRoIHNob3VsZCBub3QgYmUgdGFrZW4gZm9yIG5vbi1zdGFibGUgKHYtZm9yKSBmcmFnbWVudHNcclxuICAgICAgICAgICAgICAgICh0eXBlICE9PSBGcmFnbWVudCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChwYXRjaEZsYWcgPiAwICYmIHBhdGNoRmxhZyAmIDY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqLykpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBmYXN0IHBhdGggZm9yIGJsb2NrIG5vZGVzOiBvbmx5IG5lZWQgdG8gdW5tb3VudCBkeW5hbWljIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuKGR5bmFtaWNDaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZmFsc2UsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCh0eXBlID09PSBGcmFnbWVudCAmJlxyXG4gICAgICAgICAgICAgICAgcGF0Y2hGbGFnICZcclxuICAgICAgICAgICAgICAgICAgICAoMTI4IC8qIEtFWUVEX0ZSQUdNRU5UICovIHwgMjU2IC8qIFVOS0VZRURfRlJBR01FTlQgKi8pKSB8fFxyXG4gICAgICAgICAgICAgICAgKCFvcHRpbWl6ZWQgJiYgc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkb1JlbW92ZSkge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlKHZub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHNob3VsZEludm9rZVZub2RlSG9vayAmJlxyXG4gICAgICAgICAgICAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZVVubW91bnRlZCkpIHx8XHJcbiAgICAgICAgICAgIHNob3VsZEludm9rZURpcnMpIHtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgIHNob3VsZEludm9rZURpcnMgJiZcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICd1bm1vdW50ZWQnKTtcclxuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCByZW1vdmUgPSB2bm9kZSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB0eXBlLCBlbCwgYW5jaG9yLCB0cmFuc2l0aW9uIH0gPSB2bm9kZTtcclxuICAgICAgICBpZiAodHlwZSA9PT0gRnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgcmVtb3ZlRnJhZ21lbnQoZWwsIGFuY2hvcik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IFN0YXRpYykge1xyXG4gICAgICAgICAgICByZW1vdmVTdGF0aWNOb2RlKHZub2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwZXJmb3JtUmVtb3ZlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBob3N0UmVtb3ZlKGVsKTtcclxuICAgICAgICAgICAgaWYgKHRyYW5zaXRpb24gJiYgIXRyYW5zaXRpb24ucGVyc2lzdGVkICYmIHRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSkge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5hZnRlckxlYXZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAgICAgdHJhbnNpdGlvbiAmJlxyXG4gICAgICAgICAgICAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBsZWF2ZSwgZGVsYXlMZWF2ZSB9ID0gdHJhbnNpdGlvbjtcclxuICAgICAgICAgICAgY29uc3QgcGVyZm9ybUxlYXZlID0gKCkgPT4gbGVhdmUoZWwsIHBlcmZvcm1SZW1vdmUpO1xyXG4gICAgICAgICAgICBpZiAoZGVsYXlMZWF2ZSkge1xyXG4gICAgICAgICAgICAgICAgZGVsYXlMZWF2ZSh2bm9kZS5lbCwgcGVyZm9ybVJlbW92ZSwgcGVyZm9ybUxlYXZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBlcmZvcm1MZWF2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwZXJmb3JtUmVtb3ZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlbW92ZUZyYWdtZW50ID0gKGN1ciwgZW5kKSA9PiB7XHJcbiAgICAgICAgLy8gRm9yIGZyYWdtZW50cywgZGlyZWN0bHkgcmVtb3ZlIGFsbCBjb250YWluZWQgRE9NIG5vZGVzLlxyXG4gICAgICAgIC8vIChmcmFnbWVudCBjaGlsZCBub2RlcyBjYW5ub3QgaGF2ZSB0cmFuc2l0aW9uKVxyXG4gICAgICAgIGxldCBuZXh0O1xyXG4gICAgICAgIHdoaWxlIChjdXIgIT09IGVuZCkge1xyXG4gICAgICAgICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGN1cik7XHJcbiAgICAgICAgICAgIGhvc3RSZW1vdmUoY3VyKTtcclxuICAgICAgICAgICAgY3VyID0gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaG9zdFJlbW92ZShlbmQpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHVubW91bnRDb21wb25lbnQgPSAoaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSkgPT4ge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaW5zdGFuY2UudHlwZS5fX2htcklkKSB7XHJcbiAgICAgICAgICAgIHVucmVnaXN0ZXJITVIoaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IGJ1bSwgc2NvcGUsIHVwZGF0ZSwgc3ViVHJlZSwgdW0gfSA9IGluc3RhbmNlO1xyXG4gICAgICAgIC8vIGJlZm9yZVVubW91bnQgaG9va1xyXG4gICAgICAgIGlmIChidW0pIHtcclxuICAgICAgICAgICAgaW52b2tlQXJyYXlGbnMoYnVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc3RvcCBlZmZlY3RzIGluIGNvbXBvbmVudCBzY29wZVxyXG4gICAgICAgIHNjb3BlLnN0b3AoKTtcclxuICAgICAgICAvLyB1cGRhdGUgbWF5IGJlIG51bGwgaWYgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGJlZm9yZSBpdHMgYXN5bmNcclxuICAgICAgICAvLyBzZXR1cCBoYXMgcmVzb2x2ZWQuXHJcbiAgICAgICAgaWYgKHVwZGF0ZSkge1xyXG4gICAgICAgICAgICAvLyBzbyB0aGF0IHNjaGVkdWxlciB3aWxsIG5vIGxvbmdlciBpbnZva2UgaXRcclxuICAgICAgICAgICAgdXBkYXRlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB1bm1vdW50KHN1YlRyZWUsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB1bm1vdW50ZWQgaG9va1xyXG4gICAgICAgIGlmICh1bSkge1xyXG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QodW0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgaW5zdGFuY2UuaXNVbm1vdW50ZWQgPSB0cnVlO1xyXG4gICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAvLyBBIGNvbXBvbmVudCB3aXRoIGFzeW5jIGRlcCBpbnNpZGUgYSBwZW5kaW5nIHN1c3BlbnNlIGlzIHVubW91bnRlZCBiZWZvcmVcclxuICAgICAgICAvLyBpdHMgYXN5bmMgZGVwIHJlc29sdmVzLiBUaGlzIHNob3VsZCByZW1vdmUgdGhlIGRlcCBmcm9tIHRoZSBzdXNwZW5zZSwgYW5kXHJcbiAgICAgICAgLy8gY2F1c2UgdGhlIHN1c3BlbnNlIHRvIHJlc29sdmUgaW1tZWRpYXRlbHkgaWYgdGhhdCB3YXMgdGhlIGxhc3QgZGVwLlxyXG4gICAgICAgIGlmIChwYXJlbnRTdXNwZW5zZSAmJlxyXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nQnJhbmNoICYmXHJcbiAgICAgICAgICAgICFwYXJlbnRTdXNwZW5zZS5pc1VubW91bnRlZCAmJlxyXG4gICAgICAgICAgICBpbnN0YW5jZS5hc3luY0RlcCAmJlxyXG4gICAgICAgICAgICAhaW5zdGFuY2UuYXN5bmNSZXNvbHZlZCAmJlxyXG4gICAgICAgICAgICBpbnN0YW5jZS5zdXNwZW5zZUlkID09PSBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nSWQpIHtcclxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UuZGVwcy0tO1xyXG4gICAgICAgICAgICBpZiAocGFyZW50U3VzcGVuc2UuZGVwcyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50UmVtb3ZlZChpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHVubW91bnRDaGlsZHJlbiA9IChjaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUgPSBmYWxzZSwgb3B0aW1pemVkID0gZmFsc2UsIHN0YXJ0ID0gMCkgPT4ge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHVubW91bnQoY2hpbGRyZW5baV0sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBnZXROZXh0SG9zdE5vZGUgPSB2bm9kZSA9PiB7XHJcbiAgICAgICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXROZXh0SG9zdE5vZGUodm5vZGUuY29tcG9uZW50LnN1YlRyZWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2bm9kZS5zdXNwZW5zZS5uZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBob3N0TmV4dFNpYmxpbmcoKHZub2RlLmFuY2hvciB8fCB2bm9kZS5lbCkpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlbmRlciA9ICh2bm9kZSwgY29udGFpbmVyLCBpc1NWRykgPT4ge1xyXG4gICAgICAgIGlmICh2bm9kZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChjb250YWluZXIuX3Zub2RlKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KGNvbnRhaW5lci5fdm5vZGUsIG51bGwsIG51bGwsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXRjaChjb250YWluZXIuX3Zub2RlIHx8IG51bGwsIHZub2RlLCBjb250YWluZXIsIG51bGwsIG51bGwsIG51bGwsIGlzU1ZHKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcclxuICAgICAgICBjb250YWluZXIuX3Zub2RlID0gdm5vZGU7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaW50ZXJuYWxzID0ge1xyXG4gICAgICAgIHA6IHBhdGNoLFxyXG4gICAgICAgIHVtOiB1bm1vdW50LFxyXG4gICAgICAgIG06IG1vdmUsXHJcbiAgICAgICAgcjogcmVtb3ZlLFxyXG4gICAgICAgIG10OiBtb3VudENvbXBvbmVudCxcclxuICAgICAgICBtYzogbW91bnRDaGlsZHJlbixcclxuICAgICAgICBwYzogcGF0Y2hDaGlsZHJlbixcclxuICAgICAgICBwYmM6IHBhdGNoQmxvY2tDaGlsZHJlbixcclxuICAgICAgICBuOiBnZXROZXh0SG9zdE5vZGUsXHJcbiAgICAgICAgbzogb3B0aW9uc1xyXG4gICAgfTtcclxuICAgIGxldCBoeWRyYXRlO1xyXG4gICAgbGV0IGh5ZHJhdGVOb2RlO1xyXG4gICAgaWYgKGNyZWF0ZUh5ZHJhdGlvbkZucykge1xyXG4gICAgICAgIFtoeWRyYXRlLCBoeWRyYXRlTm9kZV0gPSBjcmVhdGVIeWRyYXRpb25GbnMoaW50ZXJuYWxzKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVuZGVyLFxyXG4gICAgICAgIGh5ZHJhdGUsXHJcbiAgICAgICAgY3JlYXRlQXBwOiBjcmVhdGVBcHBBUEkocmVuZGVyLCBoeWRyYXRlKVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiB0b2dnbGVSZWN1cnNlKHsgZWZmZWN0LCB1cGRhdGUgfSwgYWxsb3dlZCkge1xyXG4gICAgZWZmZWN0LmFsbG93UmVjdXJzZSA9IHVwZGF0ZS5hbGxvd1JlY3Vyc2UgPSBhbGxvd2VkO1xyXG59XHJcbi8qKlxyXG4gKiAjMTE1NlxyXG4gKiBXaGVuIGEgY29tcG9uZW50IGlzIEhNUi1lbmFibGVkLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGFsbCBzdGF0aWMgbm9kZXNcclxuICogaW5zaWRlIGEgYmxvY2sgYWxzbyBpbmhlcml0IHRoZSBET00gZWxlbWVudCBmcm9tIHRoZSBwcmV2aW91cyB0cmVlIHNvIHRoYXRcclxuICogSE1SIHVwZGF0ZXMgKHdoaWNoIGFyZSBmdWxsIHVwZGF0ZXMpIGNhbiByZXRyaWV2ZSB0aGUgZWxlbWVudCBmb3IgcGF0Y2hpbmcuXHJcbiAqXHJcbiAqICMyMDgwXHJcbiAqIEluc2lkZSBrZXllZCBgdGVtcGxhdGVgIGZyYWdtZW50IHN0YXRpYyBjaGlsZHJlbiwgaWYgYSBmcmFnbWVudCBpcyBtb3ZlZCxcclxuICogdGhlIGNoaWxkcmVuIHdpbGwgYWx3YXlzIGJlIG1vdmVkLiBUaGVyZWZvcmUsIGluIG9yZGVyIHRvIGVuc3VyZSBjb3JyZWN0IG1vdmVcclxuICogcG9zaXRpb24sIGVsIHNob3VsZCBiZSBpbmhlcml0ZWQgZnJvbSBwcmV2aW91cyBub2Rlcy5cclxuICovXHJcbmZ1bmN0aW9uIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yLCBzaGFsbG93ID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IGNoMSA9IG4xLmNoaWxkcmVuO1xyXG4gICAgY29uc3QgY2gyID0gbjIuY2hpbGRyZW47XHJcbiAgICBpZiAoaXNBcnJheShjaDEpICYmIGlzQXJyYXkoY2gyKSkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2gxLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgb25seSBjYWxsZWQgaW4gdGhlIG9wdGltaXplZCBwYXRoIHNvIGFycmF5IGNoaWxkcmVuIGFyZVxyXG4gICAgICAgICAgICAvLyBndWFyYW50ZWVkIHRvIGJlIHZub2Rlc1xyXG4gICAgICAgICAgICBjb25zdCBjMSA9IGNoMVtpXTtcclxuICAgICAgICAgICAgbGV0IGMyID0gY2gyW2ldO1xyXG4gICAgICAgICAgICBpZiAoYzIuc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovICYmICFjMi5keW5hbWljQ2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIGlmIChjMi5wYXRjaEZsYWcgPD0gMCB8fCBjMi5wYXRjaEZsYWcgPT09IDMyIC8qIEhZRFJBVEVfRVZFTlRTICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYzIgPSBjaDJbaV0gPSBjbG9uZUlmTW91bnRlZChjaDJbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGMyLmVsID0gYzEuZWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNoYWxsb3cpXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihjMSwgYzIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGFsc28gaW5oZXJpdCBmb3IgY29tbWVudCBub2RlcywgYnV0IG5vdCBwbGFjZWhvbGRlcnMgKGUuZy4gdi1pZiB3aGljaFxyXG4gICAgICAgICAgICAvLyB3b3VsZCBoYXZlIHJlY2VpdmVkIC5lbCBkdXJpbmcgYmxvY2sgcGF0Y2gpXHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgYzIudHlwZSA9PT0gQ29tbWVudCAmJiAhYzIuZWwpIHtcclxuICAgICAgICAgICAgICAgIGMyLmVsID0gYzEuZWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTG9uZ2VzdF9pbmNyZWFzaW5nX3N1YnNlcXVlbmNlXHJcbmZ1bmN0aW9uIGdldFNlcXVlbmNlKGFycikge1xyXG4gICAgY29uc3QgcCA9IGFyci5zbGljZSgpO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gWzBdO1xyXG4gICAgbGV0IGksIGosIHUsIHYsIGM7XHJcbiAgICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgYXJySSA9IGFycltpXTtcclxuICAgICAgICBpZiAoYXJySSAhPT0gMCkge1xyXG4gICAgICAgICAgICBqID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgaWYgKGFycltqXSA8IGFyckkpIHtcclxuICAgICAgICAgICAgICAgIHBbaV0gPSBqO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB1ID0gMDtcclxuICAgICAgICAgICAgdiA9IHJlc3VsdC5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICB3aGlsZSAodSA8IHYpIHtcclxuICAgICAgICAgICAgICAgIGMgPSAodSArIHYpID4+IDE7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJyW3Jlc3VsdFtjXV0gPCBhcnJJKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdSA9IGMgKyAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdiA9IGM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFyckkgPCBhcnJbcmVzdWx0W3VdXSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcFtpXSA9IHJlc3VsdFt1IC0gMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbdV0gPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdSA9IHJlc3VsdC5sZW5ndGg7XHJcbiAgICB2ID0gcmVzdWx0W3UgLSAxXTtcclxuICAgIHdoaWxlICh1LS0gPiAwKSB7XHJcbiAgICAgICAgcmVzdWx0W3VdID0gdjtcclxuICAgICAgICB2ID0gcFt2XTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cblxuY29uc3QgaXNUZWxlcG9ydCA9ICh0eXBlKSA9PiB0eXBlLl9faXNUZWxlcG9ydDtcclxuY29uc3QgaXNUZWxlcG9ydERpc2FibGVkID0gKHByb3BzKSA9PiBwcm9wcyAmJiAocHJvcHMuZGlzYWJsZWQgfHwgcHJvcHMuZGlzYWJsZWQgPT09ICcnKTtcclxuY29uc3QgaXNUYXJnZXRTVkcgPSAodGFyZ2V0KSA9PiB0eXBlb2YgU1ZHRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudDtcclxuY29uc3QgcmVzb2x2ZVRhcmdldCA9IChwcm9wcywgc2VsZWN0KSA9PiB7XHJcbiAgICBjb25zdCB0YXJnZXRTZWxlY3RvciA9IHByb3BzICYmIHByb3BzLnRvO1xyXG4gICAgaWYgKGlzU3RyaW5nKHRhcmdldFNlbGVjdG9yKSkge1xyXG4gICAgICAgIGlmICghc2VsZWN0KSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgd2FybihgQ3VycmVudCByZW5kZXJlciBkb2VzIG5vdCBzdXBwb3J0IHN0cmluZyB0YXJnZXQgZm9yIFRlbGVwb3J0cy4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYChtaXNzaW5nIHF1ZXJ5U2VsZWN0b3IgcmVuZGVyZXIgb3B0aW9uKWApO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHNlbGVjdCh0YXJnZXRTZWxlY3Rvcik7XHJcbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBGYWlsZWQgdG8gbG9jYXRlIFRlbGVwb3J0IHRhcmdldCB3aXRoIHNlbGVjdG9yIFwiJHt0YXJnZXRTZWxlY3Rvcn1cIi4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBOb3RlIHRoZSB0YXJnZXQgZWxlbWVudCBtdXN0IGV4aXN0IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQgLSBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYGkuZS4gdGhlIHRhcmdldCBjYW5ub3QgYmUgcmVuZGVyZWQgYnkgdGhlIGNvbXBvbmVudCBpdHNlbGYsIGFuZCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYGlkZWFsbHkgc2hvdWxkIGJlIG91dHNpZGUgb2YgdGhlIGVudGlyZSBWdWUgY29tcG9uZW50IHRyZWUuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICF0YXJnZXRTZWxlY3RvciAmJiAhaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBJbnZhbGlkIFRlbGVwb3J0IHRhcmdldDogJHt0YXJnZXRTZWxlY3Rvcn1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldFNlbGVjdG9yO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBUZWxlcG9ydEltcGwgPSB7XHJcbiAgICBfX2lzVGVsZXBvcnQ6IHRydWUsXHJcbiAgICBwcm9jZXNzKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgaW50ZXJuYWxzKSB7XHJcbiAgICAgICAgY29uc3QgeyBtYzogbW91bnRDaGlsZHJlbiwgcGM6IHBhdGNoQ2hpbGRyZW4sIHBiYzogcGF0Y2hCbG9ja0NoaWxkcmVuLCBvOiB7IGluc2VydCwgcXVlcnlTZWxlY3RvciwgY3JlYXRlVGV4dCwgY3JlYXRlQ29tbWVudCB9IH0gPSBpbnRlcm5hbHM7XHJcbiAgICAgICAgY29uc3QgZGlzYWJsZWQgPSBpc1RlbGVwb3J0RGlzYWJsZWQobjIucHJvcHMpO1xyXG4gICAgICAgIGxldCB7IHNoYXBlRmxhZywgY2hpbGRyZW4sIGR5bmFtaWNDaGlsZHJlbiB9ID0gbjI7XHJcbiAgICAgICAgLy8gIzMzMDJcclxuICAgICAgICAvLyBITVIgdXBkYXRlZCwgZm9yY2UgZnVsbCBkaWZmXHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpc0htclVwZGF0aW5nKSB7XHJcbiAgICAgICAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBpbnNlcnQgYW5jaG9ycyBpbiB0aGUgbWFpbiB2aWV3XHJcbiAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gKG4yLmVsID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgICAgICAgICA/IGNyZWF0ZUNvbW1lbnQoJ3RlbGVwb3J0IHN0YXJ0JylcclxuICAgICAgICAgICAgICAgIDogY3JlYXRlVGV4dCgnJykpO1xyXG4gICAgICAgICAgICBjb25zdCBtYWluQW5jaG9yID0gKG4yLmFuY2hvciA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVDb21tZW50KCd0ZWxlcG9ydCBlbmQnKVxyXG4gICAgICAgICAgICAgICAgOiBjcmVhdGVUZXh0KCcnKSk7XHJcbiAgICAgICAgICAgIGluc2VydChwbGFjZWhvbGRlciwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICBpbnNlcnQobWFpbkFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAobjIudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldChuMi5wcm9wcywgcXVlcnlTZWxlY3RvcikpO1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRBbmNob3IgPSAobjIudGFyZ2V0QW5jaG9yID0gY3JlYXRlVGV4dCgnJykpO1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBpbnNlcnQodGFyZ2V0QW5jaG9yLCB0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgLy8gIzI2NTIgd2UgY291bGQgYmUgdGVsZXBvcnRpbmcgZnJvbSBhIG5vbi1TVkcgdHJlZSBpbnRvIGFuIFNWRyB0cmVlXHJcbiAgICAgICAgICAgICAgICBpc1NWRyA9IGlzU1ZHIHx8IGlzVGFyZ2V0U1ZHKHRhcmdldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFkaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQgb24gbW91bnQ6JywgdGFyZ2V0LCBgKCR7dHlwZW9mIHRhcmdldH0pYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbW91bnQgPSAoY29udGFpbmVyLCBhbmNob3IpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFRlbGVwb3J0ICphbHdheXMqIGhhcyBBcnJheSBjaGlsZHJlbi4gVGhpcyBpcyBlbmZvcmNlZCBpbiBib3RoIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gY29tcGlsZXIgYW5kIHZub2RlIGNoaWxkcmVuIG5vcm1hbGl6YXRpb24uXHJcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBtb3VudENoaWxkcmVuKGNoaWxkcmVuLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKGRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICBtb3VudChjb250YWluZXIsIG1haW5BbmNob3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgbW91bnQodGFyZ2V0LCB0YXJnZXRBbmNob3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB1cGRhdGUgY29udGVudFxyXG4gICAgICAgICAgICBuMi5lbCA9IG4xLmVsO1xyXG4gICAgICAgICAgICBjb25zdCBtYWluQW5jaG9yID0gKG4yLmFuY2hvciA9IG4xLmFuY2hvcik7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IChuMi50YXJnZXQgPSBuMS50YXJnZXQpO1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRBbmNob3IgPSAobjIudGFyZ2V0QW5jaG9yID0gbjEudGFyZ2V0QW5jaG9yKTtcclxuICAgICAgICAgICAgY29uc3Qgd2FzRGlzYWJsZWQgPSBpc1RlbGVwb3J0RGlzYWJsZWQobjEucHJvcHMpO1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Q29udGFpbmVyID0gd2FzRGlzYWJsZWQgPyBjb250YWluZXIgOiB0YXJnZXQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRBbmNob3IgPSB3YXNEaXNhYmxlZCA/IG1haW5BbmNob3IgOiB0YXJnZXRBbmNob3I7XHJcbiAgICAgICAgICAgIGlzU1ZHID0gaXNTVkcgfHwgaXNUYXJnZXRTVkcodGFyZ2V0KTtcclxuICAgICAgICAgICAgaWYgKGR5bmFtaWNDaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgLy8gZmFzdCBwYXRoIHdoZW4gdGhlIHRlbGVwb3J0IGhhcHBlbnMgdG8gYmUgYSBibG9jayByb290XHJcbiAgICAgICAgICAgICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4objEuZHluYW1pY0NoaWxkcmVuLCBkeW5hbWljQ2hpbGRyZW4sIGN1cnJlbnRDb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMpO1xyXG4gICAgICAgICAgICAgICAgLy8gZXZlbiBpbiBibG9jayB0cmVlIG1vZGUgd2UgbmVlZCB0byBtYWtlIHN1cmUgYWxsIHJvb3QtbGV2ZWwgbm9kZXNcclxuICAgICAgICAgICAgICAgIC8vIGluIHRoZSB0ZWxlcG9ydCBpbmhlcml0IHByZXZpb3VzIERPTSByZWZlcmVuY2VzIHNvIHRoYXQgdGhleSBjYW5cclxuICAgICAgICAgICAgICAgIC8vIGJlIG1vdmVkIGluIGZ1dHVyZSBwYXRjaGVzLlxyXG4gICAgICAgICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFvcHRpbWl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIHBhdGNoQ2hpbGRyZW4objEsIG4yLCBjdXJyZW50Q29udGFpbmVyLCBjdXJyZW50QW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXdhc0Rpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5hYmxlZCAtPiBkaXNhYmxlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgaW50byBtYWluIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgIG1vdmVUZWxlcG9ydChuMiwgY29udGFpbmVyLCBtYWluQW5jaG9yLCBpbnRlcm5hbHMsIDEgLyogVE9HR0xFICovKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHRhcmdldCBjaGFuZ2VkXHJcbiAgICAgICAgICAgICAgICBpZiAoKG4yLnByb3BzICYmIG4yLnByb3BzLnRvKSAhPT0gKG4xLnByb3BzICYmIG4xLnByb3BzLnRvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRUYXJnZXQgPSAobjIudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldChuMi5wcm9wcywgcXVlcnlTZWxlY3RvcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0VGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVUZWxlcG9ydChuMiwgbmV4dFRhcmdldCwgbnVsbCwgaW50ZXJuYWxzLCAwIC8qIFRBUkdFVF9DSEFOR0UgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQgb24gdXBkYXRlOicsIHRhcmdldCwgYCgke3R5cGVvZiB0YXJnZXR9KWApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdhc0Rpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZGlzYWJsZWQgLT4gZW5hYmxlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgaW50byB0ZWxlcG9ydCB0YXJnZXRcclxuICAgICAgICAgICAgICAgICAgICBtb3ZlVGVsZXBvcnQobjIsIHRhcmdldCwgdGFyZ2V0QW5jaG9yLCBpbnRlcm5hbHMsIDEgLyogVE9HR0xFICovKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICByZW1vdmUodm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG9wdGltaXplZCwgeyB1bTogdW5tb3VudCwgbzogeyByZW1vdmU6IGhvc3RSZW1vdmUgfSB9LCBkb1JlbW92ZSkge1xyXG4gICAgICAgIGNvbnN0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiwgYW5jaG9yLCB0YXJnZXRBbmNob3IsIHRhcmdldCwgcHJvcHMgfSA9IHZub2RlO1xyXG4gICAgICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgaG9zdFJlbW92ZSh0YXJnZXRBbmNob3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhbiB1bm1vdW50ZWQgdGVsZXBvcnQgc2hvdWxkIGFsd2F5cyByZW1vdmUgaXRzIGNoaWxkcmVuIGlmIG5vdCBkaXNhYmxlZFxyXG4gICAgICAgIGlmIChkb1JlbW92ZSB8fCAhaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xyXG4gICAgICAgICAgICBob3N0UmVtb3ZlKGFuY2hvcik7XHJcbiAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICAgICAgdW5tb3VudChjaGlsZCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSwgISFjaGlsZC5keW5hbWljQ2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1vdmU6IG1vdmVUZWxlcG9ydCxcclxuICAgIGh5ZHJhdGU6IGh5ZHJhdGVUZWxlcG9ydFxyXG59O1xyXG5mdW5jdGlvbiBtb3ZlVGVsZXBvcnQodm5vZGUsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yLCB7IG86IHsgaW5zZXJ0IH0sIG06IG1vdmUgfSwgbW92ZVR5cGUgPSAyIC8qIFJFT1JERVIgKi8pIHtcclxuICAgIC8vIG1vdmUgdGFyZ2V0IGFuY2hvciBpZiB0aGlzIGlzIGEgdGFyZ2V0IGNoYW5nZS5cclxuICAgIGlmIChtb3ZlVHlwZSA9PT0gMCAvKiBUQVJHRVRfQ0hBTkdFICovKSB7XHJcbiAgICAgICAgaW5zZXJ0KHZub2RlLnRhcmdldEFuY2hvciwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBlbCwgYW5jaG9yLCBzaGFwZUZsYWcsIGNoaWxkcmVuLCBwcm9wcyB9ID0gdm5vZGU7XHJcbiAgICBjb25zdCBpc1Jlb3JkZXIgPSBtb3ZlVHlwZSA9PT0gMiAvKiBSRU9SREVSICovO1xyXG4gICAgLy8gbW92ZSBtYWluIHZpZXcgYW5jaG9yIGlmIHRoaXMgaXMgYSByZS1vcmRlci5cclxuICAgIGlmIChpc1Jlb3JkZXIpIHtcclxuICAgICAgICBpbnNlcnQoZWwsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcclxuICAgIH1cclxuICAgIC8vIGlmIHRoaXMgaXMgYSByZS1vcmRlciBhbmQgdGVsZXBvcnQgaXMgZW5hYmxlZCAoY29udGVudCBpcyBpbiB0YXJnZXQpXHJcbiAgICAvLyBkbyBub3QgbW92ZSBjaGlsZHJlbi4gU28gdGhlIG9wcG9zaXRlIGlzOiBvbmx5IG1vdmUgY2hpbGRyZW4gaWYgdGhpc1xyXG4gICAgLy8gaXMgbm90IGEgcmVvcmRlciwgb3IgdGhlIHRlbGVwb3J0IGlzIGRpc2FibGVkXHJcbiAgICBpZiAoIWlzUmVvcmRlciB8fCBpc1RlbGVwb3J0RGlzYWJsZWQocHJvcHMpKSB7XHJcbiAgICAgICAgLy8gVGVsZXBvcnQgaGFzIGVpdGhlciBBcnJheSBjaGlsZHJlbiBvciBubyBjaGlsZHJlbi5cclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbW92ZShjaGlsZHJlbltpXSwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IsIDIgLyogUkVPUkRFUiAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBtb3ZlIG1haW4gdmlldyBhbmNob3IgaWYgdGhpcyBpcyBhIHJlLW9yZGVyLlxyXG4gICAgaWYgKGlzUmVvcmRlcikge1xyXG4gICAgICAgIGluc2VydChhbmNob3IsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBoeWRyYXRlVGVsZXBvcnQobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCB7IG86IHsgbmV4dFNpYmxpbmcsIHBhcmVudE5vZGUsIHF1ZXJ5U2VsZWN0b3IgfSB9LCBoeWRyYXRlQ2hpbGRyZW4pIHtcclxuICAgIGNvbnN0IHRhcmdldCA9ICh2bm9kZS50YXJnZXQgPSByZXNvbHZlVGFyZ2V0KHZub2RlLnByb3BzLCBxdWVyeVNlbGVjdG9yKSk7XHJcbiAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgLy8gaWYgbXVsdGlwbGUgdGVsZXBvcnRzIHJlbmRlcmVkIHRvIHRoZSBzYW1lIHRhcmdldCBlbGVtZW50LCB3ZSBuZWVkIHRvXHJcbiAgICAgICAgLy8gcGljayB1cCBmcm9tIHdoZXJlIHRoZSBsYXN0IHRlbGVwb3J0IGZpbmlzaGVkIGluc3RlYWQgb2YgdGhlIGZpcnN0IG5vZGVcclxuICAgICAgICBjb25zdCB0YXJnZXROb2RlID0gdGFyZ2V0Ll9scGEgfHwgdGFyZ2V0LmZpcnN0Q2hpbGQ7XHJcbiAgICAgICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1RlbGVwb3J0RGlzYWJsZWQodm5vZGUucHJvcHMpKSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS5hbmNob3IgPSBoeWRyYXRlQ2hpbGRyZW4obmV4dFNpYmxpbmcobm9kZSksIHZub2RlLCBwYXJlbnROb2RlKG5vZGUpLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS50YXJnZXRBbmNob3IgPSB0YXJnZXROb2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuYW5jaG9yID0gbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS50YXJnZXRBbmNob3IgPSBoeWRyYXRlQ2hpbGRyZW4odGFyZ2V0Tm9kZSwgdm5vZGUsIHRhcmdldCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRhcmdldC5fbHBhID1cclxuICAgICAgICAgICAgICAgIHZub2RlLnRhcmdldEFuY2hvciAmJiBuZXh0U2libGluZyh2bm9kZS50YXJnZXRBbmNob3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB2bm9kZS5hbmNob3IgJiYgbmV4dFNpYmxpbmcodm5vZGUuYW5jaG9yKTtcclxufVxyXG4vLyBGb3JjZS1jYXN0ZWQgcHVibGljIHR5cGluZyBmb3IgaCBhbmQgVFNYIHByb3BzIGluZmVyZW5jZVxyXG5jb25zdCBUZWxlcG9ydCA9IFRlbGVwb3J0SW1wbDtcblxuY29uc3QgQ09NUE9ORU5UUyA9ICdjb21wb25lbnRzJztcclxuY29uc3QgRElSRUNUSVZFUyA9ICdkaXJlY3RpdmVzJztcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50KG5hbWUsIG1heWJlU2VsZlJlZmVyZW5jZSkge1xyXG4gICAgcmV0dXJuIHJlc29sdmVBc3NldChDT01QT05FTlRTLCBuYW1lLCB0cnVlLCBtYXliZVNlbGZSZWZlcmVuY2UpIHx8IG5hbWU7XHJcbn1cclxuY29uc3QgTlVMTF9EWU5BTUlDX0NPTVBPTkVOVCA9IFN5bWJvbCgpO1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlc29sdmVEeW5hbWljQ29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgaWYgKGlzU3RyaW5nKGNvbXBvbmVudCkpIHtcclxuICAgICAgICByZXR1cm4gcmVzb2x2ZUFzc2V0KENPTVBPTkVOVFMsIGNvbXBvbmVudCwgZmFsc2UpIHx8IGNvbXBvbmVudDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGludmFsaWQgdHlwZXMgd2lsbCBmYWxsdGhyb3VnaCB0byBjcmVhdGVWTm9kZSBhbmQgcmFpc2Ugd2FybmluZ1xyXG4gICAgICAgIHJldHVybiAoY29tcG9uZW50IHx8IE5VTExfRFlOQU1JQ19DT01QT05FTlQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZURpcmVjdGl2ZShuYW1lKSB7XHJcbiAgICByZXR1cm4gcmVzb2x2ZUFzc2V0KERJUkVDVElWRVMsIG5hbWUpO1xyXG59XHJcbi8vIGltcGxlbWVudGF0aW9uXHJcbmZ1bmN0aW9uIHJlc29sdmVBc3NldCh0eXBlLCBuYW1lLCB3YXJuTWlzc2luZyA9IHRydWUsIG1heWJlU2VsZlJlZmVyZW5jZSA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSB8fCBjdXJyZW50SW5zdGFuY2U7XHJcbiAgICBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICBjb25zdCBDb21wb25lbnQgPSBpbnN0YW5jZS50eXBlO1xyXG4gICAgICAgIC8vIGV4cGxpY2l0IHNlbGYgbmFtZSBoYXMgaGlnaGVzdCBwcmlvcml0eVxyXG4gICAgICAgIGlmICh0eXBlID09PSBDT01QT05FTlRTKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGZOYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpO1xyXG4gICAgICAgICAgICBpZiAoc2VsZk5hbWUgJiZcclxuICAgICAgICAgICAgICAgIChzZWxmTmFtZSA9PT0gbmFtZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGZOYW1lID09PSBjYW1lbGl6ZShuYW1lKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGZOYW1lID09PSBjYXBpdGFsaXplKGNhbWVsaXplKG5hbWUpKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDb21wb25lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzID0gXHJcbiAgICAgICAgLy8gbG9jYWwgcmVnaXN0cmF0aW9uXHJcbiAgICAgICAgLy8gY2hlY2sgaW5zdGFuY2VbdHlwZV0gZmlyc3Qgd2hpY2ggaXMgcmVzb2x2ZWQgZm9yIG9wdGlvbnMgQVBJXHJcbiAgICAgICAgcmVzb2x2ZShpbnN0YW5jZVt0eXBlXSB8fCBDb21wb25lbnRbdHlwZV0sIG5hbWUpIHx8XHJcbiAgICAgICAgICAgIC8vIGdsb2JhbCByZWdpc3RyYXRpb25cclxuICAgICAgICAgICAgcmVzb2x2ZShpbnN0YW5jZS5hcHBDb250ZXh0W3R5cGVdLCBuYW1lKTtcclxuICAgICAgICBpZiAoIXJlcyAmJiBtYXliZVNlbGZSZWZlcmVuY2UpIHtcclxuICAgICAgICAgICAgLy8gZmFsbGJhY2sgdG8gaW1wbGljaXQgc2VsZi1yZWZlcmVuY2VcclxuICAgICAgICAgICAgcmV0dXJuIENvbXBvbmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4dHJhID0gdHlwZSA9PT0gQ09NUE9ORU5UU1xyXG4gICAgICAgICAgICAgICAgPyBgXFxuSWYgdGhpcyBpcyBhIG5hdGl2ZSBjdXN0b20gZWxlbWVudCwgbWFrZSBzdXJlIHRvIGV4Y2x1ZGUgaXQgZnJvbSBgICtcclxuICAgICAgICAgICAgICAgICAgICBgY29tcG9uZW50IHJlc29sdXRpb24gdmlhIGNvbXBpbGVyT3B0aW9ucy5pc0N1c3RvbUVsZW1lbnQuYFxyXG4gICAgICAgICAgICAgICAgOiBgYDtcclxuICAgICAgICAgICAgd2FybihgRmFpbGVkIHRvIHJlc29sdmUgJHt0eXBlLnNsaWNlKDAsIC0xKX06ICR7bmFtZX0ke2V4dHJhfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgd2FybihgcmVzb2x2ZSR7Y2FwaXRhbGl6ZSh0eXBlLnNsaWNlKDAsIC0xKSl9IGAgK1xyXG4gICAgICAgICAgICBgY2FuIG9ubHkgYmUgdXNlZCBpbiByZW5kZXIoKSBvciBzZXR1cCgpLmApO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlc29sdmUocmVnaXN0cnksIG5hbWUpIHtcclxuICAgIHJldHVybiAocmVnaXN0cnkgJiZcclxuICAgICAgICAocmVnaXN0cnlbbmFtZV0gfHxcclxuICAgICAgICAgICAgcmVnaXN0cnlbY2FtZWxpemUobmFtZSldIHx8XHJcbiAgICAgICAgICAgIHJlZ2lzdHJ5W2NhcGl0YWxpemUoY2FtZWxpemUobmFtZSkpXSkpO1xyXG59XG5cbmNvbnN0IEZyYWdtZW50ID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdGcmFnbWVudCcgOiB1bmRlZmluZWQpO1xyXG5jb25zdCBUZXh0ID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdUZXh0JyA6IHVuZGVmaW5lZCk7XHJcbmNvbnN0IENvbW1lbnQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ0NvbW1lbnQnIDogdW5kZWZpbmVkKTtcclxuY29uc3QgU3RhdGljID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdTdGF0aWMnIDogdW5kZWZpbmVkKTtcclxuLy8gU2luY2Ugdi1pZiBhbmQgdi1mb3IgYXJlIHRoZSB0d28gcG9zc2libGUgd2F5cyBub2RlIHN0cnVjdHVyZSBjYW4gZHluYW1pY2FsbHlcclxuLy8gY2hhbmdlLCBvbmNlIHdlIGNvbnNpZGVyIHYtaWYgYnJhbmNoZXMgYW5kIGVhY2ggdi1mb3IgZnJhZ21lbnQgYSBibG9jaywgd2VcclxuLy8gY2FuIGRpdmlkZSBhIHRlbXBsYXRlIGludG8gbmVzdGVkIGJsb2NrcywgYW5kIHdpdGhpbiBlYWNoIGJsb2NrIHRoZSBub2RlXHJcbi8vIHN0cnVjdHVyZSB3b3VsZCBiZSBzdGFibGUuIFRoaXMgYWxsb3dzIHVzIHRvIHNraXAgbW9zdCBjaGlsZHJlbiBkaWZmaW5nXHJcbi8vIGFuZCBvbmx5IHdvcnJ5IGFib3V0IHRoZSBkeW5hbWljIG5vZGVzIChpbmRpY2F0ZWQgYnkgcGF0Y2ggZmxhZ3MpLlxyXG5jb25zdCBibG9ja1N0YWNrID0gW107XHJcbmxldCBjdXJyZW50QmxvY2sgPSBudWxsO1xyXG4vKipcclxuICogT3BlbiBhIGJsb2NrLlxyXG4gKiBUaGlzIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBgY3JlYXRlQmxvY2tgLiBJdCBjYW5ub3QgYmUgcGFydCBvZiBgY3JlYXRlQmxvY2tgXHJcbiAqIGJlY2F1c2UgdGhlIGNoaWxkcmVuIG9mIHRoZSBibG9jayBhcmUgZXZhbHVhdGVkIGJlZm9yZSBgY3JlYXRlQmxvY2tgIGl0c2VsZlxyXG4gKiBpcyBjYWxsZWQuIFRoZSBnZW5lcmF0ZWQgY29kZSB0eXBpY2FsbHkgbG9va3MgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBmdW5jdGlvbiByZW5kZXIoKSB7XHJcbiAqICAgcmV0dXJuIChvcGVuQmxvY2soKSxjcmVhdGVCbG9jaygnZGl2JywgbnVsbCwgWy4uLl0pKVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKiBkaXNhYmxlVHJhY2tpbmcgaXMgdHJ1ZSB3aGVuIGNyZWF0aW5nIGEgdi1mb3IgZnJhZ21lbnQgYmxvY2ssIHNpbmNlIGEgdi1mb3JcclxuICogZnJhZ21lbnQgYWx3YXlzIGRpZmZzIGl0cyBjaGlsZHJlbi5cclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIG9wZW5CbG9jayhkaXNhYmxlVHJhY2tpbmcgPSBmYWxzZSkge1xyXG4gICAgYmxvY2tTdGFjay5wdXNoKChjdXJyZW50QmxvY2sgPSBkaXNhYmxlVHJhY2tpbmcgPyBudWxsIDogW10pKTtcclxufVxyXG5mdW5jdGlvbiBjbG9zZUJsb2NrKCkge1xyXG4gICAgYmxvY2tTdGFjay5wb3AoKTtcclxuICAgIGN1cnJlbnRCbG9jayA9IGJsb2NrU3RhY2tbYmxvY2tTdGFjay5sZW5ndGggLSAxXSB8fCBudWxsO1xyXG59XHJcbi8vIFdoZXRoZXIgd2Ugc2hvdWxkIGJlIHRyYWNraW5nIGR5bmFtaWMgY2hpbGQgbm9kZXMgaW5zaWRlIGEgYmxvY2suXHJcbi8vIE9ubHkgdHJhY2tzIHdoZW4gdGhpcyB2YWx1ZSBpcyA+IDBcclxuLy8gV2UgYXJlIG5vdCB1c2luZyBhIHNpbXBsZSBib29sZWFuIGJlY2F1c2UgdGhpcyB2YWx1ZSBtYXkgbmVlZCB0byBiZVxyXG4vLyBpbmNyZW1lbnRlZC9kZWNyZW1lbnRlZCBieSBuZXN0ZWQgdXNhZ2Ugb2Ygdi1vbmNlIChzZWUgYmVsb3cpXHJcbmxldCBpc0Jsb2NrVHJlZUVuYWJsZWQgPSAxO1xyXG4vKipcclxuICogQmxvY2sgdHJhY2tpbmcgc29tZXRpbWVzIG5lZWRzIHRvIGJlIGRpc2FibGVkLCBmb3IgZXhhbXBsZSBkdXJpbmcgdGhlXHJcbiAqIGNyZWF0aW9uIG9mIGEgdHJlZSB0aGF0IG5lZWRzIHRvIGJlIGNhY2hlZCBieSB2LW9uY2UuIFRoZSBjb21waWxlciBnZW5lcmF0ZXNcclxuICogY29kZSBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYCBqc1xyXG4gKiBfY2FjaGVbMV0gfHwgKFxyXG4gKiAgIHNldEJsb2NrVHJhY2tpbmcoLTEpLFxyXG4gKiAgIF9jYWNoZVsxXSA9IGNyZWF0ZVZOb2RlKC4uLiksXHJcbiAqICAgc2V0QmxvY2tUcmFja2luZygxKSxcclxuICogICBfY2FjaGVbMV1cclxuICogKVxyXG4gKiBgYGBcclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHNldEJsb2NrVHJhY2tpbmcodmFsdWUpIHtcclxuICAgIGlzQmxvY2tUcmVlRW5hYmxlZCArPSB2YWx1ZTtcclxufVxyXG5mdW5jdGlvbiBzZXR1cEJsb2NrKHZub2RlKSB7XHJcbiAgICAvLyBzYXZlIGN1cnJlbnQgYmxvY2sgY2hpbGRyZW4gb24gdGhlIGJsb2NrIHZub2RlXHJcbiAgICB2bm9kZS5keW5hbWljQ2hpbGRyZW4gPVxyXG4gICAgICAgIGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgPyBjdXJyZW50QmxvY2sgfHwgRU1QVFlfQVJSIDogbnVsbDtcclxuICAgIC8vIGNsb3NlIGJsb2NrXHJcbiAgICBjbG9zZUJsb2NrKCk7XHJcbiAgICAvLyBhIGJsb2NrIGlzIGFsd2F5cyBnb2luZyB0byBiZSBwYXRjaGVkLCBzbyB0cmFjayBpdCBhcyBhIGNoaWxkIG9mIGl0c1xyXG4gICAgLy8gcGFyZW50IGJsb2NrXHJcbiAgICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiBjdXJyZW50QmxvY2spIHtcclxuICAgICAgICBjdXJyZW50QmxvY2sucHVzaCh2bm9kZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdm5vZGU7XHJcbn1cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50QmxvY2sodHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcywgc2hhcGVGbGFnKSB7XHJcbiAgICByZXR1cm4gc2V0dXBCbG9jayhjcmVhdGVCYXNlVk5vZGUodHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcywgc2hhcGVGbGFnLCB0cnVlIC8qIGlzQmxvY2sgKi8pKTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlIGEgYmxvY2sgcm9vdCB2bm9kZS4gVGFrZXMgdGhlIHNhbWUgZXhhY3QgYXJndW1lbnRzIGFzIGBjcmVhdGVWTm9kZWAuXHJcbiAqIEEgYmxvY2sgcm9vdCBrZWVwcyB0cmFjayBvZiBkeW5hbWljIG5vZGVzIHdpdGhpbiB0aGUgYmxvY2sgaW4gdGhlXHJcbiAqIGBkeW5hbWljQ2hpbGRyZW5gIGFycmF5LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlQmxvY2sodHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcykge1xyXG4gICAgcmV0dXJuIHNldHVwQmxvY2soY3JlYXRlVk5vZGUodHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcywgdHJ1ZSAvKiBpc0Jsb2NrOiBwcmV2ZW50IGEgYmxvY2sgZnJvbSB0cmFja2luZyBpdHNlbGYgKi8pKTtcclxufVxyXG5mdW5jdGlvbiBpc1ZOb2RlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgPyB2YWx1ZS5fX3ZfaXNWTm9kZSA9PT0gdHJ1ZSA6IGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGlzU2FtZVZOb2RlVHlwZShuMSwgbjIpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICBuMi5zaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLyAmJlxyXG4gICAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5oYXMobjIudHlwZSkpIHtcclxuICAgICAgICAvLyBITVIgb25seTogaWYgdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBob3QtdXBkYXRlZCwgZm9yY2UgYSByZWxvYWQuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG4xLnR5cGUgPT09IG4yLnR5cGUgJiYgbjEua2V5ID09PSBuMi5rZXk7XHJcbn1cclxubGV0IHZub2RlQXJnc1RyYW5zZm9ybWVyO1xyXG4vKipcclxuICogSW50ZXJuYWwgQVBJIGZvciByZWdpc3RlcmluZyBhbiBhcmd1bWVudHMgdHJhbnNmb3JtIGZvciBjcmVhdGVWTm9kZVxyXG4gKiB1c2VkIGZvciBjcmVhdGluZyBzdHVicyBpbiB0aGUgdGVzdC11dGlsc1xyXG4gKiBJdCBpcyAqaW50ZXJuYWwqIGJ1dCBuZWVkcyB0byBiZSBleHBvc2VkIGZvciB0ZXN0LXV0aWxzIHRvIHBpY2sgdXAgcHJvcGVyXHJcbiAqIHR5cGluZ3NcclxuICovXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVZOb2RlQXJncyh0cmFuc2Zvcm1lcikge1xyXG4gICAgdm5vZGVBcmdzVHJhbnNmb3JtZXIgPSB0cmFuc2Zvcm1lcjtcclxufVxyXG5jb25zdCBjcmVhdGVWTm9kZVdpdGhBcmdzVHJhbnNmb3JtID0gKC4uLmFyZ3MpID0+IHtcclxuICAgIHJldHVybiBfY3JlYXRlVk5vZGUoLi4uKHZub2RlQXJnc1RyYW5zZm9ybWVyXHJcbiAgICAgICAgPyB2bm9kZUFyZ3NUcmFuc2Zvcm1lcihhcmdzLCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpXHJcbiAgICAgICAgOiBhcmdzKSk7XHJcbn07XHJcbmNvbnN0IEludGVybmFsT2JqZWN0S2V5ID0gYF9fdkludGVybmFsYDtcclxuY29uc3Qgbm9ybWFsaXplS2V5ID0gKHsga2V5IH0pID0+IGtleSAhPSBudWxsID8ga2V5IDogbnVsbDtcclxuY29uc3Qgbm9ybWFsaXplUmVmID0gKHsgcmVmLCByZWZfa2V5LCByZWZfZm9yIH0pID0+IHtcclxuICAgIHJldHVybiAocmVmICE9IG51bGxcclxuICAgICAgICA/IGlzU3RyaW5nKHJlZikgfHwgaXNSZWYocmVmKSB8fCBpc0Z1bmN0aW9uKHJlZilcclxuICAgICAgICAgICAgPyB7IGk6IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSwgcjogcmVmLCBrOiByZWZfa2V5LCBmOiAhIXJlZl9mb3IgfVxyXG4gICAgICAgICAgICA6IHJlZlxyXG4gICAgICAgIDogbnVsbCk7XHJcbn07XHJcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VWTm9kZSh0eXBlLCBwcm9wcyA9IG51bGwsIGNoaWxkcmVuID0gbnVsbCwgcGF0Y2hGbGFnID0gMCwgZHluYW1pY1Byb3BzID0gbnVsbCwgc2hhcGVGbGFnID0gdHlwZSA9PT0gRnJhZ21lbnQgPyAwIDogMSAvKiBFTEVNRU5UICovLCBpc0Jsb2NrTm9kZSA9IGZhbHNlLCBuZWVkRnVsbENoaWxkcmVuTm9ybWFsaXphdGlvbiA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCB2bm9kZSA9IHtcclxuICAgICAgICBfX3ZfaXNWTm9kZTogdHJ1ZSxcclxuICAgICAgICBfX3Zfc2tpcDogdHJ1ZSxcclxuICAgICAgICB0eXBlLFxyXG4gICAgICAgIHByb3BzLFxyXG4gICAgICAgIGtleTogcHJvcHMgJiYgbm9ybWFsaXplS2V5KHByb3BzKSxcclxuICAgICAgICByZWY6IHByb3BzICYmIG5vcm1hbGl6ZVJlZihwcm9wcyksXHJcbiAgICAgICAgc2NvcGVJZDogY3VycmVudFNjb3BlSWQsXHJcbiAgICAgICAgc2xvdFNjb3BlSWRzOiBudWxsLFxyXG4gICAgICAgIGNoaWxkcmVuLFxyXG4gICAgICAgIGNvbXBvbmVudDogbnVsbCxcclxuICAgICAgICBzdXNwZW5zZTogbnVsbCxcclxuICAgICAgICBzc0NvbnRlbnQ6IG51bGwsXHJcbiAgICAgICAgc3NGYWxsYmFjazogbnVsbCxcclxuICAgICAgICBkaXJzOiBudWxsLFxyXG4gICAgICAgIHRyYW5zaXRpb246IG51bGwsXHJcbiAgICAgICAgZWw6IG51bGwsXHJcbiAgICAgICAgYW5jaG9yOiBudWxsLFxyXG4gICAgICAgIHRhcmdldDogbnVsbCxcclxuICAgICAgICB0YXJnZXRBbmNob3I6IG51bGwsXHJcbiAgICAgICAgc3RhdGljQ291bnQ6IDAsXHJcbiAgICAgICAgc2hhcGVGbGFnLFxyXG4gICAgICAgIHBhdGNoRmxhZyxcclxuICAgICAgICBkeW5hbWljUHJvcHMsXHJcbiAgICAgICAgZHluYW1pY0NoaWxkcmVuOiBudWxsLFxyXG4gICAgICAgIGFwcENvbnRleHQ6IG51bGxcclxuICAgIH07XHJcbiAgICBpZiAobmVlZEZ1bGxDaGlsZHJlbk5vcm1hbGl6YXRpb24pIHtcclxuICAgICAgICBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4pO1xyXG4gICAgICAgIC8vIG5vcm1hbGl6ZSBzdXNwZW5zZSBjaGlsZHJlblxyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICAgICAgdHlwZS5ub3JtYWxpemUodm5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNoaWxkcmVuKSB7XHJcbiAgICAgICAgLy8gY29tcGlsZWQgZWxlbWVudCB2bm9kZSAtIGlmIGNoaWxkcmVuIGlzIHBhc3NlZCwgb25seSBwb3NzaWJsZSB0eXBlcyBhcmVcclxuICAgICAgICAvLyBzdHJpbmcgb3IgQXJyYXkuXHJcbiAgICAgICAgdm5vZGUuc2hhcGVGbGFnIHw9IGlzU3RyaW5nKGNoaWxkcmVuKVxyXG4gICAgICAgICAgICA/IDggLyogVEVYVF9DSElMRFJFTiAqL1xyXG4gICAgICAgICAgICA6IDE2IC8qIEFSUkFZX0NISUxEUkVOICovO1xyXG4gICAgfVxyXG4gICAgLy8gdmFsaWRhdGUga2V5XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHZub2RlLmtleSAhPT0gdm5vZGUua2V5KSB7XHJcbiAgICAgICAgd2FybihgVk5vZGUgY3JlYXRlZCB3aXRoIGludmFsaWQga2V5IChOYU4pLiBWTm9kZSB0eXBlOmAsIHZub2RlLnR5cGUpO1xyXG4gICAgfVxyXG4gICAgLy8gdHJhY2sgdm5vZGUgZm9yIGJsb2NrIHRyZWVcclxuICAgIGlmIChpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwICYmXHJcbiAgICAgICAgLy8gYXZvaWQgYSBibG9jayBub2RlIGZyb20gdHJhY2tpbmcgaXRzZWxmXHJcbiAgICAgICAgIWlzQmxvY2tOb2RlICYmXHJcbiAgICAgICAgLy8gaGFzIGN1cnJlbnQgcGFyZW50IGJsb2NrXHJcbiAgICAgICAgY3VycmVudEJsb2NrICYmXHJcbiAgICAgICAgLy8gcHJlc2VuY2Ugb2YgYSBwYXRjaCBmbGFnIGluZGljYXRlcyB0aGlzIG5vZGUgbmVlZHMgcGF0Y2hpbmcgb24gdXBkYXRlcy5cclxuICAgICAgICAvLyBjb21wb25lbnQgbm9kZXMgYWxzbyBzaG91bGQgYWx3YXlzIGJlIHBhdGNoZWQsIGJlY2F1c2UgZXZlbiBpZiB0aGVcclxuICAgICAgICAvLyBjb21wb25lbnQgZG9lc24ndCBuZWVkIHRvIHVwZGF0ZSwgaXQgbmVlZHMgdG8gcGVyc2lzdCB0aGUgaW5zdGFuY2Ugb24gdG9cclxuICAgICAgICAvLyB0aGUgbmV4dCB2bm9kZSBzbyB0aGF0IGl0IGNhbiBiZSBwcm9wZXJseSB1bm1vdW50ZWQgbGF0ZXIuXHJcbiAgICAgICAgKHZub2RlLnBhdGNoRmxhZyA+IDAgfHwgc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8pICYmXHJcbiAgICAgICAgLy8gdGhlIEVWRU5UUyBmbGFnIGlzIG9ubHkgZm9yIGh5ZHJhdGlvbiBhbmQgaWYgaXQgaXMgdGhlIG9ubHkgZmxhZywgdGhlXHJcbiAgICAgICAgLy8gdm5vZGUgc2hvdWxkIG5vdCBiZSBjb25zaWRlcmVkIGR5bmFtaWMgZHVlIHRvIGhhbmRsZXIgY2FjaGluZy5cclxuICAgICAgICB2bm9kZS5wYXRjaEZsYWcgIT09IDMyIC8qIEhZRFJBVEVfRVZFTlRTICovKSB7XHJcbiAgICAgICAgY3VycmVudEJsb2NrLnB1c2godm5vZGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZub2RlO1xyXG59XHJcbmNvbnN0IGNyZWF0ZVZOb2RlID0gKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGNyZWF0ZVZOb2RlV2l0aEFyZ3NUcmFuc2Zvcm0gOiBfY3JlYXRlVk5vZGUpO1xyXG5mdW5jdGlvbiBfY3JlYXRlVk5vZGUodHlwZSwgcHJvcHMgPSBudWxsLCBjaGlsZHJlbiA9IG51bGwsIHBhdGNoRmxhZyA9IDAsIGR5bmFtaWNQcm9wcyA9IG51bGwsIGlzQmxvY2tOb2RlID0gZmFsc2UpIHtcclxuICAgIGlmICghdHlwZSB8fCB0eXBlID09PSBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhdHlwZSkge1xyXG4gICAgICAgICAgICB3YXJuKGBJbnZhbGlkIHZub2RlIHR5cGUgd2hlbiBjcmVhdGluZyB2bm9kZTogJHt0eXBlfS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHlwZSA9IENvbW1lbnQ7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNWTm9kZSh0eXBlKSkge1xyXG4gICAgICAgIC8vIGNyZWF0ZVZOb2RlIHJlY2VpdmluZyBhbiBleGlzdGluZyB2bm9kZS4gVGhpcyBoYXBwZW5zIGluIGNhc2VzIGxpa2VcclxuICAgICAgICAvLyA8Y29tcG9uZW50IDppcz1cInZub2RlXCIvPlxyXG4gICAgICAgIC8vICMyMDc4IG1ha2Ugc3VyZSB0byBtZXJnZSByZWZzIGR1cmluZyB0aGUgY2xvbmUgaW5zdGVhZCBvZiBvdmVyd3JpdGluZyBpdFxyXG4gICAgICAgIGNvbnN0IGNsb25lZCA9IGNsb25lVk5vZGUodHlwZSwgcHJvcHMsIHRydWUgLyogbWVyZ2VSZWY6IHRydWUgKi8pO1xyXG4gICAgICAgIGlmIChjaGlsZHJlbikge1xyXG4gICAgICAgICAgICBub3JtYWxpemVDaGlsZHJlbihjbG9uZWQsIGNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNsb25lZDtcclxuICAgIH1cclxuICAgIC8vIGNsYXNzIGNvbXBvbmVudCBub3JtYWxpemF0aW9uLlxyXG4gICAgaWYgKGlzQ2xhc3NDb21wb25lbnQodHlwZSkpIHtcclxuICAgICAgICB0eXBlID0gdHlwZS5fX3ZjY09wdHM7XHJcbiAgICB9XHJcbiAgICAvLyBjbGFzcyAmIHN0eWxlIG5vcm1hbGl6YXRpb24uXHJcbiAgICBpZiAocHJvcHMpIHtcclxuICAgICAgICAvLyBmb3IgcmVhY3RpdmUgb3IgcHJveHkgb2JqZWN0cywgd2UgbmVlZCB0byBjbG9uZSBpdCB0byBlbmFibGUgbXV0YXRpb24uXHJcbiAgICAgICAgcHJvcHMgPSBndWFyZFJlYWN0aXZlUHJvcHMocHJvcHMpO1xyXG4gICAgICAgIGxldCB7IGNsYXNzOiBrbGFzcywgc3R5bGUgfSA9IHByb3BzO1xyXG4gICAgICAgIGlmIChrbGFzcyAmJiAhaXNTdHJpbmcoa2xhc3MpKSB7XHJcbiAgICAgICAgICAgIHByb3BzLmNsYXNzID0gbm9ybWFsaXplQ2xhc3Moa2xhc3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNPYmplY3Qoc3R5bGUpKSB7XHJcbiAgICAgICAgICAgIC8vIHJlYWN0aXZlIHN0YXRlIG9iamVjdHMgbmVlZCB0byBiZSBjbG9uZWQgc2luY2UgdGhleSBhcmUgbGlrZWx5IHRvIGJlXHJcbiAgICAgICAgICAgIC8vIG11dGF0ZWRcclxuICAgICAgICAgICAgaWYgKGlzUHJveHkoc3R5bGUpICYmICFpc0FycmF5KHN0eWxlKSkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGUgPSBleHRlbmQoe30sIHN0eWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwcm9wcy5zdHlsZSA9IG5vcm1hbGl6ZVN0eWxlKHN0eWxlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBlbmNvZGUgdGhlIHZub2RlIHR5cGUgaW5mb3JtYXRpb24gaW50byBhIGJpdG1hcFxyXG4gICAgY29uc3Qgc2hhcGVGbGFnID0gaXNTdHJpbmcodHlwZSlcclxuICAgICAgICA/IDEgLyogRUxFTUVOVCAqL1xyXG4gICAgICAgIDogaXNTdXNwZW5zZSh0eXBlKVxyXG4gICAgICAgICAgICA/IDEyOCAvKiBTVVNQRU5TRSAqL1xyXG4gICAgICAgICAgICA6IGlzVGVsZXBvcnQodHlwZSlcclxuICAgICAgICAgICAgICAgID8gNjQgLyogVEVMRVBPUlQgKi9cclxuICAgICAgICAgICAgICAgIDogaXNPYmplY3QodHlwZSlcclxuICAgICAgICAgICAgICAgICAgICA/IDQgLyogU1RBVEVGVUxfQ09NUE9ORU5UICovXHJcbiAgICAgICAgICAgICAgICAgICAgOiBpc0Z1bmN0aW9uKHR5cGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gMiAvKiBGVU5DVElPTkFMX0NPTVBPTkVOVCAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDA7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHNoYXBlRmxhZyAmIDQgLyogU1RBVEVGVUxfQ09NUE9ORU5UICovICYmIGlzUHJveHkodHlwZSkpIHtcclxuICAgICAgICB0eXBlID0gdG9SYXcodHlwZSk7XHJcbiAgICAgICAgd2FybihgVnVlIHJlY2VpdmVkIGEgQ29tcG9uZW50IHdoaWNoIHdhcyBtYWRlIGEgcmVhY3RpdmUgb2JqZWN0LiBUaGlzIGNhbiBgICtcclxuICAgICAgICAgICAgYGxlYWQgdG8gdW5uZWNlc3NhcnkgcGVyZm9ybWFuY2Ugb3ZlcmhlYWQsIGFuZCBzaG91bGQgYmUgYXZvaWRlZCBieSBgICtcclxuICAgICAgICAgICAgYG1hcmtpbmcgdGhlIGNvbXBvbmVudCB3aXRoIFxcYG1hcmtSYXdcXGAgb3IgdXNpbmcgXFxgc2hhbGxvd1JlZlxcYCBgICtcclxuICAgICAgICAgICAgYGluc3RlYWQgb2YgXFxgcmVmXFxgLmAsIGBcXG5Db21wb25lbnQgdGhhdCB3YXMgbWFkZSByZWFjdGl2ZTogYCwgdHlwZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3JlYXRlQmFzZVZOb2RlKHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMsIHNoYXBlRmxhZywgaXNCbG9ja05vZGUsIHRydWUpO1xyXG59XHJcbmZ1bmN0aW9uIGd1YXJkUmVhY3RpdmVQcm9wcyhwcm9wcykge1xyXG4gICAgaWYgKCFwcm9wcylcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIHJldHVybiBpc1Byb3h5KHByb3BzKSB8fCBJbnRlcm5hbE9iamVjdEtleSBpbiBwcm9wc1xyXG4gICAgICAgID8gZXh0ZW5kKHt9LCBwcm9wcylcclxuICAgICAgICA6IHByb3BzO1xyXG59XHJcbmZ1bmN0aW9uIGNsb25lVk5vZGUodm5vZGUsIGV4dHJhUHJvcHMsIG1lcmdlUmVmID0gZmFsc2UpIHtcclxuICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBOT1QgdXNpbmcgc3ByZWFkIG9yIGV4dGVuZCB0byBhdm9pZCB0aGUgcnVudGltZVxyXG4gICAgLy8ga2V5IGVudW1lcmF0aW9uIGNvc3QuXHJcbiAgICBjb25zdCB7IHByb3BzLCByZWYsIHBhdGNoRmxhZywgY2hpbGRyZW4gfSA9IHZub2RlO1xyXG4gICAgY29uc3QgbWVyZ2VkUHJvcHMgPSBleHRyYVByb3BzID8gbWVyZ2VQcm9wcyhwcm9wcyB8fCB7fSwgZXh0cmFQcm9wcykgOiBwcm9wcztcclxuICAgIGNvbnN0IGNsb25lZCA9IHtcclxuICAgICAgICBfX3ZfaXNWTm9kZTogdHJ1ZSxcclxuICAgICAgICBfX3Zfc2tpcDogdHJ1ZSxcclxuICAgICAgICB0eXBlOiB2bm9kZS50eXBlLFxyXG4gICAgICAgIHByb3BzOiBtZXJnZWRQcm9wcyxcclxuICAgICAgICBrZXk6IG1lcmdlZFByb3BzICYmIG5vcm1hbGl6ZUtleShtZXJnZWRQcm9wcyksXHJcbiAgICAgICAgcmVmOiBleHRyYVByb3BzICYmIGV4dHJhUHJvcHMucmVmXHJcbiAgICAgICAgICAgID8gLy8gIzIwNzggaW4gdGhlIGNhc2Ugb2YgPGNvbXBvbmVudCA6aXM9XCJ2bm9kZVwiIHJlZj1cImV4dHJhXCIvPlxyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHZub2RlIGl0c2VsZiBhbHJlYWR5IGhhcyBhIHJlZiwgY2xvbmVWTm9kZSB3aWxsIG5lZWQgdG8gbWVyZ2VcclxuICAgICAgICAgICAgICAgIC8vIHRoZSByZWZzIHNvIHRoZSBzaW5nbGUgdm5vZGUgY2FuIGJlIHNldCBvbiBtdWx0aXBsZSByZWZzXHJcbiAgICAgICAgICAgICAgICBtZXJnZVJlZiAmJiByZWZcclxuICAgICAgICAgICAgICAgICAgICA/IGlzQXJyYXkocmVmKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlZi5jb25jYXQobm9ybWFsaXplUmVmKGV4dHJhUHJvcHMpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtyZWYsIG5vcm1hbGl6ZVJlZihleHRyYVByb3BzKV1cclxuICAgICAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVJlZihleHRyYVByb3BzKVxyXG4gICAgICAgICAgICA6IHJlZixcclxuICAgICAgICBzY29wZUlkOiB2bm9kZS5zY29wZUlkLFxyXG4gICAgICAgIHNsb3RTY29wZUlkczogdm5vZGUuc2xvdFNjb3BlSWRzLFxyXG4gICAgICAgIGNoaWxkcmVuOiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgcGF0Y2hGbGFnID09PSAtMSAvKiBIT0lTVEVEICovICYmIGlzQXJyYXkoY2hpbGRyZW4pXHJcbiAgICAgICAgICAgID8gY2hpbGRyZW4ubWFwKGRlZXBDbG9uZVZOb2RlKVxyXG4gICAgICAgICAgICA6IGNoaWxkcmVuLFxyXG4gICAgICAgIHRhcmdldDogdm5vZGUudGFyZ2V0LFxyXG4gICAgICAgIHRhcmdldEFuY2hvcjogdm5vZGUudGFyZ2V0QW5jaG9yLFxyXG4gICAgICAgIHN0YXRpY0NvdW50OiB2bm9kZS5zdGF0aWNDb3VudCxcclxuICAgICAgICBzaGFwZUZsYWc6IHZub2RlLnNoYXBlRmxhZyxcclxuICAgICAgICAvLyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIHdpdGggZXh0cmEgcHJvcHMsIHdlIGNhbiBubyBsb25nZXIgYXNzdW1lIGl0c1xyXG4gICAgICAgIC8vIGV4aXN0aW5nIHBhdGNoIGZsYWcgdG8gYmUgcmVsaWFibGUgYW5kIG5lZWQgdG8gYWRkIHRoZSBGVUxMX1BST1BTIGZsYWcuXHJcbiAgICAgICAgLy8gbm90ZTogcHJlc2VydmUgZmxhZyBmb3IgZnJhZ21lbnRzIHNpbmNlIHRoZXkgdXNlIHRoZSBmbGFnIGZvciBjaGlsZHJlblxyXG4gICAgICAgIC8vIGZhc3QgcGF0aHMgb25seS5cclxuICAgICAgICBwYXRjaEZsYWc6IGV4dHJhUHJvcHMgJiYgdm5vZGUudHlwZSAhPT0gRnJhZ21lbnRcclxuICAgICAgICAgICAgPyBwYXRjaEZsYWcgPT09IC0xIC8vIGhvaXN0ZWQgbm9kZVxyXG4gICAgICAgICAgICAgICAgPyAxNiAvKiBGVUxMX1BST1BTICovXHJcbiAgICAgICAgICAgICAgICA6IHBhdGNoRmxhZyB8IDE2IC8qIEZVTExfUFJPUFMgKi9cclxuICAgICAgICAgICAgOiBwYXRjaEZsYWcsXHJcbiAgICAgICAgZHluYW1pY1Byb3BzOiB2bm9kZS5keW5hbWljUHJvcHMsXHJcbiAgICAgICAgZHluYW1pY0NoaWxkcmVuOiB2bm9kZS5keW5hbWljQ2hpbGRyZW4sXHJcbiAgICAgICAgYXBwQ29udGV4dDogdm5vZGUuYXBwQ29udGV4dCxcclxuICAgICAgICBkaXJzOiB2bm9kZS5kaXJzLFxyXG4gICAgICAgIHRyYW5zaXRpb246IHZub2RlLnRyYW5zaXRpb24sXHJcbiAgICAgICAgLy8gVGhlc2Ugc2hvdWxkIHRlY2huaWNhbGx5IG9ubHkgYmUgbm9uLW51bGwgb24gbW91bnRlZCBWTm9kZXMuIEhvd2V2ZXIsXHJcbiAgICAgICAgLy8gdGhleSAqc2hvdWxkKiBiZSBjb3BpZWQgZm9yIGtlcHQtYWxpdmUgdm5vZGVzLiBTbyB3ZSBqdXN0IGFsd2F5cyBjb3B5XHJcbiAgICAgICAgLy8gdGhlbSBzaW5jZSB0aGVtIGJlaW5nIG5vbi1udWxsIGR1cmluZyBhIG1vdW50IGRvZXNuJ3QgYWZmZWN0IHRoZSBsb2dpYyBhc1xyXG4gICAgICAgIC8vIHRoZXkgd2lsbCBzaW1wbHkgYmUgb3ZlcndyaXR0ZW4uXHJcbiAgICAgICAgY29tcG9uZW50OiB2bm9kZS5jb21wb25lbnQsXHJcbiAgICAgICAgc3VzcGVuc2U6IHZub2RlLnN1c3BlbnNlLFxyXG4gICAgICAgIHNzQ29udGVudDogdm5vZGUuc3NDb250ZW50ICYmIGNsb25lVk5vZGUodm5vZGUuc3NDb250ZW50KSxcclxuICAgICAgICBzc0ZhbGxiYWNrOiB2bm9kZS5zc0ZhbGxiYWNrICYmIGNsb25lVk5vZGUodm5vZGUuc3NGYWxsYmFjayksXHJcbiAgICAgICAgZWw6IHZub2RlLmVsLFxyXG4gICAgICAgIGFuY2hvcjogdm5vZGUuYW5jaG9yXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGNsb25lZDtcclxufVxyXG4vKipcclxuICogRGV2IG9ubHksIGZvciBITVIgb2YgaG9pc3RlZCB2bm9kZXMgcmV1c2VkIGluIHYtZm9yXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS92aXRlanMvdml0ZS9pc3N1ZXMvMjAyMlxyXG4gKi9cclxuZnVuY3Rpb24gZGVlcENsb25lVk5vZGUodm5vZGUpIHtcclxuICAgIGNvbnN0IGNsb25lZCA9IGNsb25lVk5vZGUodm5vZGUpO1xyXG4gICAgaWYgKGlzQXJyYXkodm5vZGUuY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgY2xvbmVkLmNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW4ubWFwKGRlZXBDbG9uZVZOb2RlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjbG9uZWQ7XHJcbn1cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUodGV4dCA9ICcgJywgZmxhZyA9IDApIHtcclxuICAgIHJldHVybiBjcmVhdGVWTm9kZShUZXh0LCBudWxsLCB0ZXh0LCBmbGFnKTtcclxufVxyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY1ZOb2RlKGNvbnRlbnQsIG51bWJlck9mTm9kZXMpIHtcclxuICAgIC8vIEEgc3RhdGljIHZub2RlIGNhbiBjb250YWluIG11bHRpcGxlIHN0cmluZ2lmaWVkIGVsZW1lbnRzLCBhbmQgdGhlIG51bWJlclxyXG4gICAgLy8gb2YgZWxlbWVudHMgaXMgbmVjZXNzYXJ5IGZvciBoeWRyYXRpb24uXHJcbiAgICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKFN0YXRpYywgbnVsbCwgY29udGVudCk7XHJcbiAgICB2bm9kZS5zdGF0aWNDb3VudCA9IG51bWJlck9mTm9kZXM7XHJcbiAgICByZXR1cm4gdm5vZGU7XHJcbn1cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVDb21tZW50Vk5vZGUodGV4dCA9ICcnLCBcclxuLy8gd2hlbiB1c2VkIGFzIHRoZSB2LWVsc2UgYnJhbmNoLCB0aGUgY29tbWVudCBub2RlIG11c3QgYmUgY3JlYXRlZCBhcyBhXHJcbi8vIGJsb2NrIHRvIGVuc3VyZSBjb3JyZWN0IHVwZGF0ZXMuXHJcbmFzQmxvY2sgPSBmYWxzZSkge1xyXG4gICAgcmV0dXJuIGFzQmxvY2tcclxuICAgICAgICA/IChvcGVuQmxvY2soKSwgY3JlYXRlQmxvY2soQ29tbWVudCwgbnVsbCwgdGV4dCkpXHJcbiAgICAgICAgOiBjcmVhdGVWTm9kZShDb21tZW50LCBudWxsLCB0ZXh0KTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVWTm9kZShjaGlsZCkge1xyXG4gICAgaWYgKGNoaWxkID09IG51bGwgfHwgdHlwZW9mIGNoaWxkID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAvLyBlbXB0eSBwbGFjZWhvbGRlclxyXG4gICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShDb21tZW50KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzQXJyYXkoY2hpbGQpKSB7XHJcbiAgICAgICAgLy8gZnJhZ21lbnRcclxuICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUoRnJhZ21lbnQsIG51bGwsIFxyXG4gICAgICAgIC8vICMzNjY2LCBhdm9pZCByZWZlcmVuY2UgcG9sbHV0aW9uIHdoZW4gcmV1c2luZyB2bm9kZVxyXG4gICAgICAgIGNoaWxkLnNsaWNlKCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGNoaWxkID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIC8vIGFscmVhZHkgdm5vZGUsIHRoaXMgc2hvdWxkIGJlIHRoZSBtb3N0IGNvbW1vbiBzaW5jZSBjb21waWxlZCB0ZW1wbGF0ZXNcclxuICAgICAgICAvLyBhbHdheXMgcHJvZHVjZSBhbGwtdm5vZGUgY2hpbGRyZW4gYXJyYXlzXHJcbiAgICAgICAgcmV0dXJuIGNsb25lSWZNb3VudGVkKGNoaWxkKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIHN0cmluZ3MgYW5kIG51bWJlcnNcclxuICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUoVGV4dCwgbnVsbCwgU3RyaW5nKGNoaWxkKSk7XHJcbiAgICB9XHJcbn1cclxuLy8gb3B0aW1pemVkIG5vcm1hbGl6YXRpb24gZm9yIHRlbXBsYXRlLWNvbXBpbGVkIHJlbmRlciBmbnNcclxuZnVuY3Rpb24gY2xvbmVJZk1vdW50ZWQoY2hpbGQpIHtcclxuICAgIHJldHVybiBjaGlsZC5lbCA9PT0gbnVsbCB8fCBjaGlsZC5tZW1vID8gY2hpbGQgOiBjbG9uZVZOb2RlKGNoaWxkKTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4pIHtcclxuICAgIGxldCB0eXBlID0gMDtcclxuICAgIGNvbnN0IHsgc2hhcGVGbGFnIH0gPSB2bm9kZTtcclxuICAgIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XHJcbiAgICAgICAgY2hpbGRyZW4gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcclxuICAgICAgICB0eXBlID0gMTYgLyogQVJSQVlfQ0hJTERSRU4gKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmICgxIC8qIEVMRU1FTlQgKi8gfCA2NCAvKiBURUxFUE9SVCAqLykpIHtcclxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIHNsb3QgdG8gcGxhaW4gY2hpbGRyZW4gZm9yIHBsYWluIGVsZW1lbnQgYW5kIFRlbGVwb3J0XHJcbiAgICAgICAgICAgIGNvbnN0IHNsb3QgPSBjaGlsZHJlbi5kZWZhdWx0O1xyXG4gICAgICAgICAgICBpZiAoc2xvdCkge1xyXG4gICAgICAgICAgICAgICAgLy8gX2MgbWFya2VyIGlzIGFkZGVkIGJ5IHdpdGhDdHgoKSBpbmRpY2F0aW5nIHRoaXMgaXMgYSBjb21waWxlZCBzbG90XHJcbiAgICAgICAgICAgICAgICBzbG90Ll9jICYmIChzbG90Ll9kID0gZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUsIHNsb3QoKSk7XHJcbiAgICAgICAgICAgICAgICBzbG90Ll9jICYmIChzbG90Ll9kID0gdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdHlwZSA9IDMyIC8qIFNMT1RTX0NISUxEUkVOICovO1xyXG4gICAgICAgICAgICBjb25zdCBzbG90RmxhZyA9IGNoaWxkcmVuLl87XHJcbiAgICAgICAgICAgIGlmICghc2xvdEZsYWcgJiYgIShJbnRlcm5hbE9iamVjdEtleSBpbiBjaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLl9jdHggPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2xvdEZsYWcgPT09IDMgLyogRk9SV0FSREVEICovICYmIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gYSBjaGlsZCBjb21wb25lbnQgcmVjZWl2ZXMgZm9yd2FyZGVkIHNsb3RzIGZyb20gdGhlIHBhcmVudC5cclxuICAgICAgICAgICAgICAgIC8vIGl0cyBzbG90IHR5cGUgaXMgZGV0ZXJtaW5lZCBieSBpdHMgcGFyZW50J3Mgc2xvdCB0eXBlLlxyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5zbG90cy5fID09PSAxIC8qIFNUQUJMRSAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLl8gPSAxIC8qIFNUQUJMRSAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLl8gPSAyIC8qIERZTkFNSUMgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgdm5vZGUucGF0Y2hGbGFnIHw9IDEwMjQgLyogRFlOQU1JQ19TTE9UUyAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgY2hpbGRyZW4gPSB7IGRlZmF1bHQ6IGNoaWxkcmVuLCBfY3R4OiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgfTtcclxuICAgICAgICB0eXBlID0gMzIgLyogU0xPVFNfQ0hJTERSRU4gKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjaGlsZHJlbiA9IFN0cmluZyhjaGlsZHJlbik7XHJcbiAgICAgICAgLy8gZm9yY2UgdGVsZXBvcnQgY2hpbGRyZW4gdG8gYXJyYXkgc28gaXQgY2FuIGJlIG1vdmVkIGFyb3VuZFxyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiA2NCAvKiBURUxFUE9SVCAqLykge1xyXG4gICAgICAgICAgICB0eXBlID0gMTYgLyogQVJSQVlfQ0hJTERSRU4gKi87XHJcbiAgICAgICAgICAgIGNoaWxkcmVuID0gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdHlwZSA9IDggLyogVEVYVF9DSElMRFJFTiAqLztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2bm9kZS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgdm5vZGUuc2hhcGVGbGFnIHw9IHR5cGU7XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VQcm9wcyguLi5hcmdzKSB7XHJcbiAgICBjb25zdCByZXQgPSB7fTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHRvTWVyZ2UgPSBhcmdzW2ldO1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRvTWVyZ2UpIHtcclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJldC5jbGFzcyAhPT0gdG9NZXJnZS5jbGFzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldC5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKFtyZXQuY2xhc3MsIHRvTWVyZ2UuY2xhc3NdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdzdHlsZScpIHtcclxuICAgICAgICAgICAgICAgIHJldC5zdHlsZSA9IG5vcm1hbGl6ZVN0eWxlKFtyZXQuc3R5bGUsIHRvTWVyZ2Uuc3R5bGVdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc09uKGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gcmV0W2tleV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmNvbWluZyA9IHRvTWVyZ2Vba2V5XTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmNvbWluZyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nICE9PSBpbmNvbWluZyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICEoaXNBcnJheShleGlzdGluZykgJiYgZXhpc3RpbmcuaW5jbHVkZXMoaW5jb21pbmcpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldFtrZXldID0gZXhpc3RpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGluY29taW5nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGluY29taW5nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgIHJldFtrZXldID0gdG9NZXJnZVtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxufVxyXG5mdW5jdGlvbiBpbnZva2VWTm9kZUhvb2soaG9vaywgaW5zdGFuY2UsIHZub2RlLCBwcmV2Vk5vZGUgPSBudWxsKSB7XHJcbiAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCBpbnN0YW5jZSwgNyAvKiBWTk9ERV9IT09LICovLCBbXHJcbiAgICAgICAgdm5vZGUsXHJcbiAgICAgICAgcHJldlZOb2RlXHJcbiAgICBdKTtcclxufVxuXG4vKipcclxuICogQWN0dWFsIGltcGxlbWVudGF0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiByZW5kZXJMaXN0KHNvdXJjZSwgcmVuZGVySXRlbSwgY2FjaGUsIGluZGV4KSB7XHJcbiAgICBsZXQgcmV0O1xyXG4gICAgY29uc3QgY2FjaGVkID0gKGNhY2hlICYmIGNhY2hlW2luZGV4XSk7XHJcbiAgICBpZiAoaXNBcnJheShzb3VyY2UpIHx8IGlzU3RyaW5nKHNvdXJjZSkpIHtcclxuICAgICAgICByZXQgPSBuZXcgQXJyYXkoc291cmNlLmxlbmd0aCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBzb3VyY2UubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oc291cmNlW2ldLCBpLCB1bmRlZmluZWQsIGNhY2hlZCAmJiBjYWNoZWRbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhTnVtYmVyLmlzSW50ZWdlcihzb3VyY2UpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYFRoZSB2LWZvciByYW5nZSBleHBlY3QgYW4gaW50ZWdlciB2YWx1ZSBidXQgZ290ICR7c291cmNlfS5gKTtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXQgPSBuZXcgQXJyYXkoc291cmNlKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oaSArIDEsIGksIHVuZGVmaW5lZCwgY2FjaGVkICYmIGNhY2hlZFtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3Qoc291cmNlKSkge1xyXG4gICAgICAgIGlmIChzb3VyY2VbU3ltYm9sLml0ZXJhdG9yXSkge1xyXG4gICAgICAgICAgICByZXQgPSBBcnJheS5mcm9tKHNvdXJjZSwgKGl0ZW0sIGkpID0+IHJlbmRlckl0ZW0oaXRlbSwgaSwgdW5kZWZpbmVkLCBjYWNoZWQgJiYgY2FjaGVkW2ldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcclxuICAgICAgICAgICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcclxuICAgICAgICAgICAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oc291cmNlW2tleV0sIGtleSwgaSwgY2FjaGVkICYmIGNhY2hlZFtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXQgPSBbXTtcclxuICAgIH1cclxuICAgIGlmIChjYWNoZSkge1xyXG4gICAgICAgIGNhY2hlW2luZGV4XSA9IHJldDtcclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbn1cblxuLyoqXHJcbiAqIENvbXBpbGVyIHJ1bnRpbWUgaGVscGVyIGZvciBjcmVhdGluZyBkeW5hbWljIHNsb3RzIG9iamVjdFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlU2xvdHMoc2xvdHMsIGR5bmFtaWNTbG90cykge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkeW5hbWljU2xvdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBzbG90ID0gZHluYW1pY1Nsb3RzW2ldO1xyXG4gICAgICAgIC8vIGFycmF5IG9mIGR5bmFtaWMgc2xvdCBnZW5lcmF0ZWQgYnkgPHRlbXBsYXRlIHYtZm9yPVwiLi4uXCIgI1suLi5dPlxyXG4gICAgICAgIGlmIChpc0FycmF5KHNsb3QpKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2xvdC5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgc2xvdHNbc2xvdFtqXS5uYW1lXSA9IHNsb3Rbal0uZm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2xvdCkge1xyXG4gICAgICAgICAgICAvLyBjb25kaXRpb25hbCBzaW5nbGUgc2xvdCBnZW5lcmF0ZWQgYnkgPHRlbXBsYXRlIHYtaWY9XCIuLi5cIiAjZm9vPlxyXG4gICAgICAgICAgICBzbG90c1tzbG90Lm5hbWVdID0gc2xvdC5mbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2xvdHM7XHJcbn1cblxuLyoqXHJcbiAqIENvbXBpbGVyIHJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgYDxzbG90Lz5gXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiByZW5kZXJTbG90KHNsb3RzLCBuYW1lLCBwcm9wcyA9IHt9LCBcclxuLy8gdGhpcyBpcyBub3QgYSB1c2VyLWZhY2luZyBmdW5jdGlvbiwgc28gdGhlIGZhbGxiYWNrIGlzIGFsd2F5cyBnZW5lcmF0ZWQgYnlcclxuLy8gdGhlIGNvbXBpbGVyIGFuZCBndWFyYW50ZWVkIHRvIGJlIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGFuIGFycmF5XHJcbmZhbGxiYWNrLCBub1Nsb3R0ZWQpIHtcclxuICAgIGlmIChjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UuaXNDRSkge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSgnc2xvdCcsIG5hbWUgPT09ICdkZWZhdWx0JyA/IG51bGwgOiB7IG5hbWUgfSwgZmFsbGJhY2sgJiYgZmFsbGJhY2soKSk7XHJcbiAgICB9XHJcbiAgICBsZXQgc2xvdCA9IHNsb3RzW25hbWVdO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBzbG90ICYmIHNsb3QubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIHdhcm4oYFNTUi1vcHRpbWl6ZWQgc2xvdCBmdW5jdGlvbiBkZXRlY3RlZCBpbiBhIG5vbi1TU1Itb3B0aW1pemVkIHJlbmRlciBgICtcclxuICAgICAgICAgICAgYGZ1bmN0aW9uLiBZb3UgbmVlZCB0byBtYXJrIHRoaXMgY29tcG9uZW50IHdpdGggJGR5bmFtaWMtc2xvdHMgaW4gdGhlIGAgK1xyXG4gICAgICAgICAgICBgcGFyZW50IHRlbXBsYXRlLmApO1xyXG4gICAgICAgIHNsb3QgPSAoKSA9PiBbXTtcclxuICAgIH1cclxuICAgIC8vIGEgY29tcGlsZWQgc2xvdCBkaXNhYmxlcyBibG9jayB0cmFja2luZyBieSBkZWZhdWx0IHRvIGF2b2lkIG1hbnVhbFxyXG4gICAgLy8gaW52b2NhdGlvbiBpbnRlcmZlcmluZyB3aXRoIHRlbXBsYXRlLWJhc2VkIGJsb2NrIHRyYWNraW5nLCBidXQgaW5cclxuICAgIC8vIGByZW5kZXJTbG90YCB3ZSBjYW4gYmUgc3VyZSB0aGF0IGl0J3MgdGVtcGxhdGUtYmFzZWQgc28gd2UgY2FuIGZvcmNlXHJcbiAgICAvLyBlbmFibGUgaXQuXHJcbiAgICBpZiAoc2xvdCAmJiBzbG90Ll9jKSB7XHJcbiAgICAgICAgc2xvdC5fZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgb3BlbkJsb2NrKCk7XHJcbiAgICBjb25zdCB2YWxpZFNsb3RDb250ZW50ID0gc2xvdCAmJiBlbnN1cmVWYWxpZFZOb2RlKHNsb3QocHJvcHMpKTtcclxuICAgIGNvbnN0IHJlbmRlcmVkID0gY3JlYXRlQmxvY2soRnJhZ21lbnQsIHsga2V5OiBwcm9wcy5rZXkgfHwgYF8ke25hbWV9YCB9LCB2YWxpZFNsb3RDb250ZW50IHx8IChmYWxsYmFjayA/IGZhbGxiYWNrKCkgOiBbXSksIHZhbGlkU2xvdENvbnRlbnQgJiYgc2xvdHMuXyA9PT0gMSAvKiBTVEFCTEUgKi9cclxuICAgICAgICA/IDY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqL1xyXG4gICAgICAgIDogLTIgLyogQkFJTCAqLyk7XHJcbiAgICBpZiAoIW5vU2xvdHRlZCAmJiByZW5kZXJlZC5zY29wZUlkKSB7XHJcbiAgICAgICAgcmVuZGVyZWQuc2xvdFNjb3BlSWRzID0gW3JlbmRlcmVkLnNjb3BlSWQgKyAnLXMnXTtcclxuICAgIH1cclxuICAgIGlmIChzbG90ICYmIHNsb3QuX2MpIHtcclxuICAgICAgICBzbG90Ll9kID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiByZW5kZXJlZDtcclxufVxyXG5mdW5jdGlvbiBlbnN1cmVWYWxpZFZOb2RlKHZub2Rlcykge1xyXG4gICAgcmV0dXJuIHZub2Rlcy5zb21lKGNoaWxkID0+IHtcclxuICAgICAgICBpZiAoIWlzVk5vZGUoY2hpbGQpKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gQ29tbWVudClcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSBGcmFnbWVudCAmJlxyXG4gICAgICAgICAgICAhZW5zdXJlVmFsaWRWTm9kZShjaGlsZC5jaGlsZHJlbikpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0pXHJcbiAgICAgICAgPyB2bm9kZXNcclxuICAgICAgICA6IG51bGw7XHJcbn1cblxuLyoqXHJcbiAqIEZvciBwcmVmaXhpbmcga2V5cyBpbiB2LW9uPVwib2JqXCIgd2l0aCBcIm9uXCJcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHRvSGFuZGxlcnMob2JqKSB7XHJcbiAgICBjb25zdCByZXQgPSB7fTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzT2JqZWN0KG9iaikpIHtcclxuICAgICAgICB3YXJuKGB2LW9uIHdpdGggbm8gYXJndW1lbnQgZXhwZWN0cyBhbiBvYmplY3QgdmFsdWUuYCk7XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xyXG4gICAgICAgIHJldFt0b0hhbmRsZXJLZXkoa2V5KV0gPSBvYmpba2V5XTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbn1cblxuLyoqXHJcbiAqICMyNDM3IEluIFZ1ZSAzLCBmdW5jdGlvbmFsIGNvbXBvbmVudHMgZG8gbm90IGhhdmUgYSBwdWJsaWMgaW5zdGFuY2UgcHJveHkgYnV0XHJcbiAqIHRoZXkgZXhpc3QgaW4gdGhlIGludGVybmFsIHBhcmVudCBjaGFpbi4gRm9yIGNvZGUgdGhhdCByZWxpZXMgb24gdHJhdmVyc2luZ1xyXG4gKiBwdWJsaWMgJHBhcmVudCBjaGFpbnMsIHNraXAgZnVuY3Rpb25hbCBvbmVzIGFuZCBnbyB0byB0aGUgcGFyZW50IGluc3RlYWQuXHJcbiAqL1xyXG5jb25zdCBnZXRQdWJsaWNJbnN0YW5jZSA9IChpKSA9PiB7XHJcbiAgICBpZiAoIWkpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICBpZiAoaXNTdGF0ZWZ1bENvbXBvbmVudChpKSlcclxuICAgICAgICByZXR1cm4gZ2V0RXhwb3NlUHJveHkoaSkgfHwgaS5wcm94eTtcclxuICAgIHJldHVybiBnZXRQdWJsaWNJbnN0YW5jZShpLnBhcmVudCk7XHJcbn07XHJcbmNvbnN0IHB1YmxpY1Byb3BlcnRpZXNNYXAgPSBleHRlbmQoT2JqZWN0LmNyZWF0ZShudWxsKSwge1xyXG4gICAgJDogaSA9PiBpLFxyXG4gICAgJGVsOiBpID0+IGkudm5vZGUuZWwsXHJcbiAgICAkZGF0YTogaSA9PiBpLmRhdGEsXHJcbiAgICAkcHJvcHM6IGkgPT4gKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IHNoYWxsb3dSZWFkb25seShpLnByb3BzKSA6IGkucHJvcHMpLFxyXG4gICAgJGF0dHJzOiBpID0+ICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBzaGFsbG93UmVhZG9ubHkoaS5hdHRycykgOiBpLmF0dHJzKSxcclxuICAgICRzbG90czogaSA9PiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gc2hhbGxvd1JlYWRvbmx5KGkuc2xvdHMpIDogaS5zbG90cyksXHJcbiAgICAkcmVmczogaSA9PiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gc2hhbGxvd1JlYWRvbmx5KGkucmVmcykgOiBpLnJlZnMpLFxyXG4gICAgJHBhcmVudDogaSA9PiBnZXRQdWJsaWNJbnN0YW5jZShpLnBhcmVudCksXHJcbiAgICAkcm9vdDogaSA9PiBnZXRQdWJsaWNJbnN0YW5jZShpLnJvb3QpLFxyXG4gICAgJGVtaXQ6IGkgPT4gaS5lbWl0LFxyXG4gICAgJG9wdGlvbnM6IGkgPT4gKF9fVlVFX09QVElPTlNfQVBJX18gPyByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpKSA6IGkudHlwZSksXHJcbiAgICAkZm9yY2VVcGRhdGU6IGkgPT4gKCkgPT4gcXVldWVKb2IoaS51cGRhdGUpLFxyXG4gICAgJG5leHRUaWNrOiBpID0+IG5leHRUaWNrLmJpbmQoaS5wcm94eSksXHJcbiAgICAkd2F0Y2g6IGkgPT4gKF9fVlVFX09QVElPTlNfQVBJX18gPyBpbnN0YW5jZVdhdGNoLmJpbmQoaSkgOiBOT09QKVxyXG59KTtcclxuY29uc3QgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzID0ge1xyXG4gICAgZ2V0KHsgXzogaW5zdGFuY2UgfSwga2V5KSB7XHJcbiAgICAgICAgY29uc3QgeyBjdHgsIHNldHVwU3RhdGUsIGRhdGEsIHByb3BzLCBhY2Nlc3NDYWNoZSwgdHlwZSwgYXBwQ29udGV4dCB9ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgLy8gZm9yIGludGVybmFsIGZvcm1hdHRlcnMgdG8ga25vdyB0aGF0IHRoaXMgaXMgYSBWdWUgaW5zdGFuY2VcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGtleSA9PT0gJ19faXNWdWUnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBwcmlvcml0aXplIDxzY3JpcHQgc2V0dXA+IGJpbmRpbmdzIGR1cmluZyBkZXYuXHJcbiAgICAgICAgLy8gdGhpcyBhbGxvd3MgZXZlbiBwcm9wZXJ0aWVzIHRoYXQgc3RhcnQgd2l0aCBfIG9yICQgdG8gYmUgdXNlZCAtIHNvIHRoYXRcclxuICAgICAgICAvLyBpdCBhbGlnbnMgd2l0aCB0aGUgcHJvZHVjdGlvbiBiZWhhdmlvciB3aGVyZSB0aGUgcmVuZGVyIGZuIGlzIGlubGluZWQgYW5kXHJcbiAgICAgICAgLy8gaW5kZWVkIGhhcyBhY2Nlc3MgdG8gYWxsIGRlY2xhcmVkIHZhcmlhYmxlcy5cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgIHNldHVwU3RhdGUgIT09IEVNUFRZX09CSiAmJlxyXG4gICAgICAgICAgICBzZXR1cFN0YXRlLl9faXNTY3JpcHRTZXR1cCAmJlxyXG4gICAgICAgICAgICBoYXNPd24oc2V0dXBTdGF0ZSwga2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2V0dXBTdGF0ZVtrZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkYXRhIC8gcHJvcHMgLyBjdHhcclxuICAgICAgICAvLyBUaGlzIGdldHRlciBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgcHJvcGVydHkgYWNjZXNzIG9uIHRoZSByZW5kZXIgY29udGV4dFxyXG4gICAgICAgIC8vIGR1cmluZyByZW5kZXIgYW5kIGlzIGEgbWFqb3IgaG90c3BvdC4gVGhlIG1vc3QgZXhwZW5zaXZlIHBhcnQgb2YgdGhpc1xyXG4gICAgICAgIC8vIGlzIHRoZSBtdWx0aXBsZSBoYXNPd24oKSBjYWxscy4gSXQncyBtdWNoIGZhc3RlciB0byBkbyBhIHNpbXBsZSBwcm9wZXJ0eVxyXG4gICAgICAgIC8vIGFjY2VzcyBvbiBhIHBsYWluIG9iamVjdCwgc28gd2UgdXNlIGFuIGFjY2Vzc0NhY2hlIG9iamVjdCAod2l0aCBudWxsXHJcbiAgICAgICAgLy8gcHJvdG90eXBlKSB0byBtZW1vaXplIHdoYXQgYWNjZXNzIHR5cGUgYSBrZXkgY29ycmVzcG9uZHMgdG8uXHJcbiAgICAgICAgbGV0IG5vcm1hbGl6ZWRQcm9wcztcclxuICAgICAgICBpZiAoa2V5WzBdICE9PSAnJCcpIHtcclxuICAgICAgICAgICAgY29uc3QgbiA9IGFjY2Vzc0NhY2hlW2tleV07XHJcbiAgICAgICAgICAgIGlmIChuICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAobikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBTRVRVUCAqLzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldHVwU3RhdGVba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDIgLyogREFUQSAqLzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQgLyogQ09OVEVYVCAqLzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eFtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBQUk9QUyAqLzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVmYXVsdDoganVzdCBmYWxsdGhyb3VnaFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNldHVwU3RhdGUgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oc2V0dXBTdGF0ZSwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDEgLyogU0VUVVAgKi87XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0dXBTdGF0ZVtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oZGF0YSwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDIgLyogREFUQSAqLztcclxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoXHJcbiAgICAgICAgICAgIC8vIG9ubHkgY2FjaGUgb3RoZXIgcHJvcGVydGllcyB3aGVuIGluc3RhbmNlIGhhcyBkZWNsYXJlZCAodGh1cyBzdGFibGUpXHJcbiAgICAgICAgICAgIC8vIHByb3BzXHJcbiAgICAgICAgICAgIChub3JtYWxpemVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wc09wdGlvbnNbMF0pICYmXHJcbiAgICAgICAgICAgICAgICBoYXNPd24obm9ybWFsaXplZFByb3BzLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMyAvKiBQUk9QUyAqLztcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wc1trZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGN0eCAhPT0gRU1QVFlfT0JKICYmIGhhc093bihjdHgsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSA0IC8qIENPTlRFWFQgKi87XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4W2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fVlVFX09QVElPTlNfQVBJX18gfHwgc2hvdWxkQ2FjaGVBY2Nlc3MpIHtcclxuICAgICAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAwIC8qIE9USEVSICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHB1YmxpY0dldHRlciA9IHB1YmxpY1Byb3BlcnRpZXNNYXBba2V5XTtcclxuICAgICAgICBsZXQgY3NzTW9kdWxlLCBnbG9iYWxQcm9wZXJ0aWVzO1xyXG4gICAgICAgIC8vIHB1YmxpYyAkeHh4IHByb3BlcnRpZXNcclxuICAgICAgICBpZiAocHVibGljR2V0dGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICckYXR0cnMnKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFjayhpbnN0YW5jZSwgXCJnZXRcIiAvKiBHRVQgKi8sIGtleSk7XHJcbiAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgbWFya0F0dHJzQWNjZXNzZWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcHVibGljR2V0dGVyKGluc3RhbmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoXHJcbiAgICAgICAgLy8gY3NzIG1vZHVsZSAoaW5qZWN0ZWQgYnkgdnVlLWxvYWRlcilcclxuICAgICAgICAoY3NzTW9kdWxlID0gdHlwZS5fX2Nzc01vZHVsZXMpICYmXHJcbiAgICAgICAgICAgIChjc3NNb2R1bGUgPSBjc3NNb2R1bGVba2V5XSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNzc01vZHVsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY3R4ICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGN0eCwga2V5KSkge1xyXG4gICAgICAgICAgICAvLyB1c2VyIG1heSBzZXQgY3VzdG9tIHByb3BlcnRpZXMgdG8gYHRoaXNgIHRoYXQgc3RhcnQgd2l0aCBgJGBcclxuICAgICAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDQgLyogQ09OVEVYVCAqLztcclxuICAgICAgICAgICAgcmV0dXJuIGN0eFtrZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChcclxuICAgICAgICAvLyBnbG9iYWwgcHJvcGVydGllc1xyXG4gICAgICAgICgoZ2xvYmFsUHJvcGVydGllcyA9IGFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMpLFxyXG4gICAgICAgICAgICBoYXNPd24oZ2xvYmFsUHJvcGVydGllcywga2V5KSkpIHtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFByb3BlcnRpZXNba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlICYmXHJcbiAgICAgICAgICAgICghaXNTdHJpbmcoa2V5KSB8fFxyXG4gICAgICAgICAgICAgICAgLy8gIzEwOTEgYXZvaWQgaW50ZXJuYWwgaXNSZWYvaXNWTm9kZSBjaGVja3Mgb24gY29tcG9uZW50IGluc3RhbmNlIGxlYWRpbmdcclxuICAgICAgICAgICAgICAgIC8vIHRvIGluZmluaXRlIHdhcm5pbmcgbG9vcFxyXG4gICAgICAgICAgICAgICAga2V5LmluZGV4T2YoJ19fdicpICE9PSAwKSkge1xyXG4gICAgICAgICAgICBpZiAoZGF0YSAhPT0gRU1QVFlfT0JKICYmXHJcbiAgICAgICAgICAgICAgICAoa2V5WzBdID09PSAnJCcgfHwga2V5WzBdID09PSAnXycpICYmXHJcbiAgICAgICAgICAgICAgICBoYXNPd24oZGF0YSwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShrZXkpfSBtdXN0IGJlIGFjY2Vzc2VkIHZpYSAkZGF0YSBiZWNhdXNlIGl0IHN0YXJ0cyB3aXRoIGEgcmVzZXJ2ZWQgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYGNoYXJhY3RlciAoXCIkXCIgb3IgXCJfXCIpIGFuZCBpcyBub3QgcHJveGllZCBvbiB0aGUgcmVuZGVyIGNvbnRleHQuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaW5zdGFuY2UgPT09IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShrZXkpfSB3YXMgYWNjZXNzZWQgZHVyaW5nIHJlbmRlciBgICtcclxuICAgICAgICAgICAgICAgICAgICBgYnV0IGlzIG5vdCBkZWZpbmVkIG9uIGluc3RhbmNlLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHNldCh7IF86IGluc3RhbmNlIH0sIGtleSwgdmFsdWUpIHtcclxuICAgICAgICBjb25zdCB7IGRhdGEsIHNldHVwU3RhdGUsIGN0eCB9ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgaWYgKHNldHVwU3RhdGUgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oc2V0dXBTdGF0ZSwga2V5KSkge1xyXG4gICAgICAgICAgICBzZXR1cFN0YXRlW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRhdGEgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oZGF0YSwga2V5KSkge1xyXG4gICAgICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhhc093bihpbnN0YW5jZS5wcm9wcywga2V5KSkge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIHdhcm4oYEF0dGVtcHRpbmcgdG8gbXV0YXRlIHByb3AgXCIke2tleX1cIi4gUHJvcHMgYXJlIHJlYWRvbmx5LmAsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoa2V5WzBdID09PSAnJCcgJiYga2V5LnNsaWNlKDEpIGluIGluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgd2FybihgQXR0ZW1wdGluZyB0byBtdXRhdGUgcHVibGljIHByb3BlcnR5IFwiJHtrZXl9XCIuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBQcm9wZXJ0aWVzIHN0YXJ0aW5nIHdpdGggJCBhcmUgcmVzZXJ2ZWQgYW5kIHJlYWRvbmx5LmAsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBrZXkgaW4gaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcuZ2xvYmFsUHJvcGVydGllcykge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3R4W2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0sXHJcbiAgICBoYXMoeyBfOiB7IGRhdGEsIHNldHVwU3RhdGUsIGFjY2Vzc0NhY2hlLCBjdHgsIGFwcENvbnRleHQsIHByb3BzT3B0aW9ucyB9IH0sIGtleSkge1xyXG4gICAgICAgIGxldCBub3JtYWxpemVkUHJvcHM7XHJcbiAgICAgICAgcmV0dXJuICghIWFjY2Vzc0NhY2hlW2tleV0gfHxcclxuICAgICAgICAgICAgKGRhdGEgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oZGF0YSwga2V5KSkgfHxcclxuICAgICAgICAgICAgKHNldHVwU3RhdGUgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oc2V0dXBTdGF0ZSwga2V5KSkgfHxcclxuICAgICAgICAgICAgKChub3JtYWxpemVkUHJvcHMgPSBwcm9wc09wdGlvbnNbMF0pICYmIGhhc093bihub3JtYWxpemVkUHJvcHMsIGtleSkpIHx8XHJcbiAgICAgICAgICAgIGhhc093bihjdHgsIGtleSkgfHxcclxuICAgICAgICAgICAgaGFzT3duKHB1YmxpY1Byb3BlcnRpZXNNYXAsIGtleSkgfHxcclxuICAgICAgICAgICAgaGFzT3duKGFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMsIGtleSkpO1xyXG4gICAgfSxcclxuICAgIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XHJcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IuZ2V0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXQodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IuZ2V0KCksIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkZXNjcmlwdG9yLnZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXQodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IudmFsdWUsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcik7XHJcbiAgICB9XHJcbn07XHJcbmlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWZhbHNlKSB7XHJcbiAgICBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMub3duS2V5cyA9ICh0YXJnZXQpID0+IHtcclxuICAgICAgICB3YXJuKGBBdm9pZCBhcHAgbG9naWMgdGhhdCByZWxpZXMgb24gZW51bWVyYXRpbmcga2V5cyBvbiBhIGNvbXBvbmVudCBpbnN0YW5jZS4gYCArXHJcbiAgICAgICAgICAgIGBUaGUga2V5cyB3aWxsIGJlIGVtcHR5IGluIHByb2R1Y3Rpb24gbW9kZSB0byBhdm9pZCBwZXJmb3JtYW5jZSBvdmVyaGVhZC5gKTtcclxuICAgICAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldCk7XHJcbiAgICB9O1xyXG59XHJcbmNvbnN0IFJ1bnRpbWVDb21waWxlZFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyA9IC8qI19fUFVSRV9fKi8gZXh0ZW5kKHt9LCBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMsIHtcclxuICAgIGdldCh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgIC8vIGZhc3QgcGF0aCBmb3IgdW5zY29wYWJsZXMgd2hlbiB1c2luZyBgd2l0aGAgYmxvY2tcclxuICAgICAgICBpZiAoa2V5ID09PSBTeW1ib2wudW5zY29wYWJsZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLmdldCh0YXJnZXQsIGtleSwgdGFyZ2V0KTtcclxuICAgIH0sXHJcbiAgICBoYXMoXywga2V5KSB7XHJcbiAgICAgICAgY29uc3QgaGFzID0ga2V5WzBdICE9PSAnXycgJiYgIWlzR2xvYmFsbHlXaGl0ZWxpc3RlZChrZXkpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWhhcyAmJiBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMuaGFzKF8sIGtleSkpIHtcclxuICAgICAgICAgICAgd2FybihgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShrZXkpfSBzaG91bGQgbm90IHN0YXJ0IHdpdGggXyB3aGljaCBpcyBhIHJlc2VydmVkIHByZWZpeCBmb3IgVnVlIGludGVybmFscy5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhhcztcclxuICAgIH1cclxufSk7XHJcbi8vIGRldiBvbmx5XHJcbi8vIEluIGRldiBtb2RlLCB0aGUgcHJveHkgdGFyZ2V0IGV4cG9zZXMgdGhlIHNhbWUgcHJvcGVydGllcyBhcyBzZWVuIG9uIGB0aGlzYFxyXG4vLyBmb3IgZWFzaWVyIGNvbnNvbGUgaW5zcGVjdGlvbi4gSW4gcHJvZCBtb2RlIGl0IHdpbGwgYmUgYW4gZW1wdHkgb2JqZWN0IHNvXHJcbi8vIHRoZXNlIHByb3BlcnRpZXMgZGVmaW5pdGlvbnMgY2FuIGJlIHNraXBwZWQuXHJcbmZ1bmN0aW9uIGNyZWF0ZURldlJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IHRhcmdldCA9IHt9O1xyXG4gICAgLy8gZXhwb3NlIGludGVybmFsIGluc3RhbmNlIGZvciBwcm94eSBoYW5kbGVyc1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgYF9gLCB7XHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGdldDogKCkgPT4gaW5zdGFuY2VcclxuICAgIH0pO1xyXG4gICAgLy8gZXhwb3NlIHB1YmxpYyBwcm9wZXJ0aWVzXHJcbiAgICBPYmplY3Qua2V5cyhwdWJsaWNQcm9wZXJ0aWVzTWFwKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGdldDogKCkgPT4gcHVibGljUHJvcGVydGllc01hcFtrZXldKGluc3RhbmNlKSxcclxuICAgICAgICAgICAgLy8gaW50ZXJjZXB0ZWQgYnkgdGhlIHByb3h5IHNvIG5vIG5lZWQgZm9yIGltcGxlbWVudGF0aW9uLFxyXG4gICAgICAgICAgICAvLyBidXQgbmVlZGVkIHRvIHByZXZlbnQgc2V0IGVycm9yc1xyXG4gICAgICAgICAgICBzZXQ6IE5PT1BcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufVxyXG4vLyBkZXYgb25seVxyXG5mdW5jdGlvbiBleHBvc2VQcm9wc09uUmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgeyBjdHgsIHByb3BzT3B0aW9uczogW3Byb3BzT3B0aW9uc10gfSA9IGluc3RhbmNlO1xyXG4gICAgaWYgKHByb3BzT3B0aW9ucykge1xyXG4gICAgICAgIE9iamVjdC5rZXlzKHByb3BzT3B0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IGluc3RhbmNlLnByb3BzW2tleV0sXHJcbiAgICAgICAgICAgICAgICBzZXQ6IE5PT1BcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLy8gZGV2IG9ubHlcclxuZnVuY3Rpb24gZXhwb3NlU2V0dXBTdGF0ZU9uUmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgeyBjdHgsIHNldHVwU3RhdGUgfSA9IGluc3RhbmNlO1xyXG4gICAgT2JqZWN0LmtleXModG9SYXcoc2V0dXBTdGF0ZSkpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICBpZiAoIXNldHVwU3RhdGUuX19pc1NjcmlwdFNldHVwKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXlbMF0gPT09ICckJyB8fCBrZXlbMF0gPT09ICdfJykge1xyXG4gICAgICAgICAgICAgICAgd2Fybihgc2V0dXAoKSByZXR1cm4gcHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShrZXkpfSBzaG91bGQgbm90IHN0YXJ0IHdpdGggXCIkXCIgb3IgXCJfXCIgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYHdoaWNoIGFyZSByZXNlcnZlZCBwcmVmaXhlcyBmb3IgVnVlIGludGVybmFscy5gKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHNldHVwU3RhdGVba2V5XSxcclxuICAgICAgICAgICAgICAgIHNldDogTk9PUFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxuXG5jb25zdCBlbXB0eUFwcENvbnRleHQgPSBjcmVhdGVBcHBDb250ZXh0KCk7XHJcbmxldCB1aWQkMSA9IDA7XHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlKHZub2RlLCBwYXJlbnQsIHN1c3BlbnNlKSB7XHJcbiAgICBjb25zdCB0eXBlID0gdm5vZGUudHlwZTtcclxuICAgIC8vIGluaGVyaXQgcGFyZW50IGFwcCBjb250ZXh0IC0gb3IgLSBpZiByb290LCBhZG9wdCBmcm9tIHJvb3Qgdm5vZGVcclxuICAgIGNvbnN0IGFwcENvbnRleHQgPSAocGFyZW50ID8gcGFyZW50LmFwcENvbnRleHQgOiB2bm9kZS5hcHBDb250ZXh0KSB8fCBlbXB0eUFwcENvbnRleHQ7XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IHtcclxuICAgICAgICB1aWQ6IHVpZCQxKyssXHJcbiAgICAgICAgdm5vZGUsXHJcbiAgICAgICAgdHlwZSxcclxuICAgICAgICBwYXJlbnQsXHJcbiAgICAgICAgYXBwQ29udGV4dCxcclxuICAgICAgICByb290OiBudWxsLFxyXG4gICAgICAgIG5leHQ6IG51bGwsXHJcbiAgICAgICAgc3ViVHJlZTogbnVsbCxcclxuICAgICAgICBlZmZlY3Q6IG51bGwsXHJcbiAgICAgICAgdXBkYXRlOiBudWxsLFxyXG4gICAgICAgIHNjb3BlOiBuZXcgRWZmZWN0U2NvcGUodHJ1ZSAvKiBkZXRhY2hlZCAqLyksXHJcbiAgICAgICAgcmVuZGVyOiBudWxsLFxyXG4gICAgICAgIHByb3h5OiBudWxsLFxyXG4gICAgICAgIGV4cG9zZWQ6IG51bGwsXHJcbiAgICAgICAgZXhwb3NlUHJveHk6IG51bGwsXHJcbiAgICAgICAgd2l0aFByb3h5OiBudWxsLFxyXG4gICAgICAgIHByb3ZpZGVzOiBwYXJlbnQgPyBwYXJlbnQucHJvdmlkZXMgOiBPYmplY3QuY3JlYXRlKGFwcENvbnRleHQucHJvdmlkZXMpLFxyXG4gICAgICAgIGFjY2Vzc0NhY2hlOiBudWxsLFxyXG4gICAgICAgIHJlbmRlckNhY2hlOiBbXSxcclxuICAgICAgICAvLyBsb2NhbCByZXNvdmxlZCBhc3NldHNcclxuICAgICAgICBjb21wb25lbnRzOiBudWxsLFxyXG4gICAgICAgIGRpcmVjdGl2ZXM6IG51bGwsXHJcbiAgICAgICAgLy8gcmVzb2x2ZWQgcHJvcHMgYW5kIGVtaXRzIG9wdGlvbnNcclxuICAgICAgICBwcm9wc09wdGlvbnM6IG5vcm1hbGl6ZVByb3BzT3B0aW9ucyh0eXBlLCBhcHBDb250ZXh0KSxcclxuICAgICAgICBlbWl0c09wdGlvbnM6IG5vcm1hbGl6ZUVtaXRzT3B0aW9ucyh0eXBlLCBhcHBDb250ZXh0KSxcclxuICAgICAgICAvLyBlbWl0XHJcbiAgICAgICAgZW1pdDogbnVsbCxcclxuICAgICAgICBlbWl0dGVkOiBudWxsLFxyXG4gICAgICAgIC8vIHByb3BzIGRlZmF1bHQgdmFsdWVcclxuICAgICAgICBwcm9wc0RlZmF1bHRzOiBFTVBUWV9PQkosXHJcbiAgICAgICAgLy8gaW5oZXJpdEF0dHJzXHJcbiAgICAgICAgaW5oZXJpdEF0dHJzOiB0eXBlLmluaGVyaXRBdHRycyxcclxuICAgICAgICAvLyBzdGF0ZVxyXG4gICAgICAgIGN0eDogRU1QVFlfT0JKLFxyXG4gICAgICAgIGRhdGE6IEVNUFRZX09CSixcclxuICAgICAgICBwcm9wczogRU1QVFlfT0JKLFxyXG4gICAgICAgIGF0dHJzOiBFTVBUWV9PQkosXHJcbiAgICAgICAgc2xvdHM6IEVNUFRZX09CSixcclxuICAgICAgICByZWZzOiBFTVBUWV9PQkosXHJcbiAgICAgICAgc2V0dXBTdGF0ZTogRU1QVFlfT0JKLFxyXG4gICAgICAgIHNldHVwQ29udGV4dDogbnVsbCxcclxuICAgICAgICAvLyBzdXNwZW5zZSByZWxhdGVkXHJcbiAgICAgICAgc3VzcGVuc2UsXHJcbiAgICAgICAgc3VzcGVuc2VJZDogc3VzcGVuc2UgPyBzdXNwZW5zZS5wZW5kaW5nSWQgOiAwLFxyXG4gICAgICAgIGFzeW5jRGVwOiBudWxsLFxyXG4gICAgICAgIGFzeW5jUmVzb2x2ZWQ6IGZhbHNlLFxyXG4gICAgICAgIC8vIGxpZmVjeWNsZSBob29rc1xyXG4gICAgICAgIC8vIG5vdCB1c2luZyBlbnVtcyBoZXJlIGJlY2F1c2UgaXQgcmVzdWx0cyBpbiBjb21wdXRlZCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgaXNNb3VudGVkOiBmYWxzZSxcclxuICAgICAgICBpc1VubW91bnRlZDogZmFsc2UsXHJcbiAgICAgICAgaXNEZWFjdGl2YXRlZDogZmFsc2UsXHJcbiAgICAgICAgYmM6IG51bGwsXHJcbiAgICAgICAgYzogbnVsbCxcclxuICAgICAgICBibTogbnVsbCxcclxuICAgICAgICBtOiBudWxsLFxyXG4gICAgICAgIGJ1OiBudWxsLFxyXG4gICAgICAgIHU6IG51bGwsXHJcbiAgICAgICAgdW06IG51bGwsXHJcbiAgICAgICAgYnVtOiBudWxsLFxyXG4gICAgICAgIGRhOiBudWxsLFxyXG4gICAgICAgIGE6IG51bGwsXHJcbiAgICAgICAgcnRnOiBudWxsLFxyXG4gICAgICAgIHJ0YzogbnVsbCxcclxuICAgICAgICBlYzogbnVsbCxcclxuICAgICAgICBzcDogbnVsbFxyXG4gICAgfTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBpbnN0YW5jZS5jdHggPSBjcmVhdGVEZXZSZW5kZXJDb250ZXh0KGluc3RhbmNlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGluc3RhbmNlLmN0eCA9IHsgXzogaW5zdGFuY2UgfTtcclxuICAgIH1cclxuICAgIGluc3RhbmNlLnJvb3QgPSBwYXJlbnQgPyBwYXJlbnQucm9vdCA6IGluc3RhbmNlO1xyXG4gICAgaW5zdGFuY2UuZW1pdCA9IGVtaXQkMS5iaW5kKG51bGwsIGluc3RhbmNlKTtcclxuICAgIC8vIGFwcGx5IGN1c3RvbSBlbGVtZW50IHNwZWNpYWwgaGFuZGxpbmdcclxuICAgIGlmICh2bm9kZS5jZSkge1xyXG4gICAgICAgIHZub2RlLmNlKGluc3RhbmNlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBpbnN0YW5jZTtcclxufVxyXG5sZXQgY3VycmVudEluc3RhbmNlID0gbnVsbDtcclxuY29uc3QgZ2V0Q3VycmVudEluc3RhbmNlID0gKCkgPT4gY3VycmVudEluc3RhbmNlIHx8IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcclxuY29uc3Qgc2V0Q3VycmVudEluc3RhbmNlID0gKGluc3RhbmNlKSA9PiB7XHJcbiAgICBjdXJyZW50SW5zdGFuY2UgPSBpbnN0YW5jZTtcclxuICAgIGluc3RhbmNlLnNjb3BlLm9uKCk7XHJcbn07XHJcbmNvbnN0IHVuc2V0Q3VycmVudEluc3RhbmNlID0gKCkgPT4ge1xyXG4gICAgY3VycmVudEluc3RhbmNlICYmIGN1cnJlbnRJbnN0YW5jZS5zY29wZS5vZmYoKTtcclxuICAgIGN1cnJlbnRJbnN0YW5jZSA9IG51bGw7XHJcbn07XHJcbmNvbnN0IGlzQnVpbHRJblRhZyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnKTtcclxuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUsIGNvbmZpZykge1xyXG4gICAgY29uc3QgYXBwSXNOYXRpdmVUYWcgPSBjb25maWcuaXNOYXRpdmVUYWcgfHwgTk87XHJcbiAgICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGFwcElzTmF0aXZlVGFnKG5hbWUpKSB7XHJcbiAgICAgICAgd2FybignRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCBpZDogJyArIG5hbWUpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UpIHtcclxuICAgIHJldHVybiBpbnN0YW5jZS52bm9kZS5zaGFwZUZsYWcgJiA0IC8qIFNUQVRFRlVMX0NPTVBPTkVOVCAqLztcclxufVxyXG5sZXQgaXNJblNTUkNvbXBvbmVudFNldHVwID0gZmFsc2U7XHJcbmZ1bmN0aW9uIHNldHVwQ29tcG9uZW50KGluc3RhbmNlLCBpc1NTUiA9IGZhbHNlKSB7XHJcbiAgICBpc0luU1NSQ29tcG9uZW50U2V0dXAgPSBpc1NTUjtcclxuICAgIGNvbnN0IHsgcHJvcHMsIGNoaWxkcmVuIH0gPSBpbnN0YW5jZS52bm9kZTtcclxuICAgIGNvbnN0IGlzU3RhdGVmdWwgPSBpc1N0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlKTtcclxuICAgIGluaXRQcm9wcyhpbnN0YW5jZSwgcHJvcHMsIGlzU3RhdGVmdWwsIGlzU1NSKTtcclxuICAgIGluaXRTbG90cyhpbnN0YW5jZSwgY2hpbGRyZW4pO1xyXG4gICAgY29uc3Qgc2V0dXBSZXN1bHQgPSBpc1N0YXRlZnVsXHJcbiAgICAgICAgPyBzZXR1cFN0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlLCBpc1NTUilcclxuICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgIGlzSW5TU1JDb21wb25lbnRTZXR1cCA9IGZhbHNlO1xyXG4gICAgcmV0dXJuIHNldHVwUmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIHNldHVwU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSKSB7XHJcbiAgICBjb25zdCBDb21wb25lbnQgPSBpbnN0YW5jZS50eXBlO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGlmIChDb21wb25lbnQubmFtZSkge1xyXG4gICAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoQ29tcG9uZW50Lm5hbWUsIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKENvbXBvbmVudC5jb21wb25lbnRzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoQ29tcG9uZW50LmNvbXBvbmVudHMpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZXNbaV0sIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQ29tcG9uZW50LmRpcmVjdGl2ZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyhDb21wb25lbnQuZGlyZWN0aXZlcyk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKENvbXBvbmVudC5jb21waWxlck9wdGlvbnMgJiYgaXNSdW50aW1lT25seSgpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYFwiY29tcGlsZXJPcHRpb25zXCIgaXMgb25seSBzdXBwb3J0ZWQgd2hlbiB1c2luZyBhIGJ1aWxkIG9mIFZ1ZSB0aGF0IGAgK1xyXG4gICAgICAgICAgICAgICAgYGluY2x1ZGVzIHRoZSBydW50aW1lIGNvbXBpbGVyLiBTaW5jZSB5b3UgYXJlIHVzaW5nIGEgcnVudGltZS1vbmx5IGAgK1xyXG4gICAgICAgICAgICAgICAgYGJ1aWxkLCB0aGUgb3B0aW9ucyBzaG91bGQgYmUgcGFzc2VkIHZpYSB5b3VyIGJ1aWxkIHRvb2wgY29uZmlnIGluc3RlYWQuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gMC4gY3JlYXRlIHJlbmRlciBwcm94eSBwcm9wZXJ0eSBhY2Nlc3MgY2FjaGVcclxuICAgIGluc3RhbmNlLmFjY2Vzc0NhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIC8vIDEuIGNyZWF0ZSBwdWJsaWMgaW5zdGFuY2UgLyByZW5kZXIgcHJveHlcclxuICAgIC8vIGFsc28gbWFyayBpdCByYXcgc28gaXQncyBuZXZlciBvYnNlcnZlZFxyXG4gICAgaW5zdGFuY2UucHJveHkgPSBtYXJrUmF3KG5ldyBQcm94eShpbnN0YW5jZS5jdHgsIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycykpO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGV4cG9zZVByb3BzT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKTtcclxuICAgIH1cclxuICAgIC8vIDIuIGNhbGwgc2V0dXAoKVxyXG4gICAgY29uc3QgeyBzZXR1cCB9ID0gQ29tcG9uZW50O1xyXG4gICAgaWYgKHNldHVwKSB7XHJcbiAgICAgICAgY29uc3Qgc2V0dXBDb250ZXh0ID0gKGluc3RhbmNlLnNldHVwQ29udGV4dCA9XHJcbiAgICAgICAgICAgIHNldHVwLmxlbmd0aCA+IDEgPyBjcmVhdGVTZXR1cENvbnRleHQoaW5zdGFuY2UpIDogbnVsbCk7XHJcbiAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKGluc3RhbmNlKTtcclxuICAgICAgICBwYXVzZVRyYWNraW5nKCk7XHJcbiAgICAgICAgY29uc3Qgc2V0dXBSZXN1bHQgPSBjYWxsV2l0aEVycm9ySGFuZGxpbmcoc2V0dXAsIGluc3RhbmNlLCAwIC8qIFNFVFVQX0ZVTkNUSU9OICovLCBbKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gc2hhbGxvd1JlYWRvbmx5KGluc3RhbmNlLnByb3BzKSA6IGluc3RhbmNlLnByb3BzLCBzZXR1cENvbnRleHRdKTtcclxuICAgICAgICByZXNldFRyYWNraW5nKCk7XHJcbiAgICAgICAgdW5zZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgICAgICBpZiAoaXNQcm9taXNlKHNldHVwUmVzdWx0KSkge1xyXG4gICAgICAgICAgICBzZXR1cFJlc3VsdC50aGVuKHVuc2V0Q3VycmVudEluc3RhbmNlLCB1bnNldEN1cnJlbnRJbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIGlmIChpc1NTUikge1xyXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBwcm9taXNlIHNvIHNlcnZlci1yZW5kZXJlciBjYW4gd2FpdCBvbiBpdFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldHVwUmVzdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHJlc29sdmVkUmVzdWx0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHJlc29sdmVkUmVzdWx0LCBpc1NTUik7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlLCBpbnN0YW5jZSwgMCAvKiBTRVRVUF9GVU5DVElPTiAqLyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGFzeW5jIHNldHVwIHJldHVybmVkIFByb21pc2UuXHJcbiAgICAgICAgICAgICAgICAvLyBiYWlsIGhlcmUgYW5kIHdhaXQgZm9yIHJlLWVudHJ5LlxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuYXN5bmNEZXAgPSBzZXR1cFJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHNldHVwUmVzdWx0LCBpc1NTUik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZmluaXNoQ29tcG9uZW50U2V0dXAoaW5zdGFuY2UsIGlzU1NSKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgc2V0dXBSZXN1bHQsIGlzU1NSKSB7XHJcbiAgICBpZiAoaXNGdW5jdGlvbihzZXR1cFJlc3VsdCkpIHtcclxuICAgICAgICAvLyBzZXR1cCByZXR1cm5lZCBhbiBpbmxpbmUgcmVuZGVyIGZ1bmN0aW9uXHJcbiAgICAgICAgaWYgKGluc3RhbmNlLnR5cGUuX19zc3JJbmxpbmVSZW5kZXIpIHtcclxuICAgICAgICAgICAgLy8gd2hlbiB0aGUgZnVuY3Rpb24ncyBuYW1lIGlzIGBzc3JSZW5kZXJgIChjb21waWxlZCBieSBTRkMgaW5saW5lIG1vZGUpLFxyXG4gICAgICAgICAgICAvLyBzZXQgaXQgYXMgc3NyUmVuZGVyIGluc3RlYWQuXHJcbiAgICAgICAgICAgIGluc3RhbmNlLnNzclJlbmRlciA9IHNldHVwUmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UucmVuZGVyID0gc2V0dXBSZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3Qoc2V0dXBSZXN1bHQpKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpc1ZOb2RlKHNldHVwUmVzdWx0KSkge1xyXG4gICAgICAgICAgICB3YXJuKGBzZXR1cCgpIHNob3VsZCBub3QgcmV0dXJuIFZOb2RlcyBkaXJlY3RseSAtIGAgK1xyXG4gICAgICAgICAgICAgICAgYHJldHVybiBhIHJlbmRlciBmdW5jdGlvbiBpbnN0ZWFkLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzZXR1cCByZXR1cm5lZCBiaW5kaW5ncy5cclxuICAgICAgICAvLyBhc3N1bWluZyBhIHJlbmRlciBmdW5jdGlvbiBjb21waWxlZCBmcm9tIHRlbXBsYXRlIGlzIHByZXNlbnQuXHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UuZGV2dG9vbHNSYXdTZXR1cFN0YXRlID0gc2V0dXBSZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc3RhbmNlLnNldHVwU3RhdGUgPSBwcm94eVJlZnMoc2V0dXBSZXN1bHQpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgZXhwb3NlU2V0dXBTdGF0ZU9uUmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHNldHVwUmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB3YXJuKGBzZXR1cCgpIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0LiBSZWNlaXZlZDogJHtzZXR1cFJlc3VsdCA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBzZXR1cFJlc3VsdH1gKTtcclxuICAgIH1cclxuICAgIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlLCBpc1NTUik7XHJcbn1cclxubGV0IGNvbXBpbGU7XHJcbmxldCBpbnN0YWxsV2l0aFByb3h5O1xyXG4vKipcclxuICogRm9yIHJ1bnRpbWUtZG9tIHRvIHJlZ2lzdGVyIHRoZSBjb21waWxlci5cclxuICogTm90ZSB0aGUgZXhwb3J0ZWQgbWV0aG9kIHVzZXMgYW55IHRvIGF2b2lkIGQudHMgcmVseWluZyBvbiB0aGUgY29tcGlsZXIgdHlwZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiByZWdpc3RlclJ1bnRpbWVDb21waWxlcihfY29tcGlsZSkge1xyXG4gICAgY29tcGlsZSA9IF9jb21waWxlO1xyXG4gICAgaW5zdGFsbFdpdGhQcm94eSA9IGkgPT4ge1xyXG4gICAgICAgIGlmIChpLnJlbmRlci5fcmMpIHtcclxuICAgICAgICAgICAgaS53aXRoUHJveHkgPSBuZXcgUHJveHkoaS5jdHgsIFJ1bnRpbWVDb21waWxlZFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG4vLyBkZXYgb25seVxyXG5jb25zdCBpc1J1bnRpbWVPbmx5ID0gKCkgPT4gIWNvbXBpbGU7XHJcbmZ1bmN0aW9uIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlLCBpc1NTUiwgc2tpcE9wdGlvbnMpIHtcclxuICAgIGNvbnN0IENvbXBvbmVudCA9IGluc3RhbmNlLnR5cGU7XHJcbiAgICAvLyB0ZW1wbGF0ZSAvIHJlbmRlciBmdW5jdGlvbiBub3JtYWxpemF0aW9uXHJcbiAgICAvLyBjb3VsZCBiZSBhbHJlYWR5IHNldCB3aGVuIHJldHVybmVkIGZyb20gc2V0dXAoKVxyXG4gICAgaWYgKCFpbnN0YW5jZS5yZW5kZXIpIHtcclxuICAgICAgICAvLyBvbmx5IGRvIG9uLXRoZS1mbHkgY29tcGlsZSBpZiBub3QgaW4gU1NSIC0gU1NSIG9uLXRoZS1mbHkgY29tcGlsYXRpb25cclxuICAgICAgICAvLyBpcyBkb25lIGJ5IHNlcnZlci1yZW5kZXJlclxyXG4gICAgICAgIGlmICghaXNTU1IgJiYgY29tcGlsZSAmJiAhQ29tcG9uZW50LnJlbmRlcikge1xyXG4gICAgICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IENvbXBvbmVudC50ZW1wbGF0ZTtcclxuICAgICAgICAgICAgaWYgKHRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgY29tcGlsZWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBpc0N1c3RvbUVsZW1lbnQsIGNvbXBpbGVyT3B0aW9ucyB9ID0gaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWc7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRlbGltaXRlcnMsIGNvbXBpbGVyT3B0aW9uczogY29tcG9uZW50Q29tcGlsZXJPcHRpb25zIH0gPSBDb21wb25lbnQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaW5hbENvbXBpbGVyT3B0aW9ucyA9IGV4dGVuZChleHRlbmQoe1xyXG4gICAgICAgICAgICAgICAgICAgIGlzQ3VzdG9tRWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICBkZWxpbWl0ZXJzXHJcbiAgICAgICAgICAgICAgICB9LCBjb21waWxlck9wdGlvbnMpLCBjb21wb25lbnRDb21waWxlck9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LnJlbmRlciA9IGNvbXBpbGUodGVtcGxhdGUsIGZpbmFsQ29tcGlsZXJPcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgY29tcGlsZWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc3RhbmNlLnJlbmRlciA9IChDb21wb25lbnQucmVuZGVyIHx8IE5PT1ApO1xyXG4gICAgICAgIC8vIGZvciBydW50aW1lLWNvbXBpbGVkIHJlbmRlciBmdW5jdGlvbnMgdXNpbmcgYHdpdGhgIGJsb2NrcywgdGhlIHJlbmRlclxyXG4gICAgICAgIC8vIHByb3h5IHVzZWQgbmVlZHMgYSBkaWZmZXJlbnQgYGhhc2AgaGFuZGxlciB3aGljaCBpcyBtb3JlIHBlcmZvcm1hbnQgYW5kXHJcbiAgICAgICAgLy8gYWxzbyBvbmx5IGFsbG93cyBhIHdoaXRlbGlzdCBvZiBnbG9iYWxzIHRvIGZhbGx0aHJvdWdoLlxyXG4gICAgICAgIGlmIChpbnN0YWxsV2l0aFByb3h5KSB7XHJcbiAgICAgICAgICAgIGluc3RhbGxXaXRoUHJveHkoaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHN1cHBvcnQgZm9yIDIueCBvcHRpb25zXHJcbiAgICBpZiAoX19WVUVfT1BUSU9OU19BUElfXyAmJiAhKGZhbHNlICkpIHtcclxuICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2UoaW5zdGFuY2UpO1xyXG4gICAgICAgIHBhdXNlVHJhY2tpbmcoKTtcclxuICAgICAgICBhcHBseU9wdGlvbnMoaW5zdGFuY2UpO1xyXG4gICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcclxuICAgICAgICB1bnNldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgfVxyXG4gICAgLy8gd2FybiBtaXNzaW5nIHRlbXBsYXRlL3JlbmRlclxyXG4gICAgLy8gdGhlIHJ1bnRpbWUgY29tcGlsYXRpb24gb2YgdGVtcGxhdGUgaW4gU1NSIGlzIGRvbmUgYnkgc2VydmVyLXJlbmRlclxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhQ29tcG9uZW50LnJlbmRlciAmJiBpbnN0YW5jZS5yZW5kZXIgPT09IE5PT1AgJiYgIWlzU1NSKSB7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKCFjb21waWxlICYmIENvbXBvbmVudC50ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICB3YXJuKGBDb21wb25lbnQgcHJvdmlkZWQgdGVtcGxhdGUgb3B0aW9uIGJ1dCBgICtcclxuICAgICAgICAgICAgICAgIGBydW50aW1lIGNvbXBpbGF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBidWlsZCBvZiBWdWUuYCArXHJcbiAgICAgICAgICAgICAgICAoYCBDb25maWd1cmUgeW91ciBidW5kbGVyIHRvIGFsaWFzIFwidnVlXCIgdG8gXCJ2dWUvZGlzdC92dWUuZXNtLWJ1bmRsZXIuanNcIi5gXHJcbiAgICAgICAgICAgICAgICAgICAgKSAvKiBzaG91bGQgbm90IGhhcHBlbiAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB3YXJuKGBDb21wb25lbnQgaXMgbWlzc2luZyB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUF0dHJzUHJveHkoaW5zdGFuY2UpIHtcclxuICAgIHJldHVybiBuZXcgUHJveHkoaW5zdGFuY2UuYXR0cnMsIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgID8ge1xyXG4gICAgICAgICAgICBnZXQodGFyZ2V0LCBrZXkpIHtcclxuICAgICAgICAgICAgICAgIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XHJcbiAgICAgICAgICAgICAgICB0cmFjayhpbnN0YW5jZSwgXCJnZXRcIiAvKiBHRVQgKi8sICckYXR0cnMnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0KCkge1xyXG4gICAgICAgICAgICAgICAgd2Fybihgc2V0dXBDb250ZXh0LmF0dHJzIGlzIHJlYWRvbmx5LmApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkZWxldGVQcm9wZXJ0eSgpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYHNldHVwQ29udGV4dC5hdHRycyBpcyByZWFkb25seS5gKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICA6IHtcclxuICAgICAgICAgICAgZ2V0KHRhcmdldCwga2V5KSB7XHJcbiAgICAgICAgICAgICAgICB0cmFjayhpbnN0YW5jZSwgXCJnZXRcIiAvKiBHRVQgKi8sICckYXR0cnMnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVNldHVwQ29udGV4dChpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgZXhwb3NlID0gZXhwb3NlZCA9PiB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpbnN0YW5jZS5leHBvc2VkKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYGV4cG9zZSgpIHNob3VsZCBiZSBjYWxsZWQgb25seSBvbmNlIHBlciBzZXR1cCgpLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnN0YW5jZS5leHBvc2VkID0gZXhwb3NlZCB8fCB7fTtcclxuICAgIH07XHJcbiAgICBsZXQgYXR0cnM7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgLy8gV2UgdXNlIGdldHRlcnMgaW4gZGV2IGluIGNhc2UgbGlicyBsaWtlIHRlc3QtdXRpbHMgb3ZlcndyaXRlIGluc3RhbmNlXHJcbiAgICAgICAgLy8gcHJvcGVydGllcyAob3ZlcndyaXRlcyBzaG91bGQgbm90IGJlIGRvbmUgaW4gcHJvZClcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XHJcbiAgICAgICAgICAgIGdldCBhdHRycygpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhdHRycyB8fCAoYXR0cnMgPSBjcmVhdGVBdHRyc1Byb3h5KGluc3RhbmNlKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdldCBzbG90cygpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzaGFsbG93UmVhZG9ubHkoaW5zdGFuY2Uuc2xvdHMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBnZXQgZW1pdCgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoZXZlbnQsIC4uLmFyZ3MpID0+IGluc3RhbmNlLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBleHBvc2VcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGdldCBhdHRycygpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhdHRycyB8fCAoYXR0cnMgPSBjcmVhdGVBdHRyc1Byb3h5KGluc3RhbmNlKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNsb3RzOiBpbnN0YW5jZS5zbG90cyxcclxuICAgICAgICAgICAgZW1pdDogaW5zdGFuY2UuZW1pdCxcclxuICAgICAgICAgICAgZXhwb3NlXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRFeHBvc2VQcm94eShpbnN0YW5jZSkge1xyXG4gICAgaWYgKGluc3RhbmNlLmV4cG9zZWQpIHtcclxuICAgICAgICByZXR1cm4gKGluc3RhbmNlLmV4cG9zZVByb3h5IHx8XHJcbiAgICAgICAgICAgIChpbnN0YW5jZS5leHBvc2VQcm94eSA9IG5ldyBQcm94eShwcm94eVJlZnMobWFya1JhdyhpbnN0YW5jZS5leHBvc2VkKSksIHtcclxuICAgICAgICAgICAgICAgIGdldCh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5IGluIHB1YmxpY1Byb3BlcnRpZXNNYXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHB1YmxpY1Byb3BlcnRpZXNNYXBba2V5XShpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSkpO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XHJcbmNvbnN0IGNsYXNzaWZ5ID0gKHN0cikgPT4gc3RyLnJlcGxhY2UoY2xhc3NpZnlSRSwgYyA9PiBjLnRvVXBwZXJDYXNlKCkpLnJlcGxhY2UoL1stX10vZywgJycpO1xyXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkge1xyXG4gICAgcmV0dXJuIGlzRnVuY3Rpb24oQ29tcG9uZW50KVxyXG4gICAgICAgID8gQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lXHJcbiAgICAgICAgOiBDb21wb25lbnQubmFtZTtcclxufVxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCBDb21wb25lbnQsIGlzUm9vdCA9IGZhbHNlKSB7XHJcbiAgICBsZXQgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KTtcclxuICAgIGlmICghbmFtZSAmJiBDb21wb25lbnQuX19maWxlKSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBDb21wb25lbnQuX19maWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLlxcdyskLyk7XHJcbiAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBtYXRjaFsxXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIW5hbWUgJiYgaW5zdGFuY2UgJiYgaW5zdGFuY2UucGFyZW50KSB7XHJcbiAgICAgICAgLy8gdHJ5IHRvIGluZmVyIHRoZSBuYW1lIGJhc2VkIG9uIHJldmVyc2UgcmVzb2x1dGlvblxyXG4gICAgICAgIGNvbnN0IGluZmVyRnJvbVJlZ2lzdHJ5ID0gKHJlZ2lzdHJ5KSA9PiB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJlZ2lzdHJ5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVnaXN0cnlba2V5XSA9PT0gQ29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbmFtZSA9XHJcbiAgICAgICAgICAgIGluZmVyRnJvbVJlZ2lzdHJ5KGluc3RhbmNlLmNvbXBvbmVudHMgfHxcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLnBhcmVudC50eXBlLmNvbXBvbmVudHMpIHx8IGluZmVyRnJvbVJlZ2lzdHJ5KGluc3RhbmNlLmFwcENvbnRleHQuY29tcG9uZW50cyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmFtZSA/IGNsYXNzaWZ5KG5hbWUpIDogaXNSb290ID8gYEFwcGAgOiBgQW5vbnltb3VzYDtcclxufVxyXG5mdW5jdGlvbiBpc0NsYXNzQ29tcG9uZW50KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gaXNGdW5jdGlvbih2YWx1ZSkgJiYgJ19fdmNjT3B0cycgaW4gdmFsdWU7XHJcbn1cblxuY29uc3QgY29tcHV0ZWQgPSAoKGdldHRlck9yT3B0aW9ucywgZGVidWdPcHRpb25zKSA9PiB7XHJcbiAgICAvLyBAdHMtaWdub3JlXHJcbiAgICByZXR1cm4gY29tcHV0ZWQkMShnZXR0ZXJPck9wdGlvbnMsIGRlYnVnT3B0aW9ucywgaXNJblNTUkNvbXBvbmVudFNldHVwKTtcclxufSk7XG5cbi8vIGRldiBvbmx5XHJcbmNvbnN0IHdhcm5SdW50aW1lVXNhZ2UgPSAobWV0aG9kKSA9PiB3YXJuKGAke21ldGhvZH0oKSBpcyBhIGNvbXBpbGVyLWhpbnQgaGVscGVyIHRoYXQgaXMgb25seSB1c2FibGUgaW5zaWRlIGAgK1xyXG4gICAgYDxzY3JpcHQgc2V0dXA+IG9mIGEgc2luZ2xlIGZpbGUgY29tcG9uZW50LiBJdHMgYXJndW1lbnRzIHNob3VsZCBiZSBgICtcclxuICAgIGBjb21waWxlZCBhd2F5IGFuZCBwYXNzaW5nIGl0IGF0IHJ1bnRpbWUgaGFzIG5vIGVmZmVjdC5gKTtcclxuLy8gaW1wbGVtZW50YXRpb25cclxuZnVuY3Rpb24gZGVmaW5lUHJvcHMoKSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lUHJvcHNgKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbi8vIGltcGxlbWVudGF0aW9uXHJcbmZ1bmN0aW9uIGRlZmluZUVtaXRzKCkge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZUVtaXRzYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4vKipcclxuICogVnVlIGA8c2NyaXB0IHNldHVwPmAgY29tcGlsZXIgbWFjcm8gZm9yIGRlY2xhcmluZyBhIGNvbXBvbmVudCdzIGV4cG9zZWRcclxuICogaW5zdGFuY2UgcHJvcGVydGllcyB3aGVuIGl0IGlzIGFjY2Vzc2VkIGJ5IGEgcGFyZW50IGNvbXBvbmVudCB2aWEgdGVtcGxhdGVcclxuICogcmVmcy5cclxuICpcclxuICogYDxzY3JpcHQgc2V0dXA+YCBjb21wb25lbnRzIGFyZSBjbG9zZWQgYnkgZGVmYXVsdCAtIGkuZS4gdmFyaWFibGVzIGluc2lkZVxyXG4gKiB0aGUgYDxzY3JpcHQgc2V0dXA+YCBzY29wZSBpcyBub3QgZXhwb3NlZCB0byBwYXJlbnQgdW5sZXNzIGV4cGxpY2l0bHkgZXhwb3NlZFxyXG4gKiB2aWEgYGRlZmluZUV4cG9zZWAuXHJcbiAqXHJcbiAqIFRoaXMgaXMgb25seSB1c2FibGUgaW5zaWRlIGA8c2NyaXB0IHNldHVwPmAsIGlzIGNvbXBpbGVkIGF3YXkgaW4gdGhlXHJcbiAqIG91dHB1dCBhbmQgc2hvdWxkICoqbm90KiogYmUgYWN0dWFsbHkgY2FsbGVkIGF0IHJ1bnRpbWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWZpbmVFeHBvc2UoZXhwb3NlZCkge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZUV4cG9zZWApO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBWdWUgYDxzY3JpcHQgc2V0dXA+YCBjb21waWxlciBtYWNybyBmb3IgcHJvdmlkaW5nIHByb3BzIGRlZmF1bHQgdmFsdWVzIHdoZW5cclxuICogdXNpbmcgdHlwZS1iYXNlZCBgZGVmaW5lUHJvcHNgIGRlY2xhcmF0aW9uLlxyXG4gKlxyXG4gKiBFeGFtcGxlIHVzYWdlOlxyXG4gKiBgYGB0c1xyXG4gKiB3aXRoRGVmYXVsdHMoZGVmaW5lUHJvcHM8e1xyXG4gKiAgIHNpemU/OiBudW1iZXJcclxuICogICBsYWJlbHM/OiBzdHJpbmdbXVxyXG4gKiB9PigpLCB7XHJcbiAqICAgc2l6ZTogMyxcclxuICogICBsYWJlbHM6ICgpID0+IFsnZGVmYXVsdCBsYWJlbCddXHJcbiAqIH0pXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGlzIGlzIG9ubHkgdXNhYmxlIGluc2lkZSBgPHNjcmlwdCBzZXR1cD5gLCBpcyBjb21waWxlZCBhd2F5IGluIHRoZSBvdXRwdXRcclxuICogYW5kIHNob3VsZCAqKm5vdCoqIGJlIGFjdHVhbGx5IGNhbGxlZCBhdCBydW50aW1lLlxyXG4gKi9cclxuZnVuY3Rpb24gd2l0aERlZmF1bHRzKHByb3BzLCBkZWZhdWx0cykge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm5SdW50aW1lVXNhZ2UoYHdpdGhEZWZhdWx0c2ApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuZnVuY3Rpb24gdXNlU2xvdHMoKSB7XHJcbiAgICByZXR1cm4gZ2V0Q29udGV4dCgpLnNsb3RzO1xyXG59XHJcbmZ1bmN0aW9uIHVzZUF0dHJzKCkge1xyXG4gICAgcmV0dXJuIGdldENvbnRleHQoKS5hdHRycztcclxufVxyXG5mdW5jdGlvbiBnZXRDb250ZXh0KCkge1xyXG4gICAgY29uc3QgaSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaSkge1xyXG4gICAgICAgIHdhcm4oYHVzZUNvbnRleHQoKSBjYWxsZWQgd2l0aG91dCBhY3RpdmUgaW5zdGFuY2UuYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaS5zZXR1cENvbnRleHQgfHwgKGkuc2V0dXBDb250ZXh0ID0gY3JlYXRlU2V0dXBDb250ZXh0KGkpKTtcclxufVxyXG4vKipcclxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgZGVmYXVsdCBkZWNsYXJhdGlvbnMuIEltcG9ydGVkIGJ5IGNvbXBpbGVkIGNvZGVcclxuICogb25seS5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZURlZmF1bHRzKHJhdywgZGVmYXVsdHMpIHtcclxuICAgIGNvbnN0IHByb3BzID0gaXNBcnJheShyYXcpXHJcbiAgICAgICAgPyByYXcucmVkdWNlKChub3JtYWxpemVkLCBwKSA9PiAoKG5vcm1hbGl6ZWRbcF0gPSB7fSksIG5vcm1hbGl6ZWQpLCB7fSlcclxuICAgICAgICA6IHJhdztcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGRlZmF1bHRzKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0ID0gcHJvcHNba2V5XTtcclxuICAgICAgICBpZiAob3B0KSB7XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KG9wdCkgfHwgaXNGdW5jdGlvbihvcHQpKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wc1trZXldID0geyB0eXBlOiBvcHQsIGRlZmF1bHQ6IGRlZmF1bHRzW2tleV0gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG9wdC5kZWZhdWx0ID0gZGVmYXVsdHNba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcHQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcHJvcHNba2V5XSA9IHsgZGVmYXVsdDogZGVmYXVsdHNba2V5XSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgd2FybihgcHJvcHMgZGVmYXVsdCBrZXkgXCIke2tleX1cIiBoYXMgbm8gY29ycmVzcG9uZGluZyBkZWNsYXJhdGlvbi5gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJvcHM7XHJcbn1cclxuLyoqXHJcbiAqIFVzZWQgdG8gY3JlYXRlIGEgcHJveHkgZm9yIHRoZSByZXN0IGVsZW1lbnQgd2hlbiBkZXN0cnVjdHVyaW5nIHByb3BzIHdpdGhcclxuICogZGVmaW5lUHJvcHMoKS5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVQcm9wc1Jlc3RQcm94eShwcm9wcywgZXhjbHVkZWRLZXlzKSB7XHJcbiAgICBjb25zdCByZXQgPSB7fTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XHJcbiAgICAgICAgaWYgKCFleGNsdWRlZEtleXMuaW5jbHVkZXMoa2V5KSkge1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmV0LCBrZXksIHtcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHByb3BzW2tleV1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxufVxyXG4vKipcclxuICogYDxzY3JpcHQgc2V0dXA+YCBoZWxwZXIgZm9yIHBlcnNpc3RpbmcgdGhlIGN1cnJlbnQgaW5zdGFuY2UgY29udGV4dCBvdmVyXHJcbiAqIGFzeW5jL2F3YWl0IGZsb3dzLlxyXG4gKlxyXG4gKiBgQHZ1ZS9jb21waWxlci1zZmNgIGNvbnZlcnRzIHRoZSBmb2xsb3dpbmc6XHJcbiAqXHJcbiAqIGBgYHRzXHJcbiAqIGNvbnN0IHggPSBhd2FpdCBmb28oKVxyXG4gKiBgYGBcclxuICpcclxuICogaW50bzpcclxuICpcclxuICogYGBgdHNcclxuICogbGV0IF9fdGVtcCwgX19yZXN0b3JlXHJcbiAqIGNvbnN0IHggPSAoKFtfX3RlbXAsIF9fcmVzdG9yZV0gPSB3aXRoQXN5bmNDb250ZXh0KCgpID0+IGZvbygpKSksX190ZW1wPWF3YWl0IF9fdGVtcCxfX3Jlc3RvcmUoKSxfX3RlbXApXHJcbiAqIGBgYFxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIHdpdGhBc3luY0NvbnRleHQoZ2V0QXdhaXRhYmxlKSB7XHJcbiAgICBjb25zdCBjdHggPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWN0eCkge1xyXG4gICAgICAgIHdhcm4oYHdpdGhBc3luY0NvbnRleHQgY2FsbGVkIHdpdGhvdXQgYWN0aXZlIGN1cnJlbnQgaW5zdGFuY2UuIGAgK1xyXG4gICAgICAgICAgICBgVGhpcyBpcyBsaWtlbHkgYSBidWcuYCk7XHJcbiAgICB9XHJcbiAgICBsZXQgYXdhaXRhYmxlID0gZ2V0QXdhaXRhYmxlKCk7XHJcbiAgICB1bnNldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgaWYgKGlzUHJvbWlzZShhd2FpdGFibGUpKSB7XHJcbiAgICAgICAgYXdhaXRhYmxlID0gYXdhaXRhYmxlLmNhdGNoKGUgPT4ge1xyXG4gICAgICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2UoY3R4KTtcclxuICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBbYXdhaXRhYmxlLCAoKSA9PiBzZXRDdXJyZW50SW5zdGFuY2UoY3R4KV07XHJcbn1cblxuLy8gQWN0dWFsIGltcGxlbWVudGF0aW9uXHJcbmZ1bmN0aW9uIGgodHlwZSwgcHJvcHNPckNoaWxkcmVuLCBjaGlsZHJlbikge1xyXG4gICAgY29uc3QgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XHJcbiAgICBpZiAobCA9PT0gMikge1xyXG4gICAgICAgIGlmIChpc09iamVjdChwcm9wc09yQ2hpbGRyZW4pICYmICFpc0FycmF5KHByb3BzT3JDaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgLy8gc2luZ2xlIHZub2RlIHdpdGhvdXQgcHJvcHNcclxuICAgICAgICAgICAgaWYgKGlzVk5vZGUocHJvcHNPckNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIG51bGwsIFtwcm9wc09yQ2hpbGRyZW5dKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBwcm9wcyB3aXRob3V0IGNoaWxkcmVuXHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wc09yQ2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gb21pdCBwcm9wc1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgbnVsbCwgcHJvcHNPckNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAobCA+IDMpIHtcclxuICAgICAgICAgICAgY2hpbGRyZW4gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsID09PSAzICYmIGlzVk5vZGUoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgIGNoaWxkcmVuID0gW2NoaWxkcmVuXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIHByb3BzT3JDaGlsZHJlbiwgY2hpbGRyZW4pO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IHNzckNvbnRleHRLZXkgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHNzckNvbnRleHRgIDogYGApO1xyXG5jb25zdCB1c2VTU1JDb250ZXh0ID0gKCkgPT4ge1xyXG4gICAge1xyXG4gICAgICAgIGNvbnN0IGN0eCA9IGluamVjdChzc3JDb250ZXh0S2V5KTtcclxuICAgICAgICBpZiAoIWN0eCkge1xyXG4gICAgICAgICAgICB3YXJuKGBTZXJ2ZXIgcmVuZGVyaW5nIGNvbnRleHQgbm90IHByb3ZpZGVkLiBNYWtlIHN1cmUgdG8gb25seSBjYWxsIGAgK1xyXG4gICAgICAgICAgICAgICAgYHVzZVNTUkNvbnRleHQoKSBjb25kaXRpb25hbGx5IGluIHRoZSBzZXJ2ZXIgYnVpbGQuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjdHg7XHJcbiAgICB9XHJcbn07XG5cbmZ1bmN0aW9uIGlzU2hhbGxvdyh2YWx1ZSkge1xyXG4gICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzU2hhbGxvd1wiIC8qIElTX1NIQUxMT1cgKi9dKTtcclxufVxuXG5mdW5jdGlvbiBpbml0Q3VzdG9tRm9ybWF0dGVyKCkge1xyXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXHJcbiAgICBpZiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHZ1ZVN0eWxlID0geyBzdHlsZTogJ2NvbG9yOiMzYmE3NzYnIH07XHJcbiAgICBjb25zdCBudW1iZXJTdHlsZSA9IHsgc3R5bGU6ICdjb2xvcjojMGIxYmM5JyB9O1xyXG4gICAgY29uc3Qgc3RyaW5nU3R5bGUgPSB7IHN0eWxlOiAnY29sb3I6I2I2MmUyNCcgfTtcclxuICAgIGNvbnN0IGtleXdvcmRTdHlsZSA9IHsgc3R5bGU6ICdjb2xvcjojOWQyODhjJyB9O1xyXG4gICAgLy8gY3VzdG9tIGZvcm1hdHRlciBmb3IgQ2hyb21lXHJcbiAgICAvLyBodHRwczovL3d3dy5tYXR0emV1bmVydC5jb20vMjAxNi8wMi8xOS9jdXN0b20tY2hyb21lLWRldnRvb2xzLW9iamVjdC1mb3JtYXR0ZXJzLmh0bWxcclxuICAgIGNvbnN0IGZvcm1hdHRlciA9IHtcclxuICAgICAgICBoZWFkZXIob2JqKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gYWxzbyBmb3JtYXQgQ29tcG9uZW50UHVibGljSW5zdGFuY2UgJiBjdHguc2xvdHMvYXR0cnMgaW4gc2V0dXBcclxuICAgICAgICAgICAgaWYgKCFpc09iamVjdChvYmopKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob2JqLl9faXNWdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbJ2RpdicsIHZ1ZVN0eWxlLCBgVnVlSW5zdGFuY2VgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1JlZihvYmopKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIFsnc3BhbicsIHZ1ZVN0eWxlLCBnZW5SZWZGbGFnKG9iaildLFxyXG4gICAgICAgICAgICAgICAgICAgICc8JyxcclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRWYWx1ZShvYmoudmFsdWUpLFxyXG4gICAgICAgICAgICAgICAgICAgIGA+YFxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1JlYWN0aXZlKG9iaikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgICAgICAgICAgWydzcGFuJywgdnVlU3R5bGUsIGlzU2hhbGxvdyhvYmopID8gJ1NoYWxsb3dSZWFjdGl2ZScgOiAnUmVhY3RpdmUnXSxcclxuICAgICAgICAgICAgICAgICAgICAnPCcsXHJcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0VmFsdWUob2JqKSxcclxuICAgICAgICAgICAgICAgICAgICBgPiR7aXNSZWFkb25seShvYmopID8gYCAocmVhZG9ubHkpYCA6IGBgfWBcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWFkb25seShvYmopKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIFsnc3BhbicsIHZ1ZVN0eWxlLCBpc1NoYWxsb3cob2JqKSA/ICdTaGFsbG93UmVhZG9ubHknIDogJ1JlYWRvbmx5J10sXHJcbiAgICAgICAgICAgICAgICAgICAgJzwnLFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdFZhbHVlKG9iaiksXHJcbiAgICAgICAgICAgICAgICAgICAgJz4nXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFzQm9keShvYmopIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19pc1Z1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvZHkob2JqKSB7XHJcbiAgICAgICAgICAgIGlmIChvYmogJiYgb2JqLl9faXNWdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uZm9ybWF0SW5zdGFuY2Uob2JqLiQpXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIGZvcm1hdEluc3RhbmNlKGluc3RhbmNlKSB7XHJcbiAgICAgICAgY29uc3QgYmxvY2tzID0gW107XHJcbiAgICAgICAgaWYgKGluc3RhbmNlLnR5cGUucHJvcHMgJiYgaW5zdGFuY2UucHJvcHMpIHtcclxuICAgICAgICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jaygncHJvcHMnLCB0b1JhdyhpbnN0YW5jZS5wcm9wcykpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGluc3RhbmNlLnNldHVwU3RhdGUgIT09IEVNUFRZX09CSikge1xyXG4gICAgICAgICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKCdzZXR1cCcsIGluc3RhbmNlLnNldHVwU3RhdGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGluc3RhbmNlLmRhdGEgIT09IEVNUFRZX09CSikge1xyXG4gICAgICAgICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKCdkYXRhJywgdG9SYXcoaW5zdGFuY2UuZGF0YSkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSBleHRyYWN0S2V5cyhpbnN0YW5jZSwgJ2NvbXB1dGVkJyk7XHJcbiAgICAgICAgaWYgKGNvbXB1dGVkKSB7XHJcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soJ2NvbXB1dGVkJywgY29tcHV0ZWQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaW5qZWN0ZWQgPSBleHRyYWN0S2V5cyhpbnN0YW5jZSwgJ2luamVjdCcpO1xyXG4gICAgICAgIGlmIChpbmplY3RlZCkge1xyXG4gICAgICAgICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKCdpbmplY3RlZCcsIGluamVjdGVkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJsb2Nrcy5wdXNoKFtcclxuICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAnc3BhbicsXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGtleXdvcmRTdHlsZS5zdHlsZSArICc7b3BhY2l0eTowLjY2J1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICckIChpbnRlcm5hbCk6ICdcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgWydvYmplY3QnLCB7IG9iamVjdDogaW5zdGFuY2UgfV1cclxuICAgICAgICBdKTtcclxuICAgICAgICByZXR1cm4gYmxvY2tzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VCbG9jayh0eXBlLCB0YXJnZXQpIHtcclxuICAgICAgICB0YXJnZXQgPSBleHRlbmQoe30sIHRhcmdldCk7XHJcbiAgICAgICAgaWYgKCFPYmplY3Qua2V5cyh0YXJnZXQpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gWydzcGFuJywge31dO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAgeyBzdHlsZTogJ2xpbmUtaGVpZ2h0OjEuMjVlbTttYXJnaW4tYm90dG9tOjAuNmVtJyB9LFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ2NvbG9yOiM0NzY1ODInXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgdHlwZVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ3BhZGRpbmctbGVmdDoxLjI1ZW0nXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLi4uT2JqZWN0LmtleXModGFyZ2V0KS5tYXAoa2V5ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFsnc3BhbicsIGtleXdvcmRTdHlsZSwga2V5ICsgJzogJ10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdFZhbHVlKHRhcmdldFtrZXldLCBmYWxzZSlcclxuICAgICAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBmb3JtYXRWYWx1ZSh2LCBhc1JhdyA9IHRydWUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCBudW1iZXJTdHlsZSwgdl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gWydzcGFuJywgc3RyaW5nU3R5bGUsIEpTT04uc3RyaW5naWZ5KHYpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHYgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICByZXR1cm4gWydzcGFuJywga2V5d29yZFN0eWxlLCB2XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QodikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsnb2JqZWN0JywgeyBvYmplY3Q6IGFzUmF3ID8gdG9SYXcodikgOiB2IH1dO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHN0cmluZ1N0eWxlLCBTdHJpbmcodildO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RLZXlzKGluc3RhbmNlLCB0eXBlKSB7XHJcbiAgICAgICAgY29uc3QgQ29tcCA9IGluc3RhbmNlLnR5cGU7XHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oQ29tcCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBleHRyYWN0ZWQgPSB7fTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnN0YW5jZS5jdHgpIHtcclxuICAgICAgICAgICAgaWYgKGlzS2V5T2ZUeXBlKENvbXAsIGtleSwgdHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIGV4dHJhY3RlZFtrZXldID0gaW5zdGFuY2UuY3R4W2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGV4dHJhY3RlZDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzS2V5T2ZUeXBlKENvbXAsIGtleSwgdHlwZSkge1xyXG4gICAgICAgIGNvbnN0IG9wdHMgPSBDb21wW3R5cGVdO1xyXG4gICAgICAgIGlmICgoaXNBcnJheShvcHRzKSAmJiBvcHRzLmluY2x1ZGVzKGtleSkpIHx8XHJcbiAgICAgICAgICAgIChpc09iamVjdChvcHRzKSAmJiBrZXkgaW4gb3B0cykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChDb21wLmV4dGVuZHMgJiYgaXNLZXlPZlR5cGUoQ29tcC5leHRlbmRzLCBrZXksIHR5cGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQ29tcC5taXhpbnMgJiYgQ29tcC5taXhpbnMuc29tZShtID0+IGlzS2V5T2ZUeXBlKG0sIGtleSwgdHlwZSkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdlblJlZkZsYWcodikge1xyXG4gICAgICAgIGlmIChpc1NoYWxsb3codikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGBTaGFsbG93UmVmYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHYuZWZmZWN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgQ29tcHV0ZWRSZWZgO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYFJlZmA7XHJcbiAgICB9XHJcbiAgICBpZiAod2luZG93LmRldnRvb2xzRm9ybWF0dGVycykge1xyXG4gICAgICAgIHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMucHVzaChmb3JtYXR0ZXIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgd2luZG93LmRldnRvb2xzRm9ybWF0dGVycyA9IFtmb3JtYXR0ZXJdO1xyXG4gICAgfVxyXG59XG5cbmZ1bmN0aW9uIHdpdGhNZW1vKG1lbW8sIHJlbmRlciwgY2FjaGUsIGluZGV4KSB7XHJcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZVtpbmRleF07XHJcbiAgICBpZiAoY2FjaGVkICYmIGlzTWVtb1NhbWUoY2FjaGVkLCBtZW1vKSkge1xyXG4gICAgICAgIHJldHVybiBjYWNoZWQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXQgPSByZW5kZXIoKTtcclxuICAgIC8vIHNoYWxsb3cgY2xvbmVcclxuICAgIHJldC5tZW1vID0gbWVtby5zbGljZSgpO1xyXG4gICAgcmV0dXJuIChjYWNoZVtpbmRleF0gPSByZXQpO1xyXG59XHJcbmZ1bmN0aW9uIGlzTWVtb1NhbWUoY2FjaGVkLCBtZW1vKSB7XHJcbiAgICBjb25zdCBwcmV2ID0gY2FjaGVkLm1lbW87XHJcbiAgICBpZiAocHJldi5sZW5ndGggIT0gbWVtby5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXYubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAocHJldltpXSAhPT0gbWVtb1tpXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gbWFrZSBzdXJlIHRvIGxldCBwYXJlbnQgYmxvY2sgdHJhY2sgaXQgd2hlbiByZXR1cm5pbmcgY2FjaGVkXHJcbiAgICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiBjdXJyZW50QmxvY2spIHtcclxuICAgICAgICBjdXJyZW50QmxvY2sucHVzaChjYWNoZWQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cblxuLy8gQ29yZSBBUEkgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbmNvbnN0IHZlcnNpb24gPSBcIjMuMi4zMVwiO1xyXG5jb25zdCBfc3NyVXRpbHMgPSB7XHJcbiAgICBjcmVhdGVDb21wb25lbnRJbnN0YW5jZSxcclxuICAgIHNldHVwQ29tcG9uZW50LFxyXG4gICAgcmVuZGVyQ29tcG9uZW50Um9vdCxcclxuICAgIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSxcclxuICAgIGlzVk5vZGUsXHJcbiAgICBub3JtYWxpemVWTm9kZVxyXG59O1xyXG4vKipcclxuICogU1NSIHV0aWxzIGZvciBcXEB2dWUvc2VydmVyLXJlbmRlcmVyLiBPbmx5IGV4cG9zZWQgaW4gY2pzIGJ1aWxkcy5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCBzc3JVdGlscyA9IChfc3NyVXRpbHMgKTtcclxuLyoqXHJcbiAqIEBpbnRlcm5hbCBvbmx5IGV4cG9zZWQgaW4gY29tcGF0IGJ1aWxkc1xyXG4gKi9cclxuY29uc3QgcmVzb2x2ZUZpbHRlciA9IG51bGw7XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWwgb25seSBleHBvc2VkIGluIGNvbXBhdCBidWlsZHMuXHJcbiAqL1xyXG5jb25zdCBjb21wYXRVdGlscyA9IChudWxsKTtcblxuZXhwb3J0IHsgQmFzZVRyYW5zaXRpb24sIENvbW1lbnQsIEZyYWdtZW50LCBLZWVwQWxpdmUsIFN0YXRpYywgU3VzcGVuc2UsIFRlbGVwb3J0LCBUZXh0LCBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZywgY2FsbFdpdGhFcnJvckhhbmRsaW5nLCBjbG9uZVZOb2RlLCBjb21wYXRVdGlscywgY29tcHV0ZWQsIGNyZWF0ZUJsb2NrLCBjcmVhdGVDb21tZW50Vk5vZGUsIGNyZWF0ZUVsZW1lbnRCbG9jaywgY3JlYXRlQmFzZVZOb2RlIGFzIGNyZWF0ZUVsZW1lbnRWTm9kZSwgY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIsIGNyZWF0ZVByb3BzUmVzdFByb3h5LCBjcmVhdGVSZW5kZXJlciwgY3JlYXRlU2xvdHMsIGNyZWF0ZVN0YXRpY1ZOb2RlLCBjcmVhdGVUZXh0Vk5vZGUsIGNyZWF0ZVZOb2RlLCBkZWZpbmVBc3luY0NvbXBvbmVudCwgZGVmaW5lQ29tcG9uZW50LCBkZWZpbmVFbWl0cywgZGVmaW5lRXhwb3NlLCBkZWZpbmVQcm9wcywgZGV2dG9vbHMsIGdldEN1cnJlbnRJbnN0YW5jZSwgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuLCBndWFyZFJlYWN0aXZlUHJvcHMsIGgsIGhhbmRsZUVycm9yLCBpbml0Q3VzdG9tRm9ybWF0dGVyLCBpbmplY3QsIGlzTWVtb1NhbWUsIGlzUnVudGltZU9ubHksIGlzVk5vZGUsIG1lcmdlRGVmYXVsdHMsIG1lcmdlUHJvcHMsIG5leHRUaWNrLCBvbkFjdGl2YXRlZCwgb25CZWZvcmVNb3VudCwgb25CZWZvcmVVbm1vdW50LCBvbkJlZm9yZVVwZGF0ZSwgb25EZWFjdGl2YXRlZCwgb25FcnJvckNhcHR1cmVkLCBvbk1vdW50ZWQsIG9uUmVuZGVyVHJhY2tlZCwgb25SZW5kZXJUcmlnZ2VyZWQsIG9uU2VydmVyUHJlZmV0Y2gsIG9uVW5tb3VudGVkLCBvblVwZGF0ZWQsIG9wZW5CbG9jaywgcG9wU2NvcGVJZCwgcHJvdmlkZSwgcHVzaFNjb3BlSWQsIHF1ZXVlUG9zdEZsdXNoQ2IsIHJlZ2lzdGVyUnVudGltZUNvbXBpbGVyLCByZW5kZXJMaXN0LCByZW5kZXJTbG90LCByZXNvbHZlQ29tcG9uZW50LCByZXNvbHZlRGlyZWN0aXZlLCByZXNvbHZlRHluYW1pY0NvbXBvbmVudCwgcmVzb2x2ZUZpbHRlciwgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcywgc2V0QmxvY2tUcmFja2luZywgc2V0RGV2dG9vbHNIb29rLCBzZXRUcmFuc2l0aW9uSG9va3MsIHNzckNvbnRleHRLZXksIHNzclV0aWxzLCB0b0hhbmRsZXJzLCB0cmFuc2Zvcm1WTm9kZUFyZ3MsIHVzZUF0dHJzLCB1c2VTU1JDb250ZXh0LCB1c2VTbG90cywgdXNlVHJhbnNpdGlvblN0YXRlLCB2ZXJzaW9uLCB3YXJuLCB3YXRjaCwgd2F0Y2hFZmZlY3QsIHdhdGNoUG9zdEVmZmVjdCwgd2F0Y2hTeW5jRWZmZWN0LCB3aXRoQXN5bmNDb250ZXh0LCB3aXRoQ3R4LCB3aXRoRGVmYXVsdHMsIHdpdGhEaXJlY3RpdmVzLCB3aXRoTWVtbywgd2l0aFNjb3BlSWQgfTtcbiIsImltcG9ydCB7IGNhbWVsaXplLCB3YXJuLCBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZywgZGVmaW5lQ29tcG9uZW50LCBuZXh0VGljaywgY3JlYXRlVk5vZGUsIGdldEN1cnJlbnRJbnN0YW5jZSwgd2F0Y2hQb3N0RWZmZWN0LCBvbk1vdW50ZWQsIG9uVW5tb3VudGVkLCBGcmFnbWVudCwgU3RhdGljLCBoLCBCYXNlVHJhbnNpdGlvbiwgdXNlVHJhbnNpdGlvblN0YXRlLCBvblVwZGF0ZWQsIHRvUmF3LCBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4sIHNldFRyYW5zaXRpb25Ib29rcywgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcywgY3JlYXRlUmVuZGVyZXIsIGlzUnVudGltZU9ubHksIGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyIH0gZnJvbSAnQHZ1ZS9ydW50aW1lLWNvcmUnO1xuZXhwb3J0ICogZnJvbSAnQHZ1ZS9ydW50aW1lLWNvcmUnO1xuaW1wb3J0IHsgaXNTdHJpbmcsIGlzQXJyYXksIGh5cGhlbmF0ZSwgY2FwaXRhbGl6ZSwgaXNTcGVjaWFsQm9vbGVhbkF0dHIsIGluY2x1ZGVCb29sZWFuQXR0ciwgaXNPbiwgaXNNb2RlbExpc3RlbmVyLCBpc0Z1bmN0aW9uLCB0b051bWJlciwgY2FtZWxpemUgYXMgY2FtZWxpemUkMSwgZXh0ZW5kLCBFTVBUWV9PQkosIGlzT2JqZWN0LCBpbnZva2VBcnJheUZucywgbG9vc2VJbmRleE9mLCBpc1NldCwgbG9vc2VFcXVhbCwgaXNIVE1MVGFnLCBpc1NWR1RhZyB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuY29uc3Qgc3ZnTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xyXG5jb25zdCBkb2MgPSAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogbnVsbCk7XHJcbmNvbnN0IHRlbXBsYXRlQ29udGFpbmVyID0gZG9jICYmIGRvYy5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xyXG5jb25zdCBub2RlT3BzID0ge1xyXG4gICAgaW5zZXJ0OiAoY2hpbGQsIHBhcmVudCwgYW5jaG9yKSA9PiB7XHJcbiAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgYW5jaG9yIHx8IG51bGwpO1xyXG4gICAgfSxcclxuICAgIHJlbW92ZTogY2hpbGQgPT4ge1xyXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGNoaWxkLnBhcmVudE5vZGU7XHJcbiAgICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjcmVhdGVFbGVtZW50OiAodGFnLCBpc1NWRywgaXMsIHByb3BzKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZWwgPSBpc1NWR1xyXG4gICAgICAgICAgICA/IGRvYy5jcmVhdGVFbGVtZW50TlMoc3ZnTlMsIHRhZylcclxuICAgICAgICAgICAgOiBkb2MuY3JlYXRlRWxlbWVudCh0YWcsIGlzID8geyBpcyB9IDogdW5kZWZpbmVkKTtcclxuICAgICAgICBpZiAodGFnID09PSAnc2VsZWN0JyAmJiBwcm9wcyAmJiBwcm9wcy5tdWx0aXBsZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCBwcm9wcy5tdWx0aXBsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbDtcclxuICAgIH0sXHJcbiAgICBjcmVhdGVUZXh0OiB0ZXh0ID0+IGRvYy5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSxcclxuICAgIGNyZWF0ZUNvbW1lbnQ6IHRleHQgPT4gZG9jLmNyZWF0ZUNvbW1lbnQodGV4dCksXHJcbiAgICBzZXRUZXh0OiAobm9kZSwgdGV4dCkgPT4ge1xyXG4gICAgICAgIG5vZGUubm9kZVZhbHVlID0gdGV4dDtcclxuICAgIH0sXHJcbiAgICBzZXRFbGVtZW50VGV4dDogKGVsLCB0ZXh0KSA9PiB7XHJcbiAgICAgICAgZWwudGV4dENvbnRlbnQgPSB0ZXh0O1xyXG4gICAgfSxcclxuICAgIHBhcmVudE5vZGU6IG5vZGUgPT4gbm9kZS5wYXJlbnROb2RlLFxyXG4gICAgbmV4dFNpYmxpbmc6IG5vZGUgPT4gbm9kZS5uZXh0U2libGluZyxcclxuICAgIHF1ZXJ5U2VsZWN0b3I6IHNlbGVjdG9yID0+IGRvYy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSxcclxuICAgIHNldFNjb3BlSWQoZWwsIGlkKSB7XHJcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKGlkLCAnJyk7XHJcbiAgICB9LFxyXG4gICAgY2xvbmVOb2RlKGVsKSB7XHJcbiAgICAgICAgY29uc3QgY2xvbmVkID0gZWwuY2xvbmVOb2RlKHRydWUpO1xyXG4gICAgICAgIC8vICMzMDcyXHJcbiAgICAgICAgLy8gLSBpbiBgcGF0Y2hET01Qcm9wYCwgd2Ugc3RvcmUgdGhlIGFjdHVhbCB2YWx1ZSBpbiB0aGUgYGVsLl92YWx1ZWAgcHJvcGVydHkuXHJcbiAgICAgICAgLy8gLSBub3JtYWxseSwgZWxlbWVudHMgdXNpbmcgYDp2YWx1ZWAgYmluZGluZ3Mgd2lsbCBub3QgYmUgaG9pc3RlZCwgYnV0IGlmXHJcbiAgICAgICAgLy8gICB0aGUgYm91bmQgdmFsdWUgaXMgYSBjb25zdGFudCwgZS5nLiBgOnZhbHVlPVwidHJ1ZVwiYCAtIHRoZXkgZG8gZ2V0XHJcbiAgICAgICAgLy8gICBob2lzdGVkLlxyXG4gICAgICAgIC8vIC0gaW4gcHJvZHVjdGlvbiwgaG9pc3RlZCBub2RlcyBhcmUgY2xvbmVkIHdoZW4gc3Vic2VxdWVudCBpbnNlcnRzLCBidXRcclxuICAgICAgICAvLyAgIGNsb25lTm9kZSgpIGRvZXMgbm90IGNvcHkgdGhlIGN1c3RvbSBwcm9wZXJ0eSB3ZSBhdHRhY2hlZC5cclxuICAgICAgICAvLyAtIFRoaXMgbWF5IG5lZWQgdG8gYWNjb3VudCBmb3Igb3RoZXIgY3VzdG9tIERPTSBwcm9wZXJ0aWVzIHdlIGF0dGFjaCB0b1xyXG4gICAgICAgIC8vICAgZWxlbWVudHMgaW4gYWRkaXRpb24gdG8gYF92YWx1ZWAgaW4gdGhlIGZ1dHVyZS5cclxuICAgICAgICBpZiAoYF92YWx1ZWAgaW4gZWwpIHtcclxuICAgICAgICAgICAgY2xvbmVkLl92YWx1ZSA9IGVsLl92YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNsb25lZDtcclxuICAgIH0sXHJcbiAgICAvLyBfX1VOU0FGRV9fXHJcbiAgICAvLyBSZWFzb246IGlubmVySFRNTC5cclxuICAgIC8vIFN0YXRpYyBjb250ZW50IGhlcmUgY2FuIG9ubHkgY29tZSBmcm9tIGNvbXBpbGVkIHRlbXBsYXRlcy5cclxuICAgIC8vIEFzIGxvbmcgYXMgdGhlIHVzZXIgb25seSB1c2VzIHRydXN0ZWQgdGVtcGxhdGVzLCB0aGlzIGlzIHNhZmUuXHJcbiAgICBpbnNlcnRTdGF0aWNDb250ZW50KGNvbnRlbnQsIHBhcmVudCwgYW5jaG9yLCBpc1NWRywgc3RhcnQsIGVuZCkge1xyXG4gICAgICAgIC8vIDxwYXJlbnQ+IGJlZm9yZSB8IGZpcnN0IC4uLiBsYXN0IHwgYW5jaG9yIDwvcGFyZW50PlxyXG4gICAgICAgIGNvbnN0IGJlZm9yZSA9IGFuY2hvciA/IGFuY2hvci5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnQubGFzdENoaWxkO1xyXG4gICAgICAgIC8vICM1MzA4IGNhbiBvbmx5IHRha2UgY2FjaGVkIHBhdGggaWY6XHJcbiAgICAgICAgLy8gLSBoYXMgYSBzaW5nbGUgcm9vdCBub2RlXHJcbiAgICAgICAgLy8gLSBuZXh0U2libGluZyBpbmZvIGlzIHN0aWxsIGF2YWlsYWJsZVxyXG4gICAgICAgIGlmIChzdGFydCAmJiAoc3RhcnQgPT09IGVuZCB8fCBzdGFydC5uZXh0U2libGluZykpIHtcclxuICAgICAgICAgICAgLy8gY2FjaGVkXHJcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHN0YXJ0LmNsb25lTm9kZSh0cnVlKSwgYW5jaG9yKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdGFydCA9PT0gZW5kIHx8ICEoc3RhcnQgPSBzdGFydC5uZXh0U2libGluZykpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGZyZXNoIGluc2VydFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZUNvbnRhaW5lci5pbm5lckhUTUwgPSBpc1NWRyA/IGA8c3ZnPiR7Y29udGVudH08L3N2Zz5gIDogY29udGVudDtcclxuICAgICAgICAgICAgY29uc3QgdGVtcGxhdGUgPSB0ZW1wbGF0ZUNvbnRhaW5lci5jb250ZW50O1xyXG4gICAgICAgICAgICBpZiAoaXNTVkcpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBvdXRlciBzdmcgd3JhcHBlclxyXG4gICAgICAgICAgICAgICAgY29uc3Qgd3JhcHBlciA9IHRlbXBsYXRlLmZpcnN0Q2hpbGQ7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAod3JhcHBlci5maXJzdENoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUuYXBwZW5kQ2hpbGQod3JhcHBlci5maXJzdENoaWxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRlbXBsYXRlLnJlbW92ZUNoaWxkKHdyYXBwZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodGVtcGxhdGUsIGFuY2hvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIC8vIGZpcnN0XHJcbiAgICAgICAgICAgIGJlZm9yZSA/IGJlZm9yZS5uZXh0U2libGluZyA6IHBhcmVudC5maXJzdENoaWxkLFxyXG4gICAgICAgICAgICAvLyBsYXN0XHJcbiAgICAgICAgICAgIGFuY2hvciA/IGFuY2hvci5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnQubGFzdENoaWxkXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxufTtcblxuLy8gY29tcGlsZXIgc2hvdWxkIG5vcm1hbGl6ZSBjbGFzcyArIDpjbGFzcyBiaW5kaW5ncyBvbiB0aGUgc2FtZSBlbGVtZW50XHJcbi8vIGludG8gYSBzaW5nbGUgYmluZGluZyBbJ3N0YXRpY0NsYXNzJywgZHluYW1pY11cclxuZnVuY3Rpb24gcGF0Y2hDbGFzcyhlbCwgdmFsdWUsIGlzU1ZHKSB7XHJcbiAgICAvLyBkaXJlY3RseSBzZXR0aW5nIGNsYXNzTmFtZSBzaG91bGQgYmUgZmFzdGVyIHRoYW4gc2V0QXR0cmlidXRlIGluIHRoZW9yeVxyXG4gICAgLy8gaWYgdGhpcyBpcyBhbiBlbGVtZW50IGR1cmluZyBhIHRyYW5zaXRpb24sIHRha2UgdGhlIHRlbXBvcmFyeSB0cmFuc2l0aW9uXHJcbiAgICAvLyBjbGFzc2VzIGludG8gYWNjb3VudC5cclxuICAgIGNvbnN0IHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3Z0YztcclxuICAgIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcykge1xyXG4gICAgICAgIHZhbHVlID0gKHZhbHVlID8gW3ZhbHVlLCAuLi50cmFuc2l0aW9uQ2xhc3Nlc10gOiBbLi4udHJhbnNpdGlvbkNsYXNzZXNdKS5qb2luKCcgJyk7XHJcbiAgICB9XHJcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzU1ZHKSB7XHJcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGVsLmNsYXNzTmFtZSA9IHZhbHVlO1xyXG4gICAgfVxyXG59XG5cbmZ1bmN0aW9uIHBhdGNoU3R5bGUoZWwsIHByZXYsIG5leHQpIHtcclxuICAgIGNvbnN0IHN0eWxlID0gZWwuc3R5bGU7XHJcbiAgICBjb25zdCBpc0Nzc1N0cmluZyA9IGlzU3RyaW5nKG5leHQpO1xyXG4gICAgaWYgKG5leHQgJiYgIWlzQ3NzU3RyaW5nKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmV4dCkge1xyXG4gICAgICAgICAgICBzZXRTdHlsZShzdHlsZSwga2V5LCBuZXh0W2tleV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJldiAmJiAhaXNTdHJpbmcocHJldikpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJldikge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRba2V5XSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0U3R5bGUoc3R5bGUsIGtleSwgJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudERpc3BsYXkgPSBzdHlsZS5kaXNwbGF5O1xyXG4gICAgICAgIGlmIChpc0Nzc1N0cmluZykge1xyXG4gICAgICAgICAgICBpZiAocHJldiAhPT0gbmV4dCkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGUuY3NzVGV4dCA9IG5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocHJldikge1xyXG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluZGljYXRlcyB0aGF0IHRoZSBgZGlzcGxheWAgb2YgdGhlIGVsZW1lbnQgaXMgY29udHJvbGxlZCBieSBgdi1zaG93YCxcclxuICAgICAgICAvLyBzbyB3ZSBhbHdheXMga2VlcCB0aGUgY3VycmVudCBgZGlzcGxheWAgdmFsdWUgcmVnYXJkbGVzcyBvZiB0aGUgYHN0eWxlYFxyXG4gICAgICAgIC8vIHZhbHVlLCB0aHVzIGhhbmRpbmcgb3ZlciBjb250cm9sIHRvIGB2LXNob3dgLlxyXG4gICAgICAgIGlmICgnX3ZvZCcgaW4gZWwpIHtcclxuICAgICAgICAgICAgc3R5bGUuZGlzcGxheSA9IGN1cnJlbnREaXNwbGF5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jb25zdCBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xyXG5mdW5jdGlvbiBzZXRTdHlsZShzdHlsZSwgbmFtZSwgdmFsKSB7XHJcbiAgICBpZiAoaXNBcnJheSh2YWwpKSB7XHJcbiAgICAgICAgdmFsLmZvckVhY2godiA9PiBzZXRTdHlsZShzdHlsZSwgbmFtZSwgdikpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnLS0nKSkge1xyXG4gICAgICAgICAgICAvLyBjdXN0b20gcHJvcGVydHkgZGVmaW5pdGlvblxyXG4gICAgICAgICAgICBzdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgcHJlZml4ZWQgPSBhdXRvUHJlZml4KHN0eWxlLCBuYW1lKTtcclxuICAgICAgICAgICAgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gIWltcG9ydGFudFxyXG4gICAgICAgICAgICAgICAgc3R5bGUuc2V0UHJvcGVydHkoaHlwaGVuYXRlKHByZWZpeGVkKSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3R5bGVbcHJlZml4ZWRdID0gdmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNvbnN0IHByZWZpeGVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XHJcbmNvbnN0IHByZWZpeENhY2hlID0ge307XHJcbmZ1bmN0aW9uIGF1dG9QcmVmaXgoc3R5bGUsIHJhd05hbWUpIHtcclxuICAgIGNvbnN0IGNhY2hlZCA9IHByZWZpeENhY2hlW3Jhd05hbWVdO1xyXG4gICAgaWYgKGNhY2hlZCkge1xyXG4gICAgICAgIHJldHVybiBjYWNoZWQ7XHJcbiAgICB9XHJcbiAgICBsZXQgbmFtZSA9IGNhbWVsaXplKHJhd05hbWUpO1xyXG4gICAgaWYgKG5hbWUgIT09ICdmaWx0ZXInICYmIG5hbWUgaW4gc3R5bGUpIHtcclxuICAgICAgICByZXR1cm4gKHByZWZpeENhY2hlW3Jhd05hbWVdID0gbmFtZSk7XHJcbiAgICB9XHJcbiAgICBuYW1lID0gY2FwaXRhbGl6ZShuYW1lKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBwcmVmaXhlZCA9IHByZWZpeGVzW2ldICsgbmFtZTtcclxuICAgICAgICBpZiAocHJlZml4ZWQgaW4gc3R5bGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChwcmVmaXhDYWNoZVtyYXdOYW1lXSA9IHByZWZpeGVkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmF3TmFtZTtcclxufVxuXG5jb25zdCB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xyXG5mdW5jdGlvbiBwYXRjaEF0dHIoZWwsIGtleSwgdmFsdWUsIGlzU1ZHLCBpbnN0YW5jZSkge1xyXG4gICAgaWYgKGlzU1ZHICYmIGtleS5zdGFydHNXaXRoKCd4bGluazonKSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleS5zbGljZSg2LCBrZXkubGVuZ3RoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBub3RlIHdlIGFyZSBvbmx5IGNoZWNraW5nIGJvb2xlYW4gYXR0cmlidXRlcyB0aGF0IGRvbid0IGhhdmUgYVxyXG4gICAgICAgIC8vIGNvcnJlc3BvbmRpbmcgZG9tIHByb3Agb2YgdGhlIHNhbWUgbmFtZSBoZXJlLlxyXG4gICAgICAgIGNvbnN0IGlzQm9vbGVhbiA9IGlzU3BlY2lhbEJvb2xlYW5BdHRyKGtleSk7XHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgKGlzQm9vbGVhbiAmJiAhaW5jbHVkZUJvb2xlYW5BdHRyKHZhbHVlKSkpIHtcclxuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBpc0Jvb2xlYW4gPyAnJyA6IHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLy8gX19VTlNBRkVfX1xyXG4vLyBmdW5jdGlvbnMuIFRoZSB1c2VyIGlzIHJlc3BvbnNpYmxlIGZvciB1c2luZyB0aGVtIHdpdGggb25seSB0cnVzdGVkIGNvbnRlbnQuXHJcbmZ1bmN0aW9uIHBhdGNoRE9NUHJvcChlbCwga2V5LCB2YWx1ZSwgXHJcbi8vIHRoZSBmb2xsb3dpbmcgYXJncyBhcmUgcGFzc2VkIG9ubHkgZHVlIHRvIHBvdGVudGlhbCBpbm5lckhUTUwvdGV4dENvbnRlbnRcclxuLy8gb3ZlcnJpZGluZyBleGlzdGluZyBWTm9kZXMsIGluIHdoaWNoIGNhc2UgdGhlIG9sZCB0cmVlIG11c3QgYmUgcHJvcGVybHlcclxuLy8gdW5tb3VudGVkLlxyXG5wcmV2Q2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbikge1xyXG4gICAgaWYgKGtleSA9PT0gJ2lubmVySFRNTCcgfHwga2V5ID09PSAndGV4dENvbnRlbnQnKSB7XHJcbiAgICAgICAgaWYgKHByZXZDaGlsZHJlbikge1xyXG4gICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4ocHJldkNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxba2V5XSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChrZXkgPT09ICd2YWx1ZScgJiZcclxuICAgICAgICBlbC50YWdOYW1lICE9PSAnUFJPR1JFU1MnICYmXHJcbiAgICAgICAgLy8gY3VzdG9tIGVsZW1lbnRzIG1heSB1c2UgX3ZhbHVlIGludGVybmFsbHlcclxuICAgICAgICAhZWwudGFnTmFtZS5pbmNsdWRlcygnLScpKSB7XHJcbiAgICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcclxuICAgICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkLlxyXG4gICAgICAgIGVsLl92YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XHJcbiAgICAgICAgaWYgKGVsLnZhbHVlICE9PSBuZXdWYWx1ZSB8fFxyXG4gICAgICAgICAgICAvLyAjNDk1NjogYWx3YXlzIHNldCBmb3IgT1BUSU9OIGVsZW1lbnRzIGJlY2F1c2UgaXRzIHZhbHVlIGZhbGxzIGJhY2sgdG9cclxuICAgICAgICAgICAgLy8gdGV4dENvbnRlbnQgaWYgbm8gdmFsdWUgYXR0cmlidXRlIGlzIHByZXNlbnQuIEFuZCBzZXR0aW5nIC52YWx1ZSBmb3JcclxuICAgICAgICAgICAgLy8gT1BUSU9OIGhhcyBubyBzaWRlIGVmZmVjdFxyXG4gICAgICAgICAgICBlbC50YWdOYW1lID09PSAnT1BUSU9OJykge1xyXG4gICAgICAgICAgICBlbC52YWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiBlbFtrZXldO1xyXG4gICAgICAgIGlmICh0eXBlID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgLy8gZS5nLiA8c2VsZWN0IG11bHRpcGxlPiBjb21waWxlcyB0byB7IG11bHRpcGxlOiAnJyB9XHJcbiAgICAgICAgICAgIGVsW2tleV0gPSBpbmNsdWRlQm9vbGVhbkF0dHIodmFsdWUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09IG51bGwgJiYgdHlwZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgLy8gZS5nLiA8ZGl2IDppZD1cIm51bGxcIj5cclxuICAgICAgICAgICAgZWxba2V5XSA9ICcnO1xyXG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAvLyBlLmcuIDxpbWcgOndpZHRoPVwibnVsbFwiPlxyXG4gICAgICAgICAgICAvLyB0aGUgdmFsdWUgb2Ygc29tZSBJREwgYXR0ciBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwLCBlLmcuIGlucHV0LnNpemUgPSAwIC0+IGVycm9yXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBlbFtrZXldID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoX2EpIHsgfVxyXG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHNvbWUgcHJvcGVydGllcyBwZXJmb3JtIHZhbHVlIHZhbGlkYXRpb24gYW5kIHRocm93XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGVsW2tleV0gPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBGYWlsZWQgc2V0dGluZyBwcm9wIFwiJHtrZXl9XCIgb24gPCR7ZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpfT46IGAgK1xyXG4gICAgICAgICAgICAgICAgYHZhbHVlICR7dmFsdWV9IGlzIGludmFsaWQuYCwgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8vIEFzeW5jIGVkZ2UgY2FzZSBmaXggcmVxdWlyZXMgc3RvcmluZyBhbiBldmVudCBsaXN0ZW5lcidzIGF0dGFjaCB0aW1lc3RhbXAuXHJcbmxldCBfZ2V0Tm93ID0gRGF0ZS5ub3c7XHJcbmxldCBza2lwVGltZXN0YW1wQ2hlY2sgPSBmYWxzZTtcclxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAvLyBEZXRlcm1pbmUgd2hhdCBldmVudCB0aW1lc3RhbXAgdGhlIGJyb3dzZXIgaXMgdXNpbmcuIEFubm95aW5nbHksIHRoZVxyXG4gICAgLy8gdGltZXN0YW1wIGNhbiBlaXRoZXIgYmUgaGktcmVzIChyZWxhdGl2ZSB0byBwYWdlIGxvYWQpIG9yIGxvdy1yZXNcclxuICAgIC8vIChyZWxhdGl2ZSB0byBVTklYIGVwb2NoKSwgc28gaW4gb3JkZXIgdG8gY29tcGFyZSB0aW1lIHdlIGhhdmUgdG8gdXNlIHRoZVxyXG4gICAgLy8gc2FtZSB0aW1lc3RhbXAgdHlwZSB3aGVuIHNhdmluZyB0aGUgZmx1c2ggdGltZXN0YW1wLlxyXG4gICAgaWYgKF9nZXROb3coKSA+IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpLnRpbWVTdGFtcCkge1xyXG4gICAgICAgIC8vIGlmIHRoZSBsb3ctcmVzIHRpbWVzdGFtcCB3aGljaCBpcyBiaWdnZXIgdGhhbiB0aGUgZXZlbnQgdGltZXN0YW1wXHJcbiAgICAgICAgLy8gKHdoaWNoIGlzIGV2YWx1YXRlZCBBRlRFUikgaXQgbWVhbnMgdGhlIGV2ZW50IGlzIHVzaW5nIGEgaGktcmVzIHRpbWVzdGFtcCxcclxuICAgICAgICAvLyBhbmQgd2UgbmVlZCB0byB1c2UgdGhlIGhpLXJlcyB2ZXJzaW9uIGZvciBldmVudCBsaXN0ZW5lcnMgYXMgd2VsbC5cclxuICAgICAgICBfZ2V0Tm93ID0gKCkgPT4gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICB9XHJcbiAgICAvLyAjMzQ4NTogRmlyZWZveCA8PSA1MyBoYXMgaW5jb3JyZWN0IEV2ZW50LnRpbWVTdGFtcCBpbXBsZW1lbnRhdGlvblxyXG4gICAgLy8gYW5kIGRvZXMgbm90IGZpcmUgbWljcm90YXNrcyBpbiBiZXR3ZWVuIGV2ZW50IHByb3BhZ2F0aW9uLCBzbyBzYWZlIHRvIGV4Y2x1ZGUuXHJcbiAgICBjb25zdCBmZk1hdGNoID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS9pKTtcclxuICAgIHNraXBUaW1lc3RhbXBDaGVjayA9ICEhKGZmTWF0Y2ggJiYgTnVtYmVyKGZmTWF0Y2hbMV0pIDw9IDUzKTtcclxufVxyXG4vLyBUbyBhdm9pZCB0aGUgb3ZlcmhlYWQgb2YgcmVwZWF0ZWRseSBjYWxsaW5nIHBlcmZvcm1hbmNlLm5vdygpLCB3ZSBjYWNoZVxyXG4vLyBhbmQgdXNlIHRoZSBzYW1lIHRpbWVzdGFtcCBmb3IgYWxsIGV2ZW50IGxpc3RlbmVycyBhdHRhY2hlZCBpbiB0aGUgc2FtZSB0aWNrLlxyXG5sZXQgY2FjaGVkTm93ID0gMDtcclxuY29uc3QgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG5jb25zdCByZXNldCA9ICgpID0+IHtcclxuICAgIGNhY2hlZE5vdyA9IDA7XHJcbn07XHJcbmNvbnN0IGdldE5vdyA9ICgpID0+IGNhY2hlZE5vdyB8fCAocC50aGVuKHJlc2V0KSwgKGNhY2hlZE5vdyA9IF9nZXROb3coKSkpO1xyXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGVsLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xyXG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcclxuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGNoRXZlbnQoZWwsIHJhd05hbWUsIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBpbnN0YW5jZSA9IG51bGwpIHtcclxuICAgIC8vIHZlaSA9IHZ1ZSBldmVudCBpbnZva2Vyc1xyXG4gICAgY29uc3QgaW52b2tlcnMgPSBlbC5fdmVpIHx8IChlbC5fdmVpID0ge30pO1xyXG4gICAgY29uc3QgZXhpc3RpbmdJbnZva2VyID0gaW52b2tlcnNbcmF3TmFtZV07XHJcbiAgICBpZiAobmV4dFZhbHVlICYmIGV4aXN0aW5nSW52b2tlcikge1xyXG4gICAgICAgIC8vIHBhdGNoXHJcbiAgICAgICAgZXhpc3RpbmdJbnZva2VyLnZhbHVlID0gbmV4dFZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgW25hbWUsIG9wdGlvbnNdID0gcGFyc2VOYW1lKHJhd05hbWUpO1xyXG4gICAgICAgIGlmIChuZXh0VmFsdWUpIHtcclxuICAgICAgICAgICAgLy8gYWRkXHJcbiAgICAgICAgICAgIGNvbnN0IGludm9rZXIgPSAoaW52b2tlcnNbcmF3TmFtZV0gPSBjcmVhdGVJbnZva2VyKG5leHRWYWx1ZSwgaW5zdGFuY2UpKTtcclxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgaW52b2tlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGV4aXN0aW5nSW52b2tlcikge1xyXG4gICAgICAgICAgICAvLyByZW1vdmVcclxuICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgZXhpc3RpbmdJbnZva2VyLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgaW52b2tlcnNbcmF3TmFtZV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNvbnN0IG9wdGlvbnNNb2RpZmllclJFID0gLyg/Ok9uY2V8UGFzc2l2ZXxDYXB0dXJlKSQvO1xyXG5mdW5jdGlvbiBwYXJzZU5hbWUobmFtZSkge1xyXG4gICAgbGV0IG9wdGlvbnM7XHJcbiAgICBpZiAob3B0aW9uc01vZGlmaWVyUkUudGVzdChuYW1lKSkge1xyXG4gICAgICAgIG9wdGlvbnMgPSB7fTtcclxuICAgICAgICBsZXQgbTtcclxuICAgICAgICB3aGlsZSAoKG0gPSBuYW1lLm1hdGNoKG9wdGlvbnNNb2RpZmllclJFKSkpIHtcclxuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgbmFtZS5sZW5ndGggLSBtWzBdLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIG9wdGlvbnNbbVswXS50b0xvd2VyQ2FzZSgpXSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtoeXBoZW5hdGUobmFtZS5zbGljZSgyKSksIG9wdGlvbnNdO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUludm9rZXIoaW5pdGlhbFZhbHVlLCBpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgaW52b2tlciA9IChlKSA9PiB7XHJcbiAgICAgICAgLy8gYXN5bmMgZWRnZSBjYXNlICM2NTY2OiBpbm5lciBjbGljayBldmVudCB0cmlnZ2VycyBwYXRjaCwgZXZlbnQgaGFuZGxlclxyXG4gICAgICAgIC8vIGF0dGFjaGVkIHRvIG91dGVyIGVsZW1lbnQgZHVyaW5nIHBhdGNoLCBhbmQgdHJpZ2dlcmVkIGFnYWluLiBUaGlzXHJcbiAgICAgICAgLy8gaGFwcGVucyBiZWNhdXNlIGJyb3dzZXJzIGZpcmUgbWljcm90YXNrIHRpY2tzIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24uXHJcbiAgICAgICAgLy8gdGhlIHNvbHV0aW9uIGlzIHNpbXBsZTogd2Ugc2F2ZSB0aGUgdGltZXN0YW1wIHdoZW4gYSBoYW5kbGVyIGlzIGF0dGFjaGVkLFxyXG4gICAgICAgIC8vIGFuZCB0aGUgaGFuZGxlciB3b3VsZCBvbmx5IGZpcmUgaWYgdGhlIGV2ZW50IHBhc3NlZCB0byBpdCB3YXMgZmlyZWRcclxuICAgICAgICAvLyBBRlRFUiBpdCB3YXMgYXR0YWNoZWQuXHJcbiAgICAgICAgY29uc3QgdGltZVN0YW1wID0gZS50aW1lU3RhbXAgfHwgX2dldE5vdygpO1xyXG4gICAgICAgIGlmIChza2lwVGltZXN0YW1wQ2hlY2sgfHwgdGltZVN0YW1wID49IGludm9rZXIuYXR0YWNoZWQgLSAxKSB7XHJcbiAgICAgICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKHBhdGNoU3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGUsIGludm9rZXIudmFsdWUpLCBpbnN0YW5jZSwgNSAvKiBOQVRJVkVfRVZFTlRfSEFORExFUiAqLywgW2VdKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgaW52b2tlci52YWx1ZSA9IGluaXRpYWxWYWx1ZTtcclxuICAgIGludm9rZXIuYXR0YWNoZWQgPSBnZXROb3coKTtcclxuICAgIHJldHVybiBpbnZva2VyO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGNoU3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGUsIHZhbHVlKSB7XHJcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICBjb25zdCBvcmlnaW5hbFN0b3AgPSBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjtcclxuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9ICgpID0+IHtcclxuICAgICAgICAgICAgb3JpZ2luYWxTdG9wLmNhbGwoZSk7XHJcbiAgICAgICAgICAgIGUuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChmbiA9PiAoZSkgPT4gIWUuX3N0b3BwZWQgJiYgZm4gJiYgZm4oZSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IG5hdGl2ZU9uUkUgPSAvXm9uW2Etel0vO1xyXG5jb25zdCBwYXRjaFByb3AgPSAoZWwsIGtleSwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIGlzU1ZHID0gZmFsc2UsIHByZXZDaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKSA9PiB7XHJcbiAgICBpZiAoa2V5ID09PSAnY2xhc3MnKSB7XHJcbiAgICAgICAgcGF0Y2hDbGFzcyhlbCwgbmV4dFZhbHVlLCBpc1NWRyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChrZXkgPT09ICdzdHlsZScpIHtcclxuICAgICAgICBwYXRjaFN0eWxlKGVsLCBwcmV2VmFsdWUsIG5leHRWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc09uKGtleSkpIHtcclxuICAgICAgICAvLyBpZ25vcmUgdi1tb2RlbCBsaXN0ZW5lcnNcclxuICAgICAgICBpZiAoIWlzTW9kZWxMaXN0ZW5lcihrZXkpKSB7XHJcbiAgICAgICAgICAgIHBhdGNoRXZlbnQoZWwsIGtleSwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIHBhcmVudENvbXBvbmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoa2V5WzBdID09PSAnLidcclxuICAgICAgICA/ICgoa2V5ID0ga2V5LnNsaWNlKDEpKSwgdHJ1ZSlcclxuICAgICAgICA6IGtleVswXSA9PT0gJ14nXHJcbiAgICAgICAgICAgID8gKChrZXkgPSBrZXkuc2xpY2UoMSkpLCBmYWxzZSlcclxuICAgICAgICAgICAgOiBzaG91bGRTZXRBc1Byb3AoZWwsIGtleSwgbmV4dFZhbHVlLCBpc1NWRykpIHtcclxuICAgICAgICBwYXRjaERPTVByb3AoZWwsIGtleSwgbmV4dFZhbHVlLCBwcmV2Q2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIDxpbnB1dCB2LW1vZGVsIHR5cGU9XCJjaGVja2JveFwiPiB3aXRoXHJcbiAgICAgICAgLy8gOnRydWUtdmFsdWUgJiA6ZmFsc2UtdmFsdWVcclxuICAgICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBkb20gcHJvcGVydGllcyBzaW5jZSBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlXHJcbiAgICAgICAgLy8gc3RyaW5naWZpZWQuXHJcbiAgICAgICAgaWYgKGtleSA9PT0gJ3RydWUtdmFsdWUnKSB7XHJcbiAgICAgICAgICAgIGVsLl90cnVlVmFsdWUgPSBuZXh0VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ2ZhbHNlLXZhbHVlJykge1xyXG4gICAgICAgICAgICBlbC5fZmFsc2VWYWx1ZSA9IG5leHRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGF0Y2hBdHRyKGVsLCBrZXksIG5leHRWYWx1ZSwgaXNTVkcpO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBzaG91bGRTZXRBc1Byb3AoZWwsIGtleSwgdmFsdWUsIGlzU1ZHKSB7XHJcbiAgICBpZiAoaXNTVkcpIHtcclxuICAgICAgICAvLyBtb3N0IGtleXMgbXVzdCBiZSBzZXQgYXMgYXR0cmlidXRlIG9uIHN2ZyBlbGVtZW50cyB0byB3b3JrXHJcbiAgICAgICAgLy8gLi4uZXhjZXB0IGlubmVySFRNTCAmIHRleHRDb250ZW50XHJcbiAgICAgICAgaWYgKGtleSA9PT0gJ2lubmVySFRNTCcgfHwga2V5ID09PSAndGV4dENvbnRlbnQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBvciBuYXRpdmUgb25jbGljayB3aXRoIGZ1bmN0aW9uIHZhbHVlc1xyXG4gICAgICAgIGlmIChrZXkgaW4gZWwgJiYgbmF0aXZlT25SRS50ZXN0KGtleSkgJiYgaXNGdW5jdGlvbih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vIHNwZWxsY2hlY2sgYW5kIGRyYWdnYWJsZSBhcmUgbnVtZXJhdGVkIGF0dHJzLCBob3dldmVyIHRoZWlyXHJcbiAgICAvLyBjb3JyZXNwb25kaW5nIERPTSBwcm9wZXJ0aWVzIGFyZSBhY3R1YWxseSBib29sZWFucyAtIHRoaXMgbGVhZHMgdG9cclxuICAgIC8vIHNldHRpbmcgaXQgd2l0aCBhIHN0cmluZyBcImZhbHNlXCIgdmFsdWUgbGVhZGluZyBpdCB0byBiZSBjb2VyY2VkIHRvXHJcbiAgICAvLyBgdHJ1ZWAsIHNvIHdlIG5lZWQgdG8gYWx3YXlzIHRyZWF0IHRoZW0gYXMgYXR0cmlidXRlcy5cclxuICAgIC8vIE5vdGUgdGhhdCBgY29udGVudEVkaXRhYmxlYCBkb2Vzbid0IGhhdmUgdGhpcyBwcm9ibGVtOiBpdHMgRE9NXHJcbiAgICAvLyBwcm9wZXJ0eSBpcyBhbHNvIGVudW1lcmF0ZWQgc3RyaW5nIHZhbHVlcy5cclxuICAgIGlmIChrZXkgPT09ICdzcGVsbGNoZWNrJyB8fCBrZXkgPT09ICdkcmFnZ2FibGUnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gIzE3ODcsICMyODQwIGZvcm0gcHJvcGVydHkgb24gZm9ybSBlbGVtZW50cyBpcyByZWFkb25seSBhbmQgbXVzdCBiZSBzZXQgYXNcclxuICAgIC8vIGF0dHJpYnV0ZS5cclxuICAgIGlmIChrZXkgPT09ICdmb3JtJykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vICMxNTI2IDxpbnB1dCBsaXN0PiBtdXN0IGJlIHNldCBhcyBhdHRyaWJ1dGVcclxuICAgIGlmIChrZXkgPT09ICdsaXN0JyAmJiBlbC50YWdOYW1lID09PSAnSU5QVVQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gIzI3NjYgPHRleHRhcmVhIHR5cGU+IG11c3QgYmUgc2V0IGFzIGF0dHJpYnV0ZVxyXG4gICAgaWYgKGtleSA9PT0gJ3R5cGUnICYmIGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyBuYXRpdmUgb25jbGljayB3aXRoIHN0cmluZyB2YWx1ZSwgbXVzdCBiZSBzZXQgYXMgYXR0cmlidXRlXHJcbiAgICBpZiAobmF0aXZlT25SRS50ZXN0KGtleSkgJiYgaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGtleSBpbiBlbDtcclxufVxuXG5mdW5jdGlvbiBkZWZpbmVDdXN0b21FbGVtZW50KG9wdGlvbnMsIGh5ZGF0ZSkge1xyXG4gICAgY29uc3QgQ29tcCA9IGRlZmluZUNvbXBvbmVudChvcHRpb25zKTtcclxuICAgIGNsYXNzIFZ1ZUN1c3RvbUVsZW1lbnQgZXh0ZW5kcyBWdWVFbGVtZW50IHtcclxuICAgICAgICBjb25zdHJ1Y3Rvcihpbml0aWFsUHJvcHMpIHtcclxuICAgICAgICAgICAgc3VwZXIoQ29tcCwgaW5pdGlhbFByb3BzLCBoeWRhdGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFZ1ZUN1c3RvbUVsZW1lbnQuZGVmID0gQ29tcDtcclxuICAgIHJldHVybiBWdWVDdXN0b21FbGVtZW50O1xyXG59XHJcbmNvbnN0IGRlZmluZVNTUkN1c3RvbUVsZW1lbnQgPSAoKG9wdGlvbnMpID0+IHtcclxuICAgIC8vIEB0cy1pZ25vcmVcclxuICAgIHJldHVybiBkZWZpbmVDdXN0b21FbGVtZW50KG9wdGlvbnMsIGh5ZHJhdGUpO1xyXG59KTtcclxuY29uc3QgQmFzZUNsYXNzID0gKHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBIVE1MRWxlbWVudCA6IGNsYXNzIHtcclxufSk7XHJcbmNsYXNzIFZ1ZUVsZW1lbnQgZXh0ZW5kcyBCYXNlQ2xhc3Mge1xyXG4gICAgY29uc3RydWN0b3IoX2RlZiwgX3Byb3BzID0ge30sIGh5ZHJhdGUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX2RlZiA9IF9kZWY7XHJcbiAgICAgICAgdGhpcy5fcHJvcHMgPSBfcHJvcHM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3Jlc29sdmVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fbnVtYmVyUHJvcHMgPSBudWxsO1xyXG4gICAgICAgIGlmICh0aGlzLnNoYWRvd1Jvb3QgJiYgaHlkcmF0ZSkge1xyXG4gICAgICAgICAgICBoeWRyYXRlKHRoaXMuX2NyZWF0ZVZOb2RlKCksIHRoaXMuc2hhZG93Um9vdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHRoaXMuc2hhZG93Um9vdCkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgQ3VzdG9tIGVsZW1lbnQgaGFzIHByZS1yZW5kZXJlZCBkZWNsYXJhdGl2ZSBzaGFkb3cgcm9vdCBidXQgaXMgbm90IGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBkZWZpbmVkIGFzIGh5ZHJhdGFibGUuIFVzZSBcXGBkZWZpbmVTU1JDdXN0b21FbGVtZW50XFxgLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xyXG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlRGVmKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XHJcbiAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgbmV4dFRpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2Nvbm5lY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyKG51bGwsIHRoaXMuc2hhZG93Um9vdCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogcmVzb2x2ZSBpbm5lciBjb21wb25lbnQgZGVmaW5pdGlvbiAoaGFuZGxlIHBvc3NpYmxlIGFzeW5jIGNvbXBvbmVudClcclxuICAgICAqL1xyXG4gICAgX3Jlc29sdmVEZWYoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Jlc29sdmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcmVzb2x2ZWQgPSB0cnVlO1xyXG4gICAgICAgIC8vIHNldCBpbml0aWFsIGF0dHJzXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0QXR0cih0aGlzLmF0dHJpYnV0ZXNbaV0ubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHdhdGNoIGZ1dHVyZSBhdHRyIGNoYW5nZXNcclxuICAgICAgICBuZXcgTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnMgPT4ge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG0gb2YgbXV0YXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRBdHRyKG0uYXR0cmlidXRlTmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KS5vYnNlcnZlKHRoaXMsIHsgYXR0cmlidXRlczogdHJ1ZSB9KTtcclxuICAgICAgICBjb25zdCByZXNvbHZlID0gKGRlZikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IHByb3BzLCBzdHlsZXMgfSA9IGRlZjtcclxuICAgICAgICAgICAgY29uc3QgaGFzT3B0aW9ucyA9ICFpc0FycmF5KHByb3BzKTtcclxuICAgICAgICAgICAgY29uc3QgcmF3S2V5cyA9IHByb3BzID8gKGhhc09wdGlvbnMgPyBPYmplY3Qua2V5cyhwcm9wcykgOiBwcm9wcykgOiBbXTtcclxuICAgICAgICAgICAgLy8gY2FzdCBOdW1iZXItdHlwZSBwcm9wcyBzZXQgYmVmb3JlIHJlc29sdmVcclxuICAgICAgICAgICAgbGV0IG51bWJlclByb3BzO1xyXG4gICAgICAgICAgICBpZiAoaGFzT3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5fcHJvcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHQgPSBwcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHQgPT09IE51bWJlciB8fCAob3B0ICYmIG9wdC50eXBlID09PSBOdW1iZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BzW2tleV0gPSB0b051bWJlcih0aGlzLl9wcm9wc1trZXldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKG51bWJlclByb3BzIHx8IChudW1iZXJQcm9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCkpKVtrZXldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbnVtYmVyUHJvcHMgPSBudW1iZXJQcm9wcztcclxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIHByb3BzIHNldCBwcmUtdXBncmFkZSBvciBjb25uZWN0XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5WzBdICE9PSAnXycpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRQcm9wKGtleSwgdGhpc1trZXldLCB0cnVlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZGVmaW5pbmcgZ2V0dGVyL3NldHRlcnMgb24gcHJvdG90eXBlXHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHJhd0tleXMubWFwKGNhbWVsaXplJDEpKSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0KCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UHJvcChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0KHZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRQcm9wKGtleSwgdmFsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBhcHBseSBDU1NcclxuICAgICAgICAgICAgdGhpcy5fYXBwbHlTdHlsZXMoc3R5bGVzKTtcclxuICAgICAgICAgICAgLy8gaW5pdGlhbCByZW5kZXJcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBhc3luY0RlZiA9IHRoaXMuX2RlZi5fX2FzeW5jTG9hZGVyO1xyXG4gICAgICAgIGlmIChhc3luY0RlZikge1xyXG4gICAgICAgICAgICBhc3luY0RlZigpLnRoZW4ocmVzb2x2ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXNvbHZlKHRoaXMuX2RlZik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3NldEF0dHIoa2V5KSB7XHJcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5nZXRBdHRyaWJ1dGUoa2V5KTtcclxuICAgICAgICBpZiAodGhpcy5fbnVtYmVyUHJvcHMgJiYgdGhpcy5fbnVtYmVyUHJvcHNba2V5XSkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fc2V0UHJvcChjYW1lbGl6ZSQxKGtleSksIHZhbHVlLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfZ2V0UHJvcChrZXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcHJvcHNba2V5XTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9zZXRQcm9wKGtleSwgdmFsLCBzaG91bGRSZWZsZWN0ID0gdHJ1ZSwgc2hvdWxkVXBkYXRlID0gdHJ1ZSkge1xyXG4gICAgICAgIGlmICh2YWwgIT09IHRoaXMuX3Byb3BzW2tleV0pIHtcclxuICAgICAgICAgICAgdGhpcy5fcHJvcHNba2V5XSA9IHZhbDtcclxuICAgICAgICAgICAgaWYgKHNob3VsZFVwZGF0ZSAmJiB0aGlzLl9pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcmVmbGVjdFxyXG4gICAgICAgICAgICBpZiAoc2hvdWxkUmVmbGVjdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGh5cGhlbmF0ZShrZXkpLCAnJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGh5cGhlbmF0ZShrZXkpLCB2YWwgKyAnJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghdmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoaHlwaGVuYXRlKGtleSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3VwZGF0ZSgpIHtcclxuICAgICAgICByZW5kZXIodGhpcy5fY3JlYXRlVk5vZGUoKSwgdGhpcy5zaGFkb3dSb290KTtcclxuICAgIH1cclxuICAgIF9jcmVhdGVWTm9kZSgpIHtcclxuICAgICAgICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKHRoaXMuX2RlZiwgZXh0ZW5kKHt9LCB0aGlzLl9wcm9wcykpO1xyXG4gICAgICAgIGlmICghdGhpcy5faW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgdm5vZGUuY2UgPSBpbnN0YW5jZSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IGluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuaXNDRSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAvLyBITVJcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5jZVJlbG9hZCA9IG5ld1N0eWxlcyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsd2F5cyByZXNldCBzdHlsZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0eWxlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3R5bGVzLmZvckVhY2gocyA9PiB0aGlzLnNoYWRvd1Jvb3QucmVtb3ZlQ2hpbGQocykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3R5bGVzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlTdHlsZXMobmV3U3R5bGVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhbiBhc3luYyBjb21wb25lbnQsIGNlUmVsb2FkIGlzIGNhbGxlZCBmcm9tIHRoZSBpbm5lclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQgc28gbm8gbmVlZCB0byByZWxvYWQgdGhlIGFzeW5jIHdyYXBwZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9kZWYuX19hc3luY0xvYWRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVsb2FkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBpbnRlcmNlcHQgZW1pdFxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZW1pdCA9IChldmVudCwgLi4uYXJncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoZXZlbnQsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiBhcmdzXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8vIGxvY2F0ZSBuZWFyZXN0IFZ1ZSBjdXN0b20gZWxlbWVudCBwYXJlbnQgZm9yIHByb3ZpZGUvaW5qZWN0XHJcbiAgICAgICAgICAgICAgICBsZXQgcGFyZW50ID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHdoaWxlICgocGFyZW50ID1cclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQgJiYgKHBhcmVudC5wYXJlbnROb2RlIHx8IHBhcmVudC5ob3N0KSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgVnVlRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5wYXJlbnQgPSBwYXJlbnQuX2luc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2bm9kZTtcclxuICAgIH1cclxuICAgIF9hcHBseVN0eWxlcyhzdHlsZXMpIHtcclxuICAgICAgICBpZiAoc3R5bGVzKSB7XHJcbiAgICAgICAgICAgIHN0eWxlcy5mb3JFYWNoKGNzcyA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcclxuICAgICAgICAgICAgICAgIHMudGV4dENvbnRlbnQgPSBjc3M7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQocyk7XHJcbiAgICAgICAgICAgICAgICAvLyByZWNvcmQgZm9yIEhNUlxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLl9zdHlsZXMgfHwgKHRoaXMuX3N0eWxlcyA9IFtdKSkucHVzaChzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmZ1bmN0aW9uIHVzZUNzc01vZHVsZShuYW1lID0gJyRzdHlsZScpIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICB7XHJcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgICAgICBpZiAoIWluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGB1c2VDc3NNb2R1bGUgbXVzdCBiZSBjYWxsZWQgaW5zaWRlIHNldHVwKClgKTtcclxuICAgICAgICAgICAgcmV0dXJuIEVNUFRZX09CSjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbW9kdWxlcyA9IGluc3RhbmNlLnR5cGUuX19jc3NNb2R1bGVzO1xyXG4gICAgICAgIGlmICghbW9kdWxlcykge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybihgQ3VycmVudCBpbnN0YW5jZSBkb2VzIG5vdCBoYXZlIENTUyBtb2R1bGVzIGluamVjdGVkLmApO1xyXG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfT0JKO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtb2QgPSBtb2R1bGVzW25hbWVdO1xyXG4gICAgICAgIGlmICghbW9kKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgd2FybihgQ3VycmVudCBpbnN0YW5jZSBkb2VzIG5vdCBoYXZlIENTUyBtb2R1bGUgbmFtZWQgXCIke25hbWV9XCIuYCk7XHJcbiAgICAgICAgICAgIHJldHVybiBFTVBUWV9PQko7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtb2Q7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBTRkMncyBDU1MgdmFyaWFibGUgaW5qZWN0aW9uIGZlYXR1cmUuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VDc3NWYXJzKGdldHRlcikge1xyXG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBpZiAoIWluc3RhbmNlKSB7XHJcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgIHdhcm4oYHVzZUNzc1ZhcnMgaXMgY2FsbGVkIHdpdGhvdXQgY3VycmVudCBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlLmApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHNldFZhcnMgPSAoKSA9PiBzZXRWYXJzT25WTm9kZShpbnN0YW5jZS5zdWJUcmVlLCBnZXR0ZXIoaW5zdGFuY2UucHJveHkpKTtcclxuICAgIHdhdGNoUG9zdEVmZmVjdChzZXRWYXJzKTtcclxuICAgIG9uTW91bnRlZCgoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgb2IgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihzZXRWYXJzKTtcclxuICAgICAgICBvYi5vYnNlcnZlKGluc3RhbmNlLnN1YlRyZWUuZWwucGFyZW50Tm9kZSwgeyBjaGlsZExpc3Q6IHRydWUgfSk7XHJcbiAgICAgICAgb25Vbm1vdW50ZWQoKCkgPT4gb2IuZGlzY29ubmVjdCgpKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHNldFZhcnNPblZOb2RlKHZub2RlLCB2YXJzKSB7XHJcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgY29uc3Qgc3VzcGVuc2UgPSB2bm9kZS5zdXNwZW5zZTtcclxuICAgICAgICB2bm9kZSA9IHN1c3BlbnNlLmFjdGl2ZUJyYW5jaDtcclxuICAgICAgICBpZiAoc3VzcGVuc2UucGVuZGluZ0JyYW5jaCAmJiAhc3VzcGVuc2UuaXNIeWRyYXRpbmcpIHtcclxuICAgICAgICAgICAgc3VzcGVuc2UuZWZmZWN0cy5wdXNoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHNldFZhcnNPblZOb2RlKHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCwgdmFycyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGRyaWxsIGRvd24gSE9DcyB1bnRpbCBpdCdzIGEgbm9uLWNvbXBvbmVudCB2bm9kZVxyXG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudCkge1xyXG4gICAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50LnN1YlRyZWU7XHJcbiAgICB9XHJcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovICYmIHZub2RlLmVsKSB7XHJcbiAgICAgICAgc2V0VmFyc09uTm9kZSh2bm9kZS5lbCwgdmFycyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2bm9kZS50eXBlID09PSBGcmFnbWVudCkge1xyXG4gICAgICAgIHZub2RlLmNoaWxkcmVuLmZvckVhY2goYyA9PiBzZXRWYXJzT25WTm9kZShjLCB2YXJzKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2bm9kZS50eXBlID09PSBTdGF0aWMpIHtcclxuICAgICAgICBsZXQgeyBlbCwgYW5jaG9yIH0gPSB2bm9kZTtcclxuICAgICAgICB3aGlsZSAoZWwpIHtcclxuICAgICAgICAgICAgc2V0VmFyc09uTm9kZShlbCwgdmFycyk7XHJcbiAgICAgICAgICAgIGlmIChlbCA9PT0gYW5jaG9yKVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGVsID0gZWwubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNldFZhcnNPbk5vZGUoZWwsIHZhcnMpIHtcclxuICAgIGlmIChlbC5ub2RlVHlwZSA9PT0gMSkge1xyXG4gICAgICAgIGNvbnN0IHN0eWxlID0gZWwuc3R5bGU7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFycykge1xyXG4gICAgICAgICAgICBzdHlsZS5zZXRQcm9wZXJ0eShgLS0ke2tleX1gLCB2YXJzW2tleV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jb25zdCBUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xyXG5jb25zdCBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcclxuLy8gRE9NIFRyYW5zaXRpb24gaXMgYSBoaWdoZXItb3JkZXItY29tcG9uZW50IGJhc2VkIG9uIHRoZSBwbGF0Zm9ybS1hZ25vc3RpY1xyXG4vLyBiYXNlIFRyYW5zaXRpb24gY29tcG9uZW50LCB3aXRoIERPTS1zcGVjaWZpYyBsb2dpYy5cclxuY29uc3QgVHJhbnNpdGlvbiA9IChwcm9wcywgeyBzbG90cyB9KSA9PiBoKEJhc2VUcmFuc2l0aW9uLCByZXNvbHZlVHJhbnNpdGlvblByb3BzKHByb3BzKSwgc2xvdHMpO1xyXG5UcmFuc2l0aW9uLmRpc3BsYXlOYW1lID0gJ1RyYW5zaXRpb24nO1xyXG5jb25zdCBET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzID0ge1xyXG4gICAgbmFtZTogU3RyaW5nLFxyXG4gICAgdHlwZTogU3RyaW5nLFxyXG4gICAgY3NzOiB7XHJcbiAgICAgICAgdHlwZTogQm9vbGVhbixcclxuICAgICAgICBkZWZhdWx0OiB0cnVlXHJcbiAgICB9LFxyXG4gICAgZHVyYXRpb246IFtTdHJpbmcsIE51bWJlciwgT2JqZWN0XSxcclxuICAgIGVudGVyRnJvbUNsYXNzOiBTdHJpbmcsXHJcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXHJcbiAgICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcclxuICAgIGFwcGVhckZyb21DbGFzczogU3RyaW5nLFxyXG4gICAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcclxuICAgIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcclxuICAgIGxlYXZlRnJvbUNsYXNzOiBTdHJpbmcsXHJcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXHJcbiAgICBsZWF2ZVRvQ2xhc3M6IFN0cmluZ1xyXG59O1xyXG5jb25zdCBUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzID0gKFRyYW5zaXRpb24ucHJvcHMgPVxyXG4gICAgLyojX19QVVJFX18qLyBleHRlbmQoe30sIEJhc2VUcmFuc2l0aW9uLnByb3BzLCBET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzKSk7XHJcbi8qKlxyXG4gKiAjMzIyNyBJbmNvbWluZyBob29rcyBtYXkgYmUgbWVyZ2VkIGludG8gYXJyYXlzIHdoZW4gd3JhcHBpbmcgVHJhbnNpdGlvblxyXG4gKiB3aXRoIGN1c3RvbSBIT0NzLlxyXG4gKi9cclxuY29uc3QgY2FsbEhvb2sgPSAoaG9vaywgYXJncyA9IFtdKSA9PiB7XHJcbiAgICBpZiAoaXNBcnJheShob29rKSkge1xyXG4gICAgICAgIGhvb2suZm9yRWFjaChoID0+IGgoLi4uYXJncykpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaG9vaykge1xyXG4gICAgICAgIGhvb2soLi4uYXJncyk7XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIGhvb2sgZXhwZWN0cyBhIGNhbGxiYWNrICgybmQgYXJnKSwgd2hpY2ggbWVhbnMgdGhlIHVzZXJcclxuICogaW50ZW5kcyB0byBleHBsaWNpdGx5IGNvbnRyb2wgdGhlIGVuZCBvZiB0aGUgdHJhbnNpdGlvbi5cclxuICovXHJcbmNvbnN0IGhhc0V4cGxpY2l0Q2FsbGJhY2sgPSAoaG9vaykgPT4ge1xyXG4gICAgcmV0dXJuIGhvb2tcclxuICAgICAgICA/IGlzQXJyYXkoaG9vaylcclxuICAgICAgICAgICAgPyBob29rLnNvbWUoaCA9PiBoLmxlbmd0aCA+IDEpXHJcbiAgICAgICAgICAgIDogaG9vay5sZW5ndGggPiAxXHJcbiAgICAgICAgOiBmYWxzZTtcclxufTtcclxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhyYXdQcm9wcykge1xyXG4gICAgY29uc3QgYmFzZVByb3BzID0ge307XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiByYXdQcm9wcykge1xyXG4gICAgICAgIGlmICghKGtleSBpbiBET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzKSkge1xyXG4gICAgICAgICAgICBiYXNlUHJvcHNba2V5XSA9IHJhd1Byb3BzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHJhd1Byb3BzLmNzcyA9PT0gZmFsc2UpIHtcclxuICAgICAgICByZXR1cm4gYmFzZVByb3BzO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBuYW1lID0gJ3YnLCB0eXBlLCBkdXJhdGlvbiwgZW50ZXJGcm9tQ2xhc3MgPSBgJHtuYW1lfS1lbnRlci1mcm9tYCwgZW50ZXJBY3RpdmVDbGFzcyA9IGAke25hbWV9LWVudGVyLWFjdGl2ZWAsIGVudGVyVG9DbGFzcyA9IGAke25hbWV9LWVudGVyLXRvYCwgYXBwZWFyRnJvbUNsYXNzID0gZW50ZXJGcm9tQ2xhc3MsIGFwcGVhckFjdGl2ZUNsYXNzID0gZW50ZXJBY3RpdmVDbGFzcywgYXBwZWFyVG9DbGFzcyA9IGVudGVyVG9DbGFzcywgbGVhdmVGcm9tQ2xhc3MgPSBgJHtuYW1lfS1sZWF2ZS1mcm9tYCwgbGVhdmVBY3RpdmVDbGFzcyA9IGAke25hbWV9LWxlYXZlLWFjdGl2ZWAsIGxlYXZlVG9DbGFzcyA9IGAke25hbWV9LWxlYXZlLXRvYCB9ID0gcmF3UHJvcHM7XHJcbiAgICBjb25zdCBkdXJhdGlvbnMgPSBub3JtYWxpemVEdXJhdGlvbihkdXJhdGlvbik7XHJcbiAgICBjb25zdCBlbnRlckR1cmF0aW9uID0gZHVyYXRpb25zICYmIGR1cmF0aW9uc1swXTtcclxuICAgIGNvbnN0IGxlYXZlRHVyYXRpb24gPSBkdXJhdGlvbnMgJiYgZHVyYXRpb25zWzFdO1xyXG4gICAgY29uc3QgeyBvbkJlZm9yZUVudGVyLCBvbkVudGVyLCBvbkVudGVyQ2FuY2VsbGVkLCBvbkxlYXZlLCBvbkxlYXZlQ2FuY2VsbGVkLCBvbkJlZm9yZUFwcGVhciA9IG9uQmVmb3JlRW50ZXIsIG9uQXBwZWFyID0gb25FbnRlciwgb25BcHBlYXJDYW5jZWxsZWQgPSBvbkVudGVyQ2FuY2VsbGVkIH0gPSBiYXNlUHJvcHM7XHJcbiAgICBjb25zdCBmaW5pc2hFbnRlciA9IChlbCwgaXNBcHBlYXIsIGRvbmUpID0+IHtcclxuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyVG9DbGFzcyA6IGVudGVyVG9DbGFzcyk7XHJcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhckFjdGl2ZUNsYXNzIDogZW50ZXJBY3RpdmVDbGFzcyk7XHJcbiAgICAgICAgZG9uZSAmJiBkb25lKCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgZmluaXNoTGVhdmUgPSAoZWwsIGRvbmUpID0+IHtcclxuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XHJcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcclxuICAgICAgICBkb25lICYmIGRvbmUoKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBtYWtlRW50ZXJIb29rID0gKGlzQXBwZWFyKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIChlbCwgZG9uZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBob29rID0gaXNBcHBlYXIgPyBvbkFwcGVhciA6IG9uRW50ZXI7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmUgPSAoKSA9PiBmaW5pc2hFbnRlcihlbCwgaXNBcHBlYXIsIGRvbmUpO1xyXG4gICAgICAgICAgICBjYWxsSG9vayhob29rLCBbZWwsIHJlc29sdmVdKTtcclxuICAgICAgICAgICAgbmV4dEZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJGcm9tQ2xhc3MgOiBlbnRlckZyb21DbGFzcyk7XHJcbiAgICAgICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyVG9DbGFzcyA6IGVudGVyVG9DbGFzcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0V4cGxpY2l0Q2FsbGJhY2soaG9vaykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGVudGVyRHVyYXRpb24sIHJlc29sdmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBleHRlbmQoYmFzZVByb3BzLCB7XHJcbiAgICAgICAgb25CZWZvcmVFbnRlcihlbCkge1xyXG4gICAgICAgICAgICBjYWxsSG9vayhvbkJlZm9yZUVudGVyLCBbZWxdKTtcclxuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBlbnRlckZyb21DbGFzcyk7XHJcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgZW50ZXJBY3RpdmVDbGFzcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkJlZm9yZUFwcGVhcihlbCkge1xyXG4gICAgICAgICAgICBjYWxsSG9vayhvbkJlZm9yZUFwcGVhciwgW2VsXSk7XHJcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYXBwZWFyRnJvbUNsYXNzKTtcclxuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhcHBlYXJBY3RpdmVDbGFzcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkVudGVyOiBtYWtlRW50ZXJIb29rKGZhbHNlKSxcclxuICAgICAgICBvbkFwcGVhcjogbWFrZUVudGVySG9vayh0cnVlKSxcclxuICAgICAgICBvbkxlYXZlKGVsLCBkb25lKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmUgPSAoKSA9PiBmaW5pc2hMZWF2ZShlbCwgZG9uZSk7XHJcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVGcm9tQ2xhc3MpO1xyXG4gICAgICAgICAgICAvLyBmb3JjZSByZWZsb3cgc28gKi1sZWF2ZS1mcm9tIGNsYXNzZXMgaW1tZWRpYXRlbHkgdGFrZSBlZmZlY3QgKCMyNTkzKVxyXG4gICAgICAgICAgICBmb3JjZVJlZmxvdygpO1xyXG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgICAgICBuZXh0RnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUZyb21DbGFzcyk7XHJcbiAgICAgICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0V4cGxpY2l0Q2FsbGJhY2sob25MZWF2ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGxlYXZlRHVyYXRpb24sIHJlc29sdmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY2FsbEhvb2sob25MZWF2ZSwgW2VsLCByZXNvbHZlXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkVudGVyQ2FuY2VsbGVkKGVsKSB7XHJcbiAgICAgICAgICAgIGZpbmlzaEVudGVyKGVsLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGNhbGxIb29rKG9uRW50ZXJDYW5jZWxsZWQsIFtlbF0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25BcHBlYXJDYW5jZWxsZWQoZWwpIHtcclxuICAgICAgICAgICAgZmluaXNoRW50ZXIoZWwsIHRydWUpO1xyXG4gICAgICAgICAgICBjYWxsSG9vayhvbkFwcGVhckNhbmNlbGxlZCwgW2VsXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkxlYXZlQ2FuY2VsbGVkKGVsKSB7XHJcbiAgICAgICAgICAgIGZpbmlzaExlYXZlKGVsKTtcclxuICAgICAgICAgICAgY2FsbEhvb2sob25MZWF2ZUNhbmNlbGxlZCwgW2VsXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplRHVyYXRpb24oZHVyYXRpb24pIHtcclxuICAgIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc09iamVjdChkdXJhdGlvbikpIHtcclxuICAgICAgICByZXR1cm4gW051bWJlck9mKGR1cmF0aW9uLmVudGVyKSwgTnVtYmVyT2YoZHVyYXRpb24ubGVhdmUpXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IG4gPSBOdW1iZXJPZihkdXJhdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIFtuLCBuXTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBOdW1iZXJPZih2YWwpIHtcclxuICAgIGNvbnN0IHJlcyA9IHRvTnVtYmVyKHZhbCk7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKVxyXG4gICAgICAgIHZhbGlkYXRlRHVyYXRpb24ocmVzKTtcclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVEdXJhdGlvbih2YWwpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHdhcm4oYDx0cmFuc2l0aW9uPiBleHBsaWNpdCBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBgICtcclxuICAgICAgICAgICAgYGdvdCAke0pTT04uc3RyaW5naWZ5KHZhbCl9LmApO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNOYU4odmFsKSkge1xyXG4gICAgICAgIHdhcm4oYDx0cmFuc2l0aW9uPiBleHBsaWNpdCBkdXJhdGlvbiBpcyBOYU4gLSBgICtcclxuICAgICAgICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGNscykge1xyXG4gICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChjID0+IGMgJiYgZWwuY2xhc3NMaXN0LmFkZChjKSk7XHJcbiAgICAoZWwuX3Z0YyB8fFxyXG4gICAgICAgIChlbC5fdnRjID0gbmV3IFNldCgpKSkuYWRkKGNscyk7XHJcbn1cclxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcclxuICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goYyA9PiBjICYmIGVsLmNsYXNzTGlzdC5yZW1vdmUoYykpO1xyXG4gICAgY29uc3QgeyBfdnRjIH0gPSBlbDtcclxuICAgIGlmIChfdnRjKSB7XHJcbiAgICAgICAgX3Z0Yy5kZWxldGUoY2xzKTtcclxuICAgICAgICBpZiAoIV92dGMuc2l6ZSkge1xyXG4gICAgICAgICAgICBlbC5fdnRjID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBuZXh0RnJhbWUoY2IpIHtcclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNiKTtcclxuICAgIH0pO1xyXG59XHJcbmxldCBlbmRJZCA9IDA7XHJcbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgZXhwZWN0ZWRUeXBlLCBleHBsaWNpdFRpbWVvdXQsIHJlc29sdmUpIHtcclxuICAgIGNvbnN0IGlkID0gKGVsLl9lbmRJZCA9ICsrZW5kSWQpO1xyXG4gICAgY29uc3QgcmVzb2x2ZUlmTm90U3RhbGUgPSAoKSA9PiB7XHJcbiAgICAgICAgaWYgKGlkID09PSBlbC5fZW5kSWQpIHtcclxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBpZiAoZXhwbGljaXRUaW1lb3V0KSB7XHJcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQocmVzb2x2ZUlmTm90U3RhbGUsIGV4cGxpY2l0VGltZW91dCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IHR5cGUsIHRpbWVvdXQsIHByb3BDb3VudCB9ID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XHJcbiAgICBpZiAoIXR5cGUpIHtcclxuICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZW5kRXZlbnQgPSB0eXBlICsgJ2VuZCc7XHJcbiAgICBsZXQgZW5kZWQgPSAwO1xyXG4gICAgY29uc3QgZW5kID0gKCkgPT4ge1xyXG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZW5kRXZlbnQsIG9uRW5kKTtcclxuICAgICAgICByZXNvbHZlSWZOb3RTdGFsZSgpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IG9uRW5kID0gKGUpID0+IHtcclxuICAgICAgICBpZiAoZS50YXJnZXQgPT09IGVsICYmICsrZW5kZWQgPj0gcHJvcENvdW50KSB7XHJcbiAgICAgICAgICAgIGVuZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcclxuICAgICAgICAgICAgZW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgdGltZW91dCArIDEpO1xyXG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihlbmRFdmVudCwgb25FbmQpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpIHtcclxuICAgIGNvbnN0IHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcclxuICAgIC8vIEpTRE9NIG1heSByZXR1cm4gdW5kZWZpbmVkIGZvciB0cmFuc2l0aW9uIHByb3BlcnRpZXNcclxuICAgIGNvbnN0IGdldFN0eWxlUHJvcGVydGllcyA9IChrZXkpID0+IChzdHlsZXNba2V5XSB8fCAnJykuc3BsaXQoJywgJyk7XHJcbiAgICBjb25zdCB0cmFuc2l0aW9uRGVsYXlzID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKFRSQU5TSVRJT04gKyAnRGVsYXknKTtcclxuICAgIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbnMgPSBnZXRTdHlsZVByb3BlcnRpZXMoVFJBTlNJVElPTiArICdEdXJhdGlvbicpO1xyXG4gICAgY29uc3QgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xyXG4gICAgY29uc3QgYW5pbWF0aW9uRGVsYXlzID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKEFOSU1BVElPTiArICdEZWxheScpO1xyXG4gICAgY29uc3QgYW5pbWF0aW9uRHVyYXRpb25zID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKEFOSU1BVElPTiArICdEdXJhdGlvbicpO1xyXG4gICAgY29uc3QgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xyXG4gICAgbGV0IHR5cGUgPSBudWxsO1xyXG4gICAgbGV0IHRpbWVvdXQgPSAwO1xyXG4gICAgbGV0IHByb3BDb3VudCA9IDA7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcclxuICAgICAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xyXG4gICAgICAgICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XHJcbiAgICAgICAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XHJcbiAgICAgICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSBBTklNQVRJT047XHJcbiAgICAgICAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xyXG4gICAgICAgICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XHJcbiAgICAgICAgdHlwZSA9XHJcbiAgICAgICAgICAgIHRpbWVvdXQgPiAwXHJcbiAgICAgICAgICAgICAgICA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dFxyXG4gICAgICAgICAgICAgICAgICAgID8gVFJBTlNJVElPTlxyXG4gICAgICAgICAgICAgICAgICAgIDogQU5JTUFUSU9OXHJcbiAgICAgICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgcHJvcENvdW50ID0gdHlwZVxyXG4gICAgICAgICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cclxuICAgICAgICAgICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcclxuICAgICAgICAgICAgICAgIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aFxyXG4gICAgICAgICAgICA6IDA7XHJcbiAgICB9XHJcbiAgICBjb25zdCBoYXNUcmFuc2Zvcm0gPSB0eXBlID09PSBUUkFOU0lUSU9OICYmXHJcbiAgICAgICAgL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLy50ZXN0KHN0eWxlc1tUUkFOU0lUSU9OICsgJ1Byb3BlcnR5J10pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlLFxyXG4gICAgICAgIHRpbWVvdXQsXHJcbiAgICAgICAgcHJvcENvdW50LFxyXG4gICAgICAgIGhhc1RyYW5zZm9ybVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRUaW1lb3V0KGRlbGF5cywgZHVyYXRpb25zKSB7XHJcbiAgICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcclxuICAgICAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTWF0aC5tYXgoLi4uZHVyYXRpb25zLm1hcCgoZCwgaSkgPT4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKSkpO1xyXG59XHJcbi8vIE9sZCB2ZXJzaW9ucyBvZiBDaHJvbWl1bSAoYmVsb3cgNjEuMC4zMTYzLjEwMCkgZm9ybWF0cyBmbG9hdGluZyBwb2ludGVyXHJcbi8vIG51bWJlcnMgaW4gYSBsb2NhbGUtZGVwZW5kZW50IHdheSwgdXNpbmcgYSBjb21tYSBpbnN0ZWFkIG9mIGEgZG90LlxyXG4vLyBJZiBjb21tYSBpcyBub3QgcmVwbGFjZWQgd2l0aCBhIGRvdCwgdGhlIGlucHV0IHdpbGwgYmUgcm91bmRlZCBkb3duXHJcbi8vIChpLmUuIGFjdGluZyBhcyBhIGZsb29yIGZ1bmN0aW9uKSBjYXVzaW5nIHVuZXhwZWN0ZWQgYmVoYXZpb3JzXHJcbmZ1bmN0aW9uIHRvTXMocykge1xyXG4gICAgcmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKS5yZXBsYWNlKCcsJywgJy4nKSkgKiAxMDAwO1xyXG59XHJcbi8vIHN5bmNocm9ub3VzbHkgZm9yY2UgbGF5b3V0IHRvIHB1dCBlbGVtZW50cyBpbnRvIGEgY2VydGFpbiBzdGF0ZVxyXG5mdW5jdGlvbiBmb3JjZVJlZmxvdygpIHtcclxuICAgIHJldHVybiBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcclxufVxuXG5jb25zdCBwb3NpdGlvbk1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IG5ld1Bvc2l0aW9uTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuY29uc3QgVHJhbnNpdGlvbkdyb3VwSW1wbCA9IHtcclxuICAgIG5hbWU6ICdUcmFuc2l0aW9uR3JvdXAnLFxyXG4gICAgcHJvcHM6IC8qI19fUFVSRV9fKi8gZXh0ZW5kKHt9LCBUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLCB7XHJcbiAgICAgICAgdGFnOiBTdHJpbmcsXHJcbiAgICAgICAgbW92ZUNsYXNzOiBTdHJpbmdcclxuICAgIH0pLFxyXG4gICAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xyXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB1c2VUcmFuc2l0aW9uU3RhdGUoKTtcclxuICAgICAgICBsZXQgcHJldkNoaWxkcmVuO1xyXG4gICAgICAgIGxldCBjaGlsZHJlbjtcclxuICAgICAgICBvblVwZGF0ZWQoKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBjaGlsZHJlbiBpcyBndWFyYW50ZWVkIHRvIGV4aXN0IGFmdGVyIGluaXRpYWwgcmVuZGVyXHJcbiAgICAgICAgICAgIGlmICghcHJldkNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG1vdmVDbGFzcyA9IHByb3BzLm1vdmVDbGFzcyB8fCBgJHtwcm9wcy5uYW1lIHx8ICd2J30tbW92ZWA7XHJcbiAgICAgICAgICAgIGlmICghaGFzQ1NTVHJhbnNmb3JtKHByZXZDaGlsZHJlblswXS5lbCwgaW5zdGFuY2Uudm5vZGUuZWwsIG1vdmVDbGFzcykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcclxuICAgICAgICAgICAgLy8gaW4gZWFjaCBpdGVyYXRpb24gLSB3aGljaCBoZWxwcyBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcuXHJcbiAgICAgICAgICAgIHByZXZDaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcclxuICAgICAgICAgICAgcHJldkNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xyXG4gICAgICAgICAgICBjb25zdCBtb3ZlZENoaWxkcmVuID0gcHJldkNoaWxkcmVuLmZpbHRlcihhcHBseVRyYW5zbGF0aW9uKTtcclxuICAgICAgICAgICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXHJcbiAgICAgICAgICAgIGZvcmNlUmVmbG93KCk7XHJcbiAgICAgICAgICAgIG1vdmVkQ2hpbGRyZW4uZm9yRWFjaChjID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVsID0gYy5lbDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gZWwuc3R5bGU7XHJcbiAgICAgICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS50cmFuc2Zvcm0gPSBzdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBzdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNiID0gKGVsLl9tb3ZlQ2IgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlICYmIGUudGFyZ2V0ICE9PSBlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGNiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWwuX21vdmVDYiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBjYik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhd1Byb3BzID0gdG9SYXcocHJvcHMpO1xyXG4gICAgICAgICAgICBjb25zdCBjc3NUcmFuc2l0aW9uUHJvcHMgPSByZXNvbHZlVHJhbnNpdGlvblByb3BzKHJhd1Byb3BzKTtcclxuICAgICAgICAgICAgbGV0IHRhZyA9IHJhd1Byb3BzLnRhZyB8fCBGcmFnbWVudDtcclxuICAgICAgICAgICAgcHJldkNoaWxkcmVuID0gY2hpbGRyZW47XHJcbiAgICAgICAgICAgIGNoaWxkcmVuID0gc2xvdHMuZGVmYXVsdCA/IGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihzbG90cy5kZWZhdWx0KCkpIDogW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQua2V5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3MoY2hpbGQsIHJlc29sdmVUcmFuc2l0aW9uSG9va3MoY2hpbGQsIGNzc1RyYW5zaXRpb25Qcm9wcywgc3RhdGUsIGluc3RhbmNlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGA8VHJhbnNpdGlvbkdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBwcmV2Q2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKGNoaWxkLCByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKGNoaWxkLCBjc3NUcmFuc2l0aW9uUHJvcHMsIHN0YXRlLCBpbnN0YW5jZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uTWFwLnNldChjaGlsZCwgY2hpbGQuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0YWcsIG51bGwsIGNoaWxkcmVuKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBUcmFuc2l0aW9uR3JvdXAgPSBUcmFuc2l0aW9uR3JvdXBJbXBsO1xyXG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyhjKSB7XHJcbiAgICBjb25zdCBlbCA9IGMuZWw7XHJcbiAgICBpZiAoZWwuX21vdmVDYikge1xyXG4gICAgICAgIGVsLl9tb3ZlQ2IoKTtcclxuICAgIH1cclxuICAgIGlmIChlbC5fZW50ZXJDYikge1xyXG4gICAgICAgIGVsLl9lbnRlckNiKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24oYykge1xyXG4gICAgbmV3UG9zaXRpb25NYXAuc2V0KGMsIGMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xyXG59XHJcbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24oYykge1xyXG4gICAgY29uc3Qgb2xkUG9zID0gcG9zaXRpb25NYXAuZ2V0KGMpO1xyXG4gICAgY29uc3QgbmV3UG9zID0gbmV3UG9zaXRpb25NYXAuZ2V0KGMpO1xyXG4gICAgY29uc3QgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xyXG4gICAgY29uc3QgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcclxuICAgIGlmIChkeCB8fCBkeSkge1xyXG4gICAgICAgIGNvbnN0IHMgPSBjLmVsLnN0eWxlO1xyXG4gICAgICAgIHMudHJhbnNmb3JtID0gcy53ZWJraXRUcmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7ZHh9cHgsJHtkeX1weClgO1xyXG4gICAgICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcclxuICAgICAgICByZXR1cm4gYztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBoYXNDU1NUcmFuc2Zvcm0oZWwsIHJvb3QsIG1vdmVDbGFzcykge1xyXG4gICAgLy8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXHJcbiAgICAvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcclxuICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcclxuICAgIC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xyXG4gICAgLy8gaXMgYXBwbGllZC5cclxuICAgIGNvbnN0IGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XHJcbiAgICBpZiAoZWwuX3Z0Yykge1xyXG4gICAgICAgIGVsLl92dGMuZm9yRWFjaChjbHMgPT4ge1xyXG4gICAgICAgICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGMgPT4gYyAmJiBjbG9uZS5jbGFzc0xpc3QucmVtb3ZlKGMpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIG1vdmVDbGFzcy5zcGxpdCgvXFxzKy8pLmZvckVhY2goYyA9PiBjICYmIGNsb25lLmNsYXNzTGlzdC5hZGQoYykpO1xyXG4gICAgY2xvbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IChyb290Lm5vZGVUeXBlID09PSAxID8gcm9vdCA6IHJvb3QucGFyZW50Tm9kZSk7XHJcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2xvbmUpO1xyXG4gICAgY29uc3QgeyBoYXNUcmFuc2Zvcm0gfSA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcclxuICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjbG9uZSk7XHJcbiAgICByZXR1cm4gaGFzVHJhbnNmb3JtO1xyXG59XG5cbmNvbnN0IGdldE1vZGVsQXNzaWduZXIgPSAodm5vZGUpID0+IHtcclxuICAgIGNvbnN0IGZuID0gdm5vZGUucHJvcHNbJ29uVXBkYXRlOm1vZGVsVmFsdWUnXTtcclxuICAgIHJldHVybiBpc0FycmF5KGZuKSA/IHZhbHVlID0+IGludm9rZUFycmF5Rm5zKGZuLCB2YWx1ZSkgOiBmbjtcclxufTtcclxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0KGUpIHtcclxuICAgIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XHJcbn1cclxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZChlKSB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcclxuICAgIGlmICh0YXJnZXQuY29tcG9zaW5nKSB7XHJcbiAgICAgICAgdGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xyXG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCAnaW5wdXQnKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0cmlnZ2VyKGVsLCB0eXBlKSB7XHJcbiAgICBjb25zdCBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcclxuICAgIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xyXG4gICAgZWwuZGlzcGF0Y2hFdmVudChlKTtcclxufVxyXG4vLyBXZSBhcmUgZXhwb3J0aW5nIHRoZSB2LW1vZGVsIHJ1bnRpbWUgZGlyZWN0bHkgYXMgdm5vZGUgaG9va3Mgc28gdGhhdCBpdCBjYW5cclxuLy8gYmUgdHJlZS1zaGFrZW4gaW4gY2FzZSB2LW1vZGVsIGlzIG5ldmVyIHVzZWQuXHJcbmNvbnN0IHZNb2RlbFRleHQgPSB7XHJcbiAgICBjcmVhdGVkKGVsLCB7IG1vZGlmaWVyczogeyBsYXp5LCB0cmltLCBudW1iZXIgfSB9LCB2bm9kZSkge1xyXG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgICAgICBjb25zdCBjYXN0VG9OdW1iZXIgPSBudW1iZXIgfHwgKHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnR5cGUgPT09ICdudW1iZXInKTtcclxuICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBsYXp5ID8gJ2NoYW5nZScgOiAnaW5wdXQnLCBlID0+IHtcclxuICAgICAgICAgICAgaWYgKGUudGFyZ2V0LmNvbXBvc2luZylcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgbGV0IGRvbVZhbHVlID0gZWwudmFsdWU7XHJcbiAgICAgICAgICAgIGlmICh0cmltKSB7XHJcbiAgICAgICAgICAgICAgICBkb21WYWx1ZSA9IGRvbVZhbHVlLnRyaW0oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjYXN0VG9OdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgIGRvbVZhbHVlID0gdG9OdW1iZXIoZG9tVmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsLl9hc3NpZ24oZG9tVmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0cmltKSB7XHJcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsICdjaGFuZ2UnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBlbC52YWx1ZSA9IGVsLnZhbHVlLnRyaW0oKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbGF6eSkge1xyXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XHJcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsICdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xyXG4gICAgICAgICAgICAvLyBTYWZhcmkgPCAxMC4yICYgVUlXZWJWaWV3IGRvZXNuJ3QgZmlyZSBjb21wb3NpdGlvbmVuZCB3aGVuXHJcbiAgICAgICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcclxuICAgICAgICAgICAgLy8gdGhpcyBhbHNvIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzb21lIGJyb3dzZXJzIGUuZy4gaU9TIENocm9tZVxyXG4gICAgICAgICAgICAvLyBmaXJlcyBcImNoYW5nZVwiIGluc3RlYWQgb2YgXCJpbnB1dFwiIG9uIGF1dG9jb21wbGV0ZS5cclxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICAvLyBzZXQgdmFsdWUgb24gbW91bnRlZCBzbyBpdCdzIGFmdGVyIG1pbi9tYXggZm9yIHR5cGU9XCJyYW5nZVwiXHJcbiAgICBtb3VudGVkKGVsLCB7IHZhbHVlIH0pIHtcclxuICAgICAgICBlbC52YWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xyXG4gICAgfSxcclxuICAgIGJlZm9yZVVwZGF0ZShlbCwgeyB2YWx1ZSwgbW9kaWZpZXJzOiB7IGxhenksIHRyaW0sIG51bWJlciB9IH0sIHZub2RlKSB7XHJcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgICAgIC8vIGF2b2lkIGNsZWFyaW5nIHVucmVzb2x2ZWQgdGV4dC4gIzIzMDJcclxuICAgICAgICBpZiAoZWwuY29tcG9zaW5nKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGVsKSB7XHJcbiAgICAgICAgICAgIGlmIChsYXp5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRyaW0gJiYgZWwudmFsdWUudHJpbSgpID09PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgobnVtYmVyIHx8IGVsLnR5cGUgPT09ICdudW1iZXInKSAmJiB0b051bWJlcihlbC52YWx1ZSkgPT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcclxuICAgICAgICBpZiAoZWwudmFsdWUgIT09IG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgIGVsLnZhbHVlID0gbmV3VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5jb25zdCB2TW9kZWxDaGVja2JveCA9IHtcclxuICAgIC8vICM0MDk2IGFycmF5IGNoZWNrYm94ZXMgbmVlZCB0byBiZSBkZWVwIHRyYXZlcnNlZFxyXG4gICAgZGVlcDogdHJ1ZSxcclxuICAgIGNyZWF0ZWQoZWwsIF8sIHZub2RlKSB7XHJcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsICdjaGFuZ2UnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsVmFsdWUgPSBlbC5fbW9kZWxWYWx1ZTtcclxuICAgICAgICAgICAgY29uc3QgZWxlbWVudFZhbHVlID0gZ2V0VmFsdWUoZWwpO1xyXG4gICAgICAgICAgICBjb25zdCBjaGVja2VkID0gZWwuY2hlY2tlZDtcclxuICAgICAgICAgICAgY29uc3QgYXNzaWduID0gZWwuX2Fzc2lnbjtcclxuICAgICAgICAgICAgaWYgKGlzQXJyYXkobW9kZWxWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gbG9vc2VJbmRleE9mKG1vZGVsVmFsdWUsIGVsZW1lbnRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmb3VuZCA9IGluZGV4ICE9PSAtMTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGVja2VkICYmICFmb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbihtb2RlbFZhbHVlLmNvbmNhdChlbGVtZW50VmFsdWUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFjaGVja2VkICYmIGZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyZWQgPSBbLi4ubW9kZWxWYWx1ZV07XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWQuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBhc3NpZ24oZmlsdGVyZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzU2V0KG1vZGVsVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjbG9uZWQgPSBuZXcgU2V0KG1vZGVsVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbG9uZWQuYWRkKGVsZW1lbnRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjbG9uZWQuZGVsZXRlKGVsZW1lbnRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhc3NpZ24oY2xvbmVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFzc2lnbihnZXRDaGVja2JveFZhbHVlKGVsLCBjaGVja2VkKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICAvLyBzZXQgaW5pdGlhbCBjaGVja2VkIG9uIG1vdW50IHRvIHdhaXQgZm9yIHRydWUtdmFsdWUvZmFsc2UtdmFsdWVcclxuICAgIG1vdW50ZWQ6IHNldENoZWNrZWQsXHJcbiAgICBiZWZvcmVVcGRhdGUoZWwsIGJpbmRpbmcsIHZub2RlKSB7XHJcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgICAgIHNldENoZWNrZWQoZWwsIGJpbmRpbmcsIHZub2RlKTtcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gc2V0Q2hlY2tlZChlbCwgeyB2YWx1ZSwgb2xkVmFsdWUgfSwgdm5vZGUpIHtcclxuICAgIGVsLl9tb2RlbFZhbHVlID0gdmFsdWU7XHJcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICBlbC5jaGVja2VkID0gbG9vc2VJbmRleE9mKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSkgPiAtMTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzU2V0KHZhbHVlKSkge1xyXG4gICAgICAgIGVsLmNoZWNrZWQgPSB2YWx1ZS5oYXModm5vZGUucHJvcHMudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodmFsdWUgIT09IG9sZFZhbHVlKSB7XHJcbiAgICAgICAgZWwuY2hlY2tlZCA9IGxvb3NlRXF1YWwodmFsdWUsIGdldENoZWNrYm94VmFsdWUoZWwsIHRydWUpKTtcclxuICAgIH1cclxufVxyXG5jb25zdCB2TW9kZWxSYWRpbyA9IHtcclxuICAgIGNyZWF0ZWQoZWwsIHsgdmFsdWUgfSwgdm5vZGUpIHtcclxuICAgICAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpO1xyXG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY2hhbmdlJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBlbC5fYXNzaWduKGdldFZhbHVlKGVsKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgYmVmb3JlVXBkYXRlKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB2bm9kZSkge1xyXG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgICAgICBpZiAodmFsdWUgIT09IG9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5jb25zdCB2TW9kZWxTZWxlY3QgPSB7XHJcbiAgICAvLyA8c2VsZWN0IG11bHRpcGxlPiB2YWx1ZSBuZWVkIHRvIGJlIGRlZXAgdHJhdmVyc2VkXHJcbiAgICBkZWVwOiB0cnVlLFxyXG4gICAgY3JlYXRlZChlbCwgeyB2YWx1ZSwgbW9kaWZpZXJzOiB7IG51bWJlciB9IH0sIHZub2RlKSB7XHJcbiAgICAgICAgY29uc3QgaXNTZXRNb2RlbCA9IGlzU2V0KHZhbHVlKTtcclxuICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY2hhbmdlJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZFZhbCA9IEFycmF5LnByb3RvdHlwZS5maWx0ZXJcclxuICAgICAgICAgICAgICAgIC5jYWxsKGVsLm9wdGlvbnMsIChvKSA9PiBvLnNlbGVjdGVkKVxyXG4gICAgICAgICAgICAgICAgLm1hcCgobykgPT4gbnVtYmVyID8gdG9OdW1iZXIoZ2V0VmFsdWUobykpIDogZ2V0VmFsdWUobykpO1xyXG4gICAgICAgICAgICBlbC5fYXNzaWduKGVsLm11bHRpcGxlXHJcbiAgICAgICAgICAgICAgICA/IGlzU2V0TW9kZWxcclxuICAgICAgICAgICAgICAgICAgICA/IG5ldyBTZXQoc2VsZWN0ZWRWYWwpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBzZWxlY3RlZFZhbFxyXG4gICAgICAgICAgICAgICAgOiBzZWxlY3RlZFZhbFswXSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgfSxcclxuICAgIC8vIHNldCB2YWx1ZSBpbiBtb3VudGVkICYgdXBkYXRlZCBiZWNhdXNlIDxzZWxlY3Q+IHJlbGllcyBvbiBpdHMgY2hpbGRyZW5cclxuICAgIC8vIDxvcHRpb24+cy5cclxuICAgIG1vdW50ZWQoZWwsIHsgdmFsdWUgfSkge1xyXG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSk7XHJcbiAgICB9LFxyXG4gICAgYmVmb3JlVXBkYXRlKGVsLCBfYmluZGluZywgdm5vZGUpIHtcclxuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XHJcbiAgICB9LFxyXG4gICAgdXBkYXRlZChlbCwgeyB2YWx1ZSB9KSB7XHJcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIHZhbHVlKTtcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gc2V0U2VsZWN0ZWQoZWwsIHZhbHVlKSB7XHJcbiAgICBjb25zdCBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XHJcbiAgICBpZiAoaXNNdWx0aXBsZSAmJiAhaXNBcnJheSh2YWx1ZSkgJiYgIWlzU2V0KHZhbHVlKSkge1xyXG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICB3YXJuKGA8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw+IGV4cGVjdHMgYW4gQXJyYXkgb3IgU2V0IHZhbHVlIGZvciBpdHMgYmluZGluZywgYCArXHJcbiAgICAgICAgICAgICAgICBgYnV0IGdvdCAke09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpfS5gKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcclxuICAgICAgICBjb25zdCBvcHRpb25WYWx1ZSA9IGdldFZhbHVlKG9wdGlvbik7XHJcbiAgICAgICAgaWYgKGlzTXVsdGlwbGUpIHtcclxuICAgICAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIG9wdGlvblZhbHVlKSA+IC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdmFsdWUuaGFzKG9wdGlvblZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSlcclxuICAgICAgICAgICAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghaXNNdWx0aXBsZSAmJiBlbC5zZWxlY3RlZEluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcclxuICAgIH1cclxufVxyXG4vLyByZXRyaWV2ZSByYXcgdmFsdWUgc2V0IHZpYSA6dmFsdWUgYmluZGluZ3NcclxuZnVuY3Rpb24gZ2V0VmFsdWUoZWwpIHtcclxuICAgIHJldHVybiAnX3ZhbHVlJyBpbiBlbCA/IGVsLl92YWx1ZSA6IGVsLnZhbHVlO1xyXG59XHJcbi8vIHJldHJpZXZlIHJhdyB2YWx1ZSBmb3IgdHJ1ZS12YWx1ZSBhbmQgZmFsc2UtdmFsdWUgc2V0IHZpYSA6dHJ1ZS12YWx1ZSBvciA6ZmFsc2UtdmFsdWUgYmluZGluZ3NcclxuZnVuY3Rpb24gZ2V0Q2hlY2tib3hWYWx1ZShlbCwgY2hlY2tlZCkge1xyXG4gICAgY29uc3Qga2V5ID0gY2hlY2tlZCA/ICdfdHJ1ZVZhbHVlJyA6ICdfZmFsc2VWYWx1ZSc7XHJcbiAgICByZXR1cm4ga2V5IGluIGVsID8gZWxba2V5XSA6IGNoZWNrZWQ7XHJcbn1cclxuY29uc3Qgdk1vZGVsRHluYW1pYyA9IHtcclxuICAgIGNyZWF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKSB7XHJcbiAgICAgICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIG51bGwsICdjcmVhdGVkJyk7XHJcbiAgICB9LFxyXG4gICAgbW91bnRlZChlbCwgYmluZGluZywgdm5vZGUpIHtcclxuICAgICAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgbnVsbCwgJ21vdW50ZWQnKTtcclxuICAgIH0sXHJcbiAgICBiZWZvcmVVcGRhdGUoZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUpIHtcclxuICAgICAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCAnYmVmb3JlVXBkYXRlJyk7XHJcbiAgICB9LFxyXG4gICAgdXBkYXRlZChlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSkge1xyXG4gICAgICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUsICd1cGRhdGVkJyk7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUsIGhvb2spIHtcclxuICAgIGxldCBtb2RlbFRvVXNlO1xyXG4gICAgc3dpdGNoIChlbC50YWdOYW1lKSB7XHJcbiAgICAgICAgY2FzZSAnU0VMRUNUJzpcclxuICAgICAgICAgICAgbW9kZWxUb1VzZSA9IHZNb2RlbFNlbGVjdDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnVEVYVEFSRUEnOlxyXG4gICAgICAgICAgICBtb2RlbFRvVXNlID0gdk1vZGVsVGV4dDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgc3dpdGNoICh2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdjaGVja2JveCc6XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxUb1VzZSA9IHZNb2RlbENoZWNrYm94O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncmFkaW8nOlxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsVG9Vc2UgPSB2TW9kZWxSYWRpbztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxUb1VzZSA9IHZNb2RlbFRleHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IGZuID0gbW9kZWxUb1VzZVtob29rXTtcclxuICAgIGZuICYmIGZuKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKTtcclxufVxyXG4vLyBTU1Igdm5vZGUgdHJhbnNmb3Jtcywgb25seSB1c2VkIHdoZW4gdXNlciBpbmNsdWRlcyBjbGllbnQtb3JpZW50ZWQgcmVuZGVyXHJcbi8vIGZ1bmN0aW9uIGluIFNTUlxyXG5mdW5jdGlvbiBpbml0Vk1vZGVsRm9yU1NSKCkge1xyXG4gICAgdk1vZGVsVGV4dC5nZXRTU1JQcm9wcyA9ICh7IHZhbHVlIH0pID0+ICh7IHZhbHVlIH0pO1xyXG4gICAgdk1vZGVsUmFkaW8uZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9LCB2bm9kZSkgPT4ge1xyXG4gICAgICAgIGlmICh2bm9kZS5wcm9wcyAmJiBsb29zZUVxdWFsKHZub2RlLnByb3BzLnZhbHVlLCB2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgY2hlY2tlZDogdHJ1ZSB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB2TW9kZWxDaGVja2JveC5nZXRTU1JQcm9wcyA9ICh7IHZhbHVlIH0sIHZub2RlKSA9PiB7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGlmICh2bm9kZS5wcm9wcyAmJiBsb29zZUluZGV4T2YodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjaGVja2VkOiB0cnVlIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNTZXQodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGlmICh2bm9kZS5wcm9wcyAmJiB2YWx1ZS5oYXModm5vZGUucHJvcHMudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjaGVja2VkOiB0cnVlIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgY2hlY2tlZDogdHJ1ZSB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cblxuY29uc3Qgc3lzdGVtTW9kaWZpZXJzID0gWydjdHJsJywgJ3NoaWZ0JywgJ2FsdCcsICdtZXRhJ107XHJcbmNvbnN0IG1vZGlmaWVyR3VhcmRzID0ge1xyXG4gICAgc3RvcDogZSA9PiBlLnN0b3BQcm9wYWdhdGlvbigpLFxyXG4gICAgcHJldmVudDogZSA9PiBlLnByZXZlbnREZWZhdWx0KCksXHJcbiAgICBzZWxmOiBlID0+IGUudGFyZ2V0ICE9PSBlLmN1cnJlbnRUYXJnZXQsXHJcbiAgICBjdHJsOiBlID0+ICFlLmN0cmxLZXksXHJcbiAgICBzaGlmdDogZSA9PiAhZS5zaGlmdEtleSxcclxuICAgIGFsdDogZSA9PiAhZS5hbHRLZXksXHJcbiAgICBtZXRhOiBlID0+ICFlLm1ldGFLZXksXHJcbiAgICBsZWZ0OiBlID0+ICdidXR0b24nIGluIGUgJiYgZS5idXR0b24gIT09IDAsXHJcbiAgICBtaWRkbGU6IGUgPT4gJ2J1dHRvbicgaW4gZSAmJiBlLmJ1dHRvbiAhPT0gMSxcclxuICAgIHJpZ2h0OiBlID0+ICdidXR0b24nIGluIGUgJiYgZS5idXR0b24gIT09IDIsXHJcbiAgICBleGFjdDogKGUsIG1vZGlmaWVycykgPT4gc3lzdGVtTW9kaWZpZXJzLnNvbWUobSA9PiBlW2Ake219S2V5YF0gJiYgIW1vZGlmaWVycy5pbmNsdWRlcyhtKSlcclxufTtcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCB3aXRoTW9kaWZpZXJzID0gKGZuLCBtb2RpZmllcnMpID0+IHtcclxuICAgIHJldHVybiAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGlmaWVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBndWFyZCA9IG1vZGlmaWVyR3VhcmRzW21vZGlmaWVyc1tpXV07XHJcbiAgICAgICAgICAgIGlmIChndWFyZCAmJiBndWFyZChldmVudCwgbW9kaWZpZXJzKSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZuKGV2ZW50LCAuLi5hcmdzKTtcclxuICAgIH07XHJcbn07XHJcbi8vIEtlcHQgZm9yIDIueCBjb21wYXQuXHJcbi8vIE5vdGU6IElFMTEgY29tcGF0IGZvciBgc3BhY2ViYXJgIGFuZCBgZGVsYCBpcyByZW1vdmVkIGZvciBub3cuXHJcbmNvbnN0IGtleU5hbWVzID0ge1xyXG4gICAgZXNjOiAnZXNjYXBlJyxcclxuICAgIHNwYWNlOiAnICcsXHJcbiAgICB1cDogJ2Fycm93LXVwJyxcclxuICAgIGxlZnQ6ICdhcnJvdy1sZWZ0JyxcclxuICAgIHJpZ2h0OiAnYXJyb3ctcmlnaHQnLFxyXG4gICAgZG93bjogJ2Fycm93LWRvd24nLFxyXG4gICAgZGVsZXRlOiAnYmFja3NwYWNlJ1xyXG59O1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IHdpdGhLZXlzID0gKGZuLCBtb2RpZmllcnMpID0+IHtcclxuICAgIHJldHVybiAoZXZlbnQpID0+IHtcclxuICAgICAgICBpZiAoISgna2V5JyBpbiBldmVudCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBldmVudEtleSA9IGh5cGhlbmF0ZShldmVudC5rZXkpO1xyXG4gICAgICAgIGlmIChtb2RpZmllcnMuc29tZShrID0+IGsgPT09IGV2ZW50S2V5IHx8IGtleU5hbWVzW2tdID09PSBldmVudEtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZuKGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xuXG5jb25zdCB2U2hvdyA9IHtcclxuICAgIGJlZm9yZU1vdW50KGVsLCB7IHZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XHJcbiAgICAgICAgZWwuX3ZvZCA9IGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcclxuICAgICAgICBpZiAodHJhbnNpdGlvbiAmJiB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNldERpc3BsYXkoZWwsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbW91bnRlZChlbCwgeyB2YWx1ZSB9LCB7IHRyYW5zaXRpb24gfSkge1xyXG4gICAgICAgIGlmICh0cmFuc2l0aW9uICYmIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB1cGRhdGVkKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB7IHRyYW5zaXRpb24gfSkge1xyXG4gICAgICAgIGlmICghdmFsdWUgPT09ICFvbGRWYWx1ZSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGlmICh0cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XHJcbiAgICAgICAgICAgICAgICBzZXREaXNwbGF5KGVsLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5sZWF2ZShlbCwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldERpc3BsYXkoZWwsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzZXREaXNwbGF5KGVsLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGJlZm9yZVVubW91bnQoZWwsIHsgdmFsdWUgfSkge1xyXG4gICAgICAgIHNldERpc3BsYXkoZWwsIHZhbHVlKTtcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gc2V0RGlzcGxheShlbCwgdmFsdWUpIHtcclxuICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl92b2QgOiAnbm9uZSc7XHJcbn1cclxuLy8gU1NSIHZub2RlIHRyYW5zZm9ybXMsIG9ubHkgdXNlZCB3aGVuIHVzZXIgaW5jbHVkZXMgY2xpZW50LW9yaWVudGVkIHJlbmRlclxyXG4vLyBmdW5jdGlvbiBpbiBTU1JcclxuZnVuY3Rpb24gaW5pdFZTaG93Rm9yU1NSKCkge1xyXG4gICAgdlNob3cuZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9KSA9PiB7XHJcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4geyBzdHlsZTogeyBkaXNwbGF5OiAnbm9uZScgfSB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cblxuY29uc3QgcmVuZGVyZXJPcHRpb25zID0gZXh0ZW5kKHsgcGF0Y2hQcm9wIH0sIG5vZGVPcHMpO1xyXG4vLyBsYXp5IGNyZWF0ZSB0aGUgcmVuZGVyZXIgLSB0aGlzIG1ha2VzIGNvcmUgcmVuZGVyZXIgbG9naWMgdHJlZS1zaGFrYWJsZVxyXG4vLyBpbiBjYXNlIHRoZSB1c2VyIG9ubHkgaW1wb3J0cyByZWFjdGl2aXR5IHV0aWxpdGllcyBmcm9tIFZ1ZS5cclxubGV0IHJlbmRlcmVyO1xyXG5sZXQgZW5hYmxlZEh5ZHJhdGlvbiA9IGZhbHNlO1xyXG5mdW5jdGlvbiBlbnN1cmVSZW5kZXJlcigpIHtcclxuICAgIHJldHVybiAocmVuZGVyZXIgfHxcclxuICAgICAgICAocmVuZGVyZXIgPSBjcmVhdGVSZW5kZXJlcihyZW5kZXJlck9wdGlvbnMpKSk7XHJcbn1cclxuZnVuY3Rpb24gZW5zdXJlSHlkcmF0aW9uUmVuZGVyZXIoKSB7XHJcbiAgICByZW5kZXJlciA9IGVuYWJsZWRIeWRyYXRpb25cclxuICAgICAgICA/IHJlbmRlcmVyXHJcbiAgICAgICAgOiBjcmVhdGVIeWRyYXRpb25SZW5kZXJlcihyZW5kZXJlck9wdGlvbnMpO1xyXG4gICAgZW5hYmxlZEh5ZHJhdGlvbiA9IHRydWU7XHJcbiAgICByZXR1cm4gcmVuZGVyZXI7XHJcbn1cclxuLy8gdXNlIGV4cGxpY2l0IHR5cGUgY2FzdHMgaGVyZSB0byBhdm9pZCBpbXBvcnQoKSBjYWxscyBpbiByb2xsZWQtdXAgZC50c1xyXG5jb25zdCByZW5kZXIgPSAoKC4uLmFyZ3MpID0+IHtcclxuICAgIGVuc3VyZVJlbmRlcmVyKCkucmVuZGVyKC4uLmFyZ3MpO1xyXG59KTtcclxuY29uc3QgaHlkcmF0ZSA9ICgoLi4uYXJncykgPT4ge1xyXG4gICAgZW5zdXJlSHlkcmF0aW9uUmVuZGVyZXIoKS5oeWRyYXRlKC4uLmFyZ3MpO1xyXG59KTtcclxuY29uc3QgY3JlYXRlQXBwID0gKCguLi5hcmdzKSA9PiB7XHJcbiAgICBjb25zdCBhcHAgPSBlbnN1cmVSZW5kZXJlcigpLmNyZWF0ZUFwcCguLi5hcmdzKTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBpbmplY3ROYXRpdmVUYWdDaGVjayhhcHApO1xyXG4gICAgICAgIGluamVjdENvbXBpbGVyT3B0aW9uc0NoZWNrKGFwcCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IG1vdW50IH0gPSBhcHA7XHJcbiAgICBhcHAubW91bnQgPSAoY29udGFpbmVyT3JTZWxlY3RvcikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG5vcm1hbGl6ZUNvbnRhaW5lcihjb250YWluZXJPclNlbGVjdG9yKTtcclxuICAgICAgICBpZiAoIWNvbnRhaW5lcilcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGFwcC5fY29tcG9uZW50O1xyXG4gICAgICAgIGlmICghaXNGdW5jdGlvbihjb21wb25lbnQpICYmICFjb21wb25lbnQucmVuZGVyICYmICFjb21wb25lbnQudGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgLy8gX19VTlNBRkVfX1xyXG4gICAgICAgICAgICAvLyBSZWFzb246IHBvdGVudGlhbCBleGVjdXRpb24gb2YgSlMgZXhwcmVzc2lvbnMgaW4gaW4tRE9NIHRlbXBsYXRlLlxyXG4gICAgICAgICAgICAvLyBUaGUgdXNlciBtdXN0IG1ha2Ugc3VyZSB0aGUgaW4tRE9NIHRlbXBsYXRlIGlzIHRydXN0ZWQuIElmIGl0J3NcclxuICAgICAgICAgICAgLy8gcmVuZGVyZWQgYnkgdGhlIHNlcnZlciwgdGhlIHRlbXBsYXRlIHNob3VsZCBub3QgY29udGFpbiBhbnkgdXNlciBkYXRhLlxyXG4gICAgICAgICAgICBjb21wb25lbnQudGVtcGxhdGUgPSBjb250YWluZXIuaW5uZXJIVE1MO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjbGVhciBjb250ZW50IGJlZm9yZSBtb3VudGluZ1xyXG4gICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcclxuICAgICAgICBjb25zdCBwcm94eSA9IG1vdW50KGNvbnRhaW5lciwgZmFsc2UsIGNvbnRhaW5lciBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpO1xyXG4gICAgICAgIGlmIChjb250YWluZXIgaW5zdGFuY2VvZiBFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoJ3YtY2xvYWsnKTtcclxuICAgICAgICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnZGF0YS12LWFwcCcsICcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb3h5O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBhcHA7XHJcbn0pO1xyXG5jb25zdCBjcmVhdGVTU1JBcHAgPSAoKC4uLmFyZ3MpID0+IHtcclxuICAgIGNvbnN0IGFwcCA9IGVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyKCkuY3JlYXRlQXBwKC4uLmFyZ3MpO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCk7XHJcbiAgICAgICAgaW5qZWN0Q29tcGlsZXJPcHRpb25zQ2hlY2soYXBwKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgbW91bnQgfSA9IGFwcDtcclxuICAgIGFwcC5tb3VudCA9IChjb250YWluZXJPclNlbGVjdG9yKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lck9yU2VsZWN0b3IpO1xyXG4gICAgICAgIGlmIChjb250YWluZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vdW50KGNvbnRhaW5lciwgdHJ1ZSwgY29udGFpbmVyIGluc3RhbmNlb2YgU1ZHRWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBhcHA7XHJcbn0pO1xyXG5mdW5jdGlvbiBpbmplY3ROYXRpdmVUYWdDaGVjayhhcHApIHtcclxuICAgIC8vIEluamVjdCBgaXNOYXRpdmVUYWdgXHJcbiAgICAvLyB0aGlzIGlzIHVzZWQgZm9yIGNvbXBvbmVudCBuYW1lIHZhbGlkYXRpb24gKGRldiBvbmx5KVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5jb25maWcsICdpc05hdGl2ZVRhZycsIHtcclxuICAgICAgICB2YWx1ZTogKHRhZykgPT4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkdUYWcodGFnKSxcclxuICAgICAgICB3cml0YWJsZTogZmFsc2VcclxuICAgIH0pO1xyXG59XHJcbi8vIGRldiBvbmx5XHJcbmZ1bmN0aW9uIGluamVjdENvbXBpbGVyT3B0aW9uc0NoZWNrKGFwcCkge1xyXG4gICAgaWYgKGlzUnVudGltZU9ubHkoKSkge1xyXG4gICAgICAgIGNvbnN0IGlzQ3VzdG9tRWxlbWVudCA9IGFwcC5jb25maWcuaXNDdXN0b21FbGVtZW50O1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLCAnaXNDdXN0b21FbGVtZW50Jywge1xyXG4gICAgICAgICAgICBnZXQoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNDdXN0b21FbGVtZW50O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQoKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBUaGUgXFxgaXNDdXN0b21FbGVtZW50XFxgIGNvbmZpZyBvcHRpb24gaXMgZGVwcmVjYXRlZC4gVXNlIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBcXGBjb21waWxlck9wdGlvbnMuaXNDdXN0b21FbGVtZW50XFxgIGluc3RlYWQuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBjb21waWxlck9wdGlvbnMgPSBhcHAuY29uZmlnLmNvbXBpbGVyT3B0aW9ucztcclxuICAgICAgICBjb25zdCBtc2cgPSBgVGhlIFxcYGNvbXBpbGVyT3B0aW9uc1xcYCBjb25maWcgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgYCArXHJcbiAgICAgICAgICAgIGBhIGJ1aWxkIG9mIFZ1ZS5qcyB0aGF0IGluY2x1ZGVzIHRoZSBydW50aW1lIGNvbXBpbGVyIChha2EgXCJmdWxsIGJ1aWxkXCIpLiBgICtcclxuICAgICAgICAgICAgYFNpbmNlIHlvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCwgXFxgY29tcGlsZXJPcHRpb25zXFxgIGAgK1xyXG4gICAgICAgICAgICBgbXVzdCBiZSBwYXNzZWQgdG8gXFxgQHZ1ZS9jb21waWxlci1kb21cXGAgaW4gdGhlIGJ1aWxkIHNldHVwIGluc3RlYWQuXFxuYCArXHJcbiAgICAgICAgICAgIGAtIEZvciB2dWUtbG9hZGVyOiBwYXNzIGl0IHZpYSB2dWUtbG9hZGVyJ3MgXFxgY29tcGlsZXJPcHRpb25zXFxgIGxvYWRlciBvcHRpb24uXFxuYCArXHJcbiAgICAgICAgICAgIGAtIEZvciB2dWUtY2xpOiBzZWUgaHR0cHM6Ly9jbGkudnVlanMub3JnL2d1aWRlL3dlYnBhY2suaHRtbCNtb2RpZnlpbmctb3B0aW9ucy1vZi1hLWxvYWRlclxcbmAgK1xyXG4gICAgICAgICAgICBgLSBGb3Igdml0ZTogcGFzcyBpdCB2aWEgQHZpdGVqcy9wbHVnaW4tdnVlIG9wdGlvbnMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdml0ZWpzL3ZpdGUvdHJlZS9tYWluL3BhY2thZ2VzL3BsdWdpbi12dWUjZXhhbXBsZS1mb3ItcGFzc2luZy1vcHRpb25zLXRvLXZ1ZWNvbXBpbGVyLWRvbWA7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5jb25maWcsICdjb21waWxlck9wdGlvbnMnLCB7XHJcbiAgICAgICAgICAgIGdldCgpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4obXNnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21waWxlck9wdGlvbnM7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldCgpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4obXNnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbnRhaW5lcihjb250YWluZXIpIHtcclxuICAgIGlmIChpc1N0cmluZyhjb250YWluZXIpKSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihjb250YWluZXIpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIXJlcykge1xyXG4gICAgICAgICAgICB3YXJuKGBGYWlsZWQgdG8gbW91bnQgYXBwOiBtb3VudCB0YXJnZXQgc2VsZWN0b3IgXCIke2NvbnRhaW5lcn1cIiByZXR1cm5lZCBudWxsLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgIHdpbmRvdy5TaGFkb3dSb290ICYmXHJcbiAgICAgICAgY29udGFpbmVyIGluc3RhbmNlb2Ygd2luZG93LlNoYWRvd1Jvb3QgJiZcclxuICAgICAgICBjb250YWluZXIubW9kZSA9PT0gJ2Nsb3NlZCcpIHtcclxuICAgICAgICB3YXJuKGBtb3VudGluZyBvbiBhIFNoYWRvd1Jvb3Qgd2l0aCBcXGB7bW9kZTogXCJjbG9zZWRcIn1cXGAgbWF5IGxlYWQgdG8gdW5wcmVkaWN0YWJsZSBidWdzYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29udGFpbmVyO1xyXG59XHJcbmxldCBzc3JEaXJlY3RpdmVJbml0aWFsaXplZCA9IGZhbHNlO1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCBpbml0RGlyZWN0aXZlc0ZvclNTUiA9ICgpID0+IHtcclxuICAgICAgICBpZiAoIXNzckRpcmVjdGl2ZUluaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgIHNzckRpcmVjdGl2ZUluaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgaW5pdFZNb2RlbEZvclNTUigpO1xyXG4gICAgICAgICAgICBpbml0VlNob3dGb3JTU1IoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XG5cbmV4cG9ydCB7IFRyYW5zaXRpb24sIFRyYW5zaXRpb25Hcm91cCwgVnVlRWxlbWVudCwgY3JlYXRlQXBwLCBjcmVhdGVTU1JBcHAsIGRlZmluZUN1c3RvbUVsZW1lbnQsIGRlZmluZVNTUkN1c3RvbUVsZW1lbnQsIGh5ZHJhdGUsIGluaXREaXJlY3RpdmVzRm9yU1NSLCByZW5kZXIsIHVzZUNzc01vZHVsZSwgdXNlQ3NzVmFycywgdk1vZGVsQ2hlY2tib3gsIHZNb2RlbER5bmFtaWMsIHZNb2RlbFJhZGlvLCB2TW9kZWxTZWxlY3QsIHZNb2RlbFRleHQsIHZTaG93LCB3aXRoS2V5cywgd2l0aE1vZGlmaWVycyB9O1xuIiwiLyoqXHJcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxyXG4gKiBpcyBpbiB0aGF0IG1hcC5cclxuICogSU1QT1JUQU5UOiBhbGwgY2FsbHMgb2YgdGhpcyBmdW5jdGlvbiBtdXN0IGJlIHByZWZpeGVkIHdpdGhcclxuICogXFwvXFwqI1xcX1xcX1BVUkVcXF9cXF9cXCpcXC9cclxuICogU28gdGhhdCByb2xsdXAgY2FuIHRyZWUtc2hha2UgdGhlbSBpZiBuZWNlc3NhcnkuXHJcbiAqL1xyXG5mdW5jdGlvbiBtYWtlTWFwKHN0ciwgZXhwZWN0c0xvd2VyQ2FzZSkge1xyXG4gICAgY29uc3QgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIGNvbnN0IGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZSA/IHZhbCA9PiAhIW1hcFt2YWwudG9Mb3dlckNhc2UoKV0gOiB2YWwgPT4gISFtYXBbdmFsXTtcclxufVxuXG4vKipcclxuICogZGV2IG9ubHkgZmxhZyAtPiBuYW1lIG1hcHBpbmdcclxuICovXHJcbmNvbnN0IFBhdGNoRmxhZ05hbWVzID0ge1xyXG4gICAgWzEgLyogVEVYVCAqL106IGBURVhUYCxcclxuICAgIFsyIC8qIENMQVNTICovXTogYENMQVNTYCxcclxuICAgIFs0IC8qIFNUWUxFICovXTogYFNUWUxFYCxcclxuICAgIFs4IC8qIFBST1BTICovXTogYFBST1BTYCxcclxuICAgIFsxNiAvKiBGVUxMX1BST1BTICovXTogYEZVTExfUFJPUFNgLFxyXG4gICAgWzMyIC8qIEhZRFJBVEVfRVZFTlRTICovXTogYEhZRFJBVEVfRVZFTlRTYCxcclxuICAgIFs2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi9dOiBgU1RBQkxFX0ZSQUdNRU5UYCxcclxuICAgIFsxMjggLyogS0VZRURfRlJBR01FTlQgKi9dOiBgS0VZRURfRlJBR01FTlRgLFxyXG4gICAgWzI1NiAvKiBVTktFWUVEX0ZSQUdNRU5UICovXTogYFVOS0VZRURfRlJBR01FTlRgLFxyXG4gICAgWzUxMiAvKiBORUVEX1BBVENIICovXTogYE5FRURfUEFUQ0hgLFxyXG4gICAgWzEwMjQgLyogRFlOQU1JQ19TTE9UUyAqL106IGBEWU5BTUlDX1NMT1RTYCxcclxuICAgIFsyMDQ4IC8qIERFVl9ST09UX0ZSQUdNRU5UICovXTogYERFVl9ST09UX0ZSQUdNRU5UYCxcclxuICAgIFstMSAvKiBIT0lTVEVEICovXTogYEhPSVNURURgLFxyXG4gICAgWy0yIC8qIEJBSUwgKi9dOiBgQkFJTGBcclxufTtcblxuLyoqXHJcbiAqIERldiBvbmx5XHJcbiAqL1xyXG5jb25zdCBzbG90RmxhZ3NUZXh0ID0ge1xyXG4gICAgWzEgLyogU1RBQkxFICovXTogJ1NUQUJMRScsXHJcbiAgICBbMiAvKiBEWU5BTUlDICovXTogJ0RZTkFNSUMnLFxyXG4gICAgWzMgLyogRk9SV0FSREVEICovXTogJ0ZPUldBUkRFRCdcclxufTtcblxuY29uc3QgR0xPQkFMU19XSElURV9MSVNURUQgPSAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTixwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSwnICtcclxuICAgICdkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCxNYXRoLE51bWJlcixEYXRlLEFycmF5LCcgK1xyXG4gICAgJ09iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsQmlnSW50JztcclxuY29uc3QgaXNHbG9iYWxseVdoaXRlbGlzdGVkID0gLyojX19QVVJFX18qLyBtYWtlTWFwKEdMT0JBTFNfV0hJVEVfTElTVEVEKTtcblxuY29uc3QgcmFuZ2UgPSAyO1xyXG5mdW5jdGlvbiBnZW5lcmF0ZUNvZGVGcmFtZShzb3VyY2UsIHN0YXJ0ID0gMCwgZW5kID0gc291cmNlLmxlbmd0aCkge1xyXG4gICAgLy8gU3BsaXQgdGhlIGNvbnRlbnQgaW50byBpbmRpdmlkdWFsIGxpbmVzIGJ1dCBjYXB0dXJlIHRoZSBuZXdsaW5lIHNlcXVlbmNlXHJcbiAgICAvLyB0aGF0IHNlcGFyYXRlZCBlYWNoIGxpbmUuIFRoaXMgaXMgaW1wb3J0YW50IGJlY2F1c2UgdGhlIGFjdHVhbCBzZXF1ZW5jZSBpc1xyXG4gICAgLy8gbmVlZGVkIHRvIHByb3Blcmx5IHRha2UgaW50byBhY2NvdW50IHRoZSBmdWxsIGxpbmUgbGVuZ3RoIGZvciBvZmZzZXRcclxuICAgIC8vIGNvbXBhcmlzb25cclxuICAgIGxldCBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvKFxccj9cXG4pLyk7XHJcbiAgICAvLyBTZXBhcmF0ZSB0aGUgbGluZXMgYW5kIG5ld2xpbmUgc2VxdWVuY2VzIGludG8gc2VwYXJhdGUgYXJyYXlzIGZvciBlYXNpZXIgcmVmZXJlbmNpbmdcclxuICAgIGNvbnN0IG5ld2xpbmVTZXF1ZW5jZXMgPSBsaW5lcy5maWx0ZXIoKF8sIGlkeCkgPT4gaWR4ICUgMiA9PT0gMSk7XHJcbiAgICBsaW5lcyA9IGxpbmVzLmZpbHRlcigoXywgaWR4KSA9PiBpZHggJSAyID09PSAwKTtcclxuICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICBjb25zdCByZXMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb3VudCArPVxyXG4gICAgICAgICAgICBsaW5lc1tpXS5sZW5ndGggK1xyXG4gICAgICAgICAgICAgICAgKChuZXdsaW5lU2VxdWVuY2VzW2ldICYmIG5ld2xpbmVTZXF1ZW5jZXNbaV0ubGVuZ3RoKSB8fCAwKTtcclxuICAgICAgICBpZiAoY291bnQgPj0gc3RhcnQpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgLSByYW5nZTsgaiA8PSBpICsgcmFuZ2UgfHwgZW5kID4gY291bnQ7IGorKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGogPCAwIHx8IGogPj0gbGluZXMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGluZSA9IGogKyAxO1xyXG4gICAgICAgICAgICAgICAgcmVzLnB1c2goYCR7bGluZX0keycgJy5yZXBlYXQoTWF0aC5tYXgoMyAtIFN0cmluZyhsaW5lKS5sZW5ndGgsIDApKX18ICAke2xpbmVzW2pdfWApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IGxpbmVzW2pdLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xpbmVTZXFMZW5ndGggPSAobmV3bGluZVNlcXVlbmNlc1tqXSAmJiBuZXdsaW5lU2VxdWVuY2VzW2pdLmxlbmd0aCkgfHwgMDtcclxuICAgICAgICAgICAgICAgIGlmIChqID09PSBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcHVzaCB1bmRlcmxpbmVcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWQgPSBzdGFydCAtIChjb3VudCAtIChsaW5lTGVuZ3RoICsgbmV3TGluZVNlcUxlbmd0aCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KDEsIGVuZCA+IGNvdW50ID8gbGluZUxlbmd0aCAtIHBhZCA6IGVuZCAtIHN0YXJ0KTtcclxuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArICcgJy5yZXBlYXQocGFkKSArICdeJy5yZXBlYXQobGVuZ3RoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChqID4gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPiBjb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChNYXRoLm1pbihlbmQgLSBjb3VudCwgbGluZUxlbmd0aCksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArICdeJy5yZXBlYXQobGVuZ3RoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ICs9IGxpbmVMZW5ndGggKyBuZXdMaW5lU2VxTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXMuam9pbignXFxuJyk7XHJcbn1cblxuLyoqXHJcbiAqIE9uIHRoZSBjbGllbnQgd2Ugb25seSBuZWVkIHRvIG9mZmVyIHNwZWNpYWwgY2FzZXMgZm9yIGJvb2xlYW4gYXR0cmlidXRlcyB0aGF0XHJcbiAqIGhhdmUgZGlmZmVyZW50IG5hbWVzIGZyb20gdGhlaXIgY29ycmVzcG9uZGluZyBkb20gcHJvcGVydGllczpcclxuICogLSBpdGVtc2NvcGUgLT4gTi9BXHJcbiAqIC0gYWxsb3dmdWxsc2NyZWVuIC0+IGFsbG93RnVsbHNjcmVlblxyXG4gKiAtIGZvcm1ub3ZhbGlkYXRlIC0+IGZvcm1Ob1ZhbGlkYXRlXHJcbiAqIC0gaXNtYXAgLT4gaXNNYXBcclxuICogLSBub21vZHVsZSAtPiBub01vZHVsZVxyXG4gKiAtIG5vdmFsaWRhdGUgLT4gbm9WYWxpZGF0ZVxyXG4gKiAtIHJlYWRvbmx5IC0+IHJlYWRPbmx5XHJcbiAqL1xyXG5jb25zdCBzcGVjaWFsQm9vbGVhbkF0dHJzID0gYGl0ZW1zY29wZSxhbGxvd2Z1bGxzY3JlZW4sZm9ybW5vdmFsaWRhdGUsaXNtYXAsbm9tb2R1bGUsbm92YWxpZGF0ZSxyZWFkb25seWA7XHJcbmNvbnN0IGlzU3BlY2lhbEJvb2xlYW5BdHRyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKHNwZWNpYWxCb29sZWFuQXR0cnMpO1xyXG4vKipcclxuICogVGhlIGZ1bGwgbGlzdCBpcyBuZWVkZWQgZHVyaW5nIFNTUiB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IGluaXRpYWwgbWFya3VwLlxyXG4gKi9cclxuY29uc3QgaXNCb29sZWFuQXR0ciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChzcGVjaWFsQm9vbGVhbkF0dHJzICtcclxuICAgIGAsYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNvbnRyb2xzLGRlZmF1bHQsZGVmZXIsZGlzYWJsZWQsaGlkZGVuLGAgK1xyXG4gICAgYGxvb3Asb3BlbixyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3MsYCArXHJcbiAgICBgY2hlY2tlZCxtdXRlZCxtdWx0aXBsZSxzZWxlY3RlZGApO1xyXG4vKipcclxuICogQm9vbGVhbiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBpbmNsdWRlZCBpZiB0aGUgdmFsdWUgaXMgdHJ1dGh5IG9yICcnLlxyXG4gKiBlLmcuIGA8c2VsZWN0IG11bHRpcGxlPmAgY29tcGlsZXMgdG8gYHsgbXVsdGlwbGU6ICcnIH1gXHJcbiAqL1xyXG5mdW5jdGlvbiBpbmNsdWRlQm9vbGVhbkF0dHIodmFsdWUpIHtcclxuICAgIHJldHVybiAhIXZhbHVlIHx8IHZhbHVlID09PSAnJztcclxufVxyXG5jb25zdCB1bnNhZmVBdHRyQ2hhclJFID0gL1s+Lz1cIidcXHUwMDA5XFx1MDAwYVxcdTAwMGNcXHUwMDIwXS87XHJcbmNvbnN0IGF0dHJWYWxpZGF0aW9uQ2FjaGUgPSB7fTtcclxuZnVuY3Rpb24gaXNTU1JTYWZlQXR0ck5hbWUobmFtZSkge1xyXG4gICAgaWYgKGF0dHJWYWxpZGF0aW9uQ2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuICAgICAgICByZXR1cm4gYXR0clZhbGlkYXRpb25DYWNoZVtuYW1lXTtcclxuICAgIH1cclxuICAgIGNvbnN0IGlzVW5zYWZlID0gdW5zYWZlQXR0ckNoYXJSRS50ZXN0KG5hbWUpO1xyXG4gICAgaWYgKGlzVW5zYWZlKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgdW5zYWZlIGF0dHJpYnV0ZSBuYW1lOiAke25hbWV9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV0gPSAhaXNVbnNhZmUpO1xyXG59XHJcbmNvbnN0IHByb3BzVG9BdHRyTWFwID0ge1xyXG4gICAgYWNjZXB0Q2hhcnNldDogJ2FjY2VwdC1jaGFyc2V0JyxcclxuICAgIGNsYXNzTmFtZTogJ2NsYXNzJyxcclxuICAgIGh0bWxGb3I6ICdmb3InLFxyXG4gICAgaHR0cEVxdWl2OiAnaHR0cC1lcXVpdidcclxufTtcclxuLyoqXHJcbiAqIENTUyBwcm9wZXJ0aWVzIHRoYXQgYWNjZXB0IHBsYWluIG51bWJlcnNcclxuICovXHJcbmNvbnN0IGlzTm9Vbml0TnVtZXJpY1N0eWxlUHJvcCA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudCxib3JkZXItaW1hZ2Utb3V0c2V0LGJvcmRlci1pbWFnZS1zbGljZSxgICtcclxuICAgIGBib3JkZXItaW1hZ2Utd2lkdGgsYm94LWZsZXgsYm94LWZsZXgtZ3JvdXAsYm94LW9yZGluYWwtZ3JvdXAsY29sdW1uLWNvdW50LGAgK1xyXG4gICAgYGNvbHVtbnMsZmxleCxmbGV4LWdyb3csZmxleC1wb3NpdGl2ZSxmbGV4LXNocmluayxmbGV4LW5lZ2F0aXZlLGZsZXgtb3JkZXIsYCArXHJcbiAgICBgZ3JpZC1yb3csZ3JpZC1yb3ctZW5kLGdyaWQtcm93LXNwYW4sZ3JpZC1yb3ctc3RhcnQsZ3JpZC1jb2x1bW4sYCArXHJcbiAgICBgZ3JpZC1jb2x1bW4tZW5kLGdyaWQtY29sdW1uLXNwYW4sZ3JpZC1jb2x1bW4tc3RhcnQsZm9udC13ZWlnaHQsbGluZS1jbGFtcCxgICtcclxuICAgIGBsaW5lLWhlaWdodCxvcGFjaXR5LG9yZGVyLG9ycGhhbnMsdGFiLXNpemUsd2lkb3dzLHotaW5kZXgsem9vbSxgICtcclxuICAgIC8vIFNWR1xyXG4gICAgYGZpbGwtb3BhY2l0eSxmbG9vZC1vcGFjaXR5LHN0b3Atb3BhY2l0eSxzdHJva2UtZGFzaGFycmF5LHN0cm9rZS1kYXNob2Zmc2V0LGAgK1xyXG4gICAgYHN0cm9rZS1taXRlcmxpbWl0LHN0cm9rZS1vcGFjaXR5LHN0cm9rZS13aWR0aGApO1xyXG4vKipcclxuICogS25vd24gYXR0cmlidXRlcywgdGhpcyBpcyB1c2VkIGZvciBzdHJpbmdpZmljYXRpb24gb2YgcnVudGltZSBzdGF0aWMgbm9kZXNcclxuICogc28gdGhhdCB3ZSBkb24ndCBzdHJpbmdpZnkgYmluZGluZ3MgdGhhdCBjYW5ub3QgYmUgc2V0IGZyb20gSFRNTC5cclxuICogRG9uJ3QgYWxzbyBmb3JnZXQgdG8gYWxsb3cgYGRhdGEtKmAgYW5kIGBhcmlhLSpgIVxyXG4gKiBHZW5lcmF0ZWQgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0F0dHJpYnV0ZXNcclxuICovXHJcbmNvbnN0IGlzS25vd25IdG1sQXR0ciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChgYWNjZXB0LGFjY2VwdC1jaGFyc2V0LGFjY2Vzc2tleSxhY3Rpb24sYWxpZ24sYWxsb3csYWx0LGFzeW5jLGAgK1xyXG4gICAgYGF1dG9jYXBpdGFsaXplLGF1dG9jb21wbGV0ZSxhdXRvZm9jdXMsYXV0b3BsYXksYmFja2dyb3VuZCxiZ2NvbG9yLGAgK1xyXG4gICAgYGJvcmRlcixidWZmZXJlZCxjYXB0dXJlLGNoYWxsZW5nZSxjaGFyc2V0LGNoZWNrZWQsY2l0ZSxjbGFzcyxjb2RlLGAgK1xyXG4gICAgYGNvZGViYXNlLGNvbG9yLGNvbHMsY29sc3Bhbixjb250ZW50LGNvbnRlbnRlZGl0YWJsZSxjb250ZXh0bWVudSxjb250cm9scyxgICtcclxuICAgIGBjb29yZHMsY3Jvc3NvcmlnaW4sY3NwLGRhdGEsZGF0ZXRpbWUsZGVjb2RpbmcsZGVmYXVsdCxkZWZlcixkaXIsZGlybmFtZSxgICtcclxuICAgIGBkaXNhYmxlZCxkb3dubG9hZCxkcmFnZ2FibGUsZHJvcHpvbmUsZW5jdHlwZSxlbnRlcmtleWhpbnQsZm9yLGZvcm0sYCArXHJcbiAgICBgZm9ybWFjdGlvbixmb3JtZW5jdHlwZSxmb3JtbWV0aG9kLGZvcm1ub3ZhbGlkYXRlLGZvcm10YXJnZXQsaGVhZGVycyxgICtcclxuICAgIGBoZWlnaHQsaGlkZGVuLGhpZ2gsaHJlZixocmVmbGFuZyxodHRwLWVxdWl2LGljb24saWQsaW1wb3J0YW5jZSxpbnRlZ3JpdHksYCArXHJcbiAgICBgaXNtYXAsaXRlbXByb3Asa2V5dHlwZSxraW5kLGxhYmVsLGxhbmcsbGFuZ3VhZ2UsbG9hZGluZyxsaXN0LGxvb3AsbG93LGAgK1xyXG4gICAgYG1hbmlmZXN0LG1heCxtYXhsZW5ndGgsbWlubGVuZ3RoLG1lZGlhLG1pbixtdWx0aXBsZSxtdXRlZCxuYW1lLG5vdmFsaWRhdGUsYCArXHJcbiAgICBgb3BlbixvcHRpbXVtLHBhdHRlcm4scGluZyxwbGFjZWhvbGRlcixwb3N0ZXIscHJlbG9hZCxyYWRpb2dyb3VwLHJlYWRvbmx5LGAgK1xyXG4gICAgYHJlZmVycmVycG9saWN5LHJlbCxyZXF1aXJlZCxyZXZlcnNlZCxyb3dzLHJvd3NwYW4sc2FuZGJveCxzY29wZSxzY29wZWQsYCArXHJcbiAgICBgc2VsZWN0ZWQsc2hhcGUsc2l6ZSxzaXplcyxzbG90LHNwYW4sc3BlbGxjaGVjayxzcmMsc3JjZG9jLHNyY2xhbmcsc3Jjc2V0LGAgK1xyXG4gICAgYHN0YXJ0LHN0ZXAsc3R5bGUsc3VtbWFyeSx0YWJpbmRleCx0YXJnZXQsdGl0bGUsdHJhbnNsYXRlLHR5cGUsdXNlbWFwLGAgK1xyXG4gICAgYHZhbHVlLHdpZHRoLHdyYXBgKTtcclxuLyoqXHJcbiAqIEdlbmVyYXRlZCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGVcclxuICovXHJcbmNvbnN0IGlzS25vd25TdmdBdHRyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGB4bWxucyxhY2NlbnQtaGVpZ2h0LGFjY3VtdWxhdGUsYWRkaXRpdmUsYWxpZ25tZW50LWJhc2VsaW5lLGFscGhhYmV0aWMsYW1wbGl0dWRlLGAgK1xyXG4gICAgYGFyYWJpYy1mb3JtLGFzY2VudCxhdHRyaWJ1dGVOYW1lLGF0dHJpYnV0ZVR5cGUsYXppbXV0aCxiYXNlRnJlcXVlbmN5LGAgK1xyXG4gICAgYGJhc2VsaW5lLXNoaWZ0LGJhc2VQcm9maWxlLGJib3gsYmVnaW4sYmlhcyxieSxjYWxjTW9kZSxjYXAtaGVpZ2h0LGNsYXNzLGAgK1xyXG4gICAgYGNsaXAsY2xpcFBhdGhVbml0cyxjbGlwLXBhdGgsY2xpcC1ydWxlLGNvbG9yLGNvbG9yLWludGVycG9sYXRpb24sYCArXHJcbiAgICBgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzLGNvbG9yLXByb2ZpbGUsY29sb3ItcmVuZGVyaW5nLGAgK1xyXG4gICAgYGNvbnRlbnRTY3JpcHRUeXBlLGNvbnRlbnRTdHlsZVR5cGUsY3Jvc3NvcmlnaW4sY3Vyc29yLGN4LGN5LGQsZGVjZWxlcmF0ZSxgICtcclxuICAgIGBkZXNjZW50LGRpZmZ1c2VDb25zdGFudCxkaXJlY3Rpb24sZGlzcGxheSxkaXZpc29yLGRvbWluYW50LWJhc2VsaW5lLGR1cixkeCxgICtcclxuICAgIGBkeSxlZGdlTW9kZSxlbGV2YXRpb24sZW5hYmxlLWJhY2tncm91bmQsZW5kLGV4cG9uZW50LGZpbGwsZmlsbC1vcGFjaXR5LGAgK1xyXG4gICAgYGZpbGwtcnVsZSxmaWx0ZXIsZmlsdGVyUmVzLGZpbHRlclVuaXRzLGZsb29kLWNvbG9yLGZsb29kLW9wYWNpdHksYCArXHJcbiAgICBgZm9udC1mYW1pbHksZm9udC1zaXplLGZvbnQtc2l6ZS1hZGp1c3QsZm9udC1zdHJldGNoLGZvbnQtc3R5bGUsYCArXHJcbiAgICBgZm9udC12YXJpYW50LGZvbnQtd2VpZ2h0LGZvcm1hdCxmcm9tLGZyLGZ4LGZ5LGcxLGcyLGdseXBoLW5hbWUsYCArXHJcbiAgICBgZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCxnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCxnbHlwaFJlZixgICtcclxuICAgIGBncmFkaWVudFRyYW5zZm9ybSxncmFkaWVudFVuaXRzLGhhbmdpbmcsaGVpZ2h0LGhyZWYsaHJlZmxhbmcsaG9yaXotYWR2LXgsYCArXHJcbiAgICBgaG9yaXotb3JpZ2luLXgsaWQsaWRlb2dyYXBoaWMsaW1hZ2UtcmVuZGVyaW5nLGluLGluMixpbnRlcmNlcHQsayxrMSxrMixrMyxgICtcclxuICAgIGBrNCxrZXJuZWxNYXRyaXgsa2VybmVsVW5pdExlbmd0aCxrZXJuaW5nLGtleVBvaW50cyxrZXlTcGxpbmVzLGtleVRpbWVzLGAgK1xyXG4gICAgYGxhbmcsbGVuZ3RoQWRqdXN0LGxldHRlci1zcGFjaW5nLGxpZ2h0aW5nLWNvbG9yLGxpbWl0aW5nQ29uZUFuZ2xlLGxvY2FsLGAgK1xyXG4gICAgYG1hcmtlci1lbmQsbWFya2VyLW1pZCxtYXJrZXItc3RhcnQsbWFya2VySGVpZ2h0LG1hcmtlclVuaXRzLG1hcmtlcldpZHRoLGAgK1xyXG4gICAgYG1hc2ssbWFza0NvbnRlbnRVbml0cyxtYXNrVW5pdHMsbWF0aGVtYXRpY2FsLG1heCxtZWRpYSxtZXRob2QsbWluLG1vZGUsYCArXHJcbiAgICBgbmFtZSxudW1PY3RhdmVzLG9mZnNldCxvcGFjaXR5LG9wZXJhdG9yLG9yZGVyLG9yaWVudCxvcmllbnRhdGlvbixvcmlnaW4sYCArXHJcbiAgICBgb3ZlcmZsb3csb3ZlcmxpbmUtcG9zaXRpb24sb3ZlcmxpbmUtdGhpY2tuZXNzLHBhbm9zZS0xLHBhaW50LW9yZGVyLHBhdGgsYCArXHJcbiAgICBgcGF0aExlbmd0aCxwYXR0ZXJuQ29udGVudFVuaXRzLHBhdHRlcm5UcmFuc2Zvcm0scGF0dGVyblVuaXRzLHBpbmcsYCArXHJcbiAgICBgcG9pbnRlci1ldmVudHMscG9pbnRzLHBvaW50c0F0WCxwb2ludHNBdFkscG9pbnRzQXRaLHByZXNlcnZlQWxwaGEsYCArXHJcbiAgICBgcHJlc2VydmVBc3BlY3RSYXRpbyxwcmltaXRpdmVVbml0cyxyLHJhZGl1cyxyZWZlcnJlclBvbGljeSxyZWZYLHJlZlkscmVsLGAgK1xyXG4gICAgYHJlbmRlcmluZy1pbnRlbnQscmVwZWF0Q291bnQscmVwZWF0RHVyLHJlcXVpcmVkRXh0ZW5zaW9ucyxyZXF1aXJlZEZlYXR1cmVzLGAgK1xyXG4gICAgYHJlc3RhcnQscmVzdWx0LHJvdGF0ZSxyeCxyeSxzY2FsZSxzZWVkLHNoYXBlLXJlbmRlcmluZyxzbG9wZSxzcGFjaW5nLGAgK1xyXG4gICAgYHNwZWN1bGFyQ29uc3RhbnQsc3BlY3VsYXJFeHBvbmVudCxzcGVlZCxzcHJlYWRNZXRob2Qsc3RhcnRPZmZzZXQsYCArXHJcbiAgICBgc3RkRGV2aWF0aW9uLHN0ZW1oLHN0ZW12LHN0aXRjaFRpbGVzLHN0b3AtY29sb3Isc3RvcC1vcGFjaXR5LGAgK1xyXG4gICAgYHN0cmlrZXRocm91Z2gtcG9zaXRpb24sc3RyaWtldGhyb3VnaC10aGlja25lc3Msc3RyaW5nLHN0cm9rZSxgICtcclxuICAgIGBzdHJva2UtZGFzaGFycmF5LHN0cm9rZS1kYXNob2Zmc2V0LHN0cm9rZS1saW5lY2FwLHN0cm9rZS1saW5lam9pbixgICtcclxuICAgIGBzdHJva2UtbWl0ZXJsaW1pdCxzdHJva2Utb3BhY2l0eSxzdHJva2Utd2lkdGgsc3R5bGUsc3VyZmFjZVNjYWxlLGAgK1xyXG4gICAgYHN5c3RlbUxhbmd1YWdlLHRhYmluZGV4LHRhYmxlVmFsdWVzLHRhcmdldCx0YXJnZXRYLHRhcmdldFksdGV4dC1hbmNob3IsYCArXHJcbiAgICBgdGV4dC1kZWNvcmF0aW9uLHRleHQtcmVuZGVyaW5nLHRleHRMZW5ndGgsdG8sdHJhbnNmb3JtLHRyYW5zZm9ybS1vcmlnaW4sYCArXHJcbiAgICBgdHlwZSx1MSx1Mix1bmRlcmxpbmUtcG9zaXRpb24sdW5kZXJsaW5lLXRoaWNrbmVzcyx1bmljb2RlLHVuaWNvZGUtYmlkaSxgICtcclxuICAgIGB1bmljb2RlLXJhbmdlLHVuaXRzLXBlci1lbSx2LWFscGhhYmV0aWMsdi1oYW5naW5nLHYtaWRlb2dyYXBoaWMsYCArXHJcbiAgICBgdi1tYXRoZW1hdGljYWwsdmFsdWVzLHZlY3Rvci1lZmZlY3QsdmVyc2lvbix2ZXJ0LWFkdi15LHZlcnQtb3JpZ2luLXgsYCArXHJcbiAgICBgdmVydC1vcmlnaW4teSx2aWV3Qm94LHZpZXdUYXJnZXQsdmlzaWJpbGl0eSx3aWR0aCx3aWR0aHMsd29yZC1zcGFjaW5nLGAgK1xyXG4gICAgYHdyaXRpbmctbW9kZSx4LHgtaGVpZ2h0LHgxLHgyLHhDaGFubmVsU2VsZWN0b3IseGxpbms6YWN0dWF0ZSx4bGluazphcmNyb2xlLGAgK1xyXG4gICAgYHhsaW5rOmhyZWYseGxpbms6cm9sZSx4bGluazpzaG93LHhsaW5rOnRpdGxlLHhsaW5rOnR5cGUseG1sOmJhc2UseG1sOmxhbmcsYCArXHJcbiAgICBgeG1sOnNwYWNlLHkseTEseTIseUNoYW5uZWxTZWxlY3Rvcix6LHpvb21BbmRQYW5gKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGUodmFsdWUpIHtcclxuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IHt9O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHZhbHVlW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gaXNTdHJpbmcoaXRlbSlcclxuICAgICAgICAgICAgICAgID8gcGFyc2VTdHJpbmdTdHlsZShpdGVtKVxyXG4gICAgICAgICAgICAgICAgOiBub3JtYWxpemVTdHlsZShpdGVtKTtcclxuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5vcm1hbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNba2V5XSA9IG5vcm1hbGl6ZWRba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGxpc3REZWxpbWl0ZXJSRSA9IC87KD8hW14oXSpcXCkpL2c7XHJcbmNvbnN0IHByb3BlcnR5RGVsaW1pdGVyUkUgPSAvOiguKykvO1xyXG5mdW5jdGlvbiBwYXJzZVN0cmluZ1N0eWxlKGNzc1RleHQpIHtcclxuICAgIGNvbnN0IHJldCA9IHt9O1xyXG4gICAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyUkUpLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgaWYgKGl0ZW0pIHtcclxuICAgICAgICAgICAgY29uc3QgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlclJFKTtcclxuICAgICAgICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJldFt0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJldDtcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnlTdHlsZShzdHlsZXMpIHtcclxuICAgIGxldCByZXQgPSAnJztcclxuICAgIGlmICghc3R5bGVzIHx8IGlzU3RyaW5nKHN0eWxlcykpIHtcclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gc3R5bGVzKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzdHlsZXNba2V5XTtcclxuICAgICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0ga2V5LnN0YXJ0c1dpdGgoYC0tYCkgPyBrZXkgOiBoeXBoZW5hdGUoa2V5KTtcclxuICAgICAgICBpZiAoaXNTdHJpbmcodmFsdWUpIHx8XHJcbiAgICAgICAgICAgICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzTm9Vbml0TnVtZXJpY1N0eWxlUHJvcChub3JtYWxpemVkS2V5KSkpIHtcclxuICAgICAgICAgICAgLy8gb25seSByZW5kZXIgdmFsaWQgdmFsdWVzXHJcbiAgICAgICAgICAgIHJldCArPSBgJHtub3JtYWxpemVkS2V5fToke3ZhbHVlfTtgO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplQ2xhc3ModmFsdWUpIHtcclxuICAgIGxldCByZXMgPSAnJztcclxuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICByZXMgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplQ2xhc3ModmFsdWVbaV0pO1xyXG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzICs9IG5vcm1hbGl6ZWQgKyAnICc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlW25hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICByZXMgKz0gbmFtZSArICcgJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXMudHJpbSgpO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzKHByb3BzKSB7XHJcbiAgICBpZiAoIXByb3BzKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgbGV0IHsgY2xhc3M6IGtsYXNzLCBzdHlsZSB9ID0gcHJvcHM7XHJcbiAgICBpZiAoa2xhc3MgJiYgIWlzU3RyaW5nKGtsYXNzKSkge1xyXG4gICAgICAgIHByb3BzLmNsYXNzID0gbm9ybWFsaXplQ2xhc3Moa2xhc3MpO1xyXG4gICAgfVxyXG4gICAgaWYgKHN0eWxlKSB7XHJcbiAgICAgICAgcHJvcHMuc3R5bGUgPSBub3JtYWxpemVTdHlsZShzdHlsZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJvcHM7XHJcbn1cblxuLy8gVGhlc2UgdGFnIGNvbmZpZ3MgYXJlIHNoYXJlZCBiZXR3ZWVuIGNvbXBpbGVyLWRvbSBhbmQgcnVudGltZS1kb20sIHNvIHRoZXlcclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50XHJcbmNvbnN0IEhUTUxfVEFHUyA9ICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSxhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLCcgK1xyXG4gICAgJ2hlYWRlcixoMSxoMixoMyxoNCxoNSxoNixuYXYsc2VjdGlvbixkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbiwnICtcclxuICAgICdmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCxhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSwnICtcclxuICAgICdkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnVieSxzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCwnICtcclxuICAgICd0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbyxlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLCcgK1xyXG4gICAgJ2NhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucyxjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCwnICtcclxuICAgICd0aCx0cixidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsJyArXHJcbiAgICAnb3B0aW9uLG91dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsZGV0YWlscyxkaWFsb2csbWVudSwnICtcclxuICAgICdzdW1tYXJ5LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290JztcclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0VsZW1lbnRcclxuY29uc3QgU1ZHX1RBR1MgPSAnc3ZnLGFuaW1hdGUsYW5pbWF0ZU1vdGlvbixhbmltYXRlVHJhbnNmb3JtLGNpcmNsZSxjbGlwUGF0aCxjb2xvci1wcm9maWxlLCcgK1xyXG4gICAgJ2RlZnMsZGVzYyxkaXNjYXJkLGVsbGlwc2UsZmVCbGVuZCxmZUNvbG9yTWF0cml4LGZlQ29tcG9uZW50VHJhbnNmZXIsJyArXHJcbiAgICAnZmVDb21wb3NpdGUsZmVDb252b2x2ZU1hdHJpeCxmZURpZmZ1c2VMaWdodGluZyxmZURpc3BsYWNlbWVudE1hcCwnICtcclxuICAgICdmZURpc3RhbmNlTGlnaHQsZmVEcm9wU2hhZG93LGZlRmxvb2QsZmVGdW5jQSxmZUZ1bmNCLGZlRnVuY0csZmVGdW5jUiwnICtcclxuICAgICdmZUdhdXNzaWFuQmx1cixmZUltYWdlLGZlTWVyZ2UsZmVNZXJnZU5vZGUsZmVNb3JwaG9sb2d5LGZlT2Zmc2V0LCcgK1xyXG4gICAgJ2ZlUG9pbnRMaWdodCxmZVNwZWN1bGFyTGlnaHRpbmcsZmVTcG90TGlnaHQsZmVUaWxlLGZlVHVyYnVsZW5jZSxmaWx0ZXIsJyArXHJcbiAgICAnZm9yZWlnbk9iamVjdCxnLGhhdGNoLGhhdGNocGF0aCxpbWFnZSxsaW5lLGxpbmVhckdyYWRpZW50LG1hcmtlcixtYXNrLCcgK1xyXG4gICAgJ21lc2gsbWVzaGdyYWRpZW50LG1lc2hwYXRjaCxtZXNocm93LG1ldGFkYXRhLG1wYXRoLHBhdGgscGF0dGVybiwnICtcclxuICAgICdwb2x5Z29uLHBvbHlsaW5lLHJhZGlhbEdyYWRpZW50LHJlY3Qsc2V0LHNvbGlkY29sb3Isc3RvcCxzd2l0Y2gsc3ltYm9sLCcgK1xyXG4gICAgJ3RleHQsdGV4dFBhdGgsdGl0bGUsdHNwYW4sdW5rbm93bix1c2Usdmlldyc7XHJcbmNvbnN0IFZPSURfVEFHUyA9ICdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGhyLGltZyxpbnB1dCxsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicic7XHJcbi8qKlxyXG4gKiBDb21waWxlciBvbmx5LlxyXG4gKiBEbyBOT1QgdXNlIGluIHJ1bnRpbWUgY29kZSBwYXRocyB1bmxlc3MgYmVoaW5kIGAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylgIGZsYWcuXHJcbiAqL1xyXG5jb25zdCBpc0hUTUxUYWcgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoSFRNTF9UQUdTKTtcclxuLyoqXHJcbiAqIENvbXBpbGVyIG9ubHkuXHJcbiAqIERvIE5PVCB1c2UgaW4gcnVudGltZSBjb2RlIHBhdGhzIHVubGVzcyBiZWhpbmQgYChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKWAgZmxhZy5cclxuICovXHJcbmNvbnN0IGlzU1ZHVGFnID0gLyojX19QVVJFX18qLyBtYWtlTWFwKFNWR19UQUdTKTtcclxuLyoqXHJcbiAqIENvbXBpbGVyIG9ubHkuXHJcbiAqIERvIE5PVCB1c2UgaW4gcnVudGltZSBjb2RlIHBhdGhzIHVubGVzcyBiZWhpbmQgYChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKWAgZmxhZy5cclxuICovXHJcbmNvbnN0IGlzVm9pZFRhZyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChWT0lEX1RBR1MpO1xuXG5jb25zdCBlc2NhcGVSRSA9IC9bXCInJjw+XS87XHJcbmZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyaW5nKSB7XHJcbiAgICBjb25zdCBzdHIgPSAnJyArIHN0cmluZztcclxuICAgIGNvbnN0IG1hdGNoID0gZXNjYXBlUkUuZXhlYyhzdHIpO1xyXG4gICAgaWYgKCFtYXRjaCkge1xyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9XHJcbiAgICBsZXQgaHRtbCA9ICcnO1xyXG4gICAgbGV0IGVzY2FwZWQ7XHJcbiAgICBsZXQgaW5kZXg7XHJcbiAgICBsZXQgbGFzdEluZGV4ID0gMDtcclxuICAgIGZvciAoaW5kZXggPSBtYXRjaC5pbmRleDsgaW5kZXggPCBzdHIubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgc3dpdGNoIChzdHIuY2hhckNvZGVBdChpbmRleCkpIHtcclxuICAgICAgICAgICAgY2FzZSAzNDogLy8gXCJcclxuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAnJnF1b3Q7JztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDM4OiAvLyAmXHJcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZhbXA7JztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDM5OiAvLyAnXHJcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyYjMzk7JztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDYwOiAvLyA8XHJcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZsdDsnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNjI6IC8vID5cclxuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAnJmd0Oyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFzdEluZGV4ICE9PSBpbmRleCkge1xyXG4gICAgICAgICAgICBodG1sICs9IHN0ci5zbGljZShsYXN0SW5kZXgsIGluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGFzdEluZGV4ID0gaW5kZXggKyAxO1xyXG4gICAgICAgIGh0bWwgKz0gZXNjYXBlZDtcclxuICAgIH1cclxuICAgIHJldHVybiBsYXN0SW5kZXggIT09IGluZGV4ID8gaHRtbCArIHN0ci5zbGljZShsYXN0SW5kZXgsIGluZGV4KSA6IGh0bWw7XHJcbn1cclxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1Mi9zeW50YXguaHRtbCNjb21tZW50c1xyXG5jb25zdCBjb21tZW50U3RyaXBSRSA9IC9eLT8+fDwhLS18LS0+fC0tIT58PCEtJC9nO1xyXG5mdW5jdGlvbiBlc2NhcGVIdG1sQ29tbWVudChzcmMpIHtcclxuICAgIHJldHVybiBzcmMucmVwbGFjZShjb21tZW50U3RyaXBSRSwgJycpO1xyXG59XG5cbmZ1bmN0aW9uIGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSB7XHJcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGxldCBlcXVhbCA9IHRydWU7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgZXF1YWwgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBlcXVhbCA9IGxvb3NlRXF1YWwoYVtpXSwgYltpXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXF1YWw7XHJcbn1cclxuZnVuY3Rpb24gbG9vc2VFcXVhbChhLCBiKSB7XHJcbiAgICBpZiAoYSA9PT0gYilcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIGxldCBhVmFsaWRUeXBlID0gaXNEYXRlKGEpO1xyXG4gICAgbGV0IGJWYWxpZFR5cGUgPSBpc0RhdGUoYik7XHJcbiAgICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKSA6IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgYVZhbGlkVHlwZSA9IGlzQXJyYXkoYSk7XHJcbiAgICBiVmFsaWRUeXBlID0gaXNBcnJheShiKTtcclxuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcclxuICAgICAgICByZXR1cm4gYVZhbGlkVHlwZSAmJiBiVmFsaWRUeXBlID8gbG9vc2VDb21wYXJlQXJyYXlzKGEsIGIpIDogZmFsc2U7XHJcbiAgICB9XHJcbiAgICBhVmFsaWRUeXBlID0gaXNPYmplY3QoYSk7XHJcbiAgICBiVmFsaWRUeXBlID0gaXNPYmplY3QoYik7XHJcbiAgICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmOiB0aGlzIGlmIHdpbGwgcHJvYmFibHkgbmV2ZXIgYmUgY2FsbGVkICovXHJcbiAgICAgICAgaWYgKCFhVmFsaWRUeXBlIHx8ICFiVmFsaWRUeXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYUtleXNDb3VudCA9IE9iamVjdC5rZXlzKGEpLmxlbmd0aDtcclxuICAgICAgICBjb25zdCBiS2V5c0NvdW50ID0gT2JqZWN0LmtleXMoYikubGVuZ3RoO1xyXG4gICAgICAgIGlmIChhS2V5c0NvdW50ICE9PSBiS2V5c0NvdW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xyXG4gICAgICAgICAgICBjb25zdCBhSGFzS2V5ID0gYS5oYXNPd25Qcm9wZXJ0eShrZXkpO1xyXG4gICAgICAgICAgICBjb25zdCBiSGFzS2V5ID0gYi5oYXNPd25Qcm9wZXJ0eShrZXkpO1xyXG4gICAgICAgICAgICBpZiAoKGFIYXNLZXkgJiYgIWJIYXNLZXkpIHx8XHJcbiAgICAgICAgICAgICAgICAoIWFIYXNLZXkgJiYgYkhhc0tleSkgfHxcclxuICAgICAgICAgICAgICAgICFsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpO1xyXG59XHJcbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZihhcnIsIHZhbCkge1xyXG4gICAgcmV0dXJuIGFyci5maW5kSW5kZXgoaXRlbSA9PiBsb29zZUVxdWFsKGl0ZW0sIHZhbCkpO1xyXG59XG5cbi8qKlxyXG4gKiBGb3IgY29udmVydGluZyB7eyBpbnRlcnBvbGF0aW9uIH19IHZhbHVlcyB0byBkaXNwbGF5ZWQgc3RyaW5ncy5cclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IHRvRGlzcGxheVN0cmluZyA9ICh2YWwpID0+IHtcclxuICAgIHJldHVybiBpc1N0cmluZyh2YWwpXHJcbiAgICAgICAgPyB2YWxcclxuICAgICAgICA6IHZhbCA9PSBudWxsXHJcbiAgICAgICAgICAgID8gJydcclxuICAgICAgICAgICAgOiBpc0FycmF5KHZhbCkgfHxcclxuICAgICAgICAgICAgICAgIChpc09iamVjdCh2YWwpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKHZhbC50b1N0cmluZyA9PT0gb2JqZWN0VG9TdHJpbmcgfHwgIWlzRnVuY3Rpb24odmFsLnRvU3RyaW5nKSkpXHJcbiAgICAgICAgICAgICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgcmVwbGFjZXIsIDIpXHJcbiAgICAgICAgICAgICAgICA6IFN0cmluZyh2YWwpO1xyXG59O1xyXG5jb25zdCByZXBsYWNlciA9IChfa2V5LCB2YWwpID0+IHtcclxuICAgIC8vIGNhbid0IHVzZSBpc1JlZiBoZXJlIHNpbmNlIEB2dWUvc2hhcmVkIGhhcyBubyBkZXBzXHJcbiAgICBpZiAodmFsICYmIHZhbC5fX3ZfaXNSZWYpIHtcclxuICAgICAgICByZXR1cm4gcmVwbGFjZXIoX2tleSwgdmFsLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzTWFwKHZhbCkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBbYE1hcCgke3ZhbC5zaXplfSlgXTogWy4uLnZhbC5lbnRyaWVzKCldLnJlZHVjZSgoZW50cmllcywgW2tleSwgdmFsXSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZW50cmllc1tgJHtrZXl9ID0+YF0gPSB2YWw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cmllcztcclxuICAgICAgICAgICAgfSwge30pXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzU2V0KHZhbCkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBbYFNldCgke3ZhbC5zaXplfSlgXTogWy4uLnZhbC52YWx1ZXMoKV1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3QodmFsKSAmJiAhaXNBcnJheSh2YWwpICYmICFpc1BsYWluT2JqZWN0KHZhbCkpIHtcclxuICAgICAgICByZXR1cm4gU3RyaW5nKHZhbCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsO1xyXG59O1xuXG5jb25zdCBFTVBUWV9PQkogPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgID8gT2JqZWN0LmZyZWV6ZSh7fSlcclxuICAgIDoge307XHJcbmNvbnN0IEVNUFRZX0FSUiA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IE9iamVjdC5mcmVlemUoW10pIDogW107XHJcbmNvbnN0IE5PT1AgPSAoKSA9PiB7IH07XHJcbi8qKlxyXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxyXG4gKi9cclxuY29uc3QgTk8gPSAoKSA9PiBmYWxzZTtcclxuY29uc3Qgb25SRSA9IC9eb25bXmEtel0vO1xyXG5jb25zdCBpc09uID0gKGtleSkgPT4gb25SRS50ZXN0KGtleSk7XHJcbmNvbnN0IGlzTW9kZWxMaXN0ZW5lciA9IChrZXkpID0+IGtleS5zdGFydHNXaXRoKCdvblVwZGF0ZTonKTtcclxuY29uc3QgZXh0ZW5kID0gT2JqZWN0LmFzc2lnbjtcclxuY29uc3QgcmVtb3ZlID0gKGFyciwgZWwpID0+IHtcclxuICAgIGNvbnN0IGkgPSBhcnIuaW5kZXhPZihlbCk7XHJcbiAgICBpZiAoaSA+IC0xKSB7XHJcbiAgICAgICAgYXJyLnNwbGljZShpLCAxKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG5jb25zdCBoYXNPd24gPSAodmFsLCBrZXkpID0+IGhhc093blByb3BlcnR5LmNhbGwodmFsLCBrZXkpO1xyXG5jb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcclxuY29uc3QgaXNNYXAgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gJ1tvYmplY3QgTWFwXSc7XHJcbmNvbnN0IGlzU2V0ID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09ICdbb2JqZWN0IFNldF0nO1xyXG5jb25zdCBpc0RhdGUgPSAodmFsKSA9PiB2YWwgaW5zdGFuY2VvZiBEYXRlO1xyXG5jb25zdCBpc0Z1bmN0aW9uID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJztcclxuY29uc3QgaXNTdHJpbmcgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcclxuY29uc3QgaXNTeW1ib2wgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3ltYm9sJztcclxuY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XHJcbmNvbnN0IGlzUHJvbWlzZSA9ICh2YWwpID0+IHtcclxuICAgIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnRoZW4pICYmIGlzRnVuY3Rpb24odmFsLmNhdGNoKTtcclxufTtcclxuY29uc3Qgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xyXG5jb25zdCB0b1R5cGVTdHJpbmcgPSAodmFsdWUpID0+IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xyXG5jb25zdCB0b1Jhd1R5cGUgPSAodmFsdWUpID0+IHtcclxuICAgIC8vIGV4dHJhY3QgXCJSYXdUeXBlXCIgZnJvbSBzdHJpbmdzIGxpa2UgXCJbb2JqZWN0IFJhd1R5cGVdXCJcclxuICAgIHJldHVybiB0b1R5cGVTdHJpbmcodmFsdWUpLnNsaWNlKDgsIC0xKTtcclxufTtcclxuY29uc3QgaXNQbGFpbk9iamVjdCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSAnW29iamVjdCBPYmplY3RdJztcclxuY29uc3QgaXNJbnRlZ2VyS2V5ID0gKGtleSkgPT4gaXNTdHJpbmcoa2V5KSAmJlxyXG4gICAga2V5ICE9PSAnTmFOJyAmJlxyXG4gICAga2V5WzBdICE9PSAnLScgJiZcclxuICAgICcnICsgcGFyc2VJbnQoa2V5LCAxMCkgPT09IGtleTtcclxuY29uc3QgaXNSZXNlcnZlZFByb3AgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoXHJcbi8vIHRoZSBsZWFkaW5nIGNvbW1hIGlzIGludGVudGlvbmFsIHNvIGVtcHR5IHN0cmluZyBcIlwiIGlzIGFsc28gaW5jbHVkZWRcclxuJyxrZXkscmVmLHJlZl9mb3IscmVmX2tleSwnICtcclxuICAgICdvblZub2RlQmVmb3JlTW91bnQsb25Wbm9kZU1vdW50ZWQsJyArXHJcbiAgICAnb25Wbm9kZUJlZm9yZVVwZGF0ZSxvblZub2RlVXBkYXRlZCwnICtcclxuICAgICdvblZub2RlQmVmb3JlVW5tb3VudCxvblZub2RlVW5tb3VudGVkJyk7XHJcbmNvbnN0IGlzQnVpbHRJbkRpcmVjdGl2ZSA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcCgnYmluZCxjbG9hayxlbHNlLWlmLGVsc2UsZm9yLGh0bWwsaWYsbW9kZWwsb24sb25jZSxwcmUsc2hvdyxzbG90LHRleHQsbWVtbycpO1xyXG5jb25zdCBjYWNoZVN0cmluZ0Z1bmN0aW9uID0gKGZuKSA9PiB7XHJcbiAgICBjb25zdCBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICByZXR1cm4gKChzdHIpID0+IHtcclxuICAgICAgICBjb25zdCBoaXQgPSBjYWNoZVtzdHJdO1xyXG4gICAgICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKTtcclxuICAgIH0pO1xyXG59O1xyXG5jb25zdCBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IGNhbWVsaXplID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiB7XHJcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgKF8sIGMpID0+IChjID8gYy50b1VwcGVyQ2FzZSgpIDogJycpKTtcclxufSk7XHJcbmNvbnN0IGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCBoeXBoZW5hdGUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnLSQxJykudG9Mb3dlckNhc2UoKSk7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgY2FwaXRhbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpKTtcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCB0b0hhbmRsZXJLZXkgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHN0ciA/IGBvbiR7Y2FwaXRhbGl6ZShzdHIpfWAgOiBgYCk7XHJcbi8vIGNvbXBhcmUgd2hldGhlciBhIHZhbHVlIGhhcyBjaGFuZ2VkLCBhY2NvdW50aW5nIGZvciBOYU4uXHJcbmNvbnN0IGhhc0NoYW5nZWQgPSAodmFsdWUsIG9sZFZhbHVlKSA9PiAhT2JqZWN0LmlzKHZhbHVlLCBvbGRWYWx1ZSk7XHJcbmNvbnN0IGludm9rZUFycmF5Rm5zID0gKGZucywgYXJnKSA9PiB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGZuc1tpXShhcmcpO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBkZWYgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgdmFsdWVcclxuICAgIH0pO1xyXG59O1xyXG5jb25zdCB0b051bWJlciA9ICh2YWwpID0+IHtcclxuICAgIGNvbnN0IG4gPSBwYXJzZUZsb2F0KHZhbCk7XHJcbiAgICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuO1xyXG59O1xyXG5sZXQgX2dsb2JhbFRoaXM7XHJcbmNvbnN0IGdldEdsb2JhbFRoaXMgPSAoKSA9PiB7XHJcbiAgICByZXR1cm4gKF9nbG9iYWxUaGlzIHx8XHJcbiAgICAgICAgKF9nbG9iYWxUaGlzID1cclxuICAgICAgICAgICAgdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAgICAgICAgICA/IGdsb2JhbFRoaXNcclxuICAgICAgICAgICAgICAgIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxmXHJcbiAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHdpbmRvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGdsb2JhbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7fSkpO1xyXG59O1xuXG5leHBvcnQgeyBFTVBUWV9BUlIsIEVNUFRZX09CSiwgTk8sIE5PT1AsIFBhdGNoRmxhZ05hbWVzLCBjYW1lbGl6ZSwgY2FwaXRhbGl6ZSwgZGVmLCBlc2NhcGVIdG1sLCBlc2NhcGVIdG1sQ29tbWVudCwgZXh0ZW5kLCBnZW5lcmF0ZUNvZGVGcmFtZSwgZ2V0R2xvYmFsVGhpcywgaGFzQ2hhbmdlZCwgaGFzT3duLCBoeXBoZW5hdGUsIGluY2x1ZGVCb29sZWFuQXR0ciwgaW52b2tlQXJyYXlGbnMsIGlzQXJyYXksIGlzQm9vbGVhbkF0dHIsIGlzQnVpbHRJbkRpcmVjdGl2ZSwgaXNEYXRlLCBpc0Z1bmN0aW9uLCBpc0dsb2JhbGx5V2hpdGVsaXN0ZWQsIGlzSFRNTFRhZywgaXNJbnRlZ2VyS2V5LCBpc0tub3duSHRtbEF0dHIsIGlzS25vd25TdmdBdHRyLCBpc01hcCwgaXNNb2RlbExpc3RlbmVyLCBpc05vVW5pdE51bWVyaWNTdHlsZVByb3AsIGlzT2JqZWN0LCBpc09uLCBpc1BsYWluT2JqZWN0LCBpc1Byb21pc2UsIGlzUmVzZXJ2ZWRQcm9wLCBpc1NTUlNhZmVBdHRyTmFtZSwgaXNTVkdUYWcsIGlzU2V0LCBpc1NwZWNpYWxCb29sZWFuQXR0ciwgaXNTdHJpbmcsIGlzU3ltYm9sLCBpc1ZvaWRUYWcsIGxvb3NlRXF1YWwsIGxvb3NlSW5kZXhPZiwgbWFrZU1hcCwgbm9ybWFsaXplQ2xhc3MsIG5vcm1hbGl6ZVByb3BzLCBub3JtYWxpemVTdHlsZSwgb2JqZWN0VG9TdHJpbmcsIHBhcnNlU3RyaW5nU3R5bGUsIHByb3BzVG9BdHRyTWFwLCByZW1vdmUsIHNsb3RGbGFnc1RleHQsIHN0cmluZ2lmeVN0eWxlLCB0b0Rpc3BsYXlTdHJpbmcsIHRvSGFuZGxlcktleSwgdG9OdW1iZXIsIHRvUmF3VHlwZSwgdG9UeXBlU3RyaW5nIH07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2dWVfMSA9IHJlcXVpcmUoXCJ2dWVcIik7XG5leHBvcnRzLmRlZmF1bHQgPSAoMCwgdnVlXzEuZGVmaW5lQ29tcG9uZW50KSh7XG4gICAgbmFtZTogJ2hlYWRlci1jb21wb25lbnQnLFxuICAgIGNvbXBvbmVudHM6IHt9LFxuICAgIHNldHVwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgbGFuZ3VhZ2VOYXZMaUNsYXNzZXM6ICdmbGV4JyxcbiAgICAgICAgICAgIGxhbmd1YWdlTmF2QW5jaG9yQ2xhc3NlczogJ2ZsZXggdGV4dC13aGl0ZSBpdGVtcy1jZW50ZXIgdXBwZXJjYXNlIG5hdl9fcG9pbnRlci1ob3ZlciBweC0xLjUnLFxuICAgICAgICAgICAgbWVudU5hdkxpQ2xhc3NlczogJ2ZsZXggcHgtNCcsXG4gICAgICAgICAgICBtZW51TmF2QW5jaG9yQ2xhc3NlczogJ2ZsZXggdGV4dC13aGl0ZSBpdGVtcy1jZW50ZXIgdXBwZXJjYXNlIG5hdl9fcG9pbnRlci1ob3ZlcicsXG4gICAgICAgICAgICBsYW5ndWFnZXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlOiAnRU4nLFxuICAgICAgICAgICAgICAgICAgICBwZXJtYWxpbms6ICcjJyxcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZTogJ0ZSJyxcbiAgICAgICAgICAgICAgICAgICAgcGVybWFsaW5rOiAnIycsXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlOiAnRVMnLFxuICAgICAgICAgICAgICAgICAgICBwZXJtYWxpbms6ICcjJyxcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIG1lbnVzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQWN0aXZpdHkgREFUQScsXG4gICAgICAgICAgICAgICAgICAgIHBlcm1hbGluazogJyMnLFxuICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdPcmdhbmlzYXRpb24gREFUQScsXG4gICAgICAgICAgICAgICAgICAgIHBlcm1hbGluazogJyMnLFxuICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnU2V0dGluZ3MnLFxuICAgICAgICAgICAgICAgICAgICBwZXJtYWxpbms6ICcjJyxcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogZGF0YSB9O1xuICAgIH0sXG59KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZ1ZV8xID0gcmVxdWlyZShcInZ1ZVwiKTtcbmV4cG9ydHMuZGVmYXVsdCA9ICgwLCB2dWVfMS5kZWZpbmVDb21wb25lbnQpKHtcbiAgICBuYW1lOiAnYWxlcnQtbWVzc2FnZScsXG4gICAgY29tcG9uZW50czoge30sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgIH0sXG4gICAgc2V0dXA6IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICB2YXIgaWNvbiA9ICd0aWNrJztcbiAgICAgICAgaWYgKHByb3BzLnR5cGUgPT09ICdmYWlsdXJlJykge1xuICAgICAgICAgICAgaWNvbiA9ICdjbG9zZSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaWNvbjogaWNvbiB9O1xuICAgIH0sXG59KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZ1ZV8xID0gcmVxdWlyZShcInZ1ZVwiKTtcbmV4cG9ydHMuZGVmYXVsdCA9ICgwLCB2dWVfMS5kZWZpbmVDb21wb25lbnQpKHtcbiAgICBuYW1lOiAncGFnaW5hdGlvbi1jb21wb25lbnQnLFxuICAgIGNvbXBvbmVudHM6IHt9LFxufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2dWVfMSA9IHJlcXVpcmUoXCJ2dWVcIik7XG5leHBvcnRzLmRlZmF1bHQgPSAoMCwgdnVlXzEuZGVmaW5lQ29tcG9uZW50KSh7XG4gICAgbmFtZTogJ3BvcHVwLW1vZGFsJyxcbiAgICBwcm9wczogWydtb2RhbEFjdGl2ZSddLFxuICAgIGVtaXRzOiBbJ2Nsb3NlJ10sXG4gICAgc2V0dXA6IGZ1bmN0aW9uIChwcm9wcywgX2EpIHtcbiAgICAgICAgdmFyIGVtaXQgPSBfYS5lbWl0O1xuICAgICAgICB2YXIgY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbWl0KCdjbG9zZScpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geyBjbG9zZTogY2xvc2UgfTtcbiAgICB9LFxufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2dWVfMSA9IHJlcXVpcmUoXCJ2dWVcIik7XG5leHBvcnRzLmRlZmF1bHQgPSAoMCwgdnVlXzEuZGVmaW5lQ29tcG9uZW50KSh7XG4gICAgbmFtZTogJ3RvYXN0LW1lc3NhZ2UnLFxuICAgIGNvbXBvbmVudHM6IHt9LFxuICAgIHNldHVwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9LFxufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2dWVfMSA9IHJlcXVpcmUoXCJ2dWVcIik7XG52YXIgRW1wdHlBY3Rpdml0eV92dWVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9wYXJ0aWFscy9FbXB0eUFjdGl2aXR5LnZ1ZVwiKSk7XG52YXIgVGFibGVMYXlvdXRfdnVlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcGFydGlhbHMvVGFibGVMYXlvdXQudnVlXCIpKTtcbnZhciBQYWdpbmF0aW9uX3Z1ZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9jb21wb25lbnRzL1BhZ2luYXRpb24udnVlXCIpKTtcbnZhciBQYWdlVGl0bGVfdnVlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcGFydGlhbHMvUGFnZVRpdGxlLnZ1ZVwiKSk7XG52YXIgVG9hc3RNZXNzYWdlX3Z1ZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9jb21wb25lbnRzL1RvYXN0TWVzc2FnZS52dWVcIikpO1xuZXhwb3J0cy5kZWZhdWx0ID0gKDAsIHZ1ZV8xLmRlZmluZUNvbXBvbmVudCkoe1xuICAgIG5hbWU6ICdhY3Rpdml0eS1jb21wb25lbnQnLFxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgRW1wdHlBY3Rpdml0eTogRW1wdHlBY3Rpdml0eV92dWVfMS5kZWZhdWx0LFxuICAgICAgICBQYWdlVGl0bGU6IFBhZ2VUaXRsZV92dWVfMS5kZWZhdWx0LFxuICAgICAgICBQYWdpbmF0aW9uOiBQYWdpbmF0aW9uX3Z1ZV8xLmRlZmF1bHQsXG4gICAgICAgIFRvYXN0TWVzc2FnZTogVG9hc3RNZXNzYWdlX3Z1ZV8xLmRlZmF1bHQsXG4gICAgICAgIFRhYmxlTGF5b3V0OiBUYWJsZUxheW91dF92dWVfMS5kZWZhdWx0LFxuICAgIH0sXG4gICAgc2V0dXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gKDAsIHZ1ZV8xLnJlYWN0aXZlKSh7XG4gICAgICAgICAgICBzaG93QnV0dG9uczogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc2hvd09ySGlkZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSB7IGRhdGEgPSBBcnJheTsgfVxuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnNob3dCdXR0b25zID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlLnNob3dCdXR0b25zID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IHN0YXRlOiBzdGF0ZSwgc2hvd09ySGlkZTogc2hvd09ySGlkZSB9O1xuICAgIH0sXG59KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZ1ZV8xID0gcmVxdWlyZShcInZ1ZVwiKTtcbmV4cG9ydHMuZGVmYXVsdCA9ICgwLCB2dWVfMS5kZWZpbmVDb21wb25lbnQpKHtcbiAgICBuYW1lOiAnYWRkLWFjdGl2aXR5LWJ1dHRvbicsXG4gICAgY29tcG9uZW50czoge30sXG4gICAgc2V0dXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gKDAsIHZ1ZV8xLnJlYWN0aXZlKSh7XG4gICAgICAgICAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxpQ2xhc3MgPSAnYmxvY2sgcC0yLjUgdGV4dC1uLTQwIHRleHQtdGlueSBsZWFkaW5nLVsxLjVdIGZvbnQtYm9sZCBob3Zlcjp0ZXh0LW4tNTAgaG92ZXI6Ymctbi0xMCc7XG4gICAgICAgIHZhciB0b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzdGF0ZS5pc1Zpc2libGUgPSAhc3RhdGUuaXNWaXNpYmxlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geyBzdGF0ZTogc3RhdGUsIGxpQ2xhc3M6IGxpQ2xhc3MsIHRvZ2dsZTogdG9nZ2xlIH07XG4gICAgfSxcbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdnVlXzEgPSByZXF1aXJlKFwidnVlXCIpO1xudmFyIEFkZEFjdGl2aXR5QnV0dG9uX3Z1ZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL0FkZEFjdGl2aXR5QnV0dG9uLnZ1ZVwiKSk7XG5leHBvcnRzLmRlZmF1bHQgPSAoMCwgdnVlXzEuZGVmaW5lQ29tcG9uZW50KSh7XG4gICAgbmFtZTogJ2VtcHR5LWFjdGl2aXR5JyxcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIEFjdGl2aXR5QnV0dG9uOiBBZGRBY3Rpdml0eUJ1dHRvbl92dWVfMS5kZWZhdWx0LFxuICAgIH0sXG4gICAgc2V0dXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gKDAsIHZ1ZV8xLnJlYWN0aXZlKSh7XG4gICAgICAgICAgICBkaXNtaXNzOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgc3RhdGU6IHN0YXRlIH07XG4gICAgfSxcbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdnVlXzEgPSByZXF1aXJlKFwidnVlXCIpO1xudmFyIEFkZEFjdGl2aXR5QnV0dG9uX3Z1ZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL0FkZEFjdGl2aXR5QnV0dG9uLnZ1ZVwiKSk7XG52YXIgUG9wdXBNb2RhbF92dWVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vLi4vY29tcG9uZW50cy9Qb3B1cE1vZGFsLnZ1ZVwiKSk7XG52YXIgQWxlcnRNZXNzYWdlX3Z1ZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi8uLi9jb21wb25lbnRzL0FsZXJ0TWVzc2FnZS52dWVcIikpO1xuZXhwb3J0cy5kZWZhdWx0ID0gKDAsIHZ1ZV8xLmRlZmluZUNvbXBvbmVudCkoe1xuICAgIG5hbWU6ICdwYWdlLXRpdGxlJyxcbiAgICBjb21wb25lbnRzOiB7IEFkZEFjdGl2aXR5QnV0dG9uOiBBZGRBY3Rpdml0eUJ1dHRvbl92dWVfMS5kZWZhdWx0LCBNb2RhbDogUG9wdXBNb2RhbF92dWVfMS5kZWZhdWx0LCBBbGVydDogQWxlcnRNZXNzYWdlX3Z1ZV8xLmRlZmF1bHQgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBzaG93QnV0dG9uczogQm9vbGVhbixcbiAgICB9LFxuICAgIHNldHVwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9ICgwLCB2dWVfMS5yZWFjdGl2ZSkoe1xuICAgICAgICAgICAgbW9kYWxBY3RpdmU6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICBhY3Rpdml0eUxpc3Q6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnRVUtQW5nb2xhIERpYWxvZ3VlIEZhY2lsaXR5JyxcbiAgICAgICAgICAgICAgICAgICAgcGVybWFsaW5rOiAnIycsXG4gICAgICAgICAgICAgICAgICAgIGNhbkJlUHVibGlzaGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1Byb2dyYW1tZSBpbiBzdXBwb3J0IG9mIEhpZ2hlciBFZHVjYXRpb24gQWdyby1QUk9ERVNJOiBBY2NlbGVyYXRpb24gb2YgaW5jbHVzaXZlICYgc3VzdGFpbmFibGUgYWdyaWJ1c2luZXNzIGludmVzdG1lbnQgaW4gZWNvbm9taWMgY29ycmlkb3JzJyxcbiAgICAgICAgICAgICAgICAgICAgcGVybWFsaW5rOiAnIycsXG4gICAgICAgICAgICAgICAgICAgIGNhbkJlUHVibGlzaGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdVTkZQQSBBbmdvbGEgSW1wcm92ZWQgbmF0aW9uYWwgcG9wdWxhdGlvbiBkYXRhIHN5c3RlbXMgdG8gbWFwIGFuZCBhZGRyZXNzIGluZXF1YWxpdGllczsgdG8gYWR2YW5jZSBhY2hpZXZlbWVudCBvZiB0aGUgU3VzdGFpbmFibGUgRGV2ZWxvcG1lbnQgR29hbHMgYW5kIHRoZSBjb21taXRtZW50cyBvZiB0aGUgUHJvZ3JhbW1lIG9mIEFjdGlvbiBvZiB0aGUgSW50ZXJuYXRpb25hbCBDZmVyZW5jZSBvbiBQb3B1bGF0aW9uIGFuZCBEZXZlbG9wbWVudDsgYW5kIHRvIHN0cmVuZ3RoZW4gaW50ZXJ2ZW50aW9ucyBpbiBodW1hbml0YXJpYW4gY3Jpc2VzIGFjdGl2aXRpZXMnLFxuICAgICAgICAgICAgICAgICAgICBwZXJtYWxpbms6ICcjJyxcbiAgICAgICAgICAgICAgICAgICAgY2FuQmVQdWJsaXNoZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1Byb2dyYW1tZSBpbiBzdXBwb3J0IG9mIEhpZ2hlciBFZHVjYXRpb24nLFxuICAgICAgICAgICAgICAgICAgICBwZXJtYWxpbms6ICcjJyxcbiAgICAgICAgICAgICAgICAgICAgY2FuQmVQdWJsaXNoZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnQUdPLlMxIExlYWRlcnNoaXAsIGFkdm9jYWN5IGFuZCBjb21tdW5pY2F0aW9uIHRvIGZhc3QgdHJhY2sgdGhlIEFJRFMgcmVzcG9uc2UnLFxuICAgICAgICAgICAgICAgICAgICBwZXJtYWxpbms6ICcjJyxcbiAgICAgICAgICAgICAgICAgICAgY2FuQmVQdWJsaXNoZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgICAgIHZhciBsaXN0ID0gKDAsIHZ1ZV8xLnJlYWN0aXZlKSh7XG4gICAgICAgICAgICBwdWJsaXNoYWJsZTogW10sXG4gICAgICAgICAgICBub25QdWJsaXNoYWJsZTogW10sXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBjb21wdXRlZCBmdW5jdGlvblxuICAgICAgICAvLyBjb25zdCBzZWxlY3RlZEl0ZW1zID0gY29tcHV0ZWQoe1xuICAgICAgICAvL1xuICAgICAgICAvLyB9KTtcbiAgICAgICAgLy8gdG9nZ2xlIGZ1bmN0aW9uXG4gICAgICAgIHZhciB0b2dnbGVNb2RhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN0YXRlLm1vZGFsQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgbGlzdDogbGlzdCxcbiAgICAgICAgICAgIHRvZ2dsZU1vZGFsOiB0b2dnbGVNb2RhbCxcbiAgICAgICAgfTtcbiAgICB9LFxufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2dWVfMSA9IHJlcXVpcmUoXCJ2dWVcIik7XG5leHBvcnRzLmRlZmF1bHQgPSAoMCwgdnVlXzEuZGVmaW5lQ29tcG9uZW50KSh7XG4gICAgbmFtZTogJ3RhYmxlLWxheW91dCcsXG4gICAgY29tcG9uZW50czoge30sXG4gICAgZW1pdHM6IFsnc2hvd09ySGlkZSddLFxuICAgIHNldHVwOiBmdW5jdGlvbiAocHJvcHMsIF9hKSB7XG4gICAgICAgIHZhciBlbWl0ID0gX2EuZW1pdDtcbiAgICAgICAgdmFyIHN0YXRlID0gKDAsIHZ1ZV8xLnJlYWN0aXZlKSh7XG4gICAgICAgICAgICBzZWxlY3RlZDogW10sXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZW1pdFNob3dPckhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbWl0KCdzaG93T3JIaWRlJywgc3RhdGUuc2VsZWN0ZWQpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geyBzdGF0ZTogc3RhdGUsIGVtaXRTaG93T3JIaWRlOiBlbWl0U2hvd09ySGlkZSB9O1xuICAgIH0sXG59KTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBGaXJzdCB3ZSB3aWxsIGxvYWQgYWxsIG9mIHRoaXMgcHJvamVjdCdzIEphdmFTY3JpcHQgZGVwZW5kZW5jaWVzIHdoaWNoXG4gKiBpbmNsdWRlcyBWdWUgYW5kIG90aGVyIGxpYnJhcmllcy4gSXQgaXMgYSBncmVhdCBzdGFydGluZyBwb2ludCB3aGVuXG4gKiBidWlsZGluZyByb2J1c3QsIHBvd2VyZnVsIHdlYiBhcHBsaWNhdGlvbnMgdXNpbmcgVnVlIGFuZCBMYXJhdmVsLlxuICovXG52YXIgdnVlXzEgPSByZXF1aXJlKFwidnVlXCIpO1xudmFyIHN2Z192dWUzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInN2Zy12dWUzXCIpKTtcbi8qKlxuICogVnVlIGNvbXBvbmVudHMgZm9yIEFjdGl2aXRpZXMgTGlzdGluZ1xuICpcbiAqL1xudmFyIEFjdGl2aXR5TGlzdF92dWVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi92aWV3cy9hY3Rpdml0eS9BY3Rpdml0eUxpc3QudnVlXCIpKTtcbnZhciBBZG1pbkhlYWRlcl92dWVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jb21wb25lbnRzL0FkbWluSGVhZGVyLnZ1ZVwiKSk7XG52YXIgYXBwID0gKDAsIHZ1ZV8xLmNyZWF0ZUFwcCkoe30pO1xuLyoqXG4gKiBSZWdpc3RlcmluZyB2dWUgY29tcG9uZW50IGZvciBhY3Rpdml0eSBsaXN0aW5nXG4gKi9cbmFwcC5jb21wb25lbnQoJ2FjdGl2aXR5LXRlbXBsYXRlJywgQWN0aXZpdHlMaXN0X3Z1ZV8xLmRlZmF1bHQpO1xuYXBwLmNvbXBvbmVudCgnbG9nZ2VkaW4taGVhZGVyJywgQWRtaW5IZWFkZXJfdnVlXzEuZGVmYXVsdCk7XG4vKipcbiAqIEV4dGVuc2lvbiB0byBpbmxpbmUgU1ZHIGZpbGVzIHdpdGggVnVlLmpzIGFuZCBvcHRpbWl6ZSB0aGVtIGF1dG9tYXRpY2FsbHkgd2l0aCBTVkdPXG4gKi9cbmFwcC51c2Uoc3ZnX3Z1ZTNfMS5kZWZhdWx0KTtcbi8qKlxuICogTmV4dCwgd2Ugd2lsbCBjcmVhdGUgYSBmcmVzaCBWdWUgYXBwbGljYXRpb24gaW5zdGFuY2UgYW5kIGF0dGFjaCBpdCB0b1xuICogdGhlIHBhZ2UuIFRoZW4sIHlvdSBtYXkgYmVnaW4gYWRkaW5nIGNvbXBvbmVudHMgdG8gdGhpcyBhcHBsaWNhdGlvblxuICogb3IgY3VzdG9taXplIHRoZSBKYXZhU2NyaXB0IHNjYWZmb2xkaW5nIHRvIGZpdCB5b3VyIHVuaXF1ZSBuZWVkcy5cbiAqL1xuYXBwLm1vdW50KCcjYXBwJyk7XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2Nzc1dpdGhNYXBwaW5nVG9TdHJpbmcuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi5zdWNjZXNzW2RhdGEtdi02NTdmYTM0Ml0ge1xcbiAgICAtLXR3LWJvcmRlci1vcGFjaXR5OiAxO1xcbiAgICBib3JkZXItY29sb3I6IHJnYmEodmFyKC0tc3ByaW5nLTUwKSwgdmFyKC0tdHctYm9yZGVyLW9wYWNpdHkpKTtcXG4gICAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLW1pbnQpLCB2YXIoLS10dy1iZy1vcGFjaXR5KSlcXG59XFxuLnN1Y2Nlc3Mgc3ZnW2RhdGEtdi02NTdmYTM0Ml0ge1xcbiAgICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gICAgY29sb3I6IHJnYmEodmFyKC0tc3ByaW5nLTUwKSwgdmFyKC0tdHctdGV4dC1vcGFjaXR5KSlcXG59XFxuLmZhaWx1cmVbZGF0YS12LTY1N2ZhMzQyXSB7XFxuICAgIC0tdHctYmctb3BhY2l0eTogMTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS1yb3NlKSwgdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbiAgICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gICAgY29sb3I6IHJnYmEodmFyKC0tY3JpbXNvbi00MCksIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpXFxufVxcbi5mYWlsdXJlIHN2Z1tkYXRhLXYtNjU3ZmEzNDJdIHtcXG4gICAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICAgIGNvbG9yOiByZ2JhKHZhcigtLWNyaW1zb24tNDApLCB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKVxcbn1cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCI8bm8gc291cmNlPlwiLFwid2VicGFjazovLy4vQWxlcnRNZXNzYWdlLnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtJQUFBLHNCQUFBO0lBQUEsOERBQUE7SUFBQSxrQkFBQTtJQUFBO0FDS0E7QURMQTtJQUFBLG9CQUFBO0lBQUE7QUNTQTtBRFRBO0lBQUEsa0JBQUE7SUFBQSx5REFBQTtJQUFBLG9CQUFBO0lBQUE7QUNnQkE7QURoQkE7SUFBQSxvQkFBQTtJQUFBO0FDb0JBXCIsXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9jc3NXaXRoTWFwcGluZ1RvU3RyaW5nLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIubW9kYWwtYW5pbWF0aW9uLWVudGVyLWFjdGl2ZVtkYXRhLXYtNWEyYmRhNThdLFxcbi5tb2RhbC1hbmltYXRpb24tbGVhdmUtYWN0aXZlW2RhdGEtdi01YTJiZGE1OF0ge1xcbiAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjVzIGN1YmljLWJlemllcigwLjUyLCAwLjAyLCAwLjE5LCAxLjAyKTtcXG59XFxuLm1vZGFsLWFuaW1hdGlvbi1lbnRlci1mcm9tW2RhdGEtdi01YTJiZGE1OF0sXFxuLm1vZGFsLWFuaW1hdGlvbi1sZWF2ZS10b1tkYXRhLXYtNWEyYmRhNThdIHtcXG4gIG9wYWNpdHk6IDA7XFxufVxcbi5tb2RhbC1hbmltYXRpb24taW5uZXItZW50ZXItYWN0aXZlW2RhdGEtdi01YTJiZGE1OF0ge1xcbiAgdHJhbnNpdGlvbjogYWxsIDAuNXMgY3ViaWMtYmV6aWVyKDAuNTIsIDAuMDIsIDAuMTksIDEuMDIpIDAuMTVzO1xcbn1cXG4ubW9kYWwtYW5pbWF0aW9uLWlubmVyLWxlYXZlLWFjdGl2ZVtkYXRhLXYtNWEyYmRhNThdIHtcXG4gIHRyYW5zaXRpb246IGFsbCAwLjVzIGN1YmljLWJlemllcigwLjUyLCAwLjAyLCAwLjE5LCAxLjAyKTtcXG59XFxuLm1vZGFsLWFuaW1hdGlvbi1pbm5lci1lbnRlci1mcm9tW2RhdGEtdi01YTJiZGE1OF0ge1xcbiAgb3BhY2l0eTogMDtcXG4gIHRyYW5zZm9ybTogc2NhbGUoMC44KTtcXG59XFxuLm1vZGFsLWFuaW1hdGlvbi1pbm5lci1sZWF2ZS10b1tkYXRhLXYtNWEyYmRhNThdIHtcXG4gIHRyYW5zZm9ybTogc2NhbGUoMC44KTtcXG59XCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnRzL1BvcHVwTW9kYWwudnVlXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUNBOztFQUVFLDZEQUFBO0FBQUY7QUFFQTs7RUFFRSxVQUFBO0FBQ0Y7QUFDQTtFQUNFLCtEQUFBO0FBRUY7QUFBQTtFQUNFLHlEQUFBO0FBR0Y7QUFEQTtFQUNFLFVBQUE7RUFDQSxxQkFBQTtBQUlGO0FBRkE7RUFDRSxxQkFBQTtBQUtGXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIlxcbi5tb2RhbC1hbmltYXRpb24tZW50ZXItYWN0aXZlLFxcbi5tb2RhbC1hbmltYXRpb24tbGVhdmUtYWN0aXZlIHtcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgMC41cyBjdWJpYy1iZXppZXIoMC41MiwgMC4wMiwgMC4xOSwgMS4wMik7XFxufVxcbi5tb2RhbC1hbmltYXRpb24tZW50ZXItZnJvbSxcXG4ubW9kYWwtYW5pbWF0aW9uLWxlYXZlLXRvIHtcXG4gIG9wYWNpdHk6IDA7XFxufVxcbi5tb2RhbC1hbmltYXRpb24taW5uZXItZW50ZXItYWN0aXZlIHtcXG4gIHRyYW5zaXRpb246IGFsbCAwLjVzIGN1YmljLWJlemllcigwLjUyLCAwLjAyLCAwLjE5LCAxLjAyKSAwLjE1cztcXG59XFxuLm1vZGFsLWFuaW1hdGlvbi1pbm5lci1sZWF2ZS1hY3RpdmUge1xcbiAgdHJhbnNpdGlvbjogYWxsIDAuNXMgY3ViaWMtYmV6aWVyKDAuNTIsIDAuMDIsIDAuMTksIDEuMDIpO1xcbn1cXG4ubW9kYWwtYW5pbWF0aW9uLWlubmVyLWVudGVyLWZyb20ge1xcbiAgb3BhY2l0eTogMDtcXG4gIHRyYW5zZm9ybTogc2NhbGUoMC44KTtcXG59XFxuLm1vZGFsLWFuaW1hdGlvbi1pbm5lci1sZWF2ZS10byB7XFxuICB0cmFuc2Zvcm06IHNjYWxlKDAuOCk7XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzV2l0aE1hcHBpbmdUb1N0cmluZykge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0pO1xuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICByZXR1cm4gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGNvbnRlbnQsIFwifVwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbihcIlwiKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIChtb2R1bGVzLCBtZWRpYVF1ZXJ5LCBkZWR1cGUpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgIHZhciBpZCA9IHRoaXNbaV1bMF07XG5cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbW9kdWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2ldKTtcblxuICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1lZGlhUXVlcnkpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhUXVlcnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsyXSA9IFwiXCIuY29uY2F0KG1lZGlhUXVlcnksIFwiIGFuZCBcIikuY29uY2F0KGl0ZW1bMl0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2kgPSBhcnIgJiYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXSk7IGlmIChfaSA9PSBudWxsKSByZXR1cm47IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX3MsIF9lOyB0cnkgeyBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtKSB7XG4gIHZhciBfaXRlbSA9IF9zbGljZWRUb0FycmF5KGl0ZW0sIDQpLFxuICAgICAgY29udGVudCA9IF9pdGVtWzFdLFxuICAgICAgY3NzTWFwcGluZyA9IF9pdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoY3NzTWFwcGluZykpKSk7XG4gICAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgXCJcIikuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbihcIlxcblwiKTtcbn07IiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHZpZXdCb3g9XFxcIjAgMCAyMSAyMFxcXCIgZmlsbD1cXFwibm9uZVxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTAuNDY0IDEuNjY3QzUuODggMS42NjcgMi4xMyA1LjQxNyAyLjEzIDEwYzAgNC41ODQgMy43NSA4LjMzNCA4LjMzMyA4LjMzNHM4LjMzMy0zLjc1IDguMzMzLTguMzM0YzAtNC41ODMtMy43NS04LjMzMy04LjMzMy04LjMzM1ptMCAxMi41Yy0uNSAwLS44MzMtLjMzMy0uODMzLS44MzMgMC0uNS4zMzMtLjgzNC44MzMtLjgzNC41IDAgLjgzMy4zMzQuODMzLjgzNCAwIC41LS4zMzMuODMzLS44MzMuODMzWk0xMS4yOTcgMTBjMCAuNS0uMzMzLjgzNC0uODMzLjgzNC0uNSAwLS44MzMtLjMzNC0uODMzLS44MzRWNi42NjdjMC0uNS4zMzMtLjgzMy44MzMtLjgzMy41IDAgLjgzMy4zMzMuODMzLjgzM1YxMFpcXFwiIGZpbGw9XFxcImN1cnJlbnRDb2xvclxcXCIvPjwvc3ZnPlwiOyIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIGZpbGw9XFxcIm5vbmVcXFwiIHZpZXdCb3g9XFxcIjAgMCAxNiAxNlxcXCI+PHBhdGggZmlsbD1cXFwiY3VycmVudENvbG9yXFxcIiBkPVxcXCJtOS41MjcgOS40Ni0yLjE5NCAyLjE5NC0uODYtLjg2YS42NjguNjY4IDAgMSAwLS45NDYuOTRsMS4zMzMgMS4zMzNhLjY2Ni42NjYgMCAwIDAgLjk0NyAwbDIuNjY2LTIuNjY3YS42NjcuNjY3IDAgMSAwLS45NDYtLjk0Wm0yLjc1My0zLjkxM2E0LjY2NyA0LjY2NyAwIDAgMC04LjkwNyAxLjI2NyAyLjY2NyAyLjY2NyAwIDAgMC0uMjUzIDUuMS42NjguNjY4IDAgMSAwIC40MjctMS4yNDcgMS4zMzMgMS4zMzMgMCAwIDEtLjg4LTEuMjY3QTEuMzMzIDEuMzMzIDAgMCAxIDQgOC4wNjdhLjY2Ny42NjcgMCAwIDAgLjY2Ny0uNjY3IDMuMzMzIDMuMzMzIDAgMCAxIDYuNDg2LTEuMDY2LjY2OC42NjggMCAwIDAgLjUyLjQ0IDIgMiAwIDAgMSAuMTYgMy44OTNBLjY3Mi42NzIgMCAxIDAgMTIgMTJoLjE2N2EzLjMzMyAzLjMzMyAwIDAgMCAuMTEzLTYuNDEzdi0uMDRaXFxcIi8+PC9zdmc+XCI7IiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHZpZXdCb3g9XFxcIjAgMCA4IDEyXFxcIiBmaWxsPVxcXCJub25lXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk04IDEuMDU0IDYuODA1IDAgMCA2bDYuODA1IDZMOCAxMC45NDcgMi4zOSA2IDggMS4wNTRaXFxcIiBmaWxsPVxcXCJjdXJyZW50Q29sb3JcXFwiLz48L3N2Zz5cIjsiLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgdmlld0JveD1cXFwiMCAwIDggMTJcXFwiIGZpbGw9XFxcIm5vbmVcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTAgMS4wNTQgMS4xOTUgMCA4IDZsLTYuODA1IDZMMCAxMC45NDcgNS42MSA2IDAgMS4wNTRaXFxcIiBmaWxsPVxcXCJjdXJyZW50Q29sb3JcXFwiLz48L3N2Zz5cIjsiLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiBmaWxsPVxcXCJub25lXFxcIiB2aWV3Qm94PVxcXCIwIDAgMTcgMTZcXFwiPjxwYXRoIGZpbGw9XFxcImN1cnJlbnRDb2xvclxcXCIgZD1cXFwiTTUuOTU1IDEwLjMzM2g0LjY3bC0yLjMzNiAyLjI1My0yLjMzNC0yLjI1M1ptMS44NDQgMy4xOTRjLjI3LjI2LjcwNC4yNi45NzQgMGwzLjE3LTMuMDZjLjQzNi0uNDE0LjEzMi0xLjEzNC0uNDgzLTEuMTM0SDUuMTI2Yy0uNjE1IDAtLjkyNi43Mi0uNDkgMS4xNGwzLjE2MyAzLjA1M1ptLTIuNjgtNi44Nmg2LjM0MWMuNjE1IDAgLjkyNi0uNzIuNDktMS4xNGwtMy4xNy0zLjA2YS43MDYuNzA2IDAgMCAwLS45NzQgMGwtMy4xNyAzLjA2Yy0uNDM2LjQyLS4xMzIgMS4xNC40ODMgMS4xNFpcXFwiLz48L3N2Zz5cIjsiLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiBmaWxsPVxcXCJub25lXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiPjxwYXRoIGZpbGw9XFxcImN1cnJlbnRDb2xvclxcXCIgc3Ryb2tlPVxcXCJjdXJyZW50Q29sb3JcXFwiIGQ9XFxcIk0xNy4xNjcgMy4zMzR2LS41aC0xMXYxMWgxMXYtMTAuNVpNOC4yMDQgOC43NWwuNDYzLS40NjYgMS4zNyAxLjM3Ni4zNTUuMzU3LjM1NC0uMzU3IDMuOTItMy45NS40NjMuNDY1LTQuNzM3IDQuNzhMOC4yMDQgOC43NVptLTUuMzcgNy45MTZ2LjVIMTQuNXYuNjY3SDMuMzMzYy0uNjQgMC0xLjE2Ni0uNTI2LTEuMTY2LTEuMTY3VjUuNWguNjY2djExLjE2N1ptMy44MzMtMTQuNWgxMGMuNjQgMCAxLjE2Ni41MjYgMS4xNjYgMS4xNjd2MTBjMCAuNjQtLjUyNiAxLjE2Ni0xLjE2NiAxLjE2NmgtMTBjLS42NCAwLTEuMTY3LS41MjYtMS4xNjctMS4xNjZ2LTEwYzAtLjY0LjUyNi0xLjE2NyAxLjE2Ny0xLjE2N1pcXFwiLz48L3N2Zz5cIjsiLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgdmlld0JveD1cXFwiMCAwIDE4IDE5XFxcIiBmaWxsPVxcXCJub25lXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk05IDIuNDM0Yy00LjEyNSAwLTcuNSAzLjM3NS03LjUgNy41czMuMzc1IDcuNSA3LjUgNy41IDcuNS0zLjM3NSA3LjUtNy41LTMuMzc1LTcuNS03LjUtNy41Wm0yLjc3NSA5LjIyNWMuMy4zLjMuNzUgMCAxLjA1LS4zLjMtLjc1LjMtMS4wNSAwTDkgMTAuOTg0bC0xLjcyNSAxLjcyNWMtLjMuMy0uNzUuMy0xLjA1IDAtLjMtLjMtLjMtLjc1IDAtMS4wNUw3Ljk1IDkuOTM0IDYuMjI1IDguMjA5Yy0uMy0uMy0uMy0uNzUgMC0xLjA1LjMtLjMuNzUtLjMgMS4wNSAwTDkgOC44ODRsMS43MjUtMS43MjVjLjMtLjMuNzUtLjMgMS4wNSAwIC4zLjMuMy43NSAwIDEuMDVMMTAuMDUgOS45MzRsMS43MjUgMS43MjVaXFxcIiBmaWxsPVxcXCIjRTM0RDVCXFxcIi8+PC9zdmc+XCI7IiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgZmlsbD1cXFwibm9uZVxcXCIgdmlld0JveD1cXFwiMCAwIDEyIDE0XFxcIj48cGF0aCBmaWxsPVxcXCJjdXJyZW50Q29sb3JcXFwiIHN0cm9rZT1cXFwiY3VycmVudENvbG9yXFxcIiBkPVxcXCJNOC4xNjcgM3YuNWgzLjE2NmEuMTY3LjE2NyAwIDAgMSAwIC4zMzNoLTEuMTY2djcuODMzYTEuNSAxLjUgMCAwIDEtMS41IDEuNUgzLjMzM2ExLjUgMS41IDAgMCAxLTEuMDYtLjQzOWwtLjM1NC4zNTQuMzU0LS4zNTRhMS41IDEuNSAwIDAgMS0uNDQtMS4wNlYzLjgzMkguNjY3YS4xNjcuMTY3IDAgMSAxIDAtLjMzM2gzLjE2NlYyLjMzM2ExLjUgMS41IDAgMCAxIDEuNS0xLjVoMS4zMzRhMS41IDEuNSAwIDAgMSAxLjUgMS41VjNabS0uODM0LjVoLjVWMi4zMzNhMS4xNjcgMS4xNjcgMCAwIDAtMS4xNjYtMS4xNjdINS4zMzNhMS4xNjcgMS4xNjcgMCAwIDAtMS4xNjYgMS4xNjdWMy41aDMuMTY2Wm0tNC42NjYuMzMzaC0uNXY3LjgzM2ExLjE2NyAxLjE2NyAwIDAgMCAxLjE2NiAxLjE2N2g1LjMzNGExLjE2NyAxLjE2NyAwIDAgMCAxLjE2Ni0xLjE2N1YzLjgzM0gyLjY2N1ptMi4xMTggNi42MThhLjE2Ny4xNjcgMCAwIDEtLjI4NS0uMTE4di00YS4xNjcuMTY3IDAgMSAxIC4zMzMgMHY0YS4xNjcuMTY3IDAgMCAxLS4wNDguMTE4Wm0yLjY2NiAwYS4xNjcuMTY3IDAgMCAxLS4yODQtLjExOHYtNGEuMTY3LjE2NyAwIDAgMSAuMzMzIDB2NGEuMTY3LjE2NyAwIDAgMS0uMDQ5LjExOFpcXFwiLz48L3N2Zz5cIjsiLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiBmaWxsPVxcXCJub25lXFxcIiB2aWV3Qm94PVxcXCIwIDAgMTcgMTZcXFwiPjxwYXRoIGZpbGw9XFxcImN1cnJlbnRDb2xvclxcXCIgZD1cXFwiTTEwLjYyNCA1LjY2N2gtNC42N0w4LjI5IDMuNDE0bDIuMzM1IDIuMjUzWk04Ljc4IDIuNDc0YS43MDYuNzA2IDAgMCAwLS45NzQgMGwtMy4xNyAzLjA2Yy0uNDM2LjQxMy0uMTMyIDEuMTMzLjQ4MyAxLjEzM2g2LjMzNGMuNjE1IDAgLjkyNi0uNzIuNDktMS4xNEw4Ljc4IDIuNDc0Wm0yLjY4IDYuODZINS4xMTljLS42MTUgMC0uOTI2LjcyLS40OSAxLjE0bDMuMTcgMy4wNmMuMjcuMjYuNzA0LjI2Ljk3NCAwbDMuMTctMy4wNmMuNDM2LS40Mi4xMzItMS4xNC0uNDgzLTEuMTRaXFxcIi8+PC9zdmc+XCI7IiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgZmlsbD1cXFwibm9uZVxcXCIgdmlld0JveD1cXFwiMCAwIDE2IDE2XFxcIj48cGF0aCBmaWxsPVxcXCJjdXJyZW50Q29sb3JcXFwiIGQ9XFxcIm0xMy44MDcgMTEuMTQtMS42MTQtMS42MTRhLjY2Ni42NjYgMCAwIDAtLjk0NiAwTDguODYgMTEuOTEzYS42NjcuNjY3IDAgMCAwLS4xOTMuNDczVjE0YS42NjcuNjY3IDAgMCAwIC42NjYuNjY2aDEuNjE0YS42NjguNjY4IDAgMCAwIC40NzMtLjE5M2wyLjM4Ny0yLjM4N2EuNjY3LjY2NyAwIDAgMCAwLS45NDZabS0zLjE0IDIuMTkzSDEwdi0uNjY3bDEuNzItMS43Mi42NjcuNjY3LTEuNzIgMS43MlptLTQgMEg0YS42NjYuNjY2IDAgMCAxLS42NjctLjY2N1YzLjMzM0EuNjY3LjY2NyAwIDAgMSA0IDIuNjY2aDMuMzMzdjJhMiAyIDAgMCAwIDIgMmgydi42NjdhLjY2Ny42NjcgMCAwIDAgMS4zMzQgMFY1Ljk2YS44OC44OCAwIDAgMC0uMDQtLjE4di0uMDZhLjcxNC43MTQgMCAwIDAtLjEyNy0uMTg3bC00LTRhLjcxMy43MTMgMCAwIDAtLjE4Ny0uMTI3LjIxMy4yMTMgMCAwIDAtLjA2IDBsLS4yMTMtLjA3M0g0YTIgMiAwIDAgMC0yIDJ2OS4zMzNhMiAyIDAgMCAwIDIgMmgyLjY2N2EuNjY3LjY2NyAwIDEgMCAwLTEuMzMzWm0yLTkuNzI3IDEuNzI2IDEuNzI3aC0xLjA2YS42NjcuNjY3IDAgMCAxLS42NjYtLjY2N3YtMS4wNlpNNS4zMzMgOS4zMzNoNGEuNjY3LjY2NyAwIDAgMCAwLTEuMzMzaC00YS42NjcuNjY3IDAgMSAwIDAgMS4zMzNabTAtMi42NjdINmEuNjY3LjY2NyAwIDAgMCAwLTEuMzMzaC0uNjY3YS42NjcuNjY3IDAgMCAwIDAgMS4zMzNabTEuMzM0IDRINS4zMzNhLjY2Ny42NjcgMCAwIDAgMCAxLjMzNGgxLjMzNGEuNjY3LjY2NyAwIDAgMCAwLTEuMzM0WlxcXCIvPjwvc3ZnPlwiOyIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIGZpbGw9XFxcIm5vbmVcXFwiIHZpZXdCb3g9XFxcIjAgMCAxNiAxNlxcXCI+PHBhdGggZmlsbD1cXFwiY3VycmVudENvbG9yXFxcIiBzdHJva2U9XFxcImN1cnJlbnRDb2xvclxcXCIgZD1cXFwibTEyLjc5NiA1Ljg3LjAyMy4wN2EuMzA1LjMwNSAwIDAgMSAuMDE0LjA1NHY2LjY3MmExLjUgMS41IDAgMCAxLTEuNSAxLjVINC42NjdhMS41IDEuNSAwIDAgMS0xLjUtMS41VjMuMzMzYTEuNSAxLjUgMCAwIDEgMS41LTEuNWgzLjk3OGEuMjMzLjIzMyAwIDAgMSAuMDMzLjAxNGwuMTEuMDZoLjA0NWwzLjk2MyAzLjk2MlptLTMuMTEtMi42MTctLjg1My0uODU0djIuMjY3QTEuMTY3IDEuMTY3IDAgMCAwIDEwIDUuODMzaDIuMjY3bC0uODUzLS44NTQtMS43MjctMS43MjZaTTguNSAyLjY2NnYtLjVINC42NjdBMS4xNjcgMS4xNjcgMCAwIDAgMy41IDMuMzMzdjkuMzMzYTEuMTY3IDEuMTY3IDAgMCAwIDEuMTY3IDEuMTY3aDYuNjY2YTEuMTY3IDEuMTY3IDAgMCAwIDEuMTY3LTEuMTY3di02LjVIMTBhMS41IDEuNSAwIDAgMS0xLjUtMS41di0yWm0tLjMzMyA3LjA2djEuMjM3bC44Ni0uODkuMTg5LS4xOTVhLjE3LjE3IDAgMCAxIC4yMzcuMjQybC0xLjMyOCAxLjMyOGEuMTY3LjE2NyAwIDAgMS0uMDUyLjAzMmwtLjAxMS4wMDQtLjAxLjAwNWEuMTI3LjEyNyAwIDAgMS0uMTAzIDBsLS4wMS0uMDA1LS4wMTItLjAwNGEuMTY3LjE2NyAwIDAgMS0uMDUyLS4wMzJsLTEuMzI4LTEuMzI5YS4xNy4xNyAwIDAgMSAuMjM3LS4yNDFsLjE5LjE5Ni44Ni44ODlWOGEuMTY3LjE2NyAwIDAgMSAuMzMzIDB2MS43MjZaXFxcIi8+PC9zdmc+XCI7IiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgZmlsbD1cXFwibm9uZVxcXCIgdmlld0JveD1cXFwiMCAwIDk0IDk0XFxcIj48cGF0aCBmaWxsPVxcXCJ1cmwoI2EpXFxcIiBkPVxcXCJNMTcuNjAzIDI2LjI3NGMwLTIuMzc5IDAtMy41NjkuNDctNC40NzRhNC4xNzcgNC4xNzcgMCAwIDEgMS43ODItMS43ODJjLjkwNS0uNDcgMi4wOTUtLjQ3IDQuNDc0LS40N2gxNy41NTdjMS4wMTMgMCAxLjUxOSAwIDEuOTk2LjExNC40MDYuMDk2Ljc5NS4yNTMgMS4xNTQuNDY1LjQyMy4yNDkuNzg3LjYgMS41MTYgMS4zMDJsLjQzMi40MTZjLjcyOS43MDIgMS4wOTMgMS4wNTMgMS41MTYgMS4zMDIuMzYuMjEyLjc0OC4zNjkgMS4xNTQuNDY1LjQ3Ny4xMTQuOTgzLjExNCAxLjk5NS4xMTRoMTcuNzE4YzIuMzggMCAzLjU3IDAgNC40NzUuNDdhNC4xNzcgNC4xNzcgMCAwIDEgMS43ODEgMS43ODJjLjQ3LjkwNS40NyAyLjA5NS40NyA0LjQ3NHY0MC4wNDZjMCAxLjE5IDAgMS43ODQtLjIzNCAyLjIzNy0uMTk5LjM4MS0uNTEuNjkyLS44OTEuODktLjQ1My4yMzYtMS4wNDguMjM2LTIuMjM3LjIzNkgyMy42NTdjLTIuMTQyIDAtMy4yMTIgMC00LjAyNy0uNDI0YTMuNzYgMy43NiAwIDAgMS0xLjYwNC0xLjYwM2MtLjQyMy0uODE1LS40MjMtMS44ODYtLjQyMy00LjAyN1YyNi4yNzRaXFxcIi8+PGcgZmlsdGVyPVxcXCJ1cmwoI2IpXFxcIj48cGF0aCBmaWxsPVxcXCIjQjlEREZGXFxcIiBmaWxsLW9wYWNpdHk9XFxcIi42XFxcIiBkPVxcXCJNMzMuMDkgMzguMzljLjU5LTIuMDMyLjg4Ni0zLjA0OCAxLjY2Ni0zLjYzMy43OC0uNTg2IDEuODM4LS41ODYgMy45NTQtLjU4NmgzOC41MzFjMy4zMzIgMCA0Ljk5OCAwIDUuODc2IDEuMDgyLjg3OCAxLjA4Mi41MzQgMi43MTItLjE1MiA1Ljk3MmwtNS44OTMgMjcuOTkyYy0uNDY4IDIuMjI1LS43MDMgMy4zMzctMS41MDggMy45OS0uODA1LjY1NC0xLjk0Mi42NTQtNC4yMTYuNjU0SDIxLjc4MWMyLjE2MS0yLjM1IDIuMTYxLTQuNyA0LjMyMi0xMS43NSAxLjU1LTUuMDU4IDUuMTAzLTE3LjI0IDYuOTg3LTIzLjcyWlxcXCIvPjxwYXRoIHN0cm9rZT1cXFwidXJsKCNjKVxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIuMzlcXFwiIGQ9XFxcIk0zOC43MSAzNC4zNjZoMzguNTMxYzEuNjcyIDAgMi45MDUgMCAzLjgzLjEzMy45Mi4xMzIgMS41LjM5IDEuODk0Ljg3Ny4zOTUuNDg2LjUyOCAxLjEwNS40NjggMi4wMzMtLjA2LjkzMy0uMzE0IDIuMTQtLjY1OSAzLjc3NmwtNS44OTMgMjcuOTkyYy0uMjM1IDEuMTE3LS40MDggMS45MzgtLjYyMSAyLjU2MS0uMjExLjYyLS40NTUgMS4wMjMtLjgxOSAxLjMxOC0uMzY0LjI5NS0uODA5LjQ1LTEuNDU4LjUzLS42NTQuMDgtMS40OTMuMDgtMi42MzUuMDhIMjIuMjEyYy45Mi0xLjEgMS40MjEtMi4yNDQgMS45MTctMy44Ni4yMjQtLjczNC40NS0xLjU2OS43MTEtMi41NDJsLjE2OC0uNjIzYTEzNC44MiAxMzQuODIgMCAwIDEgMS4yODItNC40NzNjMS41NS01LjA2IDUuMTA0LTE3LjI0MyA2Ljk4Ny0yMy43MjMuMjk3LTEuMDIuNTE1LTEuNzcuNzU1LTIuMzM4LjIzOC0uNTY0LjQ5LS45My44NDItMS4xOTQuMzUyLS4yNjUuNzc0LS40MDQgMS4zODEtLjQ3NS42MTMtLjA3MiAxLjM5My0uMDcyIDIuNDU1LS4wNzJaXFxcIi8+PC9nPjxwYXRoIGZpbGw9XFxcInVybCgjZClcXFwiIGZpbGwtb3BhY2l0eT1cXFwiLjlcXFwiIHN0cm9rZT1cXFwidXJsKCNlKVxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIuMzEyXFxcIiBkPVxcXCJNMjguMDQ4IDIzLjg4M2g4LjM1NmExLjkzMyAxLjkzMyAwIDEgMSAwIDMuODY2aC04LjM1NmExLjkzMyAxLjkzMyAwIDAgMSAwLTMuODY2WlxcXCIvPjxkZWZzPjxsaW5lYXJHcmFkaWVudCBpZD1cXFwiYVxcXCIgeDE9XFxcIjM0LjQ3NVxcXCIgeDI9XFxcIjc4LjYwOVxcXCIgeTE9XFxcIjMxLjQyOVxcXCIgeTI9XFxcIjQ3Ljc3NFxcXCIgZ3JhZGllbnRVbml0cz1cXFwidXNlclNwYWNlT25Vc2VcXFwiPjxzdG9wIHN0b3AtY29sb3I9XFxcIiM3RkMwRkJcXFwiLz48c3RvcCBvZmZzZXQ9XFxcIjFcXFwiIHN0b3AtY29sb3I9XFxcIiM0MDg4RjRcXFwiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD1cXFwiY1xcXCIgeDE9XFxcIjE4LjY0OFxcXCIgeDI9XFxcIjQwLjhcXFwiIHkxPVxcXCIzNy4wMDZcXFwiIHkyPVxcXCI5MC40MjZcXFwiIGdyYWRpZW50VW5pdHM9XFxcInVzZXJTcGFjZU9uVXNlXFxcIj48c3RvcCBzdG9wLWNvbG9yPVxcXCIjZmZmXFxcIi8+PHN0b3Agb2Zmc2V0PVxcXCIuNzY2XFxcIiBzdG9wLWNvbG9yPVxcXCIjZmZmXFxcIiBzdG9wLW9wYWNpdHk9XFxcIjBcXFwiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD1cXFwiZFxcXCIgeDE9XFxcIjI1LjAwNlxcXCIgeDI9XFxcIjQyLjE2MVxcXCIgeTE9XFxcIjIzLjQ0N1xcXCIgeTI9XFxcIjI4LjUxNlxcXCIgZ3JhZGllbnRVbml0cz1cXFwidXNlclNwYWNlT25Vc2VcXFwiPjxzdG9wIHN0b3AtY29sb3I9XFxcIiNmZmZcXFwiLz48c3RvcCBvZmZzZXQ9XFxcIjFcXFwiIHN0b3AtY29sb3I9XFxcIiNmZmZcXFwiIHN0b3Atb3BhY2l0eT1cXFwiMFxcXCIvPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPVxcXCJlXFxcIiB4MT1cXFwiMjMuODM3XFxcIiB4Mj1cXFwiMzIuMjI2XFxcIiB5MT1cXFwiMjQuNjE3XFxcIiB5Mj1cXFwiMjcuOTA0XFxcIiBncmFkaWVudFVuaXRzPVxcXCJ1c2VyU3BhY2VPblVzZVxcXCI+PHN0b3Agc3RvcC1jb2xvcj1cXFwiI2ZmZlxcXCIvPjxzdG9wIG9mZnNldD1cXFwiMVxcXCIgc3RvcC1jb2xvcj1cXFwiI2ZmZlxcXCIgc3RvcC1vcGFjaXR5PVxcXCIwXFxcIi8+PC9saW5lYXJHcmFkaWVudD48ZmlsdGVyIGlkPVxcXCJiXFxcIiB3aWR0aD1cXFwiNzguNTcyXFxcIiBoZWlnaHQ9XFxcIjU2LjQwMlxcXCIgeD1cXFwiMTMuNDI1XFxcIiB5PVxcXCIyNS44MTVcXFwiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz1cXFwic1JHQlxcXCIgZmlsdGVyVW5pdHM9XFxcInVzZXJTcGFjZU9uVXNlXFxcIj48ZmVGbG9vZCBmbG9vZC1vcGFjaXR5PVxcXCIwXFxcIiByZXN1bHQ9XFxcIkJhY2tncm91bmRJbWFnZUZpeFxcXCIvPjxmZUdhdXNzaWFuQmx1ciBpbj1cXFwiQmFja2dyb3VuZEltYWdlXFxcIiBzdGREZXZpYXRpb249XFxcIjQuMTc4XFxcIi8+PGZlQ29tcG9zaXRlIGluMj1cXFwiU291cmNlQWxwaGFcXFwiIG9wZXJhdG9yPVxcXCJpblxcXCIgcmVzdWx0PVxcXCJlZmZlY3QxX2JhY2tncm91bmRCbHVyXzE0MjZfMTY1NTFcXFwiLz48ZmVCbGVuZCBpbj1cXFwiU291cmNlR3JhcGhpY1xcXCIgaW4yPVxcXCJlZmZlY3QxX2JhY2tncm91bmRCbHVyXzE0MjZfMTY1NTFcXFwiIHJlc3VsdD1cXFwic2hhcGVcXFwiLz48L2ZpbHRlcj48L2RlZnM+PC9zdmc+XCI7IiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgZmlsbD1cXFwibm9uZVxcXCIgdmlld0JveD1cXFwiMCAwIDE2IDE2XFxcIj48cGF0aCBmaWxsPVxcXCJjdXJyZW50Q29sb3JcXFwiIGQ9XFxcIk0xMS4zMzMgMi4yYy0yLjYtMS40NjctNS44LTEtNy45MzMgMVYyYzAtLjQtLjI2Ny0uNjY3LS42NjctLjY2N1MyLjA2NyAxLjYgMi4wNjcgMnYzYzAgLjQuMjY2LjY2Ni42NjYuNjY2aDNjLjQgMCAuNjY3LS4yNjYuNjY3LS42NjZzLS4yNjctLjY2Ny0uNjY3LS42NjdoLTEuNmMxLTEuMDY3IDIuNC0xLjY2NyAzLjg2Ny0xLjY2NyAyLjkzMyAwIDUuMzMzIDIuNCA1LjMzMyA1LjMzNCAwIDIuOTMzLTIuNCA1LjMzMy01LjMzMyA1LjMzMy0yLjkzMyAwLTUuMzMzLTIuNC01LjMzMy01LjMzMyAwLS40LS4yNjctLjY2Ny0uNjY3LS42NjdTMS4zMzMgNy42IDEuMzMzIDhjMCAzLjY2NiAzIDYuNjY2IDYuNjY3IDYuNjY2IDIuNCAwIDQuNi0xLjI2NiA1LjgtMy4zMzMgMS44LTMuMi43MzMtNy4yNjctMi40NjctOS4xMzNaTTggNS4zMzNjLS40IDAtLjY2Ny4yNjctLjY2Ny42Njd2MmMwIC40LjI2Ny42NjYuNjY3LjY2NmgxLjMzM2MuNCAwIC42NjctLjI2Ni42NjctLjY2NnMtLjI2Ny0uNjY3LS42NjctLjY2N2gtLjY2NlY2YzAtLjQtLjI2Ny0uNjY3LS42NjctLjY2N1pcXFwiLz48L3N2Zz5cIjsiLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgdmlld0JveD1cXFwiMCAwIDEyMiAzNlxcXCIgZmlsbD1cXFwibm9uZVxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB4bWxuczp4bGluaz1cXFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1xcXCI+PHBhdGggZD1cXFwiTTQ0LjAxOSAyN1YxNi45NzloMy4yNDdjMS4yMyAwIDIuMDMyLjA1IDIuNDA2LjE1LjU3NC4xNSAxLjA1NS40NzggMS40NDIuOTg0LjM4OC41MDIuNTgxIDEuMTUxLjU4MSAxLjk0OCAwIC42MTYtLjExMSAxLjEzMy0uMzM1IDEuNTUyLS4yMjMuNDItLjUwOC43NS0uODU0Ljk5Mi0uMzQyLjIzNi0uNjkuMzk0LTEuMDQ2LjQ3MS0uNDgzLjA5Ni0xLjE4My4xNDQtMi4wOTkuMTQ0aC0xLjMxOVYyN2gtMi4wMjNabTIuMDIzLTguMzI2djIuODQ0aDEuMTA3Yy43OTggMCAxLjMzMS0uMDUzIDEuNi0uMTU4YTEuMzMzIDEuMzMzIDAgMCAwIC44NjEtMS4yNzFjMC0uMzY1LS4xMDctLjY2NS0uMzItLjkwMmExLjM5OSAxLjM5OSAwIDAgMC0uODE0LS40NDVjLS4yNDItLjA0NS0uNzI3LS4wNjgtMS40NTYtLjA2OGgtLjk3OFptNy4wMi0xLjY5NWgyLjAyNHY1LjQyN2MwIC44NjIuMDI1IDEuNDIuMDc1IDEuNjc1LjA4Ny40MS4yOTIuNzQuNjE2Ljk5MS4zMjguMjQ2Ljc3NC4zNyAxLjM0LjM3LjU3NCAwIDEuMDA3LS4xMTcgMS4yOTgtLjM1LjI5Mi0uMjM2LjQ2Ny0uNTI2LjUyNy0uODY3LjA1OS0uMzQyLjA4OS0uOTEuMDg5LTEuNzAzVjE2Ljk4aDIuMDIzdjUuMjYzYzAgMS4yMDMtLjA1NSAyLjA1My0uMTY0IDIuNTUtLjExLjQ5Ny0uMzEyLjkxNi0uNjA4IDEuMjU4LS4yOTIuMzQyLS42ODQuNjE1LTEuMTc2LjgyLS40OTIuMi0xLjEzNS4zLTEuOTI4LjMtLjk1NyAwLTEuNjg0LS4xMDktMi4xOC0uMzI3LS40OTMtLjIyNC0uODgzLS41MS0xLjE3LS44NjJhMi43ODggMi43ODggMCAwIDEtLjU2Ny0xLjExNGMtLjEzMi0uNTc0LS4xOTgtMS40MjItLjE5OC0yLjU0M3YtNS4zNDZabTkuODU4IDBoNC4wMDZjLjc5MyAwIDEuMzgzLjAzNCAxLjc3LjEwMi4zOTMuMDY0Ljc0MS4yIDEuMDQ3LjQxLjMxLjIxLjU2Ny40OS43NzIuODQxLjIwNS4zNDYuMzA4LjczNi4zMDggMS4xNjkgMCAuNDctLjEyOC45LS4zODMgMS4yOTJhMi4zMyAyLjMzIDAgMCAxLTEuMDI1Ljg4MmMuNjEuMTc3IDEuMDguNDggMS40MDguOTA5LjMyOC40MjguNDkyLjkzMi40OTIgMS41MSAwIC40NTYtLjEwNy45LS4zMjEgMS4zMzQtLjIxLjQyOC0uNS43NzItLjg2OCAxLjAzMi0uMzY1LjI1NS0uODE2LjQxMi0xLjM1NC40NzItLjMzNy4wMzYtMS4xNS4wNTktMi40NC4wNjhINjIuOTJWMTYuOTc5Wm0yLjAyNCAxLjY2OHYyLjMxN2gxLjMyNmMuNzg4IDAgMS4yNzgtLjAxMSAxLjQ3LS4wMzQuMzQ2LS4wNDEuNjE3LS4xNi44MTMtLjM1Ni4yLS4yLjMwMS0uNDYyLjMwMS0uNzg2IDAtLjMxLS4wODctLjU2LS4yNi0uNzUyLS4xNjgtLjE5Ni0uNDIxLS4zMTQtLjc1OC0uMzU1LS4yMDEtLjAyMy0uNzc4LS4wMzUtMS43My0uMDM1aC0xLjE2MlptMCAzLjk4NXYyLjY4aDEuODczYy43MyAwIDEuMTkyLS4wMjEgMS4zODgtLjA2Mi4zLS4wNTUuNTQ0LS4xODcuNzMxLS4zOTYuMTkxLS4yMTUuMjg3LS41LjI4Ny0uODU1IDAtLjMtLjA3My0uNTU2LS4yMTktLjc2NmExLjIzNyAxLjIzNyAwIDAgMC0uNjM1LS40NThjLS4yNzQtLjA5NS0uODctLjE0My0xLjc5MS0uMTQzaC0xLjYzNFpNNzIuODA1IDI3di05Ljk0aDIuMDI0djguMjUyaDUuMDMxVjI3aC03LjA1NVptOC4xNjMgMFYxNi45NzloMi4wMjNWMjdoLTIuMDIzWm0zLjE2NS0zLjI2IDEuOTY5LS4xOTJjLjExOC42Ni4zNTggMS4xNDYuNzE4IDEuNDU2LjM2NC4zMS44NTQuNDY1IDEuNDcuNDY1LjY1MSAwIDEuMTQxLS4xMzcgMS40Ny0uNDEuMzMyLS4yNzguNDk4LS42MDIuNDk4LS45NzFhLjg5Ljg5IDAgMCAwLS4yMTItLjYwMmMtLjEzNi0uMTY4LS4zNzgtLjMxNC0uNzI0LS40MzctLjIzNy0uMDgyLS43NzctLjIyOC0xLjYyLS40MzgtMS4wODUtLjI2OS0xLjg0Ni0uNTk5LTIuMjg0LS45OS0uNjE1LS41NTItLjkyMi0xLjIyNC0uOTIyLTIuMDE3IDAtLjUxLjE0My0uOTg3LjQzLTEuNDMuMjkyLS40NDYuNzA5LS43ODUgMS4yNTEtMS4wMTguNTQ3LS4yMzIgMS4yMDYtLjM0OCAxLjk3Ni0uMzQ4IDEuMjU3IDAgMi4yMDMuMjc1IDIuODM3LjgyNy42MzguNTUxLjk3MyAxLjI4NyAxLjAwNSAyLjIwOGwtMi4wMjQuMDg5Yy0uMDg3LS41MTUtLjI3My0uODg0LS41Ni0xLjEwOC0uMjgzLS4yMjgtLjcxLS4zNDItMS4yNzktLjM0Mi0uNTg4IDAtMS4wNDguMTIxLTEuMzguMzYzYS43My43MyAwIDAgMC0uMzIyLjYyMmMwIC4yMzcuMS40NC4zLjYwOC4yNTYuMjE0Ljg3Ni40MzggMS44Ni42Ny45ODUuMjMyIDEuNzEyLjQ3NCAyLjE4LjcyNS40NzUuMjQ2Ljg0NC41ODUgMS4xMDggMS4wMTguMjcuNDI5LjQwNC45Ni40MDQgMS41OTMgMCAuNTc0LS4xNiAxLjExMi0uNDc5IDEuNjEzLS4zMTkuNTAyLS43Ny44NzUtMS4zNTMgMS4xMjEtLjU4NC4yNDItMS4zMS4zNjMtMi4xODEuMzYzLTEuMjY3IDAtMi4yNC0uMjkyLTIuOTE5LS44NzUtLjY3OS0uNTg4LTEuMDg1LTEuNDQzLTEuMjE3LTIuNTY0Wk05My43MTEgMjdWMTYuOTc5aDIuMDIzdjMuOTQ0SDk5Ljd2LTMuOTQ0aDIuMDIzVjI3aC0yLjAyM3YtNC4zODJoLTMuOTY1VjI3aC0yLjAyM1ptOS44MyAwVjE2Ljk3OWg3LjQzMXYxLjY5NWgtNS40MDh2Mi4yMjFoNS4wMzJ2MS42ODloLTUuMDMydjIuNzI3aDUuNTk5VjI3aC03LjYyMlptOS4wNjUgMFYxNi45NzloNC4yNThjMS4wNzEgMCAxLjg0OC4wOSAyLjMzMi4yNzNhMi4yOCAyLjI4IDAgMCAxIDEuMTY4Ljk1N2MuMjkyLjQ2LjQzOC45ODcuNDM4IDEuNTggMCAuNzUxLS4yMjEgMS4zNzMtLjY2MyAxLjg2NS0uNDQyLjQ4OC0xLjEwMy43OTYtMS45ODMuOTIzLjQzOC4yNTUuNzk4LjUzNiAxLjA4MS44NDEuMjg3LjMwNS42NzIuODQ4IDEuMTU1IDEuNjI3TDEyMS42MTUgMjdoLTIuNDE5bC0xLjQ2My0yLjE4Yy0uNTItLjc4LS44NzUtMS4yNy0xLjA2Ny0xLjQ3YTEuNTAzIDEuNTAzIDAgMCAwLS42MDgtLjQxN2MtLjIxNC0uMDc4LS41NTQtLjExNy0xLjAxOS0uMTE3aC0uNDFWMjdoLTIuMDIzWm0yLjAyMy01Ljc4M2gxLjQ5N2MuOTcxIDAgMS41NzctLjA0MSAxLjgxOS0uMTIzLjI0MS0uMDgyLjQzLS4yMjQuNTY3LS40MjQuMTM3LS4yLjIwNS0uNDUxLjIwNS0uNzUyIDAtLjMzNy0uMDkxLS42MDgtLjI3My0uODEzLS4xNzgtLjIxLS40MzEtLjM0Mi0uNzU5LS4zOTctLjE2NC0uMDIzLS42NTYtLjAzNC0xLjQ3Ny0uMDM0aC0xLjU3OXYyLjU0M1pcXFwiIGZpbGw9XFxcIiNmZmZcXFwiLz48cGF0aCBmaWxsPVxcXCJ1cmwoI2EpXFxcIiBkPVxcXCJNMCAwaDQxdjM2SDB6XFxcIi8+PGRlZnM+PHBhdHRlcm4gaWQ9XFxcImFcXFwiIHBhdHRlcm5Db250ZW50VW5pdHM9XFxcIm9iamVjdEJvdW5kaW5nQm94XFxcIiB3aWR0aD1cXFwiMVxcXCIgaGVpZ2h0PVxcXCIxXFxcIj48dXNlIHhsaW5rOmhyZWY9XFxcIiNiXFxcIiB0cmFuc2Zvcm09XFxcIm1hdHJpeCguMDAwOTMgMCAwIC4wMDEwNiAtLjEyMiAtLjAwNylcXFwiLz48L3BhdHRlcm4+PGltYWdlIGlkPVxcXCJiXFxcIiB3aWR0aD1cXFwiMjIzNVxcXCIgaGVpZ2h0PVxcXCI5NTlcXFwiIHhsaW5rOmhyZWY9XFxcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFDTHNBQUFPL0NBWUFBQUF0S2xha0FBQUFDWEJJV1hNQUFDRTNBQUFoTndFeldKOTZBQUFnQUVsRVFWUjQydXpkUFloZDZaMG04T2NkT2pEc0RXcGhZQ293YkRXdW9JT0J2ZzNPWEdBcHNwTEYzYlNTaVZSaWNhVEFyVWhSMDJvY0tlcWVRSkdETGtXVHFMSE1KdFdSTlNEREJBdHpHeWFZb0l4cllZSmFHSmdhcUlVSkJ0NE4zbHVyc3R3ZityajNQZWZjKy90QmNVdHErNTZ2OTFTcGRCNDkvd1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRG9vRGdGQUFBQU1FNjExcDBrOHovN1liNlVwODRPQUFBQUFOdEsyQVVBQUFCV3JOYTZsMlJ2K2N0NWtwM2w1Ly90eXU5bitmdnpOZXpDMHhkK3ZVank3OHZQVDVjZlNiSW9wWnk3WWdBQUFBQk1pYkFMQUFBQXZLSmE2MldBNWRyeXQzNjZmTDBhYkptUzArWEhlWkt2bDYrTEpLZWxsRk5YSEFBQUFJQXhFWFlCQUFDQWIzQmxoTkE4clpGbG50YktzcmVGcDJPUkZvRDUreXlETVVZcEFRQUFBREFVWVJjQUFBQzIzcktwWlM4dDBQTFRUTGVocGJmVHRDRE0xMm1qa3pUQkFBQUFBTEIyd2k0QUFBQnNsV1ZqeTdVSXRxekxlVnJ3NVRJQXN5aWxuRHN0QUFBQUFLeUtzQXNBQUFBYmJkbmFjaGxzdVpidEhFTTB0RVd1QkdDMHZ3QUFBQUR3Sm9SZEFBQUEyQ2kxMXIyMFVNdlBsNjlhVzhibk5DMzg4dHUwOEl2bUZ3QUFBQUJlbXJBTEFBQUFrM1psTE5GbHVHWFBXWm1jeSthWDM1WlNuam9kQUFBQUFId1hZUmNBQUFBbVo5bmU4bjZlQjF6WUhPZDUzdnJ5Uk9zTEFBQUFBQzhTZGdFQUFHQVNhcTN6SkxmU1FpNTd6c2pXV0NSNWxCWjhPWFU2QUFBQUFCQjJBUUFBWUxRRVhIaUI0QXNBQUFBQXdpNEFBQUNNaTRBTEwwbndCUUFBQUdCTENic0FBQUF3dUZyclhscTQ1WmNSY09IVlBjM3o0TXU1MHdFQUFBQ3cyWVJkQUFBQUdFeXQ5VERKejlPQ0xyQUtSMGtlbFZLZU9oVUFBQUFBbTBuWUJRQUFnSzZXTFM2L1RIS1laTWNaWVUxTzA5cGVqb3c1QWdBQUFOZ3N3aTRBQUFCMHNXeHh1WlhrbXJOQlowZlI5Z0lBQUFDd01ZUmRBQUFBV0p0bGk4dGhXcE9MRmhlR2RwcmsweVJQU2lublRnY0FBQURBTkFtN0FBQUFzSEsxMW10cExTNkh6Z1lqZEo3Vzl2SzNSaHdCQUFBQVRJK3dDd0FBQUN0VGEzMC9yY1hsbXJQeFVoYmY4SHNuU2Y3dks3ekhqNUxNWHZpOVdaSjlwL2VsSE1XSUl3QUFBSUJKRVhZQkFBRGdqZFZhRDVOOGttUnZ5MC9GUlZwWUpVbStYcjZlTFQreS9HOFhBK3pYN3ZJamFTR1lXWkwva3VlQm1MbFZuS2RKUGhWNkFRQUFBQmcvWVJjQUFBQmUyNWFHWEM3REs1Y05MSXY4YWNobHl1WjUzZ3J6VjJrQm1jdHd6TFo0bXRiMGN1UU9Cd0FBQUJnbllSY0FBQUJlU2ExMUo4bEhhZU9LZGpiNFVDOERMQ2RKL3BBV2NGbHM2V1cvRE1Ec3A0MU4yczNtdDhHY3BqVzlITG5yQVFBQUFNWkYyQVVBQUlDWFZtdTluODBOdVN6U1JnOWRCbHpPWFBIdmRUVUFNOC96c1VpYjVEUkNMd0FBQUFDakl1d0NBQURBOTlyQWNVV1hMUzEvV0w2ZXVNb3JNMTkrWEFaZ05tVUUwaUxKM1ZMS1U1Y1lBQUFBWUZqQ0xnQUFBSHlyRFFxNVhDUjVsdGJjc29qV2xwNzIwMEl2NzJZendpOVAwNXBlbnJxMEFBQUFBTU1RZGdFQUFPRFAxRnF2cFlWY3JrMzRNQlpKZmgvTkxXTnoyZnp5azB4NzdOR1R0S2FYVTVjVUFBQUFvQzloRndBQUFQNi9XdXRla2k4eXpaREw1V2lpeTRETGhTczZlck1rQjJuQmw2bTJ2bnllMXZSeTduSUNBQUFBOUNIc0FnQUFRR3F0TzJsTkxoOU5iTmZQMHNZVGZSWHRMWnZnTXZoeWtHa0ZYODdUQWkrZnU0UUFBQUFBNnlmc0FnQUFzT1ZxclIrbEJWMTJKckxMQWk3YllZckJsOU1rdDBzcFQxMCtBQUFBZ1BVUmRnRUFBTmhTdGRaclNUNUxHeDh6ZGhkSmppUGdzcTJtRm54NWt1UnVLZVhVcFFNQUFBQllQV0VYQUFDQUxiTWNXZlJaa3NNSjdPNXhrdCtuTmJuQUxDM3c4ck9NUDZSMW51UnZTeW4zWFRZQUFBQ0ExUkoyQVFBQTJDSzExc08wb011WVJ4YWRwRFc0SEtjMXVzQTMyVTF5SXkzNHNqdmkvVnlrdGJ3OGRja0FBQUFBVmtQWUJRQUFZQXZVV3ZlU2ZKSGsyb2gzOHpqSmx6R21pRmQzMmZaeU1PSjkvRHpKcDZXVWM1Y0xBQUFBNE0wSXV3QUFBR3k0V3V0SFNUN0pPTnRjenRJQ0xscGNXSVhkSkIrbU5iN01ScmgvNTBsdWwxS2V1RlFBQUFBQXIwL1lCUUFBWUVQVld1ZHBiUzd6RWU3ZUlpM2s4c3lWWWcxbWFTMHZ0ekxPRVVkUDBrSXZXbDRBQUFBQVhvT3dDd0FBd0FhcXRkNVBhM01aRzZPSzZPMGdyZTFsYktFdkxTOEFBQUFBcjBuWUJRQUFZSVBVV3ZmUzJseXVqV3pYanBNOFNodGJCRU9ZcDRWZURrYTJYMXBlQUFBQUFGNlJzQXNBQU1DR3FMVitsTmJtc2pPU1hicElhM0Y1dlB3Y3htQTNiYnpSalJIdDAybGE0T1dweXdNQUFBRHcvWVJkQUFBQUpxN1d1cFBXNXZMK1NIWkp5SVVwR0dQbzVmTlN5bDJYQmdBQUFPQzdDYnNBQUFCTVdLMzFXcExmWkJ4dExrSXVUTkhZUWkrTEpCK1VVazVkR2dBQUFJQnZKdXdDQUFBd1ViWFcrMmxqaThiZ09NbkRDTGt3WGJ0SjdpV1pqMkJmenBQY0xhVWN1U3dBQUFBQWYwN1lCUUFBWUdKcXJYdHBiUzVqZUNoL25PUlJrak5YaGcweFQydDZHY1A5ZFpRV2VqbDNXUUFBQUFDZUUzWUJBQUNZa0JHTkxWcWtoVndXcnNyYXpKTHNmODgxWUgwT2t0eEphM3daK2w2N1hVcHh2UUVBQUFDV2hGMEFBQUFtWWlSamk4N1N4aFU5YzBWZXl0WEF5dFdta0hldmZMNmIxUVlxVHZLbjQ2UytYcjVlTFA5YklpanpLZzZUZkxpOGxrTTVUd3U4UEhFNUFBQUFBSVJkQUFBQVJxL1d1cFBXNW5KdHdOMjRTUEpsMmxnVi90UitXaEJpbnVTL0xIKzk2Z0RMdWx3R1k3N084ekRNV1l5bGV0RXNyZVhseHNENzhYa3A1YTdMQVFBQUFHdzdZUmNBQUlBUnE3WE8wNEl1ZXdQdXhyTzBOcGR0RDBCY0Jsam1TWDYwL0h4L2c0OTNzYnptZjBnTHdiellHTE9ONW1taGx5R3YrOU1rSDVSU3puMkZCQUFBQUxhVnNBc0FBTUJJMVZvUGszeVdaR2VnWFRoTDhpRGJPZkxtY3Z6UVpiQmxubUhIMkl6RldWcm81ZXZsNjdhT1E3cVo1TmFBYStJMExmQmlIQlVBQUFDd2xZUmRBQUFBUnFqV2VqL0pKd1B1d3FOczE4aWl5ekZFN3k1Zjk2M0NsN1pJQzc4c3NsM3RMN01rOTVJY0RMVDk4eVIzU3lsSGxpQUFBQUN3YllSZEFBQUFScVRXdXBQVzVuSTQwQzRzMGtZV25XejRxUlp1V2U4YXVneS9iRVB6eUR3dDlMSTcwUFkvTGFYY3Qrd0FBQUNBYlNMc0FnQUFNQkxMb012djBoNmU5M2FSMXVieWVJTlA4VzVhQzhkUEJqckgyK2dpTGZEeSt5VFBzcm10TDdPMHNVWTNCOXIrVVNubHR1VUdBQUFBYkF0aEZ3QUFnQkdvdGM3VGdpNDdBMngra2VSQmtyTU5QTFg3U1g2V0ZuTFp0ZElHZDVMa3E3VGd5eWF1dHlGYlhoWkpycGRTemkwekFBQUFZTk1KdXdBQUFBeXMxbm90eVcvU1AraXlxVzB1QWk3VHNLbkJseUZiWGhaSmJwZFNGcFlYQUFBQXNNbUVYUUFBQUFaVWF6MU04c1VBbXo1SjhuRTJKMlN3bStURENMaE0xV1h3NVRpYk0rcG9udVJYYWVHWG5zN1RHbDRFWGdBQUFJQ05KZXdDQUFBd2tGcnJSMGsrRzJEVGo1SWNiY0FwbktXRld6NU1hM05oTXp4TDh2dTA0TXNtck5GN3kzWGEwM2xhdzhzVHl3a0FBQURZUk1JdUFBQUFBNmkxZnBIa3NQTm16NUk4U0J0MU1tWHp0REZGTjZ5a2pYYVJGbmo1TXROdklMcVI1RTc2dDd6Y0xxVWNXVW9BQUFEQXBoRjJBUUFBNkd5Z29NdXp0S0RMVkVmRVhMYTQzSW94UmR0b2tlZGpqcVpxUDYzbHBYY0xrY0FMQUFBQXNIR0VYUUFBQURxcHRlNmtqUzA2N0x6cGgwa2VUL1MwN2FhTkticVIvcTBZak05Wld1amxjYVlaM0pxbE5iejBiaVg2dEpSeTMvSUJBQUFBTm9Xd0N3QUFRQWZMb012djBrYnc5SEtXNU9Na0p4TThaZk8wa011QjFjTTN1RWhySzNxVWFZNDRHbUtzMFZFcDViYWxBd0FBQUd3Q1lSY0FBSUExR3lqb010V3hSUWRwSVplNWxjTkxPazVyZTFsTWJMK0hHR3NrOEFJQUFBQnNCR0VYQUFDQU5Sb282UElveWRIRVR0V05KTGZTeGhiQjYxZ3MxLzZVUWkrenRNQkx6d1lqZ1JjQUFBQmc4b1JkQUFBQTFtU0FvTXRGV3B2THN3bWRKaUVYVm0yS29aZkQ1WDNRaThBTEFBQUFNR25DTGdBQUFHdlNPZXh5a2haME9abkk2VGxJY2lkQ0xxelAxRUl2QjJrdEw3Tk8yeE40QVFBQUFDWkwyQVVBQUdDTk9nVmVGa2srVG10MkdidDVXb1BGM09xZ2srTzAwTXZaQlBaMVA4bXYwaThFSnZBQ0FBQUFUSkt3Q3dBQXdKcXRPZkJ5bk5ib01uYTdhYTBWUWk0TTVYRmE2R1hzb2JCWmtzL1NnaTg5Q0x3QUFBQUFreVBzQWdBQTBNR2FBaThQMHg3Z2o5a3NyY25scGxYQUNGd2srVExKMFFUMjlWNlNHNTIySmZBQ0FBQUFUSXF3Q3dBQVFDY3JETHhjcEFWZGprZCt5RGZUZ2k0elY1K1JPVnZlUTg5R3ZwK0h5M3VvaDg5TEtYY3REUUFBQUdBS2hGMEFBQUE2V2tIZzVTTEozU1FuSXo3TWVaSTc2VGVHQlY3WEltME0yTm1JOS9GR1dzdExEN2RMS1VlV0JRQUFBREIyd2k0QUFBQ2R2VUhnNVN6Snh4bHYwR1dXRm5LNTRTcS9scE8wTU5QcjJvOFduZGYxS09NZWJYU1FGbmpwY1gwRlhnQUFBSURSRTNZQkFBQVl3R3NFWGs3U0dsMHVSbnBJTjlLQ0xzSVdmK29pejBNc2YxaiszdUtGLzdZdWwydHJsdWN0TysrKzhOOTQ3aXl0NVdVeDB2M2JUL0paQkY0QUFBQUFoRjBBQUFDRzhncUJsekVIWFhiVEdpZTJQVHh4dHZ6NCtzcm5pNUh2ODJVSVpqL0pYMTM1Zk5zRFM0L1RtbDdHZUwvMUNyeWNKN2xlU2xrRUFBQUFZSVNFWFFBQUFBYjBFb0dYTVFkZGJpYTVsZTBMUjF3R1dmNnd2RDZiRmdpNERNSE1rL3hvK2JxTjEzaXNMUy83YVFHei9UVnZSK0FGQUFBQUdDMWhGd0FBZ0lGOVIrRGxPTW5EakMvb3NtMXRMcGVCbHErWHJ4ZGJ1RXgzbDlmNzNlWHI3cFljOTFoYlhtWnBEUy9yRHJ5Y0pubXZsSEx1S3pVQUFBQXdKc0l1QUFBQUkvQU5nWmZqdEdhSnNkbUdOaGZobHUrM1RlR1hzYmE4OUFxOExOSWFYZ1JlQUFBQWdORVFkZ0VBQUJpSks0R1h5NGZyWXpKTGEzTTUyTkRUL3l3dDNQSnNlZjU1TlpkamozNlc5WWN2aHZJNHJXbHBiUGRsajhETFVTbmx0bVVPQUFBQWpJV3dDd0FBd0VqVVd0L0tPTU1rOHlTL3ltYTF1VnprVHdNdTJsdFc1N0wxNVNmWnZIRFVTWktQTTY1QVZLL0F5K2VsbEx1V053QUFBREFHd2k0QUFBQWpzQXk2ekRPK1FNbGgydGlpVGZFc3lWZkxWOVp2bGhaNCtUQ2IwL2h5a2Rid2NqeXk4OXdqOEhLN2xISmtXUU1BQUFCREUzWUJBQUFZMkVpRExyMGVudmR3a3VUTGFIQVoybTZTRzJtampuWTM0SGlPMDBJdkYxdDB6NTRudVY1S1dWak9BQUFBd0pDRVhRQUFBQVpXYS8zckpIODVvbDNhaExGRkYybGhoQzh6cnBFelBGOWpQMHNMdjB6WjJNWWE5UXE4dkYxS09iZU1BUUFBZ0tFSXV3QUFBQXlvMXZwT3h0VnljVFBKblFtZjBzc1dsMk9yYXhKbWFZR1hEelBkdHBlTEpBOHludEZZKzJtQmwzV0cxUmFsbFBjc1h3QUFBR0Fvd2k0QUFBQURHVm5RWlpia1hwS0RpWjdPNHlSZkpURmVaYm9PMGtJdjg0bnUvNk1rUnlQWmx4NkJsNk5TeW0zTEZnQUFBQmlDc0FzQUFNQUFhcTM3U1g0NGt0M1pUUnRidEQreDAyaFUwV2JhVHd1OVRISEUwYk8wbHBlTGtaekhkUWRlYnBkU2ppeFpBQUFBb0RkaEZ3QUFnTTVxcmJ0SjNobko3dlI0SUw1cUYya0JsOGNaUjZpQTlkaE5jaXZUQzcyY0pQazQ0d2hnelpmMzk3cWNKN2xlU3RHb0JBQUFBSFFsN0FJQUFORFJ5SUl1TjlKR0YwMkZrTXQybW1MbzVTTEozYlRneTZiZjU2ZEozaXVsbkZ1cUFBQUFRQy9DTGdBQUFKM1VXbWRKZmp5UzNUbE1DeEJNZ1pBTHlmUkNMeGRKSHFhTjJocmF6U1IzMXZqK1Qwb3BIMWlpQUFBQVFDL0NMZ0FBQUIwc2d5N3pKRytOWUhmdVpUcUJnY2RKSGtYSWhlZDIwNEliQnhQWjN3Y1pSK0JsM2ZmOTNWTEs1NVluQUFBQTBJT3dDd0FBd0pyVld0OUtDN3JNQnQ2VldaSmZMZmRsN0k3VFFpNW5WaERmWXA3VzlES1Y5ZnhnQlB2eDJSclAxM21TNjZXVWhhVUpBQUFBckp1d0N3QUF3SnJWV24rY2NRUmRQa3V5UC9MVGRaSTIrc1VEYzE3V2piVFF5KzdJOTNNTWdaZDFmeDFZcEFWZXppMUxBQUFBWUoyRVhRQUFBTmFvMXZwT2huOElQNFdneTBWYXlPWFlxdUUxMS9qTnRORExtQjB2MS9tUVk3bjJsMThQMWhYQSs3eVVjdGVTQkFBQUFOWkoyQVVBQUdCTmFxMjdTZDRaZURmMjAwWVhqYm4xNG5IYXlLSUxxNFkzdEp2a1hzWTkydWdreWQyQjEvczhMZkN5TGgrVVVwNVlqZ0FBQU1DNkNMc0FBQUNzUWExMUo4TS9jRjkzZzhPYk1yS0lkYm1SNU03STEvN1FnWmVieTNPMER1ZEozamJPQ0FBQUFGaVh2M0FLQUFBQVZxdlcrb01rZnozd2Jvdzk2UElveVM4aTZNSjZIQ2Y1bXlUUFJycC9ZN2cvSDJkOVk4TjJrbnhoR1FJQUFBRHJvdGtGQUFCZ3hXcXRQODZ3RDdISEhIUTVTZkpnK1FvOUhLU05OaHJyL1RCa3c4dHMrYlZpZjAzdmY3dVVjbVFKQWdBQUFLc203QUlBQUxCQ3RkWjNrdXdPdUF0akRybzhTbkswNVV0a2Qva3h5L09Bd1krdVhLK3J2Lzhxcmpia25DWDVQeS84L2ttR0haa3p0RmxhNE9WZ2hQczJkT0JsTjhtdjEvUTE0enpKZTZXVVU5OGRBQUFBZ0ZVU2RnRUFBRmlSV3V0dWtuY0czSVd4QmwzT2tueWM3V3B6bWVkNXNPWGR2SDZJWmRVV2FhR0tQeXl2eDltV1haZXh0cndNSFhnNVNQS3JOYjMzMDFMS2RkOGhBQUFBZ0ZVU2RnRUFBRmlCV3Vzc0xlRHcxa0M3c001MmhqZHhuT1JoTnJ0VlpILzU4ZTZWejZkbWtSYTQrTVB5ODdNTnZsNjdhWUdYK2NqMmErakF5NTBrTjlmMDNzWVpBUUFBQUNzbDdBSUFBUENHYXExdnBUMDRIeXBvTWt0cmRCbFR5T0lpTGVSeXZJR1hmSDk1dmQ4ZCtMcXYwMWxhNk9YcmJHNzQ1VERKclpIdDA3TzBGcVNoL0hwTlgwZk9rN3hkU2puM0hRTUFBQUJZQldFWEFBQ0FOMVJyM1UveXc0RTJQOGFneTBtU0I5bWM4VGl6dERFdjd5NWZaMXU0ekMvREw3OVBDMlJzaW5uYStKNHhYZFBqNWYwemhIVTJSRDBwcFh6Z093WUFBQUN3Q3NJdUFBQUFiNkRXK3BkSi9ucWd6WTh4NkxJcFk0dDIwNEl0UDhzMHh4S3QyN004RDc1TS9WcVA5VDRhS3ZCeWtCWUFXb2NQU2lsUDNENEFBQURBbXhKMkFRQUFlRTIxMWg4aytYR1N0d2JhaFh0SmJvem9sRHpJdE1jV3paYm5VOERsMVd4SzhHVnM5OVBESkk4MzdGeWNKbm5QT0NNQUFBRGdUUW03QUFBQXZLWmE2enpKemtDYkg5T0QrWXNrZHpQZHNVVTNrdndrcmRHQ04xc0h6NUo4bFRieWFLcHI0ZDZJOW1lb0FOa3NiWnpSN2hyZSs5TlN5bjIzQ3dBQUFQQW1oRjBBQUFCZVE2MzFoeG11L1dOTUQrUlBrbnljNUd4aWwzQTN5WWZMY3ptem9sZnVMTW1YYVVHTnFiVzk3S2VOTlJyTHV2aEZoZ21TN2FjRlh0Ymh2VkxLd20wQ0FBQUF2QzVoRndBQWdGZFVhNTBsbVdlWThVVUhTWDQxa2xQeExLMTVZa3BoaG5sYXlFV0xTei9IU1I1bFdvR28zZVY5Tm9aeFZrTTJKeDBtdWJXRzkzMWFTcm51MWdBQUFBQmVsN0FMQUFEQUs2cTEvampEdEQ2TXFYSGlPQzNvTWhVMzBoN2E3MXJCZzFta2hWNm0wdWd4Vzk1dll3aThuS1FGWG9ZSWx2MTZUZWZnZGlubHlHMEJBQUFBdkE1aEZ3QUFnRmRRYTkxTHNqZkFwbWRwRDUzSEVOWjRtT1R4QkM3WExLM0JSY2hsWEJaSnZrb0xURTNCdmJTdzFOQ2VwWTBNNjIxZDQ0eE8wOFlabmJzbEFBQUFnRmNsN0FJQUFQQ1NsdU9MZmp6UTVqOUxHOEV6dEFlWlJramhNRzFjMGN6S0hhMnp0S2FYS2F5bnNRUmVIcWVGellhNG45WXh6dWpUVXNwOXR3SUFBQUR3cW9SZEFBQUFYbEt0ZFo1a1o0Qk4zMGx5YytERHYwaDd5RDcyWUlKeFJkTXpsZkZHTjVmMzR0Q0dDcHl0YTV6UjI2V1VVN2NCQUFBQThDcUVYUUFBQUY1Q3JmV0hXYytEM3U5ekk2MVZZa2dYU2U0bU9SbnhKVHBJQ3lJSXVVelhJaTFRTmVaMXRzMzM0enl0WVdyVmprb3B0eTEvQUFBQTRGVUl1d0FBQUh5UFd1c1Awc1lYdmRWNTAvdHBENWVISE1VejlxRExmbHJJWlc2bGJvemp0TkRMeFVqM2J3eUJsNVBsZmRuN0hLMnJaZXA2S2VXcHBROEFBQUM4TEdFWEFBQ0E3MUZyL2Vza2Y5bDVzN08wb012K2dJYys1cURMTEcxYzBVMHJkQ05kcEkwMmVqelMvUnRENE9WWmtvOEh1TzkrbmRVM0tEMHRwVnkzN0FFQUFJQ1g5UmRPQVFBQXdMZXJ0ZTZrZjlBbGFRMEtnaTdmN0NESjMwWFFaWlBObHZmQXJ6UE8xcDdqSkE5R2NCL2NIT0Ryd3NNMXZPKzFXdXY3bGowQUFBRHdzalM3QUFBQWZJdGE2MXRwNDR0KzBIblRRN2RHakRYb3NyczhMMFlXYlovSGFVMHZZeHR0TklhR2wxOE1jSzkrdG9iNzhMU1U4cmFsRGdBQUFMd016UzRBQUFEZjdvZnBIM1RaVFd1MEdNcFlneTQzTTk2V0Q3YjMrbytoNGVWZVdoTk9UK3M0NXIxYTY2R2xEZ0FBQUx3TXpTNEFBQURmb05iNmc3UldsN2M2Yi9yWEdYWjgwZDBraXhGZENtMHV2R2lNTFM5RE43dzh6bnJHQzMyWHd5UzNWdnllMmwwQUFBQ0FsNkxaQlFBQTRKdjlNUDJETG9jWk51anlJT01LdWh4RW13dC83ckxsWlg5RSszUzgvQmp5bkJ4MDN1YmpKR2NyZmsvdExnQUFBTUJMMGV3Q0FBRHdMV3F0dTJrUDFIdUVYdVpKUGh2d2NCOWsySWYxVjgzU1JqbmRzQXI1SG8rU0hJMW9mKzROdUc0dmt2eE4ramJlcktQUlJyc0xBQUFBOEwwMHV3QUFBSHlMVXNwWmtuOUljcnJtVGMweS9BaVVzUVJkOXROQ1A0SXV2SXhieS9VeUc4bitETm1PTk1UWGtlTTFISzkyRndBQUFPQjdDYnNBQUFCOGgxTEtmNVpTVHROQ0wvKzZwczNjU3JJNzBDRWVKM2s0a3ROOUl5MjRzRy9sOFFybVNmNXVST3ZtNHlRbkEyMzdJUDNIR1QxYXczdCtZbGtEQUFBQTMwWFlCUUFBNENXVVV2NmpsUEpQYVMwRy83SEN0NTRudVRuUVlaMWtQRUdYZTh1UG1kWEdhNWdsK1hYRzBRaDBrUlo0dVJqd1h1cDVIeTJTUEZ2eGUycDNBUUFBQUw1VGNRb0FBQUJlWGEzMWgwbjJrcnoxQm05eitZQitpRmFYc3lTL3lIQVA1SytlQTIwdXJOSngyamlob2UwdjcrOGhQRXNMM1BTeW05YXVzMHFucFpTM0xXY0FBQURnbTJoMkFRQUFlQTJsbEg5SkcyMzBMMi93TmpjelROQmw2T2FKUzVkaEFFRVhWdW5HY2wwTjNSSjBrdUZDTjczSEdaMmxoWXhXU2JzTEFBQUE4SzJFWFFBQUFGNVRLZVUvU3lrblNmNVhrdk5YL0wvdko3azEwSzQvVEhzUVA2UjVXcVBMcnBYRUd1eG5ISTFCeDBrZUQ3VHRPK2tiK0htMGh2Zjh4RklHQUFBQXZvbXdDd0FBd0JzcXBWeVVVaFpKL2luSmY3emsvKzNPUUx2N09LdHZZSGhWTjlLQ0NET3JoelVhUytEbFlaTEZBTnZkVGQ5QTNWbFdIM2pacTdXK2J5a0RBQUFBTHhKMkFRQUFXSkZTeXIrV1V2NGh5V21TLy95Ty8rbk50R2FUM2hacEQ5NkhkRFBKUGF1RlRtWnBnWmVEZ2ZkanFMRmhOOU0zN1BONERjZjVTOHNZQUFBQWVKR3dDd0FBd0lxVlVrNlQvRU5hMDhHTFpobG1mTkZGMmdQM0lkM0xjSTAyYks5WmtsK2xOUW9ONVNMSjNZRzJmYWZ6Y1g2NTR2ZThWbXU5WmhrREFBQUFWd203QUFBQXJFRXA1VDlMS2YrYzFxWnlmdVUvM2NrdzQzdUdhcGE0ZEMvRGhnMWc2RFY0a21HYWxlYWRqM3NkN1M2M0xGOEFBQURnS21FWEFBQ0FOU3FsbkpkU0ZrbitPV1NHOXNBQUFDQUFTVVJCVk1rUE04ekQ5a2Rwb1p1aENMb3dGa092eGNjRDNZczlRM2JyYUhjNXJMWHVXYjRBQUFEQUpXRVhBQUNBRGtvcFowbit4d0NiWGlRNUd2RFFCVjBZbTZIWDVCQXRTN01rTnp0dTcvRWEzdlBRMGdVQUFBQXVDYnNBQUFCMFVHczlUSEt0ODJZdmtqd1k4TEFGWFJpcklkZm1VUGZsclNTN0hZL3hlTVh2K1V2TEZnQUFBTGdrN0FJQUFOREhKd05zODJHU3M0R09WOUNGc1J0eWpUN0xldHBQdnMrZGp0dDZ0T0wzMjFtR0JnRUFBQUR5bGxNQUFBQ3dYclhXKzBuMk9tLzJXVmJmclBDeURpUG84cktlSmpsUDh2V1ZYMTg2TDZVc3ZtTmRYYnZ5eTUwazgrWG5QMzNoMTN5N2U4dlhJZTZWUjBrTzBxOXRKY3Z0emRQR202M2IyZks4cnZKcndTOHo3RmcyQUFBQVlDU0tVd0FBQUxBK3RkYWRKSDlNQ3gvMGNwSGtiNWF2dmQzSTh3QUJ6NTJtQlF5K1RndTBMRW9wNXgzVzMxNWF1R0dlNU4yMFVWbzdMc2VmM1M5M2s1d01zTzE1a3M4NmIzT3hQTjRlOXBQOGVzWHYrZDUzaGNBQUFBQ0E3U0RzQWdBQXNFYkxWcGZlSTR3K1RtdDI2VTNRNWJsRldxamw3NU04N1JGc2VZVTF1WmNXZXZucDhuWFA1Um8wOEhJbnljM08yN3liUHUwdVNRdnpyTEpsNktpVWN0dVNCUUFBZ08wbTdBSUFBTEFtQTdXNlBFc0x1L1Mybi9aUWU3YkZsL3hKa3QrbWhWdE9KN1JPNTJtaGwxdlo3dEZIWjBsK2tmNk5TTE8wOXBPZTQ0eE9sc2ZhdzBHU1g2M3cvYzZUdkQybUFCa0FBQURRMzE4NEJRQUFBR3Z6VWZxUEwzbzR3SEh1Wm51RExrK1MzRTd5WDBzcEg1UlNqcVlVZEVtU1VzcWlsUEo1S2VXOUpHK25iK3ZIbUZ5dTQ5NHVranpvdk0zOXRDYW1IcDZsQllsV1pTZkorNzY5QUFBQXdIWVRkZ0VBQUZpRFphdkxMenR2OWxGVysxRDVaY3pTV2h1MktlaHltdVRUdEhhSnk0RExSclJNbEZKT3J3UmYza3Z5ZVZxVHhyYll6ekNqdUJicFAzcnNWc2R0ZlRuaGZRY0FBQUJHU05nRkFBQmdQWHEzdXB3a2VUekFjZDVKQ3doc2c2ZEpQaWlsdkYxS3VUKzFCcGRYdFd4OHVadlc5bkk3TGVTekRXNGt1VG5BZGgrbTd3aWwzZlJyZHpsZThiRmRxN1h1K1RZREFBQUEyMHZZQlFBQVlNVUdhblVaWW56UnpmUjdXRDZrbzdRV2wrdWxsQ2ZidHA1TEtlZkw5cHEzazF4UEMvMXN1anRKNXAyM2VaYld6dFJUcjRhVWk2eSt1ZWJRZHhzQUFBRFlYc0l1QUFBQXE5ZTcxZVU0YlF4S1QvTzBRTUFtTzBvTHVkemU5QmFYbDFWS2VWcEt1Wjd0Q0wwTU1aN3JjZnFPSXR0TnYxQ1BVVVlBQUFEQXlnaTdBQUFBck5BQXJTNFg2ZC9xTWtzTEFteXFvd2k1ZktjdENiME10YzRmZE41ZXI5REl5ZkpqVmZacXJYTjNJd0FBQUd3bllSY0FBSURWNnQzcThtVmE0S1duSVJvdmVuaWE1THFReTh1N0VucTVuV1FUejlrOC9jZmxMTkszcVdtZTZiYTcvTkpkQ0FBQUFOdEoyQVVBQUdDMWVvN1dPRXRySWVucE1QMGVqUGR5bnVSMktlVjZLZVdwSmZ6cVNpbEhTZDVMOHVtRzN0TzkxM3p2ZHBjUE8yM25XVlliem52ZjNRY0FBQURiU2RnRkFBQmdSV3F0aDBuMk9tN3lVZWREM0UvZk1FOFBSMmtqaTQ2czREZFRTamt2cGR4UDhuWTJiN1RSdmZSdE16cExjdHh4ZXdkSmRqdHM1eUl0OExJcU83VldnUmNBQUFEWVFzSXVBQUFBcTlOenBFYnZoK0d6dEFmK20rSTB6MGNXblZ1NnExTktPVjJPTnJxYjFwcXpDWFlIV1A4UDAzZEVXYThnMjFjcmZyK2Z1K3NBQUFCZyt3aTdBQUFBckVDdDlWcjZqanJwUGVia1ZscXp5eVk0U3ZLZWtVWHJWVXI1UEcyMDBhYWM1NFBsUnk4WFNiN3NmSHc5Mm1zV2FXRzlWZEhzQWdBQUFGdEkyQVVBQUdBMWVvNzNXU3cvZXBrbnVia0IxK2c4eVFmYVhQcTUwdkx5NllZY1V1OXhSby9UcjkxbGx1UkdwMjBaWlFRQUFBQzhFV0VYQUFDQU4xUnIzVXR5MkhHVGp6b2Y0aWFNTDFxa3RiazhzV0w3SzZYY1QzSTkweDlyMUh1Y1YrOTJsdzg3YldmVngyU1VFUUFBQUd3WllSY0FBSUEzZDloeFc3MWJYUTZUN0U3OCtod2x1VjVLT2JWVWg3TWNHL1YyNS9XN0RnZnBPN0tzWjd2TGJxZGpPMHR5c3NMM3UrWU9Bd0FBZ08waTdBSUFBUERtZW80dzZ0bnFzdHY1Mk5iaHJyRkY0MUZLT1MrbHZKY1dRSnF5bnVPTWVyZTcvS3pUZHI1YTRYdnQxVnJuN2pBQUFBRFlIc0l1QUFBQWI2RFcrbjZTdlU2YjY5M3FNdVh4UmVkSlBpaWxmRzZWams4cDVYYVN1eE0raE4wa056dHVyMmU3eTQzMENmSThXL0g3M1hKbkFRQUF3UFlRZGdFQUFIZ3pQUit3ZnRWeFc3MUh0YXpTZWRyWW9pZVc1M2d0ZzBpM0ozN3Y5eHJ4ZFpIa3VPT3gzZWl3RGFPTUFBQUFnTmNtN0FJQUFQQ2FhcTA3U2Q3dnRMbXo5SHZZUFV0eVo2S1g1VExvc3JCQ3g2K1VjcFRrZytWMW02S2U3VWM5UnhsOTJHazdxd3p3eld1dGUrNHFBQUFBMkE3Q0xnQUFBSy92c09PMkhuWGMxczMwYTZ4WXBVV1N0d1ZkcG1YWndITTkwd3k4ek5PdkFhbG40RzAzeVg2SDdheDZsTkUxZHhRQUFBQnNCMkVYQUFDQTE5ZHJoTkZGVnY5UStOdk0wcS9WWVpVV2FZMHU1NWJsOUN3RFNyZVhhMzFxZXJZZzlXeDMrVm1IYlp3dFAxYmw1KzRtQUFBQTJBNXZPUVh3YXBhMXlGYy9McjJiWk9mS3J4ZEovdjNLcjU4bVNTbmxxYk1JQUxBeGZ5N3MxZWh3bkg0aGdEdHBnWmNwMllpZ3k1V2ZOWFplV0Zzdi9xeHhtdVIvdjNEODUwa1dVejBIdGRaM2xzZHdOOGxuRTF1RCswbHVwRS9yeXNueWV2ZjQybk1qeWNNTzIzbVcxaWExQ3RkOGR3SUFBSUR0VUp3QytIYTExbm5hWDVhOW05WFdVNStuL1FYbDN5OWZuL29YcUFBQWsvdXo0djBrbjNUYTNOOWt0ZTBIMzJZM3lkOU43RktjcHdWZEZoTmJQMWQvMXRqTDZoN1NYLzZzc1VqeTlmSm5qZE9SbjR0MzhxZGpzK1pwZ1pjcE9WdmVwejNjU0hLdjA3WSt6dnBicFZaOXZkOHp5Z3dBQUFBMm43QUxYRkZyM1VueWZscjE4Ylg4NmIrZVhMZEZXdnZMYjdXL0FBQk00cytPZjh5Zk52MnR5N08wQjg0OTNFdDdrRDRWa3dtNkRQeXp4dW1WbnpXZWpPeTh2QmgwdWRRejBMRXFEOUtuM1NWSi9tZjZ0TjhjTDQ5clNzZnphU25sdnU5U0FBQUFzTm1FWGRoNkwveWw4L3NqMmEzekpFK1MvSzEva1FZQU1Nby9RODZUL0dPbnpmVm9Wa2ltMmVveTZnYUhrZjZza2VYUEdvK0dEcjU4UjlEbDBzMjBzVnBUMGJQZDVVNVdOL3JudTF3aytlOGR0clBLb04zVFVzcDEzNmtBQUFCZ3MvMkZVOEMycXJYT2E2MWZKUGxqa2k4eXJyOTgza2x5bU9RZmE2MS9yTFYrdFB5TGNnQUF4cUhYbngzUDBpZm9raVMzSm5ZTmJvODE2SExsWjQxL0crSFBHcGZyOXplMTFuK3J0WDVXYTkwYjRCeDlYOUFsU1I2blgxUEtLdXltWHpQU2w1MjJNMHR5MEdFN1g2L3d2YTc1RmdVQUFBQ2JUOWlGclZOcnZWWnIvVjNhdjhROVROLzY4TmV4bHphLy9JKzExdnREL0VVMEFBQi81dWVkdHRNcjZOTHpJZjBxZkY1S09Scmh6eHJ2di9Denh0anRKUGxvK2JQR0Y3WFdhNTNPMDhzRVhTNDlTQnY1T2hXOVFtTm5IYy9MVHpwc1k3SGlOWFl0QUFBQXdFWVRkbUZyWEFtNS9DN1QvSmRlTzBrK1NmdUw2TTgwdlFBQURQYm55cjBrODA2YjY5WGVNS1ZXbDZlbGxMc2ovRm5qajBsK2srbTJTaHdtK1YydDlYZkxNVjNyT2xldkVuUzU5SEZhdUdNS2VnYkh2dXEwblI3TkxtZEpUbGI0ZmxPOUR3RUFBSUNYSk96Q3hxdTE3dFZhZjVQcGhseSt5ZVcvdnJ6dkNnTUFkTmRySk0xSitqemduMlU2clM3blNUNFkwYzhhVndQMWV4dXl2cStsalZQOVl0V3RrcThaZEVtU2k3VEF5MVQwQ284OVc1NmJIbDhqOWp0c1o1WHRMai8xclFvQUFBQTJtN0FMRzIwWkJ2bkg5SHNnMGROT2trOXFyWDlVMFF3QS80Kzl1d2VSNU16VFJmKzhnNHlCSTlnY1dEZ3lGaWFibFhFOGxlQjZaMEhaMW82bmFzNDYxMUsyY2ExcnFOdGFhK2x1anJWV3Q0eTFxOXE2MTloRGwrQWFjNnpPQmkyTXNkQWxHR09NWHBRRFkvUUJ3ZVpDSDVBaGVLOFJVZXBTVFg5VVZVWkVSbWIrZnREMGpLVEt5UGhIdkZIeDhjVC9oVUVOTllYUlVGMWQvbTZMYW4rcmxMSWF3WFhHcE5aNmxOMEsxRjgwVHhONnVkOVJ6YTRiZERueklzay9iVW50UHNvdzNaOWVaYmlwenY1MmdHVjgyK0ZudVVZR0FBQ0FIU2Zzd2s2cXRSN1VXcCtubWZabjE2ZjdtYVpwTjI1cUl3Q0Evczh6SnhudUllcFFEN0gvMjVhVS8wRXBaVEdDZmVBd3lYZHB3aUM3N2l4Zy8zeWRxWTA2Q0xxYytlZDAyLzJqVDBOMWQvbVhnWll6UkhqbnRPT3hlaEFBQUFCZ1p3bTdzSE5xclhmU2RIUFp0eHRiZDlLOGVUbXpGd0FBOUdhb2M2MmhwaWY1VFpvcFNzYnV0SlJ5ZjhQWEdaTjJldFFuMmYxQS9VVUh1V2FYbHc2RExtZitZYUN4MFVYTlB0cWhZOFhIQTZ6UHF6UWRmTGJ0ZUEwQUFBQnNnTEFMTytQY3plZUhlMXlHYVpvdUwvZnRFUUFBdlJocUNxT2h1alZzUTFlWFZaSmJHNzdXT01qdVRvOTZGZmRxclU4djIxR3loNkJMMGdRaS9uRkw2alhVK0JxcUM5UzJkWGY1eEs4c0FBQUEyRjNDTHV5RTl1YnowN2o1Zk9aZXJmV0phWTBBQURvM0cyZzVRenk4L3JqOU0zWmZsVktXRzd6V21LY0p1a3p0L2orTmdlL2VOMFZNVDBHWDgrUGpteTJvMVc4R1dzNVE0Ymdod2lQZmJ1SHhHZ0FBQU5nQVlSZTIzcm1naS9tNGYrNHdUWmNYZ1JjQWdJNlVVbTRrdVpua1VicnRRSERlVU5PU2JFTlhsNDFPWDFScmZaamt5SjcvWnlacHBqV2F2NlZ1ZlFaZHp2eFR4aitkMFljWkp2QXkxREhqYjRZWTh4MSsxdFQxTUFBQUFPd3VZUmUyMnJtM0xOM0Flck9EWE9LdFN3QUFMcStVc2lpbDNDMmxmSnJrVjJtbTJEbE9zdXhvRWQ4T3RDcC9zd1hsdnJ2QmE0MmpKSGZzOGU5MFZHdTljNkZ1UXdSZGt1Umxrc2RiVUtPL0hXZzVRM1M2K1REOWQ0TjYxVzdiTHErSkFRQUFnQjBrN01MV2FvTXUzcko4djBtYURpOXU4Z0VBZEt5VXNpcWxuSlJTYnJkZFgyNGt1WjNrSk1ucW1oODd4RVByMzZSNWNEMW14NldVeFFhdU15YTExdWRKNXZid1MzbllCb09HRExxYytlY2tMMFplbjRPQmF2THRnT3ZUdHk2N3U4d01VUUFBQU5oTndpNXNKVUdYS3hONEFRQVlRQ2xsV1VvNUxxWGNLcVg4S3NtblNSNGtXVnp5STE2azI2NEdiL05mUjE3S1ZUYlExYVdkOHNRVXFWYzNyN1UreWJCQmx6UC90QVgxR2FLTDBqY0RyY3NuQXl6ajM3YnMrd0lBQUFBYklPekMxaEYwdVRhQkZ3Q0FnWlZTVGtzcDkwc3BOMHNwSmMyVVI0L3k5czRGcHdOOHJROHovaW1NdmlxbHJJWmNvS0RMMmc2VC9QMEdsbnM2MExoWngzOGJZQm12QnFyREVPT2p5MjQ5VTBNVEFBQUFkcE93QzF1bERXbzhWSWxyT3d1OFRKVUNBR0I0N1pSSGQwc3BueWI1VlpvcGo0NlRMTnYvNUY4RytCcGpEN29zMHdTQ2huWVVRWmQxL1NhYm1mN3BIMGRlbDQrU2ZEekFjb2FZeXVqRDlOL0JwOHZRampFTkFBQUFPMHJZaGEzUkJqU2VwZ2xzY0gyVEpFL2FOMWNCQU5pUVVzcXFuZkxvZGlubFJwb3BqNGJvekREMktZd2ViS0NyeTFHYXppU3M3NHMwb1pjaHZVenkyNUhYNVc5Ny92eFZrdjkzb0hYWnF1NHV0ZGFaWVFrQUFBQzdSOWlGcmRBR001NUUwS1VyQjIwOUFRQVlqMWNETEdQc1V4Z3RTeW5IQTE5cjNNbG11cEhzc3IvUDhCMDFIbS9CTlZqWHg0cy9KZmw5a20vYUtkTitteWIwMHJlL0htQVpwaklDQUFBQTNrblloVzN4TU5vUGQyMVdhNzJ2REFBQW96RkVzSHZzVXhnOUdISmhiY2NIMDZUMjQ3K24vK2x1emh0N2Q1ZVAxNnpIaiswNi9pSEo3MG9wLzFwS2VWRksrYjZVOHVPNS8yNHh3TG9NY1czK3Z6cjhyS25oQ0FBQUFMdEgySVhScTdYTzQwM0x2dHpUMGhrQVlCVG52QitrNmJyU3R6RlBZYlFhc3F0TE8wMnFib2Y5K1RCTjRHVklZKy91Y3RXdzJmZHBPcHo4YXlubG0xTEtIMG9wTDBzcFA3empaNTROc0I0ZkQ3Q01McWQwKzh4d0JBQUFnTjBqN01Lb3RUZWd2V25acnlmdE5GRUFBR3pPVU9kalkrNlcrTlhBeXp1S2FWTDc5bkdTLzN2QTViMU10eUdKcm4zeW5uLy9Lc2t5eVdrcFpWRksrWDBwNVUrbGxLdE1jYmJZa1dPSmFZd0FBQUNBZHhKMlllemNnTzdmcEswekFBQ2JQU2ZyMjBHRzZSNXpYWStHV2xBN25lZk1iamVJdjh1d0lhc3hkM2U1Mk5ubGh5Ui9Tdkw3Sk4rMFV4TXRTeW1yNnk2Z2xESlUyS2Z2N2k2djJqOWRtQnFHQUFBQXNIdUVYUml0ZHZxaW1Vb000ckRXZXFnTUFNQ0l6Z1VQYXEzN05NWE1FQ0dVTVhkMU9WN25BZjhWOTYxcGtudEcyYUQrUHNNRnJVN1RkSGdacTRNa2Ywanl1MUxLNzBvcEwwb3AzNWRTZnV4d0dZc0IxdU0vRDdDTUZ4Mk8rd1BERUFBQUFIYUxzQXVqMUU2clkvcWlZVDAwblJFQU1KSnp3WG1TcDltdkRuOURyT3NuSTE3L0lidHg2R280dkkvU2RIZ1p5djhZY1MxK1hVcDVXVXI1b2NkbFBCdGdQVDRlWUJsZFRtWGtXaGNBQUFCMmpMQUxZM1V2YmtZTmJacmtqaklBQUp0VWE3MlRQWnZLc3RZNlZNZUxzWFkyV0paU0ZnUFZlaDdkSXpmbGl6U2hseUg4ZHNSMUdHTC9HMklxb3lHT0ovOTd5K29PQUFBQURFalloZEZwMjRvTFhXekd2YmIrQUFDYk9BODh5bjUyOTl2M0tZeStHbWovMGoxeTgvNStvT1c4U3ZMTlNHdHdNRUJIemRPQjF1V2pMVnFQdnpEOEFBQUFZTGNJdXpCRzk1UkEvUUdBL1ZGcm5kUmFueWVaNzJrSjlqM3NjakxRY3U1RTk4aE5PeGh3WC95Zkk2OURiMG9weXlTckFkYWo3N0RMcXowNUJnSUFBQURYSU96Q3FMUmRSZVlxc1ZGejNWMEFnQUhQL3c2U1BNMStQNGdjSXV6eXlValgvYlI5TU4vM2ZqWko4cVVSTndwZkRMU2NiOUp0V0tKTHN5SEcxZ0RMNlB1NC9jSndBUUFBQU41RzJJV3gwVlhFZGdBQTlrU3RkUlpCbDJTWWJpTWZqM1RkSHcrMEhGMWR4bVBJN2k1am5jcm9zd0dXTVVUWTVUOE5zSXlYSFgzT3pOQURBQUNBM1NMc3dtam82aklxdXJzQUFIMmYrODNUQkYwbWUxNkhYdzZ3bUk4elRQZVk2emdab01hNnVvelBVTjFkdmgzcCtnOFI5dm5qUU1lV3ZyMDBYQUFBQUlBM0VYWmhUT1pLWUhzQUFMdXYxdm93eVpGS0pFbUdDTHQ4Tk5KMUgyUUtvL2E4VmxlWGNSbXF1OHRZTzd0TUJuaTVZSWpPTGtNY1d6cWJpcXJ0SmdZQUFBRHNDR0VYeHVRTEpSZ1ZiNzhDQUoycXRVNXFyVS9TVENsRFk1K25NRm80cjkxcmZ6dkFNbDVsbU5ESGRmUWQ5dG1Wc011L0dTb0FBQURBbXdpN01BcTExc01rVTVVWWxVazd2UUFBUUJmbmU1TTAweFlkcXNiUGZEREFNajRaNmJwLzdUcGpyLzBtdzB5dnRaZFRHWlZTVmtsV0E2ekhSMXUwenprV0FBQUF3QTRSZG1Fc1BsY0Myd1VBMkUyMTFvTWszMldZYVV1MnpSQVArMGY1TUxxVXNuQSt1L2QrTThBeXh0clo1Wk1kV2ZlUHRtZ2Rwb1ljQUFBQTdBNWhGOGJDRzc0ajNTN3RXOWdBQU5mU2RvcDdtbUdtNjlsR1EzUjJHV1BZWlRIQXZqZEpNcmVMamRvUVV4bU5OZXd5SFdBWk9yc0FBQUFBTzB2WWhZMXJXNHQ3K0RGZWdrZ0F3SFhQOCs0a09YS3U5MDU5ZDNZWmF6ZWRaODVqU2ZKeGhnbExqREh3TXNUWUhHSUtwNzYzMzhzT1Arc1RRdzRBQUFCMmg3QUxZL0NaRXRnK0FNQnVxYlVlSlhtb0V1K3MwUkJkWFQ0YzZlb1BFVDR3aGRGMitKc0Jsdkh0U0k4QjA1NFhzZHFCL2FQTHNJdmdKUUFBQU93UVlSZkd3QnVYdGc4QXNDTnFyWk5hNi9PWVB1WXloZ2lpZkR6U2RSOGk3REt6aTIyRi96ckFNbDZNZE4ybk96RE9kRXNCQUFBQU5rTFloWTFxMzJTYnFzU29UV3F0QjhvQUFGemkzTzRneWZPTWQrcWNmZlNmUnZpZFZxV1VaYy83NGl5Nk9HeUxJWTRYTDBlNjdxNkZoOTEramdrQUFBQ3dRNFJkMkRRUFFyYkRUQWtBZ0hkcHd3VlA0K0h0VlF6eDRIV01uVjEwZFdIbzY4Szk3T3hTU2xuc3lQN3hja3YyTXdBQUFHQkF3aTVzMm1kS1lEc0JBTnV0MWpwUEUzVHgxanlYTVVUWXhmbnJkam5Za2YzdXF2N0N0Z01BQUFDNG5nK1VnQTF6WTh4MkFnQzJXSzMxS01sY0paekhYY0YvT0gvbGdrOEdXTVlyNHhNQUFBQmdkK2pzd3FhNXViY2Rwa29BQUp4WGE1M1VXcDlFMEdVZCs5b0paOUh6dmptTkxrUGJab2pwdHY3TmVOdGFMd3dSQUFBQTRDSmhGemFtMWpxSm05RGJ0TDFtcWdBQXRPY0YwelRURmgycXhxaDl1S2ZyTFZDL25mdHEzL3Vyemk3YmU2ejUzeDMrL25KOEFBQUFnQjBoN01JbXVjbTBYUVNUQUlDekI0WFBuY3R0aFkvSCtLVktLUXZYR1d4Z2Z4MWpkNUNKYmFmbUFBQUF3UFVJdTdCSmJqSnRGdzhOQUdEUDFWcm5hVHE2T0k5anpINnRCRnZwWXlYb3hVb0pBQUFBZ0YwazdNSW1DVThBQUd5Sld1djlKRWNSZE9uU1B0WnlPY0F5cG5hdHJkVDNWRGd2OXJTdTM5cTFBQUFBZ0YwazdBSmMxaWRLQUFEN3FkWjZsT1NlU3RDQjVRRExFTWphVHYrNTU4OS9OZExqcTVkQUFBQUFBSzdoQXlVQUxzbERBd0RZTTdYV1NacHBpenlNM1U0SDFwc3Q4cEhyTE43aWxSSUFBQUFBRituc3dpYnBGQUlBTUZKdHQ0SG5FUndBWUxOZUtBRUFBQUJ3a2JBTG0rUU5OZ0NBRWFxMXp0SjBkSm1xQnJCRFhpb0JBQUFBd0c0UWRnRUFBSDVTYTUybkNib0lKdE9IbFJLd1FjSXVBQUFBQUR2aUF5VUFBQUNTcE5aNmxHU3VFdlRvV3lWZ2czNmY4UVd1Qk1BQUFBQUFya0hZQlFBQTlseXRkWkxrU1pLWmFneW5sTExvZWJ2YW52QnovMUJLV1NvREFBQUF3UFl6alJHYjVBMDJBSUFOcTdWTzAweGJORk1OQnZDSkVnQUFBQUFBNnhKMllaTzBNQWNBMktCYTYwR1M1MGtPVklPQlRKU0FEZnBCQ1FBQUFBQjJnN0FMY0ZsTEpRQ0EzVkZybmFjSnVnZ2ZBUHRDMkFVQUFBQmdSd2k3QUpmMVJ5VUFnTjFRYTcyZjVFZ2xkdDdLZWdNN1FQY3hBQUFBNE04SXU3QkpDeVVBQUJoT3JYVlNhejFLY2s4MTlzS3A5V2FMbU9ZV0FBQUFnRXY3UUFuWUlHOWNicGVGRWdEQTlxcTFUcEk4alRmazJTejdINXYwb3hJQUFBQUE3QWFkWGRpWVVvbzNMcmVMY0JJQWJLbGE2MEdTNXhFMFlQTW1BeXpqbVRKdnBSY0RYSU8rMnNPNmZtYlhBZ0FBQUhhUnNBdWJ0bFNDN1NDY0JBRGJxZFo2bUthankxUTFHTWsrMlhmZ1JVaDdPNzFTQXRzT0FBQUE0TEtFWGRnMEFZcnRzRkFDQU5nK3RkWjVraWNacHBzR0kxTktHZXM1WE44ZGhseGp1RFo4RTRHTS9yellvdSs2dExrQUFBQmdOd2k3c0duZktzRlc4TUFBQUxaTXJmVW95WkZLTUVKOWg2K2N1MjZmbHdNczQwZmpiV3Y5ZFZjZlZFcFpHbTRBQUFDd0c0UmQyTFNGRW15Rlowb0FBTnVoMWpxcHRUNU5NbGNOTXM0cGZYcnQ3RkpLV1VYM2htMHpSRUJwWHp1N0hPekFPbnhvaUFBQUFBQVhDYnV3VVNOdXJjN1AyVTRBc0FWcXJkTWtUNVBNVklQV0dMdWMvTnI1S3hmODJ3REwrRUdaZTJGNktBQUFBR0FqaEYwWWc0VVNqTnBwKzNZc0FEQml0ZGFESk0rekcyL3hzOXVHMkVkTmw3cGwxeHdETEdQdlFobHRBTEp2TCt5K0FBQUF3Q1lJdXpBR1h5dkJxQzJVQUFER3JkWTZUeE4wbWFnR0Y0eHhPc29od2k0bk52M1dlSlZoQWhQNzJJRmt1aVByOGJGcld3QUFBT0FpWVJmR3dJM29jWHVzQkFBd1hyWFdoMG1PVklJdDIyOTdEYnlVVXBaSmxpcTlGYjRaWUJrL2xGSitWT3BldkJ4Z0dSOHFNd0FBQUhDUnNBc2IxOTZJUGxXSlVWcVdVbXdiQUJpaFd1dWsxbnFVNUk1cThBNkxrWDR2M1YwNE04U1VVNi8ydExhekFaYnh2K3pDQUFBQXdDWUl1ekFXdW9mWUxnREFKZFZhSjBtZUpwbXJCdSt4R3VuMytzeTVMSzBoT3J1OFV1YXQ5WEdIbitWRkRnQUFBTmdod2k2TWhiY3V4K2xZQ1FCZ1hOcnBYNzdMTUoweDJISWo3dEkzRzJqZGwvYUNVZnR0aGdtaXJQYTB2a09FeXZvK3huUTVoZEYvR0hJQUFBQ3dPNFJkR0lWMktpT0JsM0ZadE5zRkFCaUpXdXRobW80dUU5WGdDc1lZZUpuV1dxY0RMTWMxeHJqOXkwRFhtL3NhZHRtRjN4VWZHaVlBQUFEQW13aTdNQ1pmS1lIdEFRQzhXYTMxVHBJbkVYVGg2cFlqL1Y0ejU3Ujc3V1dHbWNKb3RjYzFIcUlEMkl1ZVA3L0xhWXdXaGgwQUFBRHNEbUVYUnFPVXNvZzI0Mk94TEtWNEN4WUFScUxXZXBUa29VcHdUZCtPOUh2MVBzVksyNmx3WVJjWXBmODUwSEsrMzlQZkc5T0JGdlhLcmd3QUFBQnNnckFMWS9OQUNXd0hBS0JSYTUzVVdwOG1tYXNHYTFpTTlIc2RPcmZkYS84ODBITDJ0YlBMZElCbHZCaGdHWjkwK0ZsTHd3NEFBQUIyaDdBTG8xSktPWTRiVUp1MmJMY0RBTEJCdGRhREpFOHp6RlF2N0xiVGtYNnZTYnVmOTMyTnNYQ05NVHEvelRBZFFYNG9wZXhyNTVFaGZuZHNWVzNiVGs4QUFBREFqaEIyWVl5OGVibFpkNVVBQURiclhORGxRRFZZVnlsbGxmR0dQYjV3amJHWEhnKzBuTy8zdU1hL0htQVpRMHlSMXRYdndaVmhCd0FBQUx0RjJJWFJhYnVLTEZSaUl4YWxsQk5sQUlETnFiWE9renhQTWxFTnVqelBHK24zR21RcUl4MGtSK1czU1Y0T3RLeVhlMXpuQS9YOW1WTkREd0FBQUhhTHNBdGo1YzNMemREVkJRQTJxTmI2TU1tUlN0Q0RiMGY2dmFaRFRHWFV1bTAzMkxoWEdhNnJ5ejVQWVpUc1J0aWx5M1hRMlFVQUFBQjJqTEFMbzFSS1dTUTVWb2xCUFNxbGVOc05BRGFnMWpxcHRSNGx1YU1hOUdReDR1LzI1WURYR0F1N3drYjlqd3pYRFdSdnB6Q3F0YzRHV3RTTG5qLy93dzQvNjF2RER3QUFBSGFMc0F0amRqZmV2aHJLTXJycEFNQkcxRm9uU1o0bW1hc0dmV2xEeldNOXR6NXN4OEZRMXhoc3hzc2svenpnOHY2MHg3VWVxcXRMMzUxelB1N3dzOXhiQUFBQWdCMGo3TUpvbFZKVzBXcDhLTGZiZWdNQUEycW5iL2t1d3p5WWhNVkl2OWNreWVGQTF4aW5FZkxlbEg5Sy8rR0lNNnRTeWc5N1hPdFBCbGpHRUIxNi9yckR6OUxGRkFBQUFIYU1zQXVqVmtvNWllbU0rdmFnYmVrT0FBeW8xanBQMDlGbG9ob001Tm1Jdjl1WEF5N3JVWnJPaGd6bm0vYlBVRjd1ZWIySENGQU9NUzNRUngxK2xqRVBBQUFBTzBiWWhXMXdOOTdDNnN1aWxISmZHUUJnV0xYV08wbU9JdWpDc0U1Ry9OME9hcTJ6SVJiVWRqUzhaWGNZektzay96amc4bjRvcGV4dDJLV2RFbXlJc011TEFaYnhjWWZqZm1rb0FnQUF3RzRSZG1IMHprMW5aSnFkYnJuSkR3QWJVR3M5U3ZKUUpkakFlZlV5NCs1dThNV0F0VENkMFhEK0ljTk5YNVRvNmpJYmFEbDloMTArN3ZDekZvWWhBQUFBN0I1aEY3WkNlelA2dGtwMFpwWGtaaHNrQWdBR1VHdWQxRnFmSjVtckJoczA1dTR1ODFycmRNQnJqUHZ4RUx4dmp6TnNsODRmay94cHoydisyUURMZUpYK1EwV21NQUlBQUFEZVNkaUZyVkZLT1luQVMxZHV0d0VpQUdBQXRkYURKRTh6ek5RUzhDNWZqL3o3M1J0NGViZmlRWGhmVHBNY0Q3ek1QNVZTZnR6enVzOEdXTVpXVFdHVTVJK0dJd0FBQU93ZVlSZTJTaW5sT01QZk1OMDF0OXZnRUFBd2dGcnJMSUl1ak9kOGVwRnhUdzg2ZEhlWHM2azlkVHpzMW9zMDB4Y05hZSs3dXRSYUp3UDlydmwyZ0dWODB1Rm5lZEVEQUFBQWRwQ3dDMXVubEhJN0FpL1hkYnNOREFFQUE2aTF6dE1FWFNhcXdZaU1QZmc4YUhjWFU2WjI3bFdTZjJ6L0hwS3VMc04wZFVtRzZlelM1VFJHd2k0QUFBQ3dnNFJkMkVvQ0w5Y2k2QUlBQTZxMVBreHlwQktNME5pbk1ocTB1MHQ3ZldISzFHNjhTbkkzdzRRaHp0djdyaTZ0endaYVR0L2hrUS9UWWRpbGxMSzBhd0FBQU1EdUVYWmhhd204WEltZ0N3QU1wTlk2cWJVK1NYSkhOUmpwZWZSSitzeGJ2Z0FBSUFCSlJFRlV4ajl0ejhNTjFPVTRBaS9yMkZUUUpkSFY1Y3poQU10NGtmNjc5blE1RmRQQ2JnRUFBQUM3U2RpRnJkWUdYdTZxeEZ1dGt0d1VkQUdBWWRSYUoybW1MVHBVRFVadTdPZUhoN1hXZzZFWEt2QnliWnNNdXZ3UVhWM1Nka09hRHJDb0lhWUUrbmpMdmk4QUFBQ3dBY0l1YkwxU3lxTTBONlJYcXZFenl6UkJsNFZTQUVELzJnZnozNlhiTjlLaEw0KzM0RHgySXcrcEJWNnViSk5CbHlSNW9hdExrdUZDbHQ4T3NJeFB0dXo3QWdBQUFCc2c3TUpPYUc5STMweHpZNXprSk1tbm0zcEFBQUQ3cHRZNlQ5UFJaYUlhYk1uNTgra0l6NTFYU2U2V1VtNXNPckI5THZBaVVQOXVtdzY2ckVvcDM5c01TWkl2QmxxT3ppNEFBQURBS0FpN3NEUGFHL2FmcGdsNjdMTzdwWlJicFJRMzVnRmdBTFhXTzBtT0l1akM5dmxxUk4vbFVaSWJiZGZHc1Z4ZkhLY0oxRHV2ZnJNWFNmN1BiQzdva2lSL3NCbCtta0x2WUtCdC9xcm5aWHljNU1PTzd4TUFBQUFBTzBqWWhaMVNTbG1WVW01bFA5L0NQRTNUemVXUlBRRUFobEZyUFVyeVVDWFlVc2NqK0E2TDloejI3aGpEMnUyRDhodlJIZUtpMzZicDZQSnFnOTloV1VyNXdhWklNdHdVUnY5Zmt0K2xDUmw5bjZTUDZhTzZETzBzN0JvQUFBQ3d1NFJkMkVudFc1ajcwdVZsbGVSQktjVzBSUUF3a0ZycnBOYjZQTWxjTmRqaWMrWlZOaGQ0V1NhNVZVcTVPZlp6MkRaUS8ybWE3alA3N2xXU2Yyei9iRExvOHFxVXNyUTVmdkw1UU10NVZrcjVvWlR5c3BUeSsxTEtOMG4rdFIzUFhZWFYvcnJENyt2NkdBQUFBSFpZVVFKMlhhMzFNTTBiMTlNZFhMMlROTk1XTFcxcEFCanMzT0lneVpNZFBiY1ltMFVwNWFZeTlMNC9QeDl3a2Fza1g1VlM3bTlwdldacHBpM2J4L0gvSXNrL0pIazVndS95cjZXVVYwYndUMU1ZL2ZzUXl5cWxsRXQ4bjc5TU02M2ZKTmVianVqL1NmSlJSMS81VmlubHhGNENBQUFBdTBsbkYzWmVLZVdrbEhJalRadnRYWm5hYUpIa1ppbmxscUFMQUF5bmZkRDlOSUl1N002NThtbUdtK3JqT00yVVJmZTN1RjZMTkIwazk2bkx5NnNrajVQOFh4bEgwT1dGb012UEREV0YwY2tseDhqM3BaUVhwWlIvVGZKTm1pbVBYaWE1ekpSVEg2VzdvRXVpc3dzQUFBRHNOR0VYOWtZcDVWR1NHMGtlWkh0REw0czBJWmViN1kxMkFHQWd0ZFo1bXFETFJEWFlNWThIT29lOXZRdEI3WFphbzd0SmJtYjNINlova3lia2NqeVM3L045S2VWUGh1elBmRG5RY3I2K3hsajVzWjN5NkErbGxOOGwrVjJhRGtIZkovbnhEVDl5ME9IM1hYb3hCQUFBQUhhYmFZellXKzBEcXkvVDdRMjF2aHluYWZmdXpUUUEyTnk1dzlNa001VVlsR21NaHR1L3YwdjNIWXVXU1I2VVVvNTN0R1lmSlBrLzBuVFcrQ0xkZHFUWXRCZEovaW5qQ3ZQOGtHYjZvaCtOMkovMndXbVM3d1phM0kydXd5UHRGRXpuLy96M0pIL1QxVFYwS2VXMnZRUUFBQUIyMXdkS3dMNXFiN29mMTFvUDBvUmVEak91TjdWUGszeVY1S1NVc3JMRkFBRG8wWU1rUngxLzNxTWRQNC85cXlTL1RQTGJOQjFRL2k3SjMyYTdReTh2MDNUNitlMEl2OXZ2QlYzK3pIeW9hOU0rdXFTMHg0ZFY4bE40ck1zWFVaN1pQUUFBQUdDMzZld0M1OVJhRDVOOGxpYjRNdDNBVjFpa2FROTlvdVV5QUl6dVBFRm5sdzJjRytuc010aitQVW5USVdMZDhQZEprcnU3Zmk1YmEvMWxtcTR1YjNxQjVEZlp2azR2cDJsQ0xtUHRKUG1IVXNwTEkvWFA5c00rT2pLOXlkMTJXdUErMStVZ3lmTU9QL0pUblZFQkFBQmd0K25zQXVlVVVrN1MzcUJ2VzBMUDBvUmZEdEw5ZEVlck5EZVRuNlY1a0xPd0JRQUEyTkI1OEtyVytsV1NlOWY4aU5NMEQ4VDM1WngyK283cjZkKzJmdzdTZEhyNXpValg0Vlg3UGY5SG1vNHVZL1VuUVpjLzE3Nm9NUjFvY1NjRExHUFc1Ylcyb0FzQUFBRHNQcDFkNEFyYXQ4MG1lWDBqN3BOYzd1M1gweVQva1dUWi9qazFOUkVBYk4xNWdNNHV3OVBaWmRoOS9EcmRYVlpwUWk3SGUxYW5xd1RoUDB6eU4wbithL3YzSnIxS00rWFN2N1IvajkzTFVzb2ZqTTQzN29kUDBuUWs3ZHRwS2VYVExmc2RlMXhLdVcwdkFRQUFnTjJtc3d0Y3dibTN3eGFxQVFEQWpwM3JYclc3eTZNa0QvWXd4UDN4RmYvN3N3NHF2MjMvLzkra0NjMGZYT096cnVNMHliZHB3aTB2dHFqT3I3YnMrdzZtN1VKNk9ORGlIZyt3UHVkZktPbkNNM3NKQUFBQTdENWhGd0FBQUpJa3BaVDd0ZFl2OHU3cFVSWkpicGRTbHZ0V24xcnJSMms2dGF6am0veThxOHBaNk9VL3QzOS8xUDY1cWhkcEFpTGZwcG1XNkVXMk55enlLazFIa1IrTnlqZWFEN2lzSWFZdzZqcTRzN0NMQUFBQXdPNFRkZ0VBQU9DOEIwbU8zdkRQbDJsQ0xvdDlMRXF0OVlQMDA0bmx0UDN6SnUrYkxta1h1NThJdXJ6Zmx3TXQ1M1NnVU50bkhYN1djaCtEZUFBQUFMQ1BoRjBBQUFENFNTbmx1Tlo2TDYrN3U2eVNmRlZLdWIvbnBmbXJEVnhEbis1WmpRVmQzcVBXT2s4eUdXaHhqd2RhVHBlZFhVN3NKUUFBQUxBZmZxRUVBQUFBWEhDNy9mczR5WTE5RDdyVVduK1pkMC90eFBvRVhTN255d0dYZFR6QTJEcE10K0dkWjNZUkFBQUEyQTg2dXdBQUFQQXpwWlJGcmZXRzZVQis4ckVTOUVyUTVSSnFyYk84ZjJxcnJweVVVbFlETE9mempvOWRPcnNBQUFEQW5oQjJBUUFBNE04SXVqUnFyWk1rZjZrU3ZWa2wrYjJneTZYY0czQlpwakFDQUFBQVJrM1lCUUFBQU43dXZ5aEJiMTZXVXY2Z0RPL1hkbldaRGJTNDVSQWRVbnFZd3VocmV3b0FBQURzRDJFWEFBQUFlSU5hNjE4bCthVks5T0pGS2VWUHluQnBYdzY0cktHNnVuemU4ZWN0N0NZQUFBQ3dQNFJkQUFBQTRJSmE2d2RKcGlyUnVSL1RURnUwVW9wTDc0dlRkRHZkei9zY0Q3U2NMdGZwMU5SckFBQUFzRitFWFFBQUFPRFBUVjB6ZCs1Vm1xRExEMHB4SlE4SFhOYkpFS0dSSHFZd2VtdzNBUUFBZ1AzaXhoMEFBQUNjVTJ2OVpaSy9Vb2xPL2FtVThrSVpycnd2empKc1Y1ZXZCbHBPMTFNWW5kaGJBQUFBWUw4SXV3QUFBTURQL1JjbDZNd1BTZjVnMnFKcnV6ZmdzcGFsbEVYZkM2bTFUcExNTy94SVV4Z0JBQURBSGhKMkFRQUFnRmF0OVMvVDdmUXErK3hsa2hlbGxCK1Y0bHI3NGl6SmJNQkZQaGhvT1YxM3FqR0ZFUUFBQU93aFlSY0FBQUI0N1dNbFdKdHVMdDBZc3F2TEtzTk5CZlJseDU5bkNpTUFBQURZUThJdUFBQUFrS1RXT2szeVM1Vll5ekxKbjNSeldYdGZuR2ZZcmk1ZkRSRk9hc2ZZUVljZmFRb2pBQUFBMkZQQ0xnQUFBTkJZdFg5TVkzUjEzNmVac3VnSHBWaFByWFdTWWJ1NkpNbWpnWmJUZFZjWFV4Z0JBQURBbmhKMkFRQUFnQ1J0WjR2VFd1dEhTYWJSNWVVeVZrbVdwaXpxMU5CaHErTUJ0OSs4NDg4emhSRUFBQURzcVY4b0FRQUFBTHhXU25sWlN2bGRrajhrMGFua3pWWnBwcEE1RlhUcGZQOWJKdmsweVlPMnpuMTdNTVI2dFZNemRSbmtXWmpDQ0FBQUFQYVhzQXNBQUFDOHdZWFF5eXNWU1NMa010Uyt0eXFsM0U4VGV1bXplOG54Z0lHUkx6citQRk1ZQVFBQXdCNHJTZ0FBQU85WGEzMmFaS1lTZzFxVVVtNHFBeU02RGt5U2ZOVCsyU2MvSnZrK3pYUkZPdDFzWnQrYkpYbVk1S0Rqajc0eFJOaWwxanBOOGwySEg3bHF2N3ZBRlFBQUFPeXBENVFBQUFBQTNxOTlzTDZxdFM3ek92VHl5eDFlNVZkSi9wVGsrMUxLai9hQWplNTdpeVNmdGxNQlBVdzMwd0VOMmRYbFhzZWZkeUxvQWdBQUFQdE5aeGNBQUxnRW5WMDJRbWNYdHVIWThHR2EwTXRmWmplQ0x6OGtlWm5rcFM0dW85M25Ka251WlAwQXlWQmRYU1pwdXJwTU92elltMjBBQ0FBQUFOaFRPcnNBQUFEQU5aVlNYaVY1a2VURnVlRExKTW1IVzdRYXF6VFRGSDB2NExJVis5d3F5ZjFhNjNHU28xd3ZpRGxrVjVjNzZUYm9zaFIwQVFBQUFJUmRBQUFBb0FQbmdpK3B0ZjR5elFQK3MrRExtTUl2cXpSVEZLMlNyRXhSdExYNzJ6TEp6VnJyTEUzb1pYcUZIMzh3NEZmOW91UFArOHJXQndBQUFJUmRBQUFBb0dOdGg1U1g3Wi9VV2o5SUUzaVpwSm51NkN3TTA3ZFZtcW1KWGlWNTFYWUZZYmYydFVXU0c3WFdzNm1OM3JkZlBSaXFxMHV0ZFo2cmhYQXU0OWhXQndBQUFJb1NBQURBKzlWYW4rWjZVMFZ3Zll0U3lrMWxZTWVQTFdmQmw3TXdUUEk2REhOWnI1S2NkV2M1QzdPODByRmxML2VuU1pLSFNlWnYrVTlXU1c0TUZYcXF0WDZYYnNNdXg2V1UyN1kwQUFBQW9MTUxBQUFBYkVqYkFlYUg5djkrcnlLc3VUK3RrdHl1dFg2Vkp2UXl1L0NmZkRWZzBHV1c3cnU2UExhVkFRQUFnQ1Q1aFJJQUFBQUE3STVTeW1uYkdldFdrbVg3ajVlbGxQc0RmbzE3SFgvZWFUdGxFd0FBQUlET0xnQUFBQUM3cUpSeWt1U2sxbm8veWVsUXkyMjd1c3c2L3RpdmJGRUFBQURnakxBTEFBQUF3QTRidUtOTDBuMVhsMVVwNWRpV0JBQUFBTTZZeGdnQUFBQ0FUdWpxQWdBQUFBeEIyQVVBQUFDQXJ0enI0VE1mS1NzQUFBQnduckFMQUFBQUFHdnJxYXZMY1NsbHBib0FBQURBZVI4b0FRQmNYWHNqLzh4QmtzbUYvK1N6amhlNVRQTEhDLzlzY2Y3ZmwxS1d0Z3dBQUJ2VVIxZVhCOG9LQUFBQVhDVHNBZ0RuMUZxblNjNy8rWXMwWVphays3ZFUxM1h2d25jLys1K25TVmJ0bjIvYnYwK1RyRW9wcDdZeUFBQTluRWZQMGs5WGw2WHFBZ0FBQUJjSnV3Q3dkMnF0a3pRQmxvTWt2MjcvbnJaL2RzSEJ1Zjk5ZUdIZGs5ZmhsMldhYmpHTDZBd0RBTUI2K3VqcThsaFpBUUFBZ0RjUmRnRmdwOVZhejBJdG4rUjF3R1d5NTJXWjVPZHYzZDVyYTVXMHdaYzBIV0ZPU3lrTGV4RUFBTzg1NTU2bis2NHVDK2VpQUFBQXdOc0l1d0N3TTlvcGlHWjVIV3lacWNxVnpTN1VOR202d0p3bWVaWW1BR01xSkFBQXp1dWpxOHNEWlFVQUFBRGVSdGdGZ0szVmRtMlpKZm1zL1h1aUtyMDQ2NGd6Yit1K1N0TUI1bG1hTjI2Rlh3QUE5dmVjL0g2Nm53NVVWeGNBQUFEZ25ZUmRBTmdhNXpxM2ZCN2hsazJhSkRscy81eUZYMDd5T3Z5eVZDSUFnTDA0UDU4aytiS0hqOWJWQllCTi80NmJwZ2x6enRKTTk3d1V4QVFBR0JkaEY4WjhRWEVRRDdLSHROS2RnWkVlQzJacHdpMkg2ZjZOVWJveFNkUDFaZDV1czlNMG5WOGVPNjRBTUxMemlrbWFibVVNWnlrSXU5UHU5WERkdnJHdUxoMGNJMDVMS1N1N0JjQldueThldHIvZkR0N3c3ODVlOXJucmVNOGVqNUhaZFg5V1lBeUFyaFVsWU1RblRVL1RKT2NaeHFLVWNsTVpHTW40UDh6cmdJdlEyM1picHUzNlVrbzVVWTY5R2NQMzA5d2NCRGJ2UVNubHZqTDhkSHlhSlhtcUV2WkJPaGxQQjBtZTkvRFJOemNZZGxuM0dISFRReHlBcmYyOU5rbHlsTGFMN1h1c2t0eDJuNE05SFN2MXVqOWJTdkZNRW9CTy9VSUpBQmpKaGRKaHJmVkplOEgwSkUyWEVFR1g3VGROY2lmSmsxcnJ2OWRhSDdZUFJnQUEyRzRQZS9qTWhiQUlsN2gybktvQ0dQYzllSkxMQlYyUzVuN1ZrL1psTFFBQU5rVFlCWUNOcWJYT2FxMUh0ZFovejlWdUtyQ2RKbW1DTDg5cnJkL1ZXdSs3VVEwQXNKWG44WWZwcHhQclhkWGxQZnZlL1RTZEY0RDkrcDN6dk9kbDNML203N1VqOXpVQUFEWkgyQVdBUWRWYXAyM0k0YnMwTGNMbjBjRmxIMDNUVEhQelhhMzFhYTExcmlRQUFGdHhQajlKUDExZGprc3BweXJNMi9hN1d1dFJUSlVKK3piMjc2UjVPV3JTNHpJbVNiNjg1bzlQSEpjQUFEWkgyQVdBUVp4TlU1VGt1L1pHd0ZSVmFNM1N2QTMxNzdxOUFBQ01YbC9uOGcrVWxyZGNTMDd5K2tVSllIL0cvbEg2Q1ZkZU5NOTZZUnBkaWdFQU5rVFlCWURldEcvZm5YVnhNVTBSNzNQMlJ0UjM3ZlJXTXlVQkFCalYrZjFCbW1rcHUvYW9sTEpVWWQ2eXp6MVBjcUFhc0RmamZsSnJIVExnOXRtYVB6OXgvd0lBWURPRVhRRG9YRHRWMFZGMGNlSDY1a21ldGxNY0NVa0JBSXpEVVErZnVZcXVMcno1dXZJd1RVY1gxNU93UCtQK29CMzNzd0VYMjhVVVNRSjVBQUFiSU93Q1FHZHFyYk56SVpkNWVweFRtYjB4Uy9LazF2cGRyWFd1SEFBQUd6dlh2NU4rSHVaOVZVcFpxVEJ2Mk4rZXVLYUV2UnIzc3pSQmwyME1qamhXQVFCc2dMQUxBR3RyUXk1UFl4NTErak5OY2lUMEFnQ3drZlA5YVpxT2pWMWJsbEx1cXpBWDlyZWpKQTlWQXZacTNNL1QzRlBhMXRESXFhMElBREE4WVJjQXJ1MUN5R1dtSWd4Z210ZWhGL3NjQU1Bd2p0TFBBOGk3U3N1NTY4dEplMzA1VnczWXE3SC9NUDFNazNkWnB5UDVEQUFBcmtqWUJZQXJxN1ZPaFZ6WXNHbVNwN1hXcDBJdkFBQzludnZmNmVtY2YxRktPVkZoMnYzc3dQVWw3TjI0bjlSYW55UzVzK0d2OHZXYVAzOWFTbG5hb2dBQXd4TjJBZURTMnBETFVaTHY0aVlrNHpCTEUzbzVhdHZyQXdEUTRmbC8rcG0rS0VsdXF6RHRmbllXZERsUURkaWJjVDlweC8zaHByOUxLV1dSWkxIR1J6eXdSUUVBTmtQWUJZRDNhdCsydVova2ViU1VacHptU1o2Myt5a0FBTjNvYS9xaUI5NkNwNzNXbkxmWG1SUFZnTDBaOXdkcFhxSWFVOER0YnBMVk5YN3VXSmN5QUlETkVYWUI0SjFxcllkcGJqN2VpeHVRak5za3liMWE2M2VtTmdJQVdQczY0SDc2NmVhNFRQSkloYW0xUGt3VHFBTDJaOXpQMDNSMEdkWDlwVkxLYWE0ZWVGbTBQd01Bd0lZSXV3RHdSdTJVUlUrVFBFa3lWUkcyeURTdnB6WVMwQUlBdVBxMXdFSDZtNzdvYmlsbHBjcDd2NC9Oa3R4UkNkZzdmWFVNVzFzcDVUakp6YngvU3FOVm1nNWxOLzArQXdEWXJBK1VBSUNMMnJjNHY0eE9MbXkzZVpMRFd1dHRiWVVCQUM1OUxUQkpmOTAyVHB5WEFUQldiWWVYbTIwZzcvUDhmS3FsVlpKbmFhWXVFbklCQUJnQllSY0FmdEsrd1htVWNjMmJET3VZSkhsU2F6MUpjdHNOS1FDQTkzclkwL1hBS3FaN0FHQUxsRklXZVgrSEZ3QUFOc3cwUmdBaythbWJ5L01JdXJDYkRwTThiOS9PQWdEZ3pkY0VoMm02NC9YaFFTbGxxY29BQUFCQUY0UmRBUFpjcmZXZzF2bzh5VDNWWU1kTmt6eHRnMTBBQVB6OHVtQ2EvcVl2V3BSU0hxa3lBQUFBMEJWaEY0QTlWbXVkSjNrYTNWellML2RxcmMvYkJ6b0FBRFNlcEprQ3NnK21Md0lBQUFBNjlZRVNBT3lmV3Vza3pWdWJoNnJCbmpwSU02M1JyWFl1YmdDQWZiNCtPRXAvQWZnSHBaUlRWZDdJTmQrczNhNmY1TStEVE1za2YweHltdVRVRkZPZDF2NmdyZnMweWEvYnZ5ODZUZklmdTFiL2RyODdmeXhaalczOHQ5dG4xbTZiTngzM25pVlp0ZHRsc1FVMW43YnJjWkRrTDk1eExEKy96eTBkbDNmcWVITzJEN3p0ZUhOMnZGKzIrL1hwanRWZ2RtNU1YMXovVlpKdnQybmRML3dPZWRlWWZ0Yit2V2pIdE4vakFPd2xZUmVBL2J3UWZ2S1dDMkRZSjVNMDB4cmQxVllmQU5qajY0TjVrbmxQSDM5YVNybXZ5cGZhQnRlNVBsdVdVbzR2Zk5aaGtpOXl4UmNiYXEzTEpDZEp2dXJpZ2RrbDF1blhhM3o4OUJwVGt4NzMrU0N3cmZ2bmJkMHYweUZwOW9iNkw1SThIaUpnc2NiVXJtL2I1OTY2N3JYV3RPdjJkYnNkVnBmOGp0TTFqazAvMjk3blB1dUxTNHkxMllYdmZwTGs2NHZyUFlKanhtZFgyTi9ldE0rdHptMlhrOHR1bC9kOHI5bkY1V3g0djExY2RqeXRjUnp1L2ZoeTRYdE8ydTMrZVZ2cnlUVStvL050My9mK2NmRmNvcjIzK2VVbHg4RGhoWFUvR2VwWWU0MXRlcFhmM1dlMXZIZmg5OGpYcFpRVFoxY0E3SXVpQkl4VnJmVnBueGRJdlBFQzhLWXk3UHk0bWlkNW1QN2FrOE8yT2s1eWQ2aWJQSHR3ckxtZjlvWUxzSEVQUEdqKzJmRnBsbVlLUit5RDVLZUhSVTk3dWo1WUpmbDBtOTQwN3VBWWNmTTZEOC9XdVAveDAzVjgrOTJQMHMxTERZdDI3QzdXcU9YWTd1bmM3UHJCWnZ1QThrNmFCNjVkanFGbGtxOXloV0RJTmI1N3ZlNitzZVkrdDJyWDdkSDcxbTNOOFhpemxMSm90OUc5ZGp0MWNVeTcxSGZ2YVp0TjIzMXQzc014ZTlWZUU2OFZkaHZoZGVDbHowSFdQR2JkN0RzNGNTN2NNZS9oNDgrQ2puMnZ3N1gzajFKS09UY09IcWFiVHRYTGRoODUzdUE1eHhjOWJkTmxrc2Q5SGEvVytCM3kwN1lFZ0s3OFFna0E5a090OVdHYUcxR0NMdkRuNW1tNnZCZ2ZBTUMrWEI5TTBuUjg3T3Y4NTRHVytzTnN4L1phNzJtNjY5NDVhOCtOSHpvL2Ztdk43eWY1THMyRDI2NXJORTN6TVBkNSs4TEtXTzh2WEdlZk93dWZQRzBmM3ZmNUhXZEpucWVib012NTcvNjgvZXloeC9oMzdicjBNU2JQZ2x2ZnJkSDFoMzYyLzdRTjRqeFBmMTNZRHRzeCtYVElmZnNhdFppM2RlaHFTdlpwa3FOMnZhY0RiOU1uN1RHMHIyMDZiWTlYMzQzMTl3Z0FkRVhZQldEM0w0d243WVh4SGRXQWR6cEljK1B5UUNrQWdEM1E1OVNtQzlORURtS1M1bUZaWDlkNmR6SkFLR0hMcnE5bmFSNjI5aEZ5dVdpYTF3OWlKeU9xd1ZFSCs5eFpWNm0rZkpGdUEyQVh0OHZUSVVJaFBRUjJMdU5lcmRWMThlYkgyZm1RMDJ5Z3hjN2FmZnRvYkVISDlyalQxd3Q4c3d3VUxxeTEza20zZ1ozTG5DY2MxVnFmQ0s4Q3NLdUVYUUIyKytMNDdBYlNURFhnVXFaeFF4OEEyUDNyaEljOVhpT3NrdHhTNVVFY3RILzZYb2J6NC93MEJVZGZBWXAzbWFWNU8zOE0yMkNXN2pvUjlQbmdkVDVBTGU2MUQrRDcydC9tRzlyZmpQdk5IMnZPN3VWdDZxVzFlWHZNbVkyb0xIMlA2Yk5ReUx6SDdYcVV6VTB0ZjlhOVoycUVBYkJyaEYwQWR2L2kyTTBKdUpwSmV4TmdyaFFBd0E1ZUo4elQ3d08wMjZXVWxVcnY1UG54d1I2UG02TTAzVncydVEyZXUwWVpuWGtmZ1pkMk94K05ZTnpyOExLWjM5Rmp1SmUzci9kRmVnbTh0TWVKVGRmeXJKdXhEaThBN0JSaEY0RGR2amgyQVFQWDAvdGJQUUFBRzdoT21LWGZCNmlQU2lrbktyMno1OGQ3T1EzQ1NCNVNubkdOTWo3ekxyZkpTSUl1NStud010eXg1bXpiaitrNGU5Um5CNk9ST3VweW54L1o3NUN6RUpQN3hRRHNER0VYQUJmSHdOdTVtUXdBN01wMXdrR1NKejB1NGpUSkE1WGVhZE0wVXpEczA3Z1owMFBLODljb3dnZmo4ckNMNlVIYTdUcTJZTUZraE45cEY0ODE4eEhYZWI2SGdaZE93cDIxMWpzai9CMXlrTTEyS2dPQVRnbTdBTGc0QnQ1TjRBVUEyUGJyaExPSGxYMEY0bGN4ZmRHK21MY2RndlpoM056UCtCNVNudkZtL3JoMEZRaDVNdEwxTzJqSEEvMGNhdzR6L250NTh6MjdMekxObWxNK3RnRzRzUVpFNyt6TDczSUFkcCt3QzhEdVhCelBJK2dDZlJGNEFRQzI5VHBoa21hSzB6NDdRZHd0cFp5cTl0NjR0d2ZqWmpieTlaeGt2TUdJZlRWYjUrRnhHeWFaam5qOXZoU3c2dVZZTThadVBtOXp0R2NCaVhYMytiRnZWOTFkQU5nSndpNEF1M0Z4L0RDQ0x0QTNnUmNBWUJzOVRMOUJsK05TeXJFeTc1WFpMai93YkI5dVB0bVM3ZUQ2WkZ6dXJiSFBmVG55ZFp0a3pVNFh2TkcyVFVQK1pJOUNUOWZlNTl2ZmtXUC9QVG5UM1FXQVhTRHNBckRsMnB0YmJqakFNSTdhRnNNQUFOdHdyWENVZnFkaE9VMXlWNlgzMGhjN3ZHNzNzajBQbngvcXRqRXFzM2Jxa3FzNjNKSjk3Z3VidU5QZjBmZlRieGkxRDVPTWQycWVNZTN6MnpKV3ZqUVNBZGgySHlnQndGWmZHTStqb3dzTTdhald1dFNxSHdBWStiWEN3L1FiZEZrbHVWVktXYW4yWGpwTWNuc0h4ODAwM2I1TWNwcms2L1ovTDlOTVUvTVhhZDc0NytJaDkxbm5nZnQyeVZHTmpVZFgvSmt1SGppdmtwd2tlZGJ1YStjZEpQa2s2NGRxcHJYV1dTbGxZVE4zY3F6WjFxREJ2TmI2ZUUvMmd5dnY4MjBBc1l2enIrVzVNWDN4WEd0MmJreXZkYnlxdFU2Y3l3R3d6WVJkQUxiM3duZ2VRUmZZaEVtU3A3WFdtd0l2QU1DSXJ4WDY3djU0dTVTeVZPMVJPazN5dVAxN1dVcFp0bE1WVE5POGJUN3I0cHk0MW5wWVNqblpzZHJkNitoekhxU1o0bXY1am5FNmJaYzNYM05aWDBiWTVUTE93aUJmSjFtVlVoYnROcGdtK2J6ZERsMTBWL2tpVndpN3RBL0dEenJZM3g2OTQ0SDFvbDNXM1RSZE9kYlo1ejQvK3p6V1B0WjAyYzFuMlc2WGkyR25hVjZISXFZZGYvOU43d2ZMQzJQNnROWjZjR0ZNZCtHcSsveTZ2Mk5YU2U2K1o0ckl4Ym5mSTAvV1BJYk0yam9Dd0ZZU2RnSFlRb0l1c0hHVE5ITlZmK29OR0FCZ0Q2OFZIdXhneUdFWG5IWGJXVno4RitmKzJYRWJmRG5LK2c4K1A4dmJINURkemJzZjVCN2srbE5oWEdmNnJOTkxqSjFwMW44NGVwb21DUGJlNWJWQm1OdTExc2RwSGxaZTk4SDNwTlk2ZjgrRDBiNmREMWdscjd2WVROdjlaSlp1SDdSZjFYR2FoOGVyTjJ5RFpaSkZyZlZCbWdmNDZ3WUZENjdZS1dHMjV2SSt2ZXhMR08xM3VsMXJ6UnI3K3NGNzZyeDR6ODgvWFdOZGIxN3h2MStPOVBkMEY4ZWE4K3Y0NEJMai8yNTc3TCtYYmdLUHN3MTMrYmxiU25uMGhuMzh0RDBPbmJSaitxaUQ5YjNxejMrMjV2YThlZGt3Y1J0bXZkbU9xK3NHWHQ3MXV4d0FSay9ZQldETHRHOHBDTHJBNWszVDNGRDRWQ2tBZ0pGY0s4d0h1Rlk0S2FYY1YrM1JXU1c1Y1prSDdHMUhpMCtUUE05NkFZU0RkeXpqOUQzNzZscnIydE1EMW5Xbmd6aE44NUR5U21INGRudWNQYXk4YnVEbDh6UkJnNkdkcG5uby9LYnRzV3ovUG02MytXR2FMalN6Z2Ivakd4K0t2MkU3ck5JRUF2Nlk2d2V4em8rTnhicmo2SkxyZHAxdW8zZHovYkRGN0IwMVhPWTlBWk4xeHY0T1Rac3o3K2h6SHBWUzdsNnhmb3RhNjUwTzl2R2s2V0swaVcxeTZ6S0IyM1ovdkZscmZiTG04ZjJnNS8vKzRyb3Ryemd1Vm0zWHBxY0RyUjhBak1vdmxBQmdlN1JCbDZjcUFhTnhVR3NWUGdNQXhuQ3RNRS8vUVpmVEpMZFZlNVN1RkxJNDYvQ3c1akpuTzFiREw5ZjQyVld1RVhRNXR6MnUwNjNtdk1OMk9wd2hIWmRTUHIxc0FLR1VjbEpLdWRtdTUxRGRNVTh1RTNTNThEMGZaZjBIK0ZkNWVIemRMaENycTY3YmhmRi83WFZzTzVOd2ZWOTA4Qm0zcnhKMGVjTSszc1h2OHZrR2pqdlg2U3gzTzJ0MitXbTc0dlF4L2k4ZXIwNnZ1VTNYT1dZWnp3QnNOV0VYZ0MzUlhrQ3UwOW9ZNk1lOGZUTUtBR0JUMXdyejlCOTBPWnNpeHhTTzQzTjhuUWRrN2NPeFkrWDc2ZUg5ZEkyUHVMdnUyR2luSVZtdThSR0hBNVpzVVVxNWZjMzFmSlNtTyticEFOL3p1Z0dpZFlNQVE5eTNPZG5nZDV3NmFsejdXSFBRUWYwZXJEdHRXZnZ6WFFSZWhqenVMSy9UV2E0OU5qOFljTHhjZDJ3OTI5QnVhVHdEc05WTVl3U3dQWjY2QUlIUmVsaHJYVnozTFJ3QWdEVjlPY0F5Ymw2MXRUNkQrV3FObi8wNmEweXBVV3VkN2NqVUl1czhzRjJ0KytENW5NZEo3bDN6WnovTGNPR2x0UjZTdDhlU3ZxZURQYjd1TWF1VXNxeTFudWI2SFJxdTBxM2xicTczY0h5NXhyZzlpS2xMdHZGWWt5U25YVTBsV0VvNXJyVit2dVozR3ZLNHM4N3Z1cE0wVXpkZE40aHlrTXNIekc1ZWQ5dXVNYWE5Z0FYQTNoSjJBZGdDN1RRcGJrVEF1RDJ0dGQ3d3RqTUFzQUUzMDRUais3cG11QzNVTzFyTGRiWk5LZVdrMXFxSzE1OUtKa2xPcnpqRnhidXNjeTB4RzZoV3gxc1NmUHU2ZzUvdi9UN01rTWZXdG1Qd1BOY1BWTEhaWTAyeTNuUm5iL3U4ZGNJdXN3RnJkN0xHT0Z2VldoY1pvQlBOa0FIUXRpdVpNUTNBWGhOMkFSaTV0aVg1WENWZzlNNm1HcnVwRkFEQWtOcUhPSDBGWGg1MDJMV0M3cDEwOEJtTERQdkFjb3pXR1RlemtkUnZPdEJ5dnQ2U2Jicm80T2UzOWdGeUcydzVhSzlURDlLRUxQWjluSS9CT3R0ZzBYV1FvdTFpZEp6cjMzZWMxbHFuQXdUZ1RqdFl4cmNaZHRxbHJzZjB0RDNPbi8zcGJFenZVSmMyQVBhUXNBdkF1QzlrRHBJY3FRUnNqVm10OVg1WGJZVUJBQzZycDhETHNmT2EwZnUyZzg5WUt1TnVUQmxZeUlTUUFBQWdBRWxFUVZRODBBUExiZWp5dE95ZzQrWnF4TnY1YkJxaWFaSmZuOXQvSjlFVk9DUGZidXQ0M05OWFcyczZ1M2IvNi92M3lISWtuOUhic1R1dncybWY1UFYwUzlPWTBoNEEza25ZQldDOEZ6cG5YU0tBN1hLdjFucWkxVDhBTUxTT0F5K0xVc3B0VlIyOVpRZWY4Y2M5di9ZV0RyamFjV2E1RCtPaWxISTZsaW0rMm80T2gwaytqKzRzMjJ5eTd1L2xuc2IwdXRQWkhmVDEzYzdacVdCbiszdm5pM1k4K3gwRUFHdjRoUklBak5aUnBQZGhXejFwQTJzQUFJTnF1eG5jekhyZEYwNlQzRkxOcmJCU2dyWHQwbm43ek9iY25YRlJhNTNYV3A4bStTN0pROXQzNjAzWDJhZDdEcG90SEVON0g4K1RXdXVkV3V0M1NaNG51Uk5CRndCWW03QUx3RGd2Z081a2krZVJCVExORnMvdkRnQnN0elVETDZkSmJuWXdCUWpEYkd2ZEJPSFBmYnZOWDc3V09tc2ZpQjlGd0dYWDdoTmMxNzRmNnhkYlBxYm5lUjFhbXhvS0FOQWRZUmVBOFYwQUhiUVhQOEIydTlQT3V3d0FNTGhyQmw1V1NXNEp1Z0JzUnEzMVlacXA2S2Fxd1lBRUovc1p6NU8yTzlOUmRNQUJnRjRJdXdDTXo1RVN3TzZNWjlNWkFRQ2Jjc1hBeXlwTlI1ZWx5Z0VNcTMwb2ZqYTFDUXpOZll2dXgvUkJtbTR1TTlVQWdQNEl1d0NNNjBMb2ZzelhDcnRrR2pjckFZQU51bVRnNVN6bzRzMXVnTTE0R3ZlRGVMdSt3eWhUSmU1T3JYWGFqbWtoSWdEb21iQUx3SGd1aEE2UzNGTUoyRG4zMnZFTkFMQVI3d204Q0xvQWJGQTdkWkZyeHQyM3p1L1p2dmVQcWMzVHFTY1JkQUdBUVFpN0FJeUg2WXRnZHoxVUFnQmdrOTRTZUJGMEFkaWdXdXNzdzNZRFhTWTVUbktpK29OYnJibXZIUFMwRDA2eVh0aGxhZFArcko3M00yeDQ3VFRKbzZ3WHBnS0FyZldCRWdEczVZVVFNS3haclhWZVNqbFdDZ0JnVTBvcHExcnJ6YnllTHVPdW9BdkdSVm5VV3EvNzQ4dFN5ZzFWWkExZGQvaGQ1blg0WUpYazIvWi9MNUtjdHNISHMvdFFoOG8vcUhWLzMzNlJmZ0lOaHgzc2M3ejJaUS83emVwY3JmL1kvdi9UQzJQNnFkSURzSStFWFFBMnJKM0g5VXVWZ0oxM3I5WjZjbllqQWdCZ0U4NEZYbWFsRkcvMlEyT1Y2MDA1TWEyMUhnaU5jUjN0L2FCWkIvdnVjWkt2U3lrTFZSMzk3OS9ySG11U0pwUnl0NGV2OXNXYTYyVy9lejJtNTFsLytxSmxtczVMai8xdUFZRDNNNDBSd09ZOWpIbGNZUjlNTTJ4N2FnQ0FOeXFsckFSZDRHZldlYURvNVJXdWE5Mk9HaWRKYnBSUzdsNGpjUENKOG0vRVlvMmZuYlpoaXM2MDAyak5OblRzM0VXZnJmbnpEMG9wWjJQNnFyV2RLajhBKzBqWUJXQ0Qyb3RLYldOaGYzelp6b2NOQUFCY3o3U0h6M3kyeHMvTzJ3NGRjRlhyQkU0V3BaUmJhM1FPM2JwOWRrZkcyYk0xZi81aFYvY1Uyczg1V3ZOakZvYnh6OHpXK05rSHBaVDdhMnhMdjRjQTJFdW1NUUxZckNNbGdMMHlTZFBONmJaU0FBREF0VXhycmJPT3A4NDRTWEp2alo5L2t1VFRkYjVBKzdCeXJVNlExMzFReXViMjVUVis5dTRhKzlvMHljRVcxbXVlWk52MzhaUDJuc0IxVFpJOFhmZDQwM3FZOVFNU3p3emp6c2Iwb3pWKzFvdVVBT3d0WVJlQURhbTEzb25VUGV5amVhMzFRU2xscVJRQUFPeXAxWm8vZnk4ZGRoUW9wWnpXV3BkclhLTWYxRnFQU2lucmhOcVBzdDREeTlOc2Z4Q0FLK3l6YTQ2ZmJmUmxyZlhSR3Qxc3hyRGRsclhXMDZ3WE5qcW90UjRsdVh2ZFdyUS9QMTl6ZFphbVJPek1ZczM5K3A0U0FyQ3ZUR01Fc0FIdEcxc3VSR0IvR2Y4QUFPeXROUi9VSjhtczF2cmtmZE9hMUZvUDI0ZTZsL0Y0emU4MHI3VSt2YzVVSysxM1hQZk4vTWYyclAxeDNTbDkydW0wNXh2ODZvczFmbmFTNUdtN0R1OWF4NE5hNjhOYTYxaTcxM3pWd1dmTTIxb2NYSFcvcWJVKzdXZ2ZjTXpwenNFYXh3SXZVd0t3MTNSMkFkaU1PKzFGT3JDZmRIY0JBSUQxSENZNXJMVXU4dWRUYVh5VzV1SGgyWFgzWlRxdUhHZjlVUG9zeWZOYTYxZEozdHVCb24xby96RGRUQ2x6YkpmWXIydktYTEdUVHh1TWVMTGw2MzJRSnVSeG1pWTQ4eC9uL3QwbjdiK2Z0di8vNjVHdXc5bFVScE1PYXZHODFucWM1S3QzaFFqYmJmOWx1ZzA2T2VaMFozS2Q2ZmxxcmZPc055MFdBR3c5WVJlQWdiVmRYYjVVQ2RoNzkzSzVtKzRBQUxDTEZtbkNJZXVhZGZFNTdmUWl4MW4vWWZCWko5ZDc1NEk0eS9aUDBqeWcvbldhc002MG8xb2ViL1BVTGx6dmVyTFd1aXlsSEYvbVAyNjdQOXpMNWwrOGV0YlJ1RDlJTnlHeHdaVlNWbTBncnF1T3IvTTBMOVFzMDB4bjl1MjVmM2N4QU5TVll5L3ZkTzVKcmZYbVpUcWZuZXNZZmtmWkFOaDN3aTRBd3h2RHpRVmc4M1IzQVFCZ241Mm1tNGZlWFhxUWJqc2Z6QVpheHdkMnA2MjBidkRqcU5iNlJacXVIaWNYLzJYYnpXT1c1b1dyNllqRy9kNHJwZHh2dDEyWDIyWGEvam5zK2V1dmt0eTFGZDlvc2NhWW51UjFwNTdIYityeTBuWUQrN3o5UGVYZU1nQWsrWVVTQUF5bm5WTlo2aDQ0YzA4SkFBRFlVOC9HOW9YYUlQcTJCVWQwV05oZVhRUS9abWs2UXRSYTY3L1hXcCsyZjlja3o5Tk1jVElkMFRvdmJQYWZiR3VuMXdjNlNmVTZwdWRwcHVwNjA1aCttdWErc3FBTEFMU0VYUUNHTlZjQzRKekR0djBzQUFEc2xiWVR4UmdmbUQ3SzluU2YwR0ZodXkwNi9yeEptdkRMWk1UamZwWGt4S1pQMnM0ZGo3WnRueTJsUExMMTN1cnh2bzFwQU5nMFlSZUFnYlFQdEw5VUNlQ2NTWFI3QWdCZ2Z4MlA3UXUxRCtOdlo1eEJuSXR1NjdDd3ZkcHRkN3lIcS83WTF2L0pnMnhYdU82V1RmYk9NWDJhWktrU0FEQWNZUmVBNFdnekNiekpGMG9BQU1DZStpb2pESlcwRHl6SDNqSGx1TzJPdzNaN3NHOHIzTzYzcHpiOVQ0R25teGwvdUc2VjVLWnduVEVOQUdNajdBSXdIRjFkZ0RlWjFscm55Z0FBd0w0cHBTelRCRjdHK04yTzAzUjRHYU50Q09OdytUR3dqOVBDMkg5Zjd3TmpEN3ljQlYwRWxDNy91ME90QUdBZ3dpNEFBMmdmWk92cUFyeU43aTRBQU95bFVzcjlqUFRCNEVnREw2ZlJZV0hYYk5OVU5sMk5yVVgyTStUenRucWNwZ204TEVmMjFRUmRybWRicHNJRGdLMG43QUl3akh0S0FMekRyTlk2VlFZQUFQYlV6WXc3OEhJcjQzaHdLZWl5ZzlydHVZbUg0NHNOci9mZEpNZjJnSi9xY1pyazB4RWRDOCtPTjRJdTE5dVdtK2hldEZCOUFQYU5zQXRBejJxdHN5UlRsUURldzFSbkFBRHNwWFBUZUl3MThIS1N6VCtFUG9tZ3l5NlBnYlBPSGtOdDMrTlN5c2FuemltbDNJN0F5OCtPaGFXVVQ5TjArOW1rUnhGMFdYZGJIbWZZem1DM005NnA5d0NnTjhJdUFQMHpQUWx3R1hNbEFBQmdYNTBMdkR3YTZmZGJ0ZytoNzJiWWdNQXF5ZDFTeWkxQmw1MGZBNmRKYnFUL1VOV0RObVNTTkNHcVRhLzM3UTJNcTdIdkMvZlRCT3dXQXk5Nm1TYmtjdGZ4cHBQdGVOeHV4MlhQdnlOdWwxS09TeW5Makc4cUxBRG9sYkFMUUk5cXJaTjRnQTFjenFUV2VxZ01BQURzcTdhcndkMDBEd2U3ZWdpLzZ2ZzdQa29UU0hpUS9oL09IeWU1MFM2VC9Sa0RuL2EwZnkzVEJCbnVuL3RuejBheTNtZmo2cmpEOVY1dCtiNXcybmJmdVpYK0ExRExOSUdKRzZXVWhaSFk3WFpzZjZmMWNSeGZKUG0wRGRXYy8yY0FzRGVFWFFENk5WY0M0QW8rVndJQUFQWmQrNUQzVnBxSDMzZHo5WWQzcDJrZUxONHFwZnlxaCsrM2FnTURaOSt2eXdmUnl6UkJoeHVsbE51NksrenRHRGpidjdvSXZTelRkSE41VTVCaE1hSjFYclZkWG02a21ZN2w1SXJydmt3VGxybWQ1RmU3TWdWUEtlV2tEVURkVExkaG9MUTF2dFh1RzhkR1hxLzc5dDI4RG5TdDZ6Uk5PT2xtMjgzbHZHY3FEc0JlL1o1VkFzYXExdm8weVV3bEJyTm8zeGFnMi8zNHV5UlRsUUN1NEZmYmZrTzcxbm8veVQyYkVrYmh3WVczZC9mOTNHeVc1S2xLMkFmaExjZUlTWktETlQ3aTlEcm5jYlhXZ3lTVDZ5eXdpemZ3YTYzVE5hNWJUNGM4ZHoxWHE0dmYrVFROQStEVnBoNXd0M1djSmZtcy9mdXlOVjIxMy85WmtwTWh2bi83K3pDYjJ1Y0dHSS9MTnp3QUhySk9uZStIYlJmUXo5dWFYS1l1cCsyZnIwc3BKeDJ2NTlEai9teThYOXdubHUyZnRmZkxkWTdEUTlmajNQN3dXVnVQcTJ5L3hibmp6V0pEMjNFak5SN0RNZVhDZHptODR1K0wwM2I3UFg3WDhlV2E2M21sK203RDd4QUE5b2V3QzZNbDdESTRZWmZ1OStHREpNOVZZcStjM1dBOVRmSWY1MjRrdlBjaThpMFhpbWYvN0MvYUM5VjFiNzZ6SFc1dit4dFZ3aTR3S29JR2YvNzdWdGpGUGdndzVIMkJkejFBUDlXNWhUWE9hZDdJdytTOTNCL2VkNytvMDdBR2cyNi8xYTUwS1FLQVBueWdCQUM5K1VJSmR0WXlUYURsMnpSaGxyVnZHcnpsWnRUaUxSZkIwelJ2ZmN5Uy9EcFhlMnVROGZzODNiUzFCUUFBTnNnRFNucmN0eGFxd0xuOVlaVVJUVW1GN1FjQVF4RjJBZWpQb1JMc2pMTldvWU8zZVgzTFJmQXlUZURtcHd2aDlpMlFXWm9XcUljUmZ0bnFZMGV0ZGVJTlR3QUFBQUFBZ0RjVGRnSG9RVHQzN2xRbHR0cEpYcytadmh6N2wyMkRFU2Z0bjd0dDk1ZkROQjJHVEgyMGZRNmp1d3NBQUFBQUFNQWIvVUlKQUhyeHVSSnNwV1dTdTBsdWxGSnVsVkllYmV1Y3hxV1VaZnY5UDAxeUk4bWpKRHFGT0lZQUFBQUFBQUJzUFdFWGdIN01sR0NySENlNVdVcTVzYzBCbDdkcGd5OTNTeW0vU25JN1RhZ0h4eEFBQUFBQUFJQ3RKT3dDMExGYTYwRk1ZYlF0anROMGNibGRTbG5zd3dxWFVvNUxLVGNpOURKMmsxcnJUQmtBQUFBQUFBRCtuTEFMUVBlK1VJTFJPOG5ya010eUh3dHdMdlJ5TjZZM0dpdFRHUUVBQUFBQUFMeUJzQXRBOTJaS01GcW5hYVlydXJXdklaZUxTaW1Qa255YUpnQ0VZd2tBQUFBQUFNRG9DYnNBZEtqV09rMXlvQktqOUtDVTh1bStURmQwRmFXVVpTbmxWcG91TDR6SFFYdE1BUUFBQUFBQTRCeGhGNEJ1elpSZ2RKWkpQaTJsM0ZlS2R6dlg1Y1cwUm80cEFBQUFBQUFBb3lYc0F0Q3R6NVJnVkU3U0JGMU9sZUp5MmxyZFNEUGxFNDRwQUFBQUFBQUFveVBzQXRDdFF5VVlqUWVsbEZ1bEZGMUtycWl0MmMwSXZJekJUQWtBQUFBQUFBQis3Z01sQU9oR3JmVWd5VVFsUnVGMktlVllHYTZ2bExLcXRkNU04alRKZ1lwc3pMVFdPaTJsTExmc2V4OG5XZXpnOW5ob1BBenVOTWxkWlZqTFVna0FBQUFBZ0YwajdBTFFuWmtTaklLZ1MwZmF3TXZ0TklFWFFhN05PY2lXUGF4dXd6bkxYZHNRdFZhZG9vYTNLcVVzbEFFQUFBQUFnUE5NWXdUUW5VK1VZT01FWFRwV1NqbE5jbHNsTnVvekpRQUFBQUFBQUhoTjJBV2dPek1sMktpN2dpNzlLS1djSkhta0VodGoyaHdBQUFBQUFJQnpoRjBBT2xCcm5TU1pxc1RHSEpmeS83TjNyMWRPSk1rQ2dDUDM3UC9WV3JBYUM2YXhBR0VCalFXb0xZQzJnTVlDR0F0YVdFQmpBUm9MUm1NQldndFcxNEs0UDVSYU5DelFrcklrbGFUdk82Y1BUejBxTWl2cmtWR1JSVExHZnIyTkNFdTRITWRJQ0FBQUFBQUFBTDZTN0FMUWpaRVFITTJzbEdLWm5UMHJwU3dpNGxZa2ppTXpWWGNCQUFBQUFBQ29KTHNBZE1ORTlIRXNJdUtGTUJ4R1hTWnFMaExHR0FBQUFBQUFnR09TN0FMUWpWK0Y0Q2plbGxMbXduRFltQXVCTVFZQUFBQUFBT0NZSkxzQWRFUFZoY09ibGxMZUM4UEJQY1N5b2c3R0dBQUFBQUFBZ0tPUTdBTFFLRE1IRVRFVWlZTzdGWUxESzZVc1lwbnd3bUZKZGdFQUFBQUFBS2drdXdDME13bDllSk5TeWt3WWp1YVRFQnpjb0NiV0FRQUFBQUFBWER6SkxnRHRKTHNjM2xzaE9LcXBFQmhyQUFBQUFBQUFqa1d5QzBBNzFSWU9hMUpLbVF2RDhkU2xqRlRXT1R6SkxnQUFBQUFBQUNIWkJhQUxUNFhnb0g0VGdsNllDOEhCU2F3REFBQUFBQUFJeVM0QVhUQUJmVGl6VW9xS0l2M3dweEFjbk1RNkFBQUFBQUNBa093QzBBVkxpeHlPcWk1Y01vbDFBQUFBQUFBQUlka0ZvRWxtbW53K3JBY2g2QTBWZGc1UFloMEFBQUFBQUVCSWRnRm9aZkw1Y0thbGxJVXc5SWEyT0FJSmRnQUFBQUFBQUpKZEFGcVplRDZjVDBJQUV1d0FBQUFBQUFBa3V3QzBNZkY4T0ZNaDZKV2hFQUFBQUFBQUFIQU1rbDBBT0FtbGxKa285TXBRQ0k1aUpBUUFBQUFBQU1DbGsrd0MwT1pmUW5BUVV5SG9uWDhJQVFBQUFBQUFBTWNnMlFXZ3pWQUlEa0pWbC82eGhOZHhTTEFEQUFBQUFBQXVubVFYQUU3Qi93bEI3NHlFNENpR1FnQUFBQUFBQUZ3NnlTNEFiWVpDY0JCVEllaVB6THdXQlFBQUFBQUFBSTdsNzBJQTBPUkdDQTdDTWtiOThsd0lqbVlvQkFBQUFBQUF3S1dUN0FMUW9KUXlGUVV1U1dZT0ltSXNFa2N6RkFJQUFBQUFBT0RTV2NZSUFOakdheUVBQUFBQUFBRGdtQ1M3QUFBYnljeXJpSGdqRWdBQUFBQUFBQnlUWkJjQTRGRjErYUo3a2VoRld3eEZBUUFBQUFBQXVHU1NYUUNBVGJ5TGlDdGg2SVdoRUFBQUFBQUFBSmRNc2dzQThGT1plUjhSWTVFQUFBQUFBQUNnRHlTN0FBRGZsWmtEaVM0QUFBQUFBQUQwemQrRkFBRDRWbVplUmNSOVdMb0lBQUFBQUFDQW5sSFpCUUQ0aTh5OGk0Zy9RcUlMQUFBQUFBQUFQYVN5Q3dBUUVSR1pPWTZJTnhFeEZBMEFBQUFBQUFENlNySUxBRnc0U1M0blJ6c0JBTkNYYTRsaFJGeEh4SzlyNTZtemlQZ3pJaDVLS1F0UkFnQUFZQjhrdXdEQUJjck1xNGg0R1JIamlCaUl5RWtaQ2dFQXdFbWRlNDhienVHbXBaUnBEN2RwRU11RStkZmYrZWRSL2ZWZFp2NVdTcm5UbGhFUk1TbWx6TTlzbTA1RkwyTVBBQUMwa2V3Q0FCZWlKcmlNWXBua2NpVWlBQUN3OTNQd1FVUzhpOTBUeko5R3hMU0gyL1I1ZzJ1S1FVUzh5Y3luRWZIaVRLcTh2SXl2eVR6Ym1rYkUvTXkyNlZUME5mWUFBRUFEeVM0QWNLYnFUZWhSTEcrUVg0ZUtJQUFBY0dqWDBWWkpjWlNadzc1VXBkZ2kwZVV2MnhBUkh5UGltZTRBQUFCQVZ5UzdBTUNaeU14aExHOGsvMXAvVmIwRkFBQ082MlVINy9FcUltNTdzajJ2ZDd6T0dHWG11SlF5MFNVQUFBRG9nbVFYQURoQm1UbUtaYVdXWVN3cnQxeEYyeE9qQUFCQXQrZnN3K2htZVpoeDlDRFpwVloxZWRYd0ZtOGlZcUpuQUFBQTBBWEpMZ0RRVS9YbStEQytKckk4amE4SkxnQUFRTCs5NnVoOUJwbDVYVXA1T1BMMnRDN0pOTXpNVVNsbHFtc0FBQURRU3JJTEFCeEpyYzRTOFRXQjVWOXJ2eCtLRUFBQW5MUnhoKy8xTWlLT25lelN4VFhLS0NLbXVnWUFBQUN0SkxzQVFJY3ljMzA1b2ZYZlA2Mi9EbUszTmU0QkFJRFR1UzRZUjdmTGpGNW41ckNVTWovaVpqM1ZzZ0FBQVBTRlpCY0ErTWJhOGtFcjMvNzVYOS84ZVNScUFBREFtdWQ3ZU05eFJOd0pMUUFBQUVoMkFlRE1mWk80TWxyN3AvV25FdGYvRHdBQVFPczF5UFVlM3ZwbEhEZlo1ZmVRNkE4QUFFQlBTSFlCNEtSbDVpait1alRRS29sbEpEb0FBTUFSalBmMHZzUE12QzZsUEJ4cHUyWWR2TWVEN2dFQUFFQVhKTHNBMEh1WmVSWEx5aXRYOFhVSm9hdFlKcmtBQUFEMHljczl2dmZ6T0ZMQ1NDbmxJVE1YRGRkaDgxTEtUUGNBQUFDZ0M1SmRBT2lOekZ4VmFCbkZNcW5sS3I1V2JBRUFBT2o3TmMxMTdIZUoxSEZtM3BaU0ZrZmF4TGNSOFc3SDE5N3FJUUFBQUhSRnNnc0FSL0ZOWXN1djlmZERrUUVBQUU3WXl3Tjh4amdpM2g5ajQwb3A3elB6YVVSY2IvblN5UkdYWHdJQUFPQU1TWFlCNENBeWN4akx4SmFub1dJTEFBQndmdGM4ZzlnK0NXUVhyK0pJeVM3VlRmMTEwMjE5WDBwUjFhVy91bDVhYXRCNHZUK3ZQMTFhYUdZQUFEZy9rbDBBMkl0dmtsdEdvV29MQUFCdzNzWUgrcHhoWmw2VlVtYkgyTWk2aE5LTHpCeEh4SnVmWE90TkkrSnRLV1dxYS9SWDE0bEltVG1LaU04TmIvR2hsSEtuWlFBQWdNZElkZ0dnTTNWOStsVko2NkdJQUFBQUYrVFZnVC9yNXBnYlcwcVpSTVFrTTFmTDB3N3FQeTBpWW5xc1pCd0FBQUF1ZzJRWEFIWldxN2VzSjdnQUFBQmM0clhSS0E2YjhIK2RtYmUxeXNwUjFhUVdpUzBBQUFBY2xHUVhBTGF5bHVEeU10clc0UVlBQURnWEx3LzhlWU42WFRZUmVnQUFBQzZSWkJjQUhpWEJCUUFBNElmWFM2dkVrME43RlpKZEFBQUF1RkNTWFFENHJyVWJ0aTlqdWY0NkFBQUEvK3M2bHBWV0R1MHFNNi9xTWtJQUFBQndVU1M3QVBBWGRhMzVseEV4RmcwQUFJQkh2V3A0N1NMYUVtVmVSb1JrbDU5ZjM0NGk0dGVJR01hUEs1WE82OC92RVRFdHBVeEZqeTM2Mk5WMzl1TlpSTXhLS2ZNRGZwZXI3L1QzbjQwdnN6b0cvVjUvUHkybExFNjBIYTRqNG1uZDV0RUcrL21zbFBMUTh6RnJFSTgvZkRhdDIvUm5iYi9aQ2JiZFZTeVRSbit0N1RmY29MK2V4RGhkSHlSY2pSRlBhNXRlUFhKT01EdjFObDNiOWgvdGo5TzZEeTRPL0oyR2EvdlgxU05qNUdxOG1LMzF1Wk1jSDlmMnM1ZVBiSGZ2eDhnTjlySGhUOGFRVmQ5YkgwZWNROE1aa093Q3dPckVjQnpMbTdSREVRRUFBTmpvV21vMWFiQ3JoMWplcE4vMU9td2NFYmNIM041eExDZExkbkY3aUVtRk91bjlQTGFydURPc1A2T0llSk9aaTlvMnY1a0lPYXY5OWZPT0w1MlZVbTdYM21jWUVXODI2V09aT2F2OWFMTEhNZWpWanVQSWF1d2FyYjNmTkNJK1JNVER2aVoydXhwSDZyMnMxL1c5aGx2dTU5R1gvWHp0b2JOZHFvU052bm12MVRaOTZEb1pwUGExZHp1Ky9NUDZQbEQzb2ZFV2JmZHRmMzJUbWF0ajZLZDk3Vjg3eG1td3RtM2JuaDhNdnRPbTg3VitPdS9oK1BodDI0N3FtUFN6NVIzZnJJODMrMnkvaHZaWUh5OWVyNC9uK3h3ZmV6WkdSaXlYeS96UXArU3l4bjFzdFg5ZDcyUE1yUDMvVGVQYjdPVjh1WEVNLzU5eklRQTJQTUZLRHVtelhuZVIrOWt3TSs4ejh6OTJBVGdaZDBZdjV5Yk9UMkQzbTA5Mks4Y3Q2SGhjdVcvY1IwYVorYnJ4UGNZSDNONjdsbTNkODNjYlorYVhmWnlQMUFtQzF2UEIwWVhzRTZPK0hqZGF6MGt6YzVDWjczWjhqeTlkOW9FYTUzMWVuL3luN3UrRFBvNGpkWC8vVDhmNytmQUkrOG8rMi9Eekh2cGMwMzVkOTZIN1UrcXZPOXhqelZOcDA0N0d4L1cyL2RoNm5EMlI5dGhyZit0b2pMemV3eGg1ZGVUemkzM3ZZMTlhejZucmZ0QWE5L3M5eGU5ZDQvY2FCL1RVMzRRQTRDSnZ5STR5ODJORWZJbGxKdlJBVkFBQUFMWjIzZkRhZVgyS3RMVk0vTXRMYm9CNmZmc2xJdTVqUDVWS1J4SHhoK1M5eTFZbk5UOUhmY0ovQjhPSStOekJSTnF3SnQ5OGpzZVh1R2t4aU9YVDZWOXF0YVMrR05UN1dmZlI3YjJzVWQzV3UwUDBwYm9OKzI3RFVlMXpINCtaQkxLMjNkZng5VDdrUHZ2citBamJkcmZIYmZ0ZW03N3JRNXV1YmY5VjNmN3J4dTI2Nm1qLzJuZDdyUGUzMTlFdmc1b3M4WEVQWStSUnpvVldTWElIMk1lR0VYR2ZtWC9zbWxSV0svNjBudGZ2NjVqYkVyc3V0Z3YyUnJJTHdBVlpQVFZTTDZpdlJRUUFBR0RuNjZ0eHRFMGsvQllSVVpjbGFMbUJQRHAwUllLZXhIK1FtZS9xOWUwaHR2OU43SGRpbXY1YUpicDA4VlQ3ZlVPZkgwZkVId2Z1aDRPSStMaXZKODEzak44KzcyZTkyV2R5U0FkSkFidTRqdVdrL0RHck1yeU03aWZmZjlSZjcyc1ZpcjBuZzlUa3N6K2lmZG1TYmIyT1plTEJWUS8yeVgvVjhYSFFRZHU5NjJEL09tUjdEQ0xpM2FINjJ4Wmo1SGpQWStUQnRuZlBTWEkvY2hYTDVLdTdsdlA3bG43VmRaSnBmYitXTnR2cjBsM1FTcklMd0FYNEpzbGxKQ0lBQUFETldpdXFyQ2U0ZkdwOHIxY1hkbzE3RlcxVk5tQWJWOUZOb2t0TG43K1A3cXVaYkdOY24zWS85b1R1SVQ3L09wWVRuWU9PMjNBMWJnMk9GTGRqTGtNeVBQRG5qV0xQQ1Q1cmlSWEhqT25uSGlTOGpLTUhGY1BYa2dHSFIvajR2ZmUzbm8yUm8zMk1rZCswNTc0cTFHeGpwOFNlVXNvc0l1Wkh2c2JvK3YxK0MrZ3h5UzRBWjB5U0N3QUF3RjZ1dFlhTjExZ1B0YUpMUkVTVVVpYXhMQkcrcStzTGl2MXF3dmhLVCtSQyt2eStuOVRmMUZVc0p4NHZ3VlUwVk9INXliaDF6S1NBWXllOEhHTjcvOWpIc2tZOWFjOUxiTk1mdGNlN0x2ZFhiYkh4R1BsNVQrMjVxcWJXaCtQZUtIWkw3R2xORHJudUtwbW92ay9MZGNLc0p2QkFiMGwyQVRqUGsvd3JTUzRBQUFCNzAxcEo1WHVWWENZTjd6ZnN1dVI1WDY5MW94OFRqSENvUHY4NitqSGh0ektxRTh1WDRMcGhHWXYxTmh6RWNhc1RyRnN0UzNWSlkraDlsd2t2TmRtMVQ4ZWhWWkxGUlI0WGF6TGc2NTYxeGNVa3ZIUjlQRmhMZE9sVERLOTIyTWNtSFh4dVYrZjFyZU9mcWk3MG5tUVhnUE02d1YrVitEdjBHczRBQUFDWFpOencya1d0NVBLdEQ0M2Y2ZVU1Qjd5SEU0eXc3ejQvaW9nK0pwYThydC90RXJ6cFlPTDZUUnhuYVpVZkdjYnhxMkFjMm4ySENRaDlTVnhhTjdqQU5sMHRYVFR1WVZ0Y1V2SlJaOGVEbmlhNnJHeFZ5YWFVc29qMmhKZXVsaWh0dVQ1WXhGK1hYWVZla3V3Q2NENG4rSGNSOGFXSEova0FBQURuZE8xMUhXMFRYZCs5YVZ4TGhMZVVDYit1Q1NIbkdQTStWVWFBUTduMzNYcGg1NFNqT2lhLzd1RTJYVjlRd3RKS2N3SkN2ZmZhMTZvZDE1ZFE0VzJ0TFVZOUhvZFc1eXpHeU8yUEszMnVpck50Slp0UEhYemVzSEUvdVdxTTZVTk4zSUZlayt3Q2NBWW45NW41Unl5ZkZISGpEd0FBWUw5YUs2ajhyQng0YTNXWDhabkcvRTMwZXdJRU9sVXJGZ3g3L0JXSFhTNE4wM09qaHNTUU56MGZWeTlKVXdKQ1RaUjUxZk50dklnbHh0WVNZUHMrYnR4ZHlMNTExWG84cUxFNmhXU3RqU3ZabEZJZUltSis1UFA2ZlY2elFHOUlkZ0U0NFJQN21rM2MxL0orQUFBQTUzWWROb3kybS9HeldzSGxSeWFOWC9IbEdjWjhGUDJzakFENzlNWjM3SlZka3h6NlBIazdPdGRxWUk5czgzakgxNzZPL2o5a09MeVFpajN2NGpRZStIeDFRZnZZenVlZnRmcklteFByZjVzNjloS2wrN3htZ2Q2UTdBSndndXFGeXgvaGhoOEFBTUFoalJ0Zi85T2IzclZVK0tUaC9jOXhvdXRldCtPUzFLVkloaDIvN1N3aXBoSFI1WElFd3d0YUNtZnJaZUpxYkFZZHROdmJpTGlOaUdmMTUyMDlUc3c3Mks1WEY3aUx2ZHR4T2FPdWswa1hkWitjZC95K0w4KzU4ZXArTlQ2UnJ6dUl5MGtLYkVtZU83V0tSTnRVc3BrMGZ0Yk94OWtPemlWVWRlRmsvRjBJQUU3cWhINTFraXpKQlFBQTRQQmFKNUVtRy95ZlQ5RTJrZk15bGhObzUzQU5QSTd1Si8xWEU0eC9ydjNkUHlKaUZLcW1jaDdqVE5RKy9pRWlwcVdVK1hmMnJldUllQjd0azhiUGV6YmVySCtYVWNmdmZSMFI3N2Y0L3kyZlA0dUlGOTlydS9WdHJHTmtTNVdMVVkvYWJsWi8vcjMyZDcvVzc5aGxGWTlCTE8rcjNtMXhMQnAxY0N4YUpiTisrRjYxaEZyZFloVExCS1NXenhwSHhNMFpqNDlkSlk4c0l1S2hublBOVjIxUzIyRll4N2JyRHZyZU9EUGYvbUJmdnZReGNqV0dqVTYwSHo1NlRsOUttV2ZtUTdSVldObjF2UDU1Qi9zSG5BU1ZYUUJPUkQzWlZzMEZBQURnT05ka3JVOUlQdFRLTFQ5VlNubUl0aWU5eHpzK3RkNUhYVDRSUFkySVo2V1VmNVpTWHBSUzd0Witia3NwVHlMaWwxaFdUVmpvOGV6UXY2YlJUWldHVWNOckY3Rk1rbmhXU3BuOGFJSzFsUEpRU3JtSmlDZXhURERZVlIrVzZabEV4Sk95OUd6dHAwVEVpK2d1R2VmcGx2Ly8xeDAvWjE3SHFrZjdVaWxsVXNldFhjZXNxeU1mTHhaMXpQMmxsUEtrbEhMenpkajhvcFR5ejFoV3RKbDIrTG5iVnJSNTNrRWYvYVVlYTJZL2FNdFpLZVY5S2VXWGFLd0cwYk9LUzR1MThYSFJ3WFoxc1cyclBuZFR4OExaTisyd0doOVg1d1I5T3BmWnh4alpWVkxEOHlQSFpoN0xaSnRuWlUxdHg1dU94NUJ0S3E1OGF2eXM2eDMybFVHMEpiTnVkTTBDZlNIWkJmZmYxUmdBQUNBQVNVUkJWT0FFWk9icldDYTZERVVEQUFEZ0tGb251ejVzOFg5Ykp4N0daM0FkUE9yb0duZ1J5NG1QWjZXVTZjLytZeWxsWGtxNWkrWEVpQ2RhK1psNUxKZVcrZVdiQ2NSZjZ1VGFzMWhPdWkyMjdQZFhzWHNsZ1ZWZjM3anYxa25lbGlvUXd5TW1TOHhqT1lGNzg1TUVnb2RTeXJQb3B0TEZhTXYvdjJ0Y3RwcGtyUC8zUmNOMkhhdWkxVVBkZis0ZVMrd3BwVXhyT3o2TGJwSVJCMXNzUTlJYW8wbnRvOXUwYWV2RS9DaU9hMTczdVY5cWd1bHFmUHhuUlB5ejl0ZkpEdS9idXV6V29vNFpkeHNtSHkvcU9VRnJ2enRXRXZMcW1QRFlHUG1pdGxmcnZyVlZ2K3R3eWI1RlJOelc0Ky90dCtkNjlkeHVzamFHekR1Szc4c045K2RKWTJ5M0hhOGkyaE5STFdIRVNaSHNBdEJqbVRuSXpJOXhlbXRYQWdBQW5OVzFXYlFsa0N5Mm1ZQ085cHZNcjg0ZzdGMHM1VEtMNVdUYmRKc1gxUW11RjdGTVpvQnZ2YTJUYXU5L1VqbGxXa3E1amUyckJiVk1xdi8yb3duTlIvcjdMTnFTdTQ2UkxMR2F4SjF0dUkyVGFFOTRHV1RtOEFEYk50cWhEYWUxRGFjNy9BeU90QSs5MkxaeVFOM09YNkt0R3RISzgzMjJTVFd2aVNzNzdjOE4yL1pySE1kNjBzRjNLMHZWNCt1cWNzby9ZOFBLS2ZVODdQcFFZOFozK2wzcitIRjloTFo0dHVuNVR4MGptODk1dHF3cTFNVjUzcnh1NS9zdDJ2SkpSMlBJTm0wNk9lQjQxWG9kTU50bFA0RmprdXdDMEZQMWFaN1AwWStTc0FBQUFKZHMzUGo2eVRiL3VVNFF0ZHhvSHRacnlsUFdlaTI4bXVqWitXbmFPbm55WHZkbnpVMTkwbi9UUHJUWXNsclFzT0c3dGZUVlAxdkdteU8xdzN6TC9Ya1M3UldiRHJHdFY1bjVjZHZFbXBvODhteUhuME5Yc1hxL3pUNzB2WDBxdXFud2NyMUp0WTNHaWh3dENTdlRodGNlczRySSsyM2FzdmFGVFpJUHhoMk1HYk9HZnZjUWJRa0x6dy9jSHJmYmJtOGRJeWVObjd2UnVOVkI4dEtxenozWllUdFhZOGk4OGZNSFd5VDN0Q2F4WDI4NkZ0VmpSMVBpckZNOVRzM2ZoUUNnZitxSjBzY2pYWndBQUFEd1Y2MlZVbjdiOFRYM2pkLzU1aFNEWGErSlc2K0hYN1FrdXF5VVVtNXI0dERJYm5EeDN0Zkp3RjM2MFNJaVhtVG1ZNVY3NTdIYkpQZThzYi8vcStHMXd3TzN3N1FoUWVOdHRFMndqcUl0Q1dGVDE3R2MzSHlJWlNMU05KWlAyeTlPZkI5YVZUeHFIWmNYbWZraWxnOEpSbU43UG16UXYzZHQ4Mm5qZDl2Vk1aSmQzKzZhVEZKS21XWG1zMGYyemFkSEdqTytQUzhiTit6VGh6TGY5VmhWeDhoeHcyY1BEeGlQblJPYTZ4aHlHOHY1bDlZeFpMckI1ODB6YzlxNFg0OWpzNlRXbG11V1JWakdreE1rMlFXZ1orb2FqUGNpQVFBQTBJdHJ0S3RvbTh5ZGJWdUJvSHFJNVpLMnV5WjlYR2ZtN1lsT2pvNGFYei9aZHVtaVI5eEV4QmQ3dzBWYnhJYkxiZnpNWXhQOUhUMVp2KzBZTjRyMnFnbUg5S0VoL3JQTW5NVmhrZ0ZtSFl4bDEvWG5UVzJyV1gzZlArdXhaWHBpKzFGblM4T1ZVcWFaT1duc3UwL2prWW5kbXNEeDdNRDc1R0RWNWpzNjlNT1Q4MjBxdXZ3Z3pvdEh4cjdyWTR3WjN4ay81cnVlRTJibTZFRDc3RzhOMnpodkhDUC9zY1crMStKdDYxSTdwWlNIbHZhc2Z0MnlIN1ljRTE3R1pza3VMZnZLd3hra1ZYS0JKTHNBOUVoOXd1ZTFTQUFBQVBUR01hcTZySjQ2ZllqZEovSldKZUluSnhqejVrbVFMcjlNbmZ5WnhHa2xCTkN0czVzQXFra3VMMCt3WDdjK2RUNk53eVM3L0xtSDk3eGEvKzZaR2JGTWZsa2x3RXhiSjREM2FMS0g3OVphaGVLcVovdmtzQjYzWDhWeGxnZnJ4VEgzQjJOVmkxOHo4NjRIY1JyRllTcER0WTZSbnhyMmphc3RZckdyUlhTM3hPU3p4bjF0c1dXN3RDU3hYMlhtOEdjSjlIVmZhZGtlU3hoeGtpUzdBUFRuZ3VZKzNEZ0RBQURvMDNYYUttR2tSY3VrdzRmRzY4UlhjWnJKTGkwVGtBODdWdEo1ekNmWDdCZnQwd21PWFZmZjdGT0RXQzVYTkl6VFhaYXJpNlY4L3QzdzJtMldlNW9lY0x4Y1Q0Q1oxOC8rMExQS0w1M3ZRelVSOGFIaE9EMDY4SDY1Mmcrai9ub1Z5MG9ZcXdweXd4UGRML2ZkejFyajBwY0hTLzkxZ005WWRIQU9kSWlFdVpZMjdTejV0TVpxZm9qRzd5Q0pmWFZlLzdNS1dTOGJqNjk5VFphRW41THNBdENQbXhBU1hRQUFBUHJuT3RxV0E1aTAzSkN2eXpUTVkvZEpnVWVmQXUycGxwai92bzh2Vk12ZEwrTHd5MFBRRDlNK2ZxbjZGUGNvbGtzcERPSjBrMWcyMWNWWTFqS1p0L0ZZWEJNeHBrZG9rMkVzN3pHTzYvSGp0OVpqVVZkajZKN2UrdmRvVDBydGNwOWNKUi85R3FlZnhMSnhYejlBbno0SGg5aU9McElWRm52ZVIxckh4RThuM0FkK2k3WTVvT3Y0UWJKTEJ3bjZxcnB3c2lTN0FCei9Ja2lpQ3dBQVFEKzFMbUgwN3c1dTZzK2liWUxrc2FkQSszYU5mTlZCdlBabEZ1ZWZUTUIzOUdVSm83WEpyT2ZSb3duK0Evcnp4TDd2MnlPUEdjTllMcHZ4SmpOdlN5bVRJMzJQYVYvZk96TkhyUlZ3Nm5IclZXM3I0WVh0azlNRGZNYlRNNG5WSWZyRzJWZm0yR1BpM0NHKyt5d3paN0Y3QmNQaFQ4YXNsZ1Q5UmJRdmZ3VkhJOWtGNElna3VnQUFBUFQyZXUwdlMwUHM2RTM5T2FaeG5GQ3lTelJXVHRuenNoMlNYVGpXZURTSTVWSWNyMEoxb1pOUnEzTzFMTFBUNWJoNm41a3ZJK0xGRVpLM1pudU04U3d6ajdWZmp1c3hmcWkzczRGRDlKUC9PNEU0dEp4SHpjK2dIM3hvdkw1NEdkOVBNbXRad3VpaEwwbTlzSXUvQ1FIQWNVaDBBUUFBNkxXWFo3SWRnem9oUjd2L0V3SU9MVE5mUjhTWFdFNnFTM1E1UFRmUm4yb0xvNGo0MGtFRnJZc2VPelB6S2pQL2lJajdrT2dDaHpRL2cyMllOTDcrK2p0ajBqRGFrb2dzWWNSSmsrd0NjSnlMSW9rdUFBQUEvWFpPMTJ3dk5TZWNsc3djWk9ibldDNURJOG5sUk5XbjVaOUZmeEplQmhIeCtRZ0pMK2V5WDQ0ajRvOW9yL3dHWE80eFlkSXlobjhuaWIzbG1tVldTcGxwR1U2WlpCZUF3MThVdlF1SkxnQUFBSDIrYmh2SGVVMHVqK3BUbjhCcGpFR0RpUGdjbHMwNkN6MU5lTG12L1l6Tjk4djdXRlp6QVdqeG9mSDF6Ny81YzB0U3U2b3VuRHpKTGdDSHZTZ2F4M0tOWlFBQUFQcnJIQ3VoakRVcjlOOWFvb3ZLRVdla2xMSW9wVHlKaUxjOStVcFhjYmg3bFA4NGcvMXk3RGdLUnpjOGsrUEJOTnFXWkxwZUpiSFhLbDI3eG1VUkVRKzZGYWRPc2d2QTRTNktSaUg3SHdBQW9PL1hic000ejJvS0x5K2svZmFaSVBEVUhzSUJ2QW1KTG1lcmxISVhFYjlFMnpJV1hYbDFvT291ZSt2UGgxaU9xWDZHZTdyUWpXbkRhNGRuRklmVzZpN1hxM0c4NFQwZWF1VXhPR2wvRndLQS9hczNTeitLQkFBQVFPKzlPdFB0R21ibWRTbWwxMDl3bGxLbW1kbnlGcVBZMzFJaEVoRFlxM3IvNkZEVk5tYjE1L2RZUHQzdHZ0WGh4cmw1Uk54azV0dFlWZ3Q1R2NlWnhCM1V6MysvNTgrNTZ1dDcxd29MajNsM29QYVlyKzJUMDRqNHc5N3kzN2pzYWhJUi94YkNzenBPOXY1Y2RvdSsrYWJoOVMvcjJIM2Q4QjZXTU9Jc1NIWUIyUDhKMktEZU1MQU9MZ0FBUVA5ZG4vRzJ2WXpUS0ZlK2FMaUdmaHA3bUxqTnpHdlg5UnpBbXc3ZmF4ckxpZlAvVy90elJNUzhKbHVzOSsrUjBCOWViWWU3aUxpcjFVT3U2eGgyeVBaNEdmdFBkaG5zY1lMNmVlT3g1ckd4LzZyRDlwalhmZkxQK3VmWjZqdDhMK21tTWZIem5MUWtxeXhxTlNYNlk5YkJQbi95eVM2bGxIbG1QalJjZDF4bDVydUdjOU5aS1dXbU8zSU9KTHNBN04rNzhQUVhBQUJBNzlXRWh1RVpiK0oxWmc2L25lanVvVm5zUHJtNHIyMThiZy9oRVB0b0Ivdk9iNldVeVphdms4aDFaSFhTY2JaMlBCckY4bjdpci9YWGZkMWJ2TXJNd1FHV3N1aDhncnBXUXJwdTNGOGUwMXJ0YlJITDZnbVRFemoyOXZtY29HVk12UlhDWG8xMWk4eWNONXh2WDJmbWJWZGpWbVorYVR6M2Y5dVFVUFdoY1F4cnFRU25xZ3RuNDI5Q0FMQS85VWJwV0NRQUFBQk93c3NMMk1aVHFGelQrcVJwbDlVeFZoT3FydTNacTVyYzBKSjBNaW1sUE5raDBTWENRMXE5VTBxWmxsTGVsMUp1YXJ1V2lIZ1d5NG43U1hTN1hOc2gybjljeDlJdXRZNzFtOFJ3MVBqK1Qwb3BkOXNtdXRSSzRiU2ZFd3hWcnVxbGFjTnJCOUhSY24rMWJ3eVAxVDlydGF2RkVlSy9pRE9vamdNcmtsMEE5cVJld04yTEJBQUF3TWxjdzExZndLYStPb0h2K0h2ajY4ZDE2WW11dUxibkVFWU5yNTJXVW00YVh2K3I4UGZmdHdrd0VmRkxSTnpFY25tY0ZvZEtyT2hzTEsxai9QZ0F4NXBody92Zk5GUnpHZW54LyszMzg4WSsvazRVeis0ODcwMUg1M2xkSkVkUEcxOC9PVUw4SHc1UXpRc094akpHQVB1OWdKT0ZEd0FBY0JyR0Y3S2R3OHdjbFZLbVBmNk9YWHkzajVuNXBQVm1mbWJlaFVsSCt1OURReDhmeEdVaytoMUVyZks4NnlUc2RKdXh1U1lCVENKaWtwbjNEY2V4cXpqTVUvNmp6THhyV1BKanZjOStiUDB5dGFyQ3p6Nm5aZXlmMXFXcGRtWHB2TDk2aU4ycmVWeGw1bjFqUW1CazVzZkdzZkp0YTk4L3MvWnNUWDVyT3MvcjZQeHUxa0hTeUcvUlVhV2FMVDhUem9aa0Y0RDlYTmkrRGpmREFBQUFUc25MQzl2V2FWKy9YQ2xsa1prUDBUYXBOSXlJejVuNXJHRWlaQndkTDRrRVAvR3ZodGZPRzE2cmozZnJxaUdtLzJvWW0yL2pOSkkyMzJUbWZNZmx0bGFKTHAramZlbVIzaTdoWWVtODcvb1FiUWtCNDh5TVhSTmU2cjMrNjNQdGN5ZCtubmV6YldKWmgrZDNIenFJeFR3enAzRzR1YVJaWXlJZTlJNWtGNEQ5WEpDNFVjQWxtTGo0QmdEZ1RLN2pSdEUrY1RZOTRGY2V4TzZWQXlLV2t6NjNQUzloL2luYUo1YXVJdUtQT2hFeTNhSS9ER0s1N0lIckhVN0YxUzVqVUIzN1hndGZwMW9tRWNlWitYYVhwVy9xNVBHcHhPZytNNTlHeEZiSG9kcGY3enM0WGtkME1FbjlpSjIrWTFkVmE4NU5LV1dXbWZQR3RoL1grL1piTFM5Vks0QzAzdXVmU3pENDdqN1l4WG5lNXpwdXZ0OXcvM3JUNFhGdjBtRXNSZ2VLdTZvdW5CM0pMZ0RkZXhlV0wrSjh6ZW9KK0tUZVNCa0xDUUFBWjZDMXFzdWt0VHorTnVyTitpK04xNTdqaUhqZjF3WXBwVXd5ODAyMFQyb09ZemtSTW9tSTMzNDIyVlRqT283bFJJanJlZzd0M3cydmZaV1preDBTQjB5cWQyL2ErUHFQdTFTa2FsMXk1d2h4R2tmRWRXYStyY2ZReFUrMjdTb2lYa1YzQ1lqeng1WXdxbG9TUW9lWitYcVRDZmh2amtHZm95Mlo5Wnk5amZhbGIwWVI4YVdlRTN6NFdTTHNXdldQWVFmZlhZTEIvNTduUFhTUXdCVDFmTzFkWnI2S1pmV2NUOSsyYXgwZm45Y3hwS3Z6dTBsWFNlUDFuUGNRYzBxTFVHR0lNeVRaQmFCRDljVEpPc2VjbTFXQ3k4TXVUeGNCQUVEUHIrTldDUTR0UGh6eU82K1ZmMi81M2krang4a3VhM0h0cW5McU9KWlBkYzlqT2JIN2JXTEIwN0FjTWFkckdNdWtyaGVQWGJldlZTUWVDOXZleHVkWjdKNndzSFZGcWc0U2w0NVY1V3RWUmV0ZFhjYmo5Mi8rL1Y5MVhCNTIvTGx2TjJ6TFdXTzFuSGQxNlp4TktrNk13d09VajNub01FYXJjNEtJcjhsZTg3VysxdVg1d0NLNnF3QnlicnBJWUZvL0RyNk9pTmNIcW5MMWRnLzllOS9INVllZVYzV0VuVWgyQWVqV3ZSQndCaGIxUXU5VFJFd2x1QUFBY09iR2phK2ZiN05FVG9kK2EvenVWNWw1MWZPeSt1OWptWlF6N1BBOWgyR1NuMzZhUmx0eTExVXNLeFk4eERKcDROdDlleFFSdjRhSHRBN2hRN1JWNXhqR01ubHBIc3NKMEQ5ak9SRy9icldjM2ZQR3o0cWVIQWRHY1ppRXcza3BaYkxOLzI4OEJxMHFUbnlJLzYyZ000eGxvdVYxU0hMWnBKOHVNdk0ydXIvL3Z1OSs5NXNFZ3grMjZhVHVINmRXeldpeWgvdmxyZWYxbTM0R25CM0pMZ0FkeWN6WDBmMlRCbkFvMDFqZURIdXdoaXdBQUJmbVZlUHJqM0xqdUQ1eFBvMjJTWnBYRVhIVDE0WlptOWl5MUFwbnI1UXk3ZWhwOU91UTBISnNrK2htT2JSaExDc1Y3Tk9sTFdteDdURnZHdTBUME1QYUg5N1lOWnJIeVVsbXZvelRxY1Eyai81WDBldkRQdm5IQ1gzZlJYUmYxV1YxWHQ5U0Zld3hNL2Y4T1ZkL0V3S0FkclhzdFFzV1RzVThsamN6YmlQaVNWbDZWa3E1YzlJTEFNQ0ZYY3RkUmZ0REM1TWpia0xyOGtuWDlYcTJ0MG9wRDNGNWs3RmNMbjM5RE5RcURwTVQrYnFmTHFocDN1OVFpZTJESHQwN3QzRzhwYmUyL3E2cXVqdzZYczVpRDhramUvUjJqMVhROTVsQXI2b0xaMHV5QzBBM1hvZHlrL1RUUEpZM3k5NUd4TE9JK0djcDVaZFN5b3RTeW52SkxRQUFYTGpXcWk2VFkwNWkxS1VZV2o1L0VLZFJBZUltVG1kaUMxcVlqRG9mYjA5ZzNGcHN1YVRQS2R0cFFyMG14OHgxNS82bzl6SnZUK0NyUHRTRVhSNXYwN3M0aldUUGgxTEtQaXYxN0NzR2k1Qk15eG1UN0FMUXFENEY5MG9rT0xKNUxFdXJ2cThYZk05cXhaWlZZc3RkS1dYcWFRSUFBUGpMdFZ4cm9rY2Zub2lmTkw3K1pkL2JxbDdIUEFzSkw1eTVPckUrRlltemFNdEY5SGladU9ydGhUVEhJaUp1R3U2SnZkV2plN2QvVGFMZnl3UE5UbUQvNzV1YkdyZUxiZE05VmdWN01DZkFPWlBzQXRCT1ZSY09lVkk5clJkenEwb3RUOWFTV3A2VlVtNXJ4WmFwY0FFQXdFOWROMTdMelh2eXhHNXJKWWhSWmc3NzNsajFTVzRUUjF5Q1d5RTREL1VZTWVucDE1dnR1VUpCWHl4aStVRFlyS0VkSnlFSnJZLzcxMjFQOTYvVzVLcExiYzlWWXZPc3AyMzY0a0J0dW8rbDAxU040Nno5WFFnQW1xbnFRdXZKOG16dDkzL1czOC9yVDBoY0FRQ0FYbDdMZmVqRFJwUlM1cGs1alloUll5eDZQOEZlU25uSXpHY1I4VEU4ZE1LWktxWE1Ndk1tSXU1RjR5emE4eVl6SXlMR1BmcGFpNGg0Y1FIaGIwNTBXZk1pSXI0NDl2UnkvMXJFOG1IVWMrdHpsOWllaTNxZTl6a2lybnJ5dGVheFRIU1pIeWdHMDh5Y1I4U3dvN2VjNlkrY084a3VBQTB5Yyt3aWg3V0xtZG5hU2ZDL3YvUDMvejFwRlM0QUFEanF0ZHd3Mm0raVQzcTBTUitpTGRsbEhDZFNUYUpPQXF3U1hvWjZNK2VvbERMSnpLZHgyQVNKOTdHc2VHVy82cjQ5KzVUd3NwcU1uNTk1MkdmUjRRVDFONVB3Z3dOdXc2ZUllR012K21uYjNHYm1ueEh4TG81N24xNmlTMGY3V2tROHljejdIb3laczlxbWg2N1M4MXZ0ejEyOUY1dzF5UzRBYlZ4c1hKWlpMQk5aL295dmxWZm1GM0NEQUFBQXprMXJWWmVIUGwwSDFJbnhsa21lUVdhTzYxSU52VmNyWHp5SlplV0w2d04rOUNJODhNTGgrdmxOWnY0N0RuUHY2WDJkTUI1RXZ5cVFhTTl1eldLNXZNcTVUOGEvajRpM1hVOVExMlBQb1JKZVpyRmMwbVVZN2o5dmVoNDBpMldDd09nSVgyRWFoMXZtNXBMR3pFLzFYTzhZNTE1dlN5bDNSOXI4aCtnbTJXVlIzd3ZPMnQrRUFHQTNtVGtLVDd1Y3MybEV2STNsbXZCUHl0S1RVc3FMVXNwZEtXVlNTcGxLZEFFQWdKTTBibno5aHg1dTA2VHg5YzlQcVFGTEtZdFN5b3RZTGkyeDcrdXlSYjAyOUhRc2grN25kN1dQTC9iWnQwc3BxOHBPdjR2NjN0dnpTU3p2T1IzYSt6aGUxWWxwL2Z4OW05ZHR2TjFYMGtHTjN5OTdic09IdWgyTCtua1NLRFpzbTFMS3MzcThQbFRNRmhGeFcwcDVKdEZsTDIzNlVQZTM5d2Y4MkdrczV3THVqcmpkOCtnbVNlVkJ2K1FTU0hZQjJOMUxJVGdicXl6bjIvaWEyUEpzTGFsRitVa0FBRGdUSFN4SE82ODMzL3VtTlJIanVpN3ZkRkpLS1ErbGxGOWlPYmsxMzhOSFRDTGlsMU9wZXNQNTJlTmszelNXOTBEVys3WW53UGZmbnFzSitXZHhtS1NYMVJoMmU4eEp6NXBRdGE5RW4za3NrN1orT2NUUzRUVUo1ZGtlamp2eldGWUgrYlpDeU5TZXMxWDdUT3FZZVJ2N1M0WmR4UEloeVY5S0tlOUZmZS83MjIxdDAwbnNMNUZwVmZtcUwwdFJkWkZZTDBtYml5RFpCV0FIeXJxZWhWa3NieFE5S2FYOHMxNUl2cGZZQWdBQVo2KzFna2tmcTdwMDlSVG85YWsyYW4xUTRaZFlWc0dZUk50a3lEeStUbUxkZUNxV0h2VHY5Y20rdDlFMmdUdUpaZFdJWjk5V3E2MTkzWDJSdzdUcHRDWk1QSW5sL2FrdTR6Nkw1VVQvYWd5YjkyU2JaMnZiM0RwT0w5YjY4bEVTRXRlT096ZlJscEF5aTYrVnBiOTNIRmR4YWJjeDgzMkg1d1VyMDlwV3Y5U0hKSjBmSFBBOHQ1UnlVNCtETjlGTmN1WTh2czRQUE9sVFluTWRDMXJHN3BsNURpNW1mQkFDK2lvelA4ZHgxbGU4VktzTExEYnJuK05ZcmhmSmFabkg4c2IweFBKRG5lMExLUW9IZDh3MVk1MmJPRGR4ZnNLcDc4ZWppUGdzRW81YndFV04rNk9JK0RXVzFYeXU0dnRWZmFheG5BVDd2WjUvbUJ6Z0ZQcjNWZTNmVDJ1Ly90NjF5aXA1WmJiV3YwM085cmROaDNXY3V0cGczRnB2MzBWRS9GbC92NWMyYmp5UC91RjEzVGZqOUdyN2Y3U2Q4N3FkdlJ5bjY4T1IxM1Zicmh4emVqMXVydnJiNmlkKzBFNVIyMmx2K3hiTis5elZOK2Q2b3gvODkzbjltVVhFdjA5aDM4dk0vOFR1MVNodlZDWGtVdnhkQ0FCMllnbWowektKaUErSEtHVjZnUmVJQUFBQXZWU3ZBVjBIY3E3OWU1WEVZZ21OODJuVGVTd25ZeDh1YUp2UFpweXVpUkFUUGZra3hrM09aNTg3eTNPOXpMeU8zUk5kRm1GWlFpNklaQmVBN1U4MGh1SEovbE93aU9XNmxLcTQ3TTlBQ0FBQUFBQUFvRE92R2w3N29Bb1JsMFN5QzhEMnJvV2cxMVpKTHUrZDFBRUFBQUFBQUtjZ004ZlI5ckQxYjZMSUpaSHNBckM5cDBMUVc1T0llS3VTeThFTWhRQUFBQUFBQU5yVVJKZjdocmVZMXVXNjRHTDhUUWdBdGpyWkdJVEtMbjAwajRobnBaUWJpUzRITlJRQ0FBQUFBQUQ0cTh5OHk4ejd6THg2NVA4Tk0vTSsyaEpkSWlJK2lEcVhSbVVYZ08yTWhLQjNKaEZ4YThtaW8vaUhFQUFBQUFBQXdIZU5JMktjbVl1SW1FYkVuMnYvOW85WXpqbGRkZkE1ODFMS1JMaTVOSkpkQUxaakNhTit1WEVDZDFSWFFnQVlad0FBQUFEZ3AxYXJCdXhyNVlDM1Fzd2xrdXdDc0oyUkVQVENJaUplbEZLbVFuRlVReUVBRG5BakFBQUFBQUQ0UGxWZHVGaC9Fd0tBeldUbUlEeGgzZ2VMaUhnbTBhVVhoa0lBSE9qNEN3QUFBQUQ4TDFWZHVGaVNYUUEyTnhLQ1huaFdTcGtKdzNGbHB2MEJPQlNKcGdBQUFBRHd2MVIxNGFKSmRnSFluTW0yNDd1UjZOSWJReUVBakRjQUFBQUFjRFEzUXNBbGsrd0NzTG1uUW5CVTcyVW8yeCtBaS9TckVBQUFBQURBWHp5VVVxYkN3Q1dUN0FLd09aVmRqbWNlMXAyMFB3REdHd0FBQUFCZ0hxcTZnR1FYZ0UxazVpQWlCaUp4TkRlbGxJVXc5R3AvTVBrTUhNcElDQUFBQUFEZ3YxNllNd0hKTGdDYk1yRi9QRk9sK0hwbkpBVEFJV1dtY1FjQUFBQUFsZzhIejRRQkpMc0FiRXF5eS9GWXZxaC9uZ3NCY0dBaklRQUFBQURnd3QyVVVpYkNBRXVTWFFBMll3bWo0NWlwNnRKTEl5RUFEa3lTSFFBQUFBQ1hhaEVSenlTNndGOUpkZ0hZekZNaE9JcmZoS0JmTXZNcUlvWWlBUnpZVldZYWV3QUFBQUE0RmZPTzN1ZDlSUHppd1dENFg1SmRBT2l6QnlIb25aZENBQnpKV0FnQUFBQUFPQVcxQ3NzdkVYRWJ5N21PK1JZdm45WFgvVkpLdVMybExFUVUvdGZmaFFCZ0kxZENjSEF6SjNDOU5CWUM0RWhlUnNTZE1BQUFBQnhXclNaUVJBSmc2L0Z6SHN2S0xPOVhmNWVabzdYL3N2cjlJcFlKTHFHQ0MyeE9zZ3ZBWmdaQ2NIQk82SG9tTTYvdEMxdzRDWGpITmN6TXNiV0pBUUFBQURoVjN5U3pURVVFZG1jWkk0QkhaS2JKL2VQNFV3aDZ4eEpHR0pjd0RnRUFBQUFBY0hTU1hRQWVad21qNDVnTFFYOWs1akFpcmtVQ09MSlJabzZGQVFBQUFBRGdza2wyQWFDdlprTFFLMitFQURBZUFRQUFBQURRQjVKZEFPaWxVc3BDRlBxaEx1VTFGZ21nSjRhWmVTY01BQUFBQUFDWFM3SUxBUENZMTBJQUVSRWhDYTgvM21TbVpRWUJBQUFBQUM2VVpCZUF4NDJFZ0V1Vm1jT3daQWlzV0Y2dFh6N1d5bE1BQUFBQUFGd1l5UzRBd005SWRBSDZhaGdSSDRVQkFBQUFBT0R5U0hZQkFMNHJNMGNSTVJZSm9NZEdtWGt2REFBQUFBQUFsMFd5Q3dDOWxKbFhvbkIwNzRRQXZpcWxURVdobDhZU1hnQUFBQUFBTG90a0Z3RDZhaUFFeDVPWmR4RWg0UWc0RmVQTXZNOU14NDdsR0Q3SXpLRklBQUFBQUFEblNySUxBSDAxRW9ManFGVjEzb2dFZk5kQ0NIcHJIQkdmTHpuSkl6T0h0Y3JObDdBTUhRQUFBQUJ3eGlTN0FOQlh2d3JCNGRXcUNKWURnUitiQ1VHdlhVWEVINWw1ZlVuamRtYU9NL056ZkUxeVVlRUdBQUFBQURocmZ4Y0NBSHBxSkFSSDhTNHNYd1NjdGtGRWZNek1oNGk0TGFYTXozRWphMExQODRpNERza3RBQUFBQU1DRlVka0Y0SEZ6SVRpS1FWMU9od1BKek5kaDJRdDR6TzlDY0RLdUkrSkxadDdWcWxXblBrWVBNdk02TSs4ejh6OFI4VEZVY1FFQUFBQUFMcFJrRjRESHpZWGdhRjRKd1dIVUNnSHZSQUk0UTI5aW1mUnluNW5ERXh1YnJ6THpkVjJpU0lJTEFBQUFBRUFsMlFXQVBycytoNmZ4KzY1VzBMa1hDZGpJVkFoTzBpQ1dTU0pmTXZOelpvNzdlSHhaUzI3NVdLdTMvQkhMUk1TUkpnUUFBQUFBK09ydlFnQkFqdzBpNG5WRTNBbkZmdFJFbDgraFNnQnNhaUVFSjI5VWYrNHpjeFlSbnlKaVdrcVpIbmo4SFVYRU1DSitqWWlya05BQ0FBQUFBTEF4eVM0QWp6T3hlVnl2TXZOOUtVVTdkRXlpQzJ5dmxETExUSUU0SDFmMTUwMXQxMW45K1hmOWRSRVJzMTJPUVhXTUhkU2ZxNGo0Ui8xMVdIOEFBQUFBQU5pUlpCZUFSNWpZUERyVlhmWkFvZ3MwbVlka2hYTzFTbjc1ZHN4Y2IvdjVEMTQ3MUM4QUFBQUFBQTVEc2dzQXArQk5aajZVVW1aQzBTNHpyeVBpUGlTNndLN21JYW5oVWcyMVBRQUFBQURBOGYxTkNBQTJNaGVDbzd2UFRNa1pqVEp6SEJFZlE2SUx0UGhkQ0FBQUFBQUE0SGdrdXdCc1ppNEVSM2NWRWUrRVlUZVpPY2pNKzFoV2RBRWNFd0FBQUFBQTRHUlp4Z2hnTTNNaDZJVnhaa1lwNVVZb05wZVpWN0ZNY3JrU0RlaUVKZFVBQUFBQUFPQ0lWSFlCMk15L2hhQTN4cG41V2hnMlUyUDFPU1M2UUdkS0taSmRBQUFBQUFEZ2lDUzdBR3htTGdTOThxNHV5Y01QWk9aVlpuNk81ZEpQQXhHQnprMkZBQUFBQUFBQWprT3lDOEJtNWtMUU8rUE0vSmlaRWpuV1pPWWdNKzhpNG8rSUdJa0k3STNxTGdBQUFBQUFjQ1NTWFFBMlVFcVppa0l2WFVmRUg1azVFb3FJekJ4SHhKZUllQ01hc0hkL0NnRUFBQUFBQUJ5SFpCZUF6YzJGb0plR0VmRTVNOTlkYXBXWHpCeG41cGVJdUE5TEZzR2hUSVVBQUFBQUFBQ09RN0lMd09Zc1dkRnZyeVBpUzYxdWN2Wld5eFd0SmJrTWRRRTRuRkxLUENJV0lnRUEwSFJkczFxZWR0MS82dCtOTHpRbW83cjkvL2ttTHA5cnZEemdjTDc3d2JkdGZySDdBUUFBYkVLeUM4RG1MRm5SZjRPSXVNL01zMDE2cVRjKzd5UGlQN0Zjcm1pbzJlRm9wa0lBQUdkM3J0MWlKSW9ieC9vcU0vK0laZUwrOVhldTY2N3J0ZDBmbVhsMUlURVpaT2JuaVBoY3QvL2JwSlpSalplbGZNOTNQL2kyelZmN3daZEwyUThBQUdBYmtsMEFOamNWZ3BNeGpLODNoTzR5YzNqS0cxTnZnTDJyVlZ3K1I4UllFME12L0M0RUFBRGJYOS9VNjVwTkp1K3ZZcmxzN2RVRnhPUkxMQk5hTnJuZS9heml4MFh0QjhOWUpqbGRpeHdBQUh3bDJRVmdjNVl4T2ozRFdGWS8rYklxLzNzcUpaL3JVNldyQkpjL1lybE0wMUNUUXE5TWhRQUFZS3ZybkVFc0ovaTN1UzRieERLNVkzaWs3L3o2QUpWVTdyZU1TY1R5QVEvVlB2YlQ1dS8yMmVaMVAvaTRZNXU3THdBQUFKVmtGNEFObFZJV0llSGxsRjNIOGdiaWYyb3A3THUrbEg2dTVhcEg5VHQ5enN5TTVRMWdDUzdRNytQQ0xDTG1JZ0VBc0xGM3NmMEVmOVRYdkRuQ3RkcDkvYzc3L0l5NzJLeTZ4L2Zja25IYjJRQUFIa3BKUkVGVTYxS2RYNXQvck5maSs3VHJrc1FEYlE0QUFGLzlYUWdBdGpLTDNXOUMwUjlYOWVmTk1xOGtadlhuei9ycnZKUXkzOGNIMXdTYlFmMzhYK3V2UTAwQ0oyc2FsaFlEQU5qa1dtalFlTjQwenN5Mys3cFcrODUzM1hTSm1WWXZXNjV0TTNOVVNwbnFZYWZSNWgzc0I2UE12S3FKOXdBQWNORWt1d0JzNS9jd3FYbU9Wc2t2LzFXVFlPYnh0V3JETENMK2I4djNmVnAvSFlRa0tUaFhueHdYQUFBMmN0M1JlN3pmNTVlc1N3UGRIK0lhcm43V3NQRnRub2ZsTmJ0b2gyMlgxOXJWcUlQUHVRNlZod0VBUUxJTHdKWWVRc25ZU3pLTXJ6Y2VSOElCZk1kVUNBQUFOcjYrYXZXdmZYN0JXb256WXh3bTZTR2ltNFFhRDFhMHRmazRkbDllNjFqdDlhdVdBd0NBaUw4SkFjRG1TaW1MOFBRTUFIODlManlJQkFEQVFld3RzYU1tUFJ5cXVzZktVSk1lVDJhK2p1VURUWU1UKytvRHJRY0FBSkpkQUhZeEZRSUExbndTQWdDQWc1anY0MDB6ODEwY3A0cnJRcE1lUjJiZXg3S2lDd0FBY0tJa3V3QnM3NE1RQUxCbUtnUUFBSS9xSXJIajMxMStvY3djWk9iSGlIaDlwSmgwVVRsMnJtdHQzZVovUk1UNFNGK2hpL2I2WFVzQ0FJQmtGNEN0bFZKbTRla3JBTDRlRitZaDRRVUE0REVQUFhtUGlGZ21QY1J5MmFMckk1NUhUcVA5L29MRWg4M2IvS3EyK2RXSjd3ZXVQUUFBSUNTN0FPenFRUWdBV0tQcUZ3REFUM1NRSUR5dEQ1ODBxMGtQWCtLNFNROHJMZmNYNXFXVWlkNjFVWnVQNHZpSkxsRktXVVRFcExITnAxb1VBQUFrdXdEczZwTVFBTEJHRWlRQXdPTnVqL1RhLzhyTWNTeVRIZ1k5aXNuaW1ERTVkejFzODdjTmJYNmpSUUVBWUVteUM4QU9TaWtQWVNrakFMNGVGeFloNFFVQTRMRnpwbG5zTmxsLzAwVlZsOHg4SFJIMzBaK2toOVY1NUxQWS9oN0QrM3B2Z3ArMytidmE1bjNhRCtZTis4RlVxd0lBd0pKa0Y0RGRUWVFBZ0RXV01nSUFlRVJkZHVkRmJKYmNzWWlJRjEwczFWTVRYZDcxTkNheldDYTh6RGVNeVUwcFJWV1h4OXY4WFVTODdtbWJQOFRtU1U2ck5wOW9WUUFBK0VxeUM4RHVUR29DOEYvMWh2VmNKQUFBTmpwditpV1d5N2w4Ny94cFh2L3RsdzZybHd4NkhwTlpSRHlKNWRKRXN4L0U1SDFFUEpIMHNMR3JucmY1ZEl2OVFKc0RBTUEzL2k0RUFMc3BwY3d5Y3hZOXYza0N3RUY5aUlnM3dnQUE4T2cxOVNJaTdpTGlMak1IYTlmV3MvcHZseHFUOXhIeC9wdVl6T3ZTTjlnUEFBQ0FTcklMUUp2Zm9tZHJQd053VkpPUTdBSUFzSlU2cVQ4VkNUSFI1dG9jQUFBMlpSa2pnRFlQc2RuNnlnQmNnUHJFN1VRa0FBQUFBQUJnZnlTN0FEU29UOTFNUkFLQU5SK0VBQUFBQUFBQTlzY3lSZ0R0Zm91STE4SUFRRVJFS1dXYW1kT0lHSWtHQUhCTW1Ya1ZFWU9JR05hZmlJaFpMQ3VVTGtvcE0xRmloMzQxaUlpcitzZjEzMGVzTGNOVFNwbUtGajN1eDZ2cnRmWHhjVkhIeUlpSWVhM2NDUUJBVDBsMkFXaFVTcGxuNWlRaXhxSUJRUFUySkxzQUFCdFlTMGpaMW5lVFZUSnpIQkhQNjduSTRKSFBqbGdtSi93ZUVRLzdUbjdKekdGOG5WVGUxazhubnRjbXJuL2tYdzFmL2FyR2FwdDdCZE1OWS9KdHNraG5NZW00ajE1SHhOUDZYWC9Xcjk1ODA3L21zVXdlK0JRUjB5Ni83d1p0UHVocG0rOWxQMmpzU3o4Y1U0NHd0bTBWenkzMnMxVWZIbTBhLzh4Y0piOGNaSXdFQUdBN2tsMEF1dkVoSkxzQVVOWHFMdlBZL1NZMkFIQTUzc1Z1U2JMVGlIZ1c4ZCtKM05jUjhTcTJuMXdlMVo4M21UbUxpTjlLS1pNOWJlczQxcElodHZRMkl1NSs4dStmOTl4R1c1OFNidmovcmhxKysyTXgyVmxOeUJoSHhNdkdjOXBoL2JtdTd6dU5pQThkOWJGVGJmTzk3QWVsbEVWbWZvemRFMHptRWZGTGh6SDhvK0cxblh5WG1oRDFNbmEvWnpmNFpveWN4N0xDODZRdWJRNEF3Qkg5VFFnQTJ0V25UYVlpQWNDYXQwSUFBT3hibmN6OUk1YVQ1NFBHdDd1S2lQdk0vTEpCMVF6T3N6OE5Ndk0rSXI3VVBqWHMrQ05HYTMzc1dzUTc5OUR3Mm1HdHh0SkZQN28rNG5aRVpvNHk4M01zRTZMR0hjWjNHTXRFcUMrWmVWY1REUUVBT0JMSkxnRGRNYWtKd0gvVnAxV1Z1UVlBOWlZelg4ZHlNbmZZOFZzUEkrSnpacjRUNVl2cVQrTllKcm1NRC9CeHc0ajRtSm1mSlF4MDZsUGo2MTkyOUQyZU43Nyt0eDM3OEtCV3Qva2MrMTFXZGhETFpMQS9KQVlDQUJ5UFpCZUFqcWp1QXNCMzNBb0JBTEFubzlodHFaVnR2SmFNY1A3V3FybmNSM3Qxb0YzNjhaZXVLb3BjdWxMS1EwUzBMSy9UVmJXZGx2ZVpsVkxtTy9UajYxZ21heDJ5WXRBd0pBWUNBQnlOWkJlQWJ0MElBUUFyRWlFQmdETXdpdVZrcm9TWE0xVGJ0ZXVsWHJZMXFIMU13a3MzSmcydkhXYm1zTEZQWFVkYjB0U0hIVDd6ZFVSOGpNTW5hNjI4enN5UHhra0FnTU9TN0FMUW9mcmt5VVFrQUZoam1Uc0E0TlJkeGY2cnlIQmdhNGt1ZlVneWtmRFNuUStOcjIrdGpOSzZoTkhEbHYzNHZpZmowM1ZJREFRQU9DakpMZ0RkZXh0dEpXTUJPQ08xdXN0RUpBQ0FFemV1MVJNNEgrK2lINGt1SzRPSVVCMmovZnBqRmhIemhyZDQyZmdWUmcydmZkaG1DYU9hNkRMdVVmaXZZcmtjR0FBQUJ5RFpCYUJqOWFMOE41RUFZTTF0U0lRRUFFN2ZHNGtJNTZFdU5UUHU0VmNiUnNRYkxkU3NwYnJMMWE1TEdkWEtQTU9Hei82MHhXZU5lOXFIcnpOVEpTd0FnQU9RN0FLd0I2V1V1Mmg3aWdhQTh6b3VMTUp5UmdEQTZSdUU1WXhPWGsxWTZuUDFpZGU3Smx2d1g1UEcxKys2bEZGclZaaUhEZnZ3MVFuMDRXdmRFQUJndnlTN0FPelBqUkFBc0ZKS2VSOFJNNUVBQUU3Y1dDTEN5WHNkeThTbFBsUGRwZTNhWTk1NDdmRjB4OWUxSkhnODFJY0VmcW9tYTMwOGdXYTRWd2tMQUdDL0pMc0E3RWtwWlJvYlBwRUN3TVdRQ0FrQW5JT3hFSnkwVjZmUXh5UlZOV3RaeXVoNjIwU05EcFl3MnZUN3ZtbjhuRU1aaEtRdEFJQzlrdXdDc0Y4M0ViRVFCZ0FpSWtvcHM3Q2NFUUJ3K2w0S3dXbkt6SEYwVjlWbEZzdmxjdDZ1L1V5anUvc2dsb0ZwTXpsdy9FY05uN1VvcFR4czBIK0hzYXhNMUtWNTdiZlRqdnR2aENXNUFBRDI2dTlDQUxBL3BaUkZadDdFYVpSWEJlQXd4NGE3ekh3ZUVWZWlBUURzeVN5V2s3Yi90L1ozVDZOdE1ucmRNRE92YWlJdnArVjU0K3NYRWZGYlJMei8yWkl6bVRtS1pWV0xVZU4zZmEvSmRyN3VXR1RtUSt5ZU5QUTh0a3VZYVVtQzI3UXljbGVWVXFheHJDVHozYVdUYXBXYWw3R3NZdFdhSFBZbVZQZ0VBTmdMeVM0QWUxWktlV2k4dVFEQStibUppRCtFQVFEbzJDUWkzcFpTNXQvN3g3b3N5WnZvcGpMQ0tKWkpOWDN4V1BXOGxtU2ZTVVQ4KzB6NnlLamh0Yk9JZVBhekpKZVZ1clR6TkRQdlkvZGxyMGFOYmY0eWRsL3U1bHphL0ZQc2ZqOXE0OWZWNmlVdHlmd2ZOdnlNY1dNOEZoRng4MWdWbVpySU44dk10eEZ4SDIzMzlNYVplYnZKZmdNQXdIWWt1d0FjeGsyOTZCOEtCUUNsbEZsbTNrYkVPOUVBQUxxNjdpeWxUQjQ1QjFsRXhHMW0vaG5MQ2R3V1Q2TkhWVGRLS1hjLysvZk12SXZkRXowKzFPU05rMWFyVmV4YXBXSVJHeWE2Zk5NdU43WEt5M0RIN3p6NlVldzNhUE9uc2Z0OW1MTm84MWhXVExsdjZEUFhteXd2RkczSklQTU5ZLzJxTVJhclBqemJvdjh1SXVKRlk5SlcxTmVxVWdRQTBMRy9DUUhBL3RXTFl5VkxBVmcvTnJ5UHpjdDFBd0Q4ek8xamlTN2ZuSWRNSXVLMjhUTXR5WGg2aG8xOWJOZktGQitPOUoxZGN5emJiTkx3RnBzdWUzV0lKWXhhRW1xMlRuVDVKbzQzMFZiSjZxWGVDQURRUGNrdUFBZFNuMUo1S3hJQXJMbUppTGt3QUFBTnBqV0pkdHRyMVBlTjV5RkRvVDg1TFFsS3gwclMxcy9hZldwNDdhTUpKblY1dEgwdllkUmFMZm50cm9rdWExb1NCSzlxbkFBQTZKQmxqQUFPcUpSeWw1bS9SdHZUS0FDY3ozRmhrWmt2SXVKejdGNVNIZ0M0Ykw4MXZQWnR0QzF4Y3RYQkJES0hNOTN4ZFl1R3FpNFJ5eVd2T040MXgwTm1MbmE4M2hoc3NKUlI2eEpHbTR3aEx4cy80MzBIY1p4bTVpeDJUK3k1anJZcU93QUFmRU95QzhEaDNjVHlhUlFsbndHSVVzb3NNMitqWWFJSkFMaFlpMGNtb1IvejBIZ09JbG4zdE00N3A3Rjd3c3RPTXZNdUlrWU5ieUZScGhzUEVUSGU4YlhQNCtlVmZaNDNmSzlOay9YNlVwWG9VOE4zK1ZVM0JBRG9sbVFYZ0FPclQvSGZoS2Y0QWZoNmJKalV5bCt2UlFNQTJNSzBnK3ZUbGtvRjhCZDFxWlpSTEpOVXJzTXlSSDN4Vyt5ZTdESjZwTDFiS3JzOHRINkhUVjZibVo4N2ltTkxmemJPQWdCMFRMSUx3QkhVcC9odkl1S2phSERHSnJIN3pUUzR4R1BEYmIxWmJMOEJBRGIxWndmdnNSQkdIcE9adzFoTzlBL2lyNVAyLzRxdkNRQWprZXJ0dGNZc00rZXhXN0xHOENkTGxyVWt1c3hLS2ZNTitsNXJra2hma2t6c0h3QUFIWlBzQW5Ba2RjM2ttN0JzQmVkcEZoRzNzYnlSTmhJTzJOaHRMRy9HZXVvUEFOakV0SVAzK04wNU8rdStxYzV5cFgrY2pZZll2WkxreTNxZC82MldaYVkyWGNKb2NFNzdWaWxGZ2lFQVFFZitKZ1FBeDFOS21VVEVlNUhnek13ajRsbTlnZk5KT0dDcjQ4SWlJcDdGOTI4a0F3REEzbVRtZFdaK2pJai94TElTN2V1UTZISk9QalM4OW5yTHY5L0VJWll3NmhzUE5RQUFkRWl5QzhDUmxWSnVZN25jQzV5RFJVUzhXSHRTYVNva3NQVnhRY0lMQUxBcDV3czBxMGt1WDJLWjRISXRJbWQ3blRGckdET0czeTRubEpuWHNYdlZsUWNWVGdBQWFDWFpCYUFIU2lrM0llR0YwN2VJWlVXWDJWcmZudFcvQjdZN0xraDRBUUEyUFdlQW5XVG1JRE0veHpMSlpTZ2lGNkdsdXN2b216OC9iM2d2VldBQkFHZ20yUVdnSjJyQ3k0TkljTUplckNlNnJKa0tEZXgwWEpEd0FnREFYdFFxSFYvQ01rV1hwdVcrMDh0di9yeHJGYUJGdVA4RkFFQUhKTHNBOU10Tm1OVGtSUHR1S1dYNmczLzdYWGhnTnhKZUFBRG9XazEwK1J5N0wwSEQ2VjVmekdQM0IxS3VNbk80MW9jc1lRUUF3RkZKZGdIb2tiVkp6WWxvY0VKdVNpay82N05USVlKT2pnMFNYZ0FBYUpLWmc1RG9jdWxhbGpKYVZYTjUyZkFlbGpBQ0FLQVRrbDBBZXFhVXNxaExHazFFZ3hQd1dLSkwxS1dOUExVRmpjZUdXQ2E4VEVVREFJQUc5M0g0UkJkSjIvM1N4VkpHT3k5aFZFcXhoQkVBQUozNHV4QUE5Rk1wNVNZekl5TEdva0ZQUFpyb3N1WkJYNGJtNDhJaUlwNWw1cjM5Q1FDQWJXWG1LSFpQVXRqVU5KWVBPL3daeXlTWGFVU3NsazJpSjljVm1mbXdZMSs0cXYxb3VPUEhUM2JzVTI4YSt1UGJIb1ZmNGhjQVFJY2t1d0QwV0UxNFdVVEVhOUdnUnhheFRIVFo1bW1zMzhQa1BIUjViUGd6SXQ2SkJnQUFXM2pWMGZzOHhES1paUnJMU2gwL25jQ3ZEL0xRTDU5aTk4U24rNGJQM1dVSnBaWktzY05TeWxSekF3Q2NKOHNZQWZSY0tlVTJJbTVFZ3A1WVJNU3pIY29PVDRVT09qMDJ2SS9sc2thV0NBTUEyTC9CbVd4SGExV1h0eEh4ejFMS2kxTEtYU2xsK2xpaUM3MjlucGcwWEVzTWQzemRmSmYrMHRqSGhyVVNEUUFBWjBpeUM4QUpxRGNoVEdweWJLdEVsMTF1VHMwallpNkUwT214WVJvUlQwSXBiQUNBZmJzNjlRM29ZTUwvcGlhNDdISmZZblNDSVJ0ZVFMOStPUERuZldoNDdiVGh0VzhDQUlDelpCa2pnQk5SU3BsbTVyTllsb3U5RWhFT2JCYkxSSmVXaEt0cFdNb0l1ajQyekNQaVNXYStDMHZlQVFEc3k2OW5zQTB0OXhFbTlTR2NTNHJmMDRpWW5IbS8vblRnYS9TV2VQNGV1eWROalRKejNOaUhJek1IamZ0UldGSUpBS0Jia2wwQVRrZ3BaYmFXOEhJdEloeklReXlmNG11dExQUjdTSGFCZlIwZmJqUHo5M3A4R0lnSUFFQ25yalB6NnNTWDdHazVSL3g5MXhkbTVqQ09kLytpSlVGaW5KbHZhM0w1dVY1RFBHVG1QQTVUeFdiV0dNdUhhS3ZROGk0elo0MzdjT3U5dUlld3hETUFRS2NzWXdSd1lrb3BpMUxLaTRpNEZRME80RzFkajcyTEpiUWVoQlAyZW54NGlJaGY3R3NBQUh2eE9UTWZyZXFRbVlQTTlIREtWKzlPK0x0L3JNazZtN1Q1cVZiZ1BkUzFROHNTUmxHVFZPWU5iekdvKy9Cb2x4ZG41bDIwSjIxOU1od0FBSFJMc2d2QWlTcWx2SStJSjQwWCsvQWppNGg0VVVxNTY3RFBMbUs1SEJLd3YyUERLaUh5UmQyUEFRQllhcjBXR1VURUg1bDVuNW5YcXlTSXpCeG01aWd6WDJmbXg0ajRUMFM4T3JQWVBkM2xSWms1anRPdVNudFYyL3hkYmVOVm0xL1ZQOTlsNXVmYTVxZTZuUjhPOURsZEpOWDgxc0UrL0xudXc4TU4rL0FnTSsranJhcE0xR3N6RHlVQUFIUk1zZ3ZBQ2F0UHRqeHh3VXpIWmhIeHJGYUo2TnBVZU9FZ3g0ZFZsWmVKYUFBQVJFUjNpY0RqaVBnWUVWOHlNeVBpUzBSOGptVUZrM090NkRLdWlTc2J5OHgzc1Z6MjVaaTZ1UDRjUk1UcjJzYXJOditqL3ZsTjdMNU1VbCt1RzFvcnBtemlvYVBsb0NZZDdjZmoycGIzbVRuK052R2xKcmlNYWgvK0V0MHN4L3pRVWNWY0FBRFdTSFlCT0hHZTRxZGprMWdtdXV5ckFzdnZRZ3dIUFQ3Y1JNU3pVRlVKQUhCdU5MM3dFTFJ1LzMydFpETDQwWCtvU1FManpQd1N5d1NSWTNNT3ZKbDlWM2Y1MU5FK3ZJajI2aTdyeHJGTXlQcVNhMkpacWVkejdjT0Rqajdyclc0R0FOQTl5UzRBWjZJK3hmOGtWTTVnTjZ0bGkyNzIvTFNSL2dtSFB6NU1TeWxQSXVJMkpFVUNBSmZ0a3E5SDVoMjh4NXVJK0U5bWZxNUwrOXpWbjNkcnkvbmNSOFN3SitmQmk3RDA4eVltZTM3L0xxdkd2ai9CTnAxMFZOa0dBSUJ2U0hZQk9DT2xsSGtwNVZtbzhzSjJwaEh4eTU2V0xmcTJqeTdDMDNWd3JHUEUrMWd1YmZUV01RSUF1RkNmTG5YRDYyUjdWOWRpbzFoV3ZYaFRmMTVIZjVmenNlenpZZnZHdHlaZFBsQlQzK3YyaE1KN2F0OFhBT0NrU0hZQk9FTTFhZUdYMlAvVE9aeTJSVVRjbGxLZUhYanQ2S25RdzlHT0Q0dFN5bDA5UnJ3WEVRRGd3bHo2TmZLSEM5em0zM1Q3by9hTnpoUE02ajJ2VTdtV2VYdmcreTBBQUJkRnNndkFtYW9UbWpjUjhTeFUwdUIvUGNTeW1zc3hiaEI5RW43b3hUSGlObFI2QVFBdTdCd29ManZoWlhKcDUzMjFhc2xVNzkrb2IzUnRzYThLc3ZWYXB1LzN1aDZPZE04RkFPQmlTSFlCT0hPbGxHa3A1VWxFM0lUSlRKWnJXNzhvcGJ3NDF0TkZwWlNwWm9EZUhDUG1hNVZlM3RZeGd0Tm55VGdBK0xHTFRmU3QxNENYV09ua1JyZmZxRzkwblppeTd5V2srdnh3MTF5L0F3RFlQOGt1QUJlaWxESUpUL0Jmc2tWdCt5ZjdlckpxUzFOTkFyMDZSaXhLS1hlbGxGOWllVk5Xb3NScG1zUXlvZkdmUFJuckFhQ1A1ejN6aUxpOTRPMi91N1J6dmRybWIvWCtSM1ZkaGZYRG50dDFFZjFNZUZuVWMzTDMzZ0FBOWt5eUM4QUZXVTFteGpMcFJTblZ5ekdKWlpMTFhZOXV0dnl1V2FDM3g0cEpyUWoySkM2dzFQMEplb2hsZ3RJL1N5azNrbHdBWUxQem5ianM1WXhlSE9rY2IzSEVOcis3OERiZjlMeXlxemFhSDZLcWF3OFRYaFlSOGF5VTR1RUJBSUFEa093QzhQL3QzZEZ4R2tjQUJ1RC9adkllcDRMSUZWaXVRRklGamlwd3FDQkRCM1lGY1Ftb0E2V0Rjd2ZuRGxBRndSVmNIbmJQTUxGa0dZSGdUbnpmREFNampSRHNMdHplM3IrN0o2aUdYdVlwb1plRkVubXgycFNReTZ6T1pCdmJhd1BHZmF6bzZ2ZkhieWxoQ2lHS2NWalZZL2QxU3NEbHVnYVVoSklBWUx1K3p1eFV6NGZyK2VGVkRocyttWTNnUEhDdVQvdkRkckhQcll4dUQvbTZhMWovMkpPNnVwUXhHRUVYQUlBREVYWUJPR0ZOMHl6ckFKL3RqVjZXTm1VbTBXaG5FOVVaWHRvYlRPZDRzV2lhNWpxSjRNdnh2dGVIcmVpK3JlQWk0QUlBTy9keFpqblI3VzNxdWVKVmt1VXovNnRoUzVkRmpyekNadzFGWE1kS3R6K3lyNjJNYm81UXYvTUR0ZW43ZkVvWmgxbHFRZ0FBaHlQc0FzQVFldm1RZGVqRnlmazB0Vm1IWE5xSnZGNWdXc2VMMVQzQmwwV0UxL2F0U3hrd0gxWnZ1YXBiMFprbENnRDc3OTk4U05tK3NUM0I5OTdWOS81YzRZK3VucVBlanVrY2NDTVU0WnowKzdMWngxWkczYkg2clhVczVHME9ONkZyV2R2NFhCQWRBT0R3aEYwQTJCd1VXTldMYWE4emppV0crVG1MSks4bkZISVpmRloxTVBsanhtSmpxNk5oVU5teFl6dXJyRmR1dVVvSnQ3eXRBK1pXYndHQXcvUnJ1cVpwcm1wL1pwR25YeVJmcGdSSDVoUHIwKzA3L0xGS01xOTltbTZ6bkRPU2tIVFRORzJ0ODZzZDYzd0lLUzllMEVkaTExVWNiMGJRcGora1RPaWE1M2ttZEhWSlprM1R2SjdZT0F3QXdJdnlpeUlBNElIQmdVV1NSZC8zNTBuK1N2SkhrbGRLWmpTV0tRTklueVo4SWJSVmpmQ2lqaHRkeXFCdmtxVHYrOHNrbDBrdWtwdzdoaVFwRjFHR2N2cVNJODU2QmVEQlB2YkhIZi8rS1c1eTNDQjRlOEQzM0I3cGRXN1RuNWtsbWRWejRjdmFoN2w0NEUrNkpGL3JhK3VlZUc2MlM3dHI5L2plMnlSdDMvZG5HMk1BWjFzK3pXMlNmK3A0d2tQbVd6N3Y4cG5ydkszbE9LdjkxL05INnZ6elJ0ay90YzVIL1RtbzdmRnVoNzhmeFphbnRXNCtKZmxVUDgvdjYyZjYvSWxQMmFWczgzU3JEdzhBTUE2TklnRGdaL1Y5LzJlU2R5bURYaHpIYlpLYmpXV2dwOTZtL28wTDROdjZXR2Vwd2RRKzcyY3BBOHZuS1JjUHpyTDlCWlFwYVZNdXp0d05qNXVtV1dvSkFNQkUrMisvNXZ1UXdMZmdoOVV0bUZqYnZzdzYyUFQ3UGVjbFF6OStsUkpxMHI0QkFFWkkyQVdBcHd3S25LVUVYdDduNlROaStIbGR5bXpQMjVkMm9iVHYrNysxb2EzZFBESlRFcWIyUFhDWmRmRGxUY3FBOHhSV2dsbHUzTzQySG5lMkhnSUFBQUFBZUY3Q0xnRHNaQ1A0OGk1bE9WajJZNW4xS2k2V3h3Vk85Umd6aEY2R0FFeHkvNnppWFk4L3cvWkNtNFp0Q1lidjVPWHdjMkVXQUFBQUFJRGpFbllCWUcvNnZuK1ZFbnk1cVBlMnA5bE9tL1grejB2RkFRQUFBQUFBQU44VGRnSGcyZFFaK1pleDZzdERsbGtIWEZvckJRQUFBQUFBQU1EamhGMEFPSmlOOE10RnloWVVaeWRXQkYxS3VPVkxTcmhscVZVQUFBQUFBQURBZG9SZEFEaWF1dTNSRUlCNWt4SitPWDhoYjY5TldibmxTNUt1YVpwV2pRTUFBQUFBQU1EdWhGMEFHSjI2QXN4WlN2RGw5L3A0dUkxSmwyUlY3NyttQmx5czJBSUFBQUFBQUFEUFI5Z0ZnRW5aV0EwbTlmNVZmVHlFWWpadC92NHh5M3I3LzgvdTd2bDkxelROU20wQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBY0hyK0EzTEJkNGF3OFV5TEFBQUFBRWxGVGtTdVFtQ0NcXFwiLz48L2RlZnM+PC9zdmc+XCI7IiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgZmlsbD1cXFwibm9uZVxcXCIgdmlld0JveD1cXFwiMCAwIDE2IDE2XFxcIj48cGF0aCBmaWxsPVxcXCJjdXJyZW50Q29sb3JcXFwiIHN0cm9rZT1cXFwiY3VycmVudENvbG9yXFxcIiBzdHJva2Utd2lkdGg9XFxcIi42NjdcXFwiIGQ9XFxcIk04LjMzMyA3LjMzM3YuMzMzaDIuMzM0YS4zMzMuMzMzIDAgMSAxIDAgLjY2N0g4LjMzM3YyLjMzM2EuMzMzLjMzMyAwIDEgMS0uNjY2IDBWOC4zMzNINS4zMzNhLjMzMy4zMzMgMCAwIDEgMC0uNjY3aDIuMzM0VjUuMzMzYS4zMzMuMzMzIDAgMSAxIC42NjYgMHYyWm0tMy44NTItNC42YTYuMzMzIDYuMzMzIDAgMSAxIDcuMDM4IDEwLjUzM0E2LjMzMyA2LjMzMyAwIDAgMSA0LjQ4IDIuNzM0Wm0uMzcgOS45NzhhNS42NjYgNS42NjYgMCAxIDAgNi4yOTctOS40MjIgNS42NjYgNS42NjYgMCAwIDAtNi4yOTYgOS40MjJaXFxcIi8+PC9zdmc+XCI7IiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgZmlsbD1cXFwibm9uZVxcXCIgdmlld0JveD1cXFwiMCAwIDE3IDE2XFxcIj48cGF0aCBmaWxsPVxcXCJjdXJyZW50Q29sb3JcXFwiIHN0cm9rZT1cXFwiY3VycmVudENvbG9yXFxcIiBzdHJva2Utd2lkdGg9XFxcIi42NjdcXFwiIGQ9XFxcIk04LjE2NyAzLjZ2LS44MDVsLS41Ny41NjktLjg2Ni44NjdhLjMxMi4zMTIgMCAwIDEtLjQ2MiAwIC4zMTIuMzEyIDAgMCAxIDAtLjQ2MmwyLTItLjIzNC0uMjM1LjIzNC4yMzVhLjMxMi4zMTIgMCAwIDEgLjQ2MiAwbC4yMzMtLjIzNC0uMjMzLjIzNCAyIDJhLjMxMi4zMTIgMCAwIDEgMCAuNDYyLjM2OC4zNjggMCAwIDEtLjEwOC4wOC4yOTIuMjkyIDAgMCAxLS4xMjMuMDIyLjI5Mi4yOTIgMCAwIDEtLjEyMy0uMDIxLjM2OC4zNjggMCAwIDEtLjEwOC0uMDgxbC0uODY3LS44NjctLjU2OS0uNTd2OC41MzljMCAuMTI0LS4wNC4yMDItLjA4NS4yNDgtLjA0Ni4wNDUtLjEyNC4wODUtLjI0OC4wODVzLS4yMDItLjA0LS4yNDgtLjA4NWMtLjA0NS0uMDQ2LS4wODUtLjEyNC0uMDg1LS4yNDhWMy42Wm0zIDIuNzMzSDEyLjVjLjk1IDAgMS42NjcuNzE3IDEuNjY3IDEuNjY3djQuNjY2YzAgLjk1LS43MTggMS42NjctMS42NjcgMS42NjdoLThjLS45NSAwLTEuNjY3LS43MTctMS42NjctMS42NjdWOGMwLS45NS43MTgtMS42NjcgMS42NjctMS42NjdoMS4zMzNjLjEyNSAwIC4yMDIuMDQuMjQ4LjA4Ni4wNDYuMDQ1LjA4Ni4xMjMuMDg2LjI0NyAwIC4xMjUtLjA0LjIwMi0uMDg2LjI0OC0uMDQ2LjA0Ni0uMTIzLjA4Ni0uMjQ4LjA4Nkg0LjVhMSAxIDAgMCAwLS43MTkuMjhBMSAxIDAgMCAwIDMuNSA4djQuNjY2YTEgMSAwIDAgMCAuMjgxLjcyIDEgMSAwIDAgMCAuNzE5LjI4aDhhMSAxIDAgMCAwIC43MTktLjI4IDEgMSAwIDAgMCAuMjgxLS43MlY4YTEgMSAwIDAgMC0uMjgxLS43MkExIDEgMCAwIDAgMTIuNSA3aC0xLjMzM2MtLjEyNSAwLS4yMDItLjA0LS4yNDgtLjA4Ni0uMDQ2LS4wNDYtLjA4Ni0uMTIzLS4wODYtLjI0OCAwLS4xMjQuMDQtLjIwMi4wODYtLjI0Ny4wNDYtLjA0Ni4xMjMtLjA4Ni4yNDgtLjA4NlpcXFwiLz48L3N2Zz5cIjsiLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiBmaWxsPVxcXCJub25lXFxcIiB2aWV3Qm94PVxcXCIwIDAgMTUgMTRcXFwiPjxwYXRoIGZpbGw9XFxcImN1cnJlbnRDb2xvclxcXCIgc3Ryb2tlPVxcXCJjdXJyZW50Q29sb3JcXFwiIHN0cm9rZS13aWR0aD1cXFwiLjY2N1xcXCIgZD1cXFwiTTcuNSA0LjY2NmExIDEgMCAwIDAtLjg2OS41bC0uMDA2LjAxMmEuMzMzLjMzMyAwIDAgMS0uMjAzLjE2NmwuMDkzLjMyLS4wOTMtLjMyYS4zMzMuMzMzIDAgMCAxLS4zNi0uMTJsLS4yNjYuMi4yNjctLjJhLjMzMy4zMzMgMCAwIDEtLjAxNS0uMzc5bC4wMDQtLjAwNi4wMDMtLjAwNkExLjY2NyAxLjY2NyAwIDAgMSA3LjUgNGExLjY2NyAxLjY2NyAwIDAgMSAuNTU0IDMuMjMzbC0uMjIuMDh2LjM1M2EuMzMzLjMzMyAwIDEgMS0uNjY2IDBWN2EuMzMzLjMzMyAwIDAgMSAuMzMzLS4zMzQgMSAxIDAgMCAwIDAtMlptMCAwVjVsLjAwMS0uMzM0Wm0tLjMxNiA0Ljg5OC4wMS0uMDIuMDA4LS4wMjNhLjE3My4xNzMgMCAwIDEgLjAyLS4wMzkgMS4yIDEuMiAwIDAgMSAuMDQ2LS4wNi4zMzMuMzMzIDAgMCAxIC4xMDQtLjA2N2wtLjEyOC0uMzA4LjEyOC4zMDhhLjMzMy4zMzMgMCAwIDEgLjM2NS4wNzMuMzMzLjMzMyAwIDAgMSAuMDk2LjIzNnYuMDE1YS4zMzMuMzMzIDAgMCAxLS4wMi4xMjZ2LjAwMWEuMjY3LjI2NyAwIDAgMS0uMDYyLjA5OGwuMjM2LjIzNi0uMjM2LS4yMzZhLjI2Ny4yNjcgMCAwIDEtLjA5OC4wNjJsLS4wMS4wMDQtLjAxMS4wMDVhLjI5My4yOTMgMCAwIDEtLjIzNyAwbC0uMDEtLjAwNS0uMDEyLS4wMDRhLjI2Ny4yNjcgMCAwIDEtLjA5Ny0uMDYybC0uMjM2LjIzNi4yMzYtLjIzNmEuMjY3LjI2NyAwIDAgMS0uMDYzLS4wOThsLS4wMDUtLjAxNC0uMDA3LS4wMTVhLjIyNy4yMjcgMCAwIDEtLjAyMS0uMTAydi0uMDMzYS41NzMuNTczIDAgMCAxLS4wMDItLjA2NC4wOTQuMDk0IDAgMCAxIC4wMDYtLjAxNFpNMy45OCAxLjczNGE2LjMzMyA2LjMzMyAwIDEgMSA3LjAzOCAxMC41MzJBNi4zMzMgNi4zMzMgMCAwIDEgMy45OCAxLjczNFptLjM3IDkuOTc3YTUuNjY2IDUuNjY2IDAgMSAwIDYuMjk3LTkuNDIyIDUuNjY2IDUuNjY2IDAgMCAwLTYuMjk2IDkuNDIyWlxcXCIvPjwvc3ZnPlwiOyIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIGZpbGw9XFxcIm5vbmVcXFwiIHZpZXdCb3g9XFxcIjAgMCAxNiAxNlxcXCI+PHBhdGggZmlsbD1cXFwiI2ZmZlxcXCIgZD1cXFwiTTYuODc1IDEwLjcyOWEuNjY1LjY2NSAwIDAgMS0uNDcxLS4xOTZMNC41MjkgOC42NThhLjY2Ny42NjcgMCAwIDEgLjk0Mi0uOTQybDEuNDA0IDEuNDAzIDMuNjU0LTMuNjUzYS42NjcuNjY3IDAgMCAxIC45NDIuOTQybC00LjEyNSA0LjEyNWEuNjY0LjY2NCAwIDAgMS0uNDcxLjE5NlpcXFwiIG9wYWNpdHk9XFxcIi45OVxcXCIvPjxwYXRoIGZpbGw9XFxcImN1cnJlbnRDb2xvclxcXCIgZD1cXFwiTTggMS4zMzNBNi42NjcgNi42NjcgMCAxIDAgMTQuNjY3IDggNi42NzQgNi42NzQgMCAwIDAgOCAxLjMzM1ptMy40NzEgNS4wNzYtNC4xMjUgNC4xMjVhLjY2Ny42NjcgMCAwIDEtLjk0MiAwTDQuNTI5IDguNjU5YS42NjcuNjY3IDAgMCAxIC45NDItLjk0M2wxLjQwNCAxLjQwMyAzLjY1NC0zLjY1M2EuNjY3LjY2NyAwIDAgMSAuOTQyLjk0M1pcXFwiLz48L3N2Zz5cIjsiLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgdmlld0JveD1cXFwiMCAwIDE2IDE2XFxcIiBmaWxsPVxcXCJub25lXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIm0zLjgzNyAxMS42NDMtLjEyOC4zMTQuMjQzLjIzNUE1LjgzMyA1LjgzMyAwIDAgMCA4IDEzLjgzM2guMDAyYTUuODMzIDUuODMzIDAgMCAwIDQuMDQ3LTEuNjRsLjI0My0uMjM2LS4xMjktLjMxNGE0LjUgNC41IDAgMCAwLTguMzI1IDBabTguMzM4LS43MjQuNDMuNzM2LjQzMy0uNzM2QTUuNzggNS43OCAwIDAgMCAxMy44MzMgOCA1LjgzMyA1LjgzMyAwIDAgMCAyLjE2NyA4YTUuNzggNS43OCAwIDAgMCAuNzk1IDIuOTJsLjQzMi43MzYuNDMtLjczN2E0LjgzMyA0LjgzMyAwIDAgMSAyLjM2My0yLjA0MmwuNjU1LS4yNjUtLjQ2Ny0uNTNhMi4xNjcgMi4xNjcgMCAxIDEgMy4yNSAwbC0uNDY3LjUzLjY1NS4yNjVhNC44MzMgNC44MzMgMCAwIDEgMi4zNjIgMi4wNDJaTTQuNjM1IDIuODRjMS0uNjU1IDIuMTctMS4wMDUgMy4zNjUtMS4wMDdhNi4xNjYgNi4xNjYgMCAwIDEgNC41MzIgMTAuMzM1IDYuMTY3IDYuMTY3IDAgMCAxLTkuMDY0IDBBNi4xNjcgNi4xNjcgMCAwIDEgNC42MzUgMi44NFptMS44NCAyLjgwOGExLjgzMyAxLjgzMyAwIDEgMCAzLjA1IDIuMDM3IDEuODMzIDEuODMzIDAgMCAwLTMuMDUtMi4wMzdaXFxcIiBmaWxsPVxcXCJ0cmFuc3BhcmVudFxcXCIgc3Ryb2tlPVxcXCJjdXJyZW50Q29sb3JcXFwiLz48L3N2Zz5cIjsiLCJpbXBvcnQgYXBpIGZyb20gXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICAgICAgICBpbXBvcnQgY29udGVudCBmcm9tIFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC0xNC51c2VbMV0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTE0LnVzZVsyXSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtMTQudXNlWzNdIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMF0udXNlWzBdIS4vQWxlcnRNZXNzYWdlLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTY1N2ZhMzQyJmxhbmc9c2NzcyZzY29wZWQ9dHJ1ZVwiO1xuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCBkZWZhdWx0IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsImltcG9ydCBhcGkgZnJvbSBcIiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgICAgICAgIGltcG9ydCBjb250ZW50IGZyb20gXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTE0LnVzZVsxXSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtMTQudXNlWzJdIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC0xNC51c2VbM10hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFswXS51c2VbMF0hLi9Qb3B1cE1vZGFsLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTVhMmJkYTU4Jmxhbmc9c2NzcyZzY29wZWQ9dHJ1ZVwiO1xuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCBkZWZhdWx0IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNPbGRJRSA9IGZ1bmN0aW9uIGlzT2xkSUUoKSB7XG4gIHZhciBtZW1vO1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUoKSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3NcbiAgICAgIC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcbiAgICAgIC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcbiAgICAgIC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG4gICAgICBtZW1vID0gQm9vbGVhbih3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG59KCk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiBnZXRUYXJnZXQoKSB7XG4gIHZhciBtZW1vID0ge307XG4gIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSh0YXJnZXQpIHtcbiAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTsgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblxuICAgICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbiAgfTtcbn0oKTtcblxudmFyIHN0eWxlc0luRG9tID0gW107XG5cbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5Eb20ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5Eb21baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXVxuICAgIH07XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcysrO1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnVwZGF0ZXIob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzSW5Eb20ucHVzaCh7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgIHVwZGF0ZXI6IGFkZFN0eWxlKG9iaiwgb3B0aW9ucyksXG4gICAgICAgIHJlZmVyZW5jZXM6IDFcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gIH1cblxuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHZhciBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9O1xuXG4gIGlmICh0eXBlb2YgYXR0cmlidXRlcy5ub25jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09ICd1bmRlZmluZWQnID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuXG4gICAgaWYgKG5vbmNlKSB7XG4gICAgICBhdHRyaWJ1dGVzLm5vbmNlID0gbm9uY2U7XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgfSk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KG9wdGlvbnMuaW5zZXJ0IHx8ICdoZWFkJyk7XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICB9XG5cbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG52YXIgcmVwbGFjZVRleHQgPSBmdW5jdGlvbiByZXBsYWNlVGV4dCgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdO1xuICByZXR1cm4gZnVuY3Rpb24gcmVwbGFjZShpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG4gICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG4gIH07XG59KCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmoubWVkaWEgPyBcIkBtZWRpYSBcIi5jb25jYXQob2JqLm1lZGlhLCBcIiB7XCIpLmNvbmNhdChvYmouY3NzLCBcIn1cIikgOiBvYmouY3NzOyAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgIH1cblxuICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgc3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzcztcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZSgnbWVkaWEnKTtcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH0gLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZS5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhciBzaW5nbGV0b25Db3VudGVyID0gMDtcblxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBzdHlsZTtcbiAgdmFyIHVwZGF0ZTtcbiAgdmFyIHJlbW92ZTtcblxuICBpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcbiAgICB2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcbiAgICBzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcbiAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cbiAgICByZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuICAgIH07XG4gIH1cblxuICB1cGRhdGUob2JqKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKCk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbiAgLy8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXG4gIGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSAnYm9vbGVhbicpIHtcbiAgICBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcbiAgfVxuXG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICB2YXIgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3TGlzdCkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgfVxuXG4gICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2lkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbX2ldO1xuXG4gICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuXG4gICAgICBpZiAoc3R5bGVzSW5Eb21bX2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgIHN0eWxlc0luRG9tW19pbmRleF0udXBkYXRlcigpO1xuXG4gICAgICAgIHN0eWxlc0luRG9tLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgfTtcbn07IiwiaW1wb3J0IHsgY29tcHV0ZWQsIG9wZW5CbG9jaywgY3JlYXRlQmxvY2ssIG1lcmdlUHJvcHMgfSBmcm9tICd2dWUnO1xuXG52YXIgc2NyaXB0ID0ge1xuICBuYW1lOiAnU3ZnVnVlJyxcbiAgcHJvcHM6IHtcbiAgICBpY29uOiBTdHJpbmdcbiAgfSxcblxuICBzZXR1cChwcm9wcykge1xuICAgIGNvbnN0IGljb25QYXRoID0gY29tcHV0ZWQoKCkgPT4gcHJvcHMuaWNvbi5yZXBsYWNlKG5ldyBSZWdFeHAoJy4nLnJlcGxhY2UoLyhbLiorP149IToke30oKXxcXFtcXF1cXC9cXFxcXSkvZywgJ1xcXFwkMScpLCAnZycpLCAnLycpICsgJy5zdmcnKTtcbiAgICBjb25zdCBzdmdTdHJpbmcgPSBjb21wdXRlZCgoKSA9PiByZXF1aXJlKGBzdmctZmlsZXMtcGF0aC8ke2ljb25QYXRoLnZhbHVlfWApLmRlZmF1bHQpO1xuICAgIGNvbnN0IHN2Z0F0dHJpYnV0ZXMgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgICBpZiAoIXN2Z1N0cmluZykgcmV0dXJuIHt9O1xuICAgICAgbGV0IHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHdyYXBwZXIuaW5uZXJIVE1MID0gc3ZnU3RyaW5nLnZhbHVlO1xuICAgICAgbGV0IGF0dHJpYnV0ZXNMaXN0ID0gd3JhcHBlci5maXJzdEVsZW1lbnRDaGlsZC5hdHRyaWJ1dGVzO1xuICAgICAgbGV0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXNMaXN0KS5tYXAoaSA9PiBhdHRyaWJ1dGVzW2F0dHJpYnV0ZXNMaXN0W2ldLm5hbWVdID0gYXR0cmlidXRlc0xpc3RbaV0udmFsdWUpO1xuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgfSk7XG4gICAgY29uc3Qgc3ZnQ29udGVudCA9IGNvbXB1dGVkKCgpID0+IHN2Z1N0cmluZyA/IHN2Z1N0cmluZy52YWx1ZS5yZXBsYWNlKC9ePHN2Z1tePl0qPnw8XFwvc3ZnPiQvZywgJycpIDogbnVsbCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN2Z0F0dHJpYnV0ZXMsXG4gICAgICBzdmdDb250ZW50XG4gICAgfTtcbiAgfVxuXG59O1xuXG5mdW5jdGlvbiByZW5kZXIoX2N0eCwgX2NhY2hlLCAkcHJvcHMsICRzZXR1cCwgJGRhdGEsICRvcHRpb25zKSB7XG4gIHJldHVybiBvcGVuQmxvY2soKSwgY3JlYXRlQmxvY2soXCJzdmdcIiwgbWVyZ2VQcm9wcygkc2V0dXAuc3ZnQXR0cmlidXRlcywge1xuICAgIGlubmVySFRNTDogJHNldHVwLnN2Z0NvbnRlbnRcbiAgfSksIG51bGwsIDE2LCBbXCJpbm5lckhUTUxcIl0pO1xufVxuXG5zY3JpcHQucmVuZGVyID0gcmVuZGVyO1xuXG4vLyBJbXBvcnQgdnVlIGNvbXBvbmVudFxuLy8gSUlGRSBpbmplY3RzIGluc3RhbGwgZnVuY3Rpb24gaW50byBjb21wb25lbnQsIGFsbG93aW5nIGNvbXBvbmVudFxuLy8gdG8gYmUgcmVnaXN0ZXJlZCB2aWEgVnVlLnVzZSgpIGFzIHdlbGwgYXMgVnVlLmNvbXBvbmVudCgpLFxuXG52YXIgZW50cnlfZXNtID0gLyojX19QVVJFX18qLygoKSA9PiB7XG4gIC8vIEdldCBjb21wb25lbnQgaW5zdGFuY2VcbiAgY29uc3QgaW5zdGFsbGFibGUgPSBzY3JpcHQ7IC8vIEF0dGFjaCBpbnN0YWxsIGZ1bmN0aW9uIGV4ZWN1dGVkIGJ5IFZ1ZS51c2UoKVxuXG4gIGluc3RhbGxhYmxlLmluc3RhbGwgPSBhcHAgPT4ge1xuICAgIGFwcC5jb21wb25lbnQoJ1N2Z1Z1ZScsIGluc3RhbGxhYmxlKTtcbiAgfTtcblxuICByZXR1cm4gaW5zdGFsbGFibGU7XG59KSgpOyAvLyBJdCdzIHBvc3NpYmxlIHRvIGV4cG9zZSBuYW1lZCBleHBvcnRzIHdoZW4gd3JpdGluZyBjb21wb25lbnRzIHRoYXQgY2FuXG4vLyBhbHNvIGJlIHVzZWQgYXMgZGlyZWN0aXZlcywgZXRjLiAtIGVnLiBpbXBvcnQgeyBSb2xsdXBEZW1vRGlyZWN0aXZlIH0gZnJvbSAncm9sbHVwLWRlbW8nO1xuLy8gZXhwb3J0IGNvbnN0IFJvbGx1cERlbW9EaXJlY3RpdmUgPSBkaXJlY3RpdmU7XG5cbmV4cG9ydCBkZWZhdWx0IGVudHJ5X2VzbTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gcnVudGltZSBoZWxwZXIgZm9yIHNldHRpbmcgcHJvcGVydGllcyBvbiBjb21wb25lbnRzXG4vLyBpbiBhIHRyZWUtc2hha2FibGUgd2F5XG5leHBvcnRzLmRlZmF1bHQgPSAoc2ZjLCBwcm9wcykgPT4ge1xuICAgIGNvbnN0IHRhcmdldCA9IHNmYy5fX3ZjY09wdHMgfHwgc2ZjO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiBwcm9wcykge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG4iLCJpbXBvcnQgeyByZW5kZXIgfSBmcm9tIFwiLi9BZG1pbkhlYWRlci52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NmZlNTkwNTUmdHM9dHJ1ZVwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL0FkbWluSGVhZGVyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10c1wiXG5leHBvcnQgKiBmcm9tIFwiLi9BZG1pbkhlYWRlci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9dHNcIlxuXG5pbXBvcnQgZXhwb3J0Q29tcG9uZW50IGZyb20gXCIvVXNlcnMvdGl0dW5nZHVwL3Byb2plY3RzL2lhdGlwdWJsaXNoZXIvbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9leHBvcnRIZWxwZXIuanNcIlxuY29uc3QgX19leHBvcnRzX18gPSAvKiNfX1BVUkVfXyovZXhwb3J0Q29tcG9uZW50KHNjcmlwdCwgW1sncmVuZGVyJyxyZW5kZXJdLFsnX19maWxlJyxcInJlc291cmNlcy9hc3NldHMvanMvY29tcG9uZW50cy9BZG1pbkhlYWRlci52dWVcIl1dKVxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgX19leHBvcnRzX18uX19obXJJZCA9IFwiNmZlNTkwNTVcIlxuICBjb25zdCBhcGkgPSBfX1ZVRV9ITVJfUlVOVElNRV9fXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFhcGkuY3JlYXRlUmVjb3JkKCc2ZmU1OTA1NScsIF9fZXhwb3J0c19fKSkge1xuICAgIGFwaS5yZWxvYWQoJzZmZTU5MDU1JywgX19leHBvcnRzX18pXG4gIH1cbiAgXG4gIG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9BZG1pbkhlYWRlci52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NmZlNTkwNTUmdHM9dHJ1ZVwiLCAoKSA9PiB7XG4gICAgYXBpLnJlcmVuZGVyKCc2ZmU1OTA1NScsIHJlbmRlcilcbiAgfSlcblxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IF9fZXhwb3J0c19fIiwiaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSBcIi4vQWxlcnRNZXNzYWdlLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD02NTdmYTM0MiZzY29wZWQ9dHJ1ZSZ0cz10cnVlXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vQWxlcnRNZXNzYWdlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10c1wiXG5leHBvcnQgKiBmcm9tIFwiLi9BbGVydE1lc3NhZ2UudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPXRzXCJcblxuaW1wb3J0IFwiLi9BbGVydE1lc3NhZ2UudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9NjU3ZmEzNDImbGFuZz1zY3NzJnNjb3BlZD10cnVlXCJcblxuaW1wb3J0IGV4cG9ydENvbXBvbmVudCBmcm9tIFwiL1VzZXJzL3RpdHVuZ2R1cC9wcm9qZWN0cy9pYXRpcHVibGlzaGVyL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvZXhwb3J0SGVscGVyLmpzXCJcbmNvbnN0IF9fZXhwb3J0c19fID0gLyojX19QVVJFX18qL2V4cG9ydENvbXBvbmVudChzY3JpcHQsIFtbJ3JlbmRlcicscmVuZGVyXSxbJ19fc2NvcGVJZCcsXCJkYXRhLXYtNjU3ZmEzNDJcIl0sWydfX2ZpbGUnLFwicmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnRzL0FsZXJ0TWVzc2FnZS52dWVcIl1dKVxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgX19leHBvcnRzX18uX19obXJJZCA9IFwiNjU3ZmEzNDJcIlxuICBjb25zdCBhcGkgPSBfX1ZVRV9ITVJfUlVOVElNRV9fXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFhcGkuY3JlYXRlUmVjb3JkKCc2NTdmYTM0MicsIF9fZXhwb3J0c19fKSkge1xuICAgIGFwaS5yZWxvYWQoJzY1N2ZhMzQyJywgX19leHBvcnRzX18pXG4gIH1cbiAgXG4gIG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9BbGVydE1lc3NhZ2UudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTY1N2ZhMzQyJnNjb3BlZD10cnVlJnRzPXRydWVcIiwgKCkgPT4ge1xuICAgIGFwaS5yZXJlbmRlcignNjU3ZmEzNDInLCByZW5kZXIpXG4gIH0pXG5cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBfX2V4cG9ydHNfXyIsImltcG9ydCB7IHJlbmRlciB9IGZyb20gXCIuL1BhZ2luYXRpb24udnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTM4OTVhZmRlJnRzPXRydWVcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9QYWdpbmF0aW9uLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10c1wiXG5leHBvcnQgKiBmcm9tIFwiLi9QYWdpbmF0aW9uLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10c1wiXG5cbmltcG9ydCBleHBvcnRDb21wb25lbnQgZnJvbSBcIi9Vc2Vycy90aXR1bmdkdXAvcHJvamVjdHMvaWF0aXB1Ymxpc2hlci9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2V4cG9ydEhlbHBlci5qc1wiXG5jb25zdCBfX2V4cG9ydHNfXyA9IC8qI19fUFVSRV9fKi9leHBvcnRDb21wb25lbnQoc2NyaXB0LCBbWydyZW5kZXInLHJlbmRlcl0sWydfX2ZpbGUnLFwicmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnRzL1BhZ2luYXRpb24udnVlXCJdXSlcbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7XG4gIF9fZXhwb3J0c19fLl9faG1ySWQgPSBcIjM4OTVhZmRlXCJcbiAgY29uc3QgYXBpID0gX19WVUVfSE1SX1JVTlRJTUVfX1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghYXBpLmNyZWF0ZVJlY29yZCgnMzg5NWFmZGUnLCBfX2V4cG9ydHNfXykpIHtcbiAgICBhcGkucmVsb2FkKCczODk1YWZkZScsIF9fZXhwb3J0c19fKVxuICB9XG4gIFxuICBtb2R1bGUuaG90LmFjY2VwdChcIi4vUGFnaW5hdGlvbi52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9Mzg5NWFmZGUmdHM9dHJ1ZVwiLCAoKSA9PiB7XG4gICAgYXBpLnJlcmVuZGVyKCczODk1YWZkZScsIHJlbmRlcilcbiAgfSlcblxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IF9fZXhwb3J0c19fIiwiaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSBcIi4vUG9wdXBNb2RhbC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NWEyYmRhNTgmc2NvcGVkPXRydWUmdHM9dHJ1ZVwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL1BvcHVwTW9kYWwudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPXRzXCJcbmV4cG9ydCAqIGZyb20gXCIuL1BvcHVwTW9kYWwudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPXRzXCJcblxuaW1wb3J0IFwiLi9Qb3B1cE1vZGFsLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTVhMmJkYTU4Jmxhbmc9c2NzcyZzY29wZWQ9dHJ1ZVwiXG5cbmltcG9ydCBleHBvcnRDb21wb25lbnQgZnJvbSBcIi9Vc2Vycy90aXR1bmdkdXAvcHJvamVjdHMvaWF0aXB1Ymxpc2hlci9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2V4cG9ydEhlbHBlci5qc1wiXG5jb25zdCBfX2V4cG9ydHNfXyA9IC8qI19fUFVSRV9fKi9leHBvcnRDb21wb25lbnQoc2NyaXB0LCBbWydyZW5kZXInLHJlbmRlcl0sWydfX3Njb3BlSWQnLFwiZGF0YS12LTVhMmJkYTU4XCJdLFsnX19maWxlJyxcInJlc291cmNlcy9hc3NldHMvanMvY29tcG9uZW50cy9Qb3B1cE1vZGFsLnZ1ZVwiXV0pXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkge1xuICBfX2V4cG9ydHNfXy5fX2htcklkID0gXCI1YTJiZGE1OFwiXG4gIGNvbnN0IGFwaSA9IF9fVlVFX0hNUl9SVU5USU1FX19cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIWFwaS5jcmVhdGVSZWNvcmQoJzVhMmJkYTU4JywgX19leHBvcnRzX18pKSB7XG4gICAgYXBpLnJlbG9hZCgnNWEyYmRhNTgnLCBfX2V4cG9ydHNfXylcbiAgfVxuICBcbiAgbW9kdWxlLmhvdC5hY2NlcHQoXCIuL1BvcHVwTW9kYWwudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTVhMmJkYTU4JnNjb3BlZD10cnVlJnRzPXRydWVcIiwgKCkgPT4ge1xuICAgIGFwaS5yZXJlbmRlcignNWEyYmRhNTgnLCByZW5kZXIpXG4gIH0pXG5cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBfX2V4cG9ydHNfXyIsImltcG9ydCB7IHJlbmRlciB9IGZyb20gXCIuL1RvYXN0TWVzc2FnZS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9ZDAxZDhjZDImdHM9dHJ1ZVwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL1RvYXN0TWVzc2FnZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9dHNcIlxuZXhwb3J0ICogZnJvbSBcIi4vVG9hc3RNZXNzYWdlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10c1wiXG5cbmltcG9ydCBleHBvcnRDb21wb25lbnQgZnJvbSBcIi9Vc2Vycy90aXR1bmdkdXAvcHJvamVjdHMvaWF0aXB1Ymxpc2hlci9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2V4cG9ydEhlbHBlci5qc1wiXG5jb25zdCBfX2V4cG9ydHNfXyA9IC8qI19fUFVSRV9fKi9leHBvcnRDb21wb25lbnQoc2NyaXB0LCBbWydyZW5kZXInLHJlbmRlcl0sWydfX2ZpbGUnLFwicmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnRzL1RvYXN0TWVzc2FnZS52dWVcIl1dKVxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgX19leHBvcnRzX18uX19obXJJZCA9IFwiZDAxZDhjZDJcIlxuICBjb25zdCBhcGkgPSBfX1ZVRV9ITVJfUlVOVElNRV9fXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFhcGkuY3JlYXRlUmVjb3JkKCdkMDFkOGNkMicsIF9fZXhwb3J0c19fKSkge1xuICAgIGFwaS5yZWxvYWQoJ2QwMWQ4Y2QyJywgX19leHBvcnRzX18pXG4gIH1cbiAgXG4gIG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9Ub2FzdE1lc3NhZ2UudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPWQwMWQ4Y2QyJnRzPXRydWVcIiwgKCkgPT4ge1xuICAgIGFwaS5yZXJlbmRlcignZDAxZDhjZDInLCByZW5kZXIpXG4gIH0pXG5cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBfX2V4cG9ydHNfXyIsImltcG9ydCB7IHJlbmRlciB9IGZyb20gXCIuL0FjdGl2aXR5TGlzdC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MjIyMmVkNmMmdHM9dHJ1ZVwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL0FjdGl2aXR5TGlzdC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9dHNcIlxuZXhwb3J0ICogZnJvbSBcIi4vQWN0aXZpdHlMaXN0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10c1wiXG5cbmltcG9ydCBleHBvcnRDb21wb25lbnQgZnJvbSBcIi9Vc2Vycy90aXR1bmdkdXAvcHJvamVjdHMvaWF0aXB1Ymxpc2hlci9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2V4cG9ydEhlbHBlci5qc1wiXG5jb25zdCBfX2V4cG9ydHNfXyA9IC8qI19fUFVSRV9fKi9leHBvcnRDb21wb25lbnQoc2NyaXB0LCBbWydyZW5kZXInLHJlbmRlcl0sWydfX2ZpbGUnLFwicmVzb3VyY2VzL2Fzc2V0cy9qcy92aWV3cy9hY3Rpdml0eS9BY3Rpdml0eUxpc3QudnVlXCJdXSlcbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7XG4gIF9fZXhwb3J0c19fLl9faG1ySWQgPSBcIjIyMjJlZDZjXCJcbiAgY29uc3QgYXBpID0gX19WVUVfSE1SX1JVTlRJTUVfX1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghYXBpLmNyZWF0ZVJlY29yZCgnMjIyMmVkNmMnLCBfX2V4cG9ydHNfXykpIHtcbiAgICBhcGkucmVsb2FkKCcyMjIyZWQ2YycsIF9fZXhwb3J0c19fKVxuICB9XG4gIFxuICBtb2R1bGUuaG90LmFjY2VwdChcIi4vQWN0aXZpdHlMaXN0LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0yMjIyZWQ2YyZ0cz10cnVlXCIsICgpID0+IHtcbiAgICBhcGkucmVyZW5kZXIoJzIyMjJlZDZjJywgcmVuZGVyKVxuICB9KVxuXG59XG5cblxuZXhwb3J0IGRlZmF1bHQgX19leHBvcnRzX18iLCJpbXBvcnQgeyByZW5kZXIgfSBmcm9tIFwiLi9BZGRBY3Rpdml0eUJ1dHRvbi52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MDUwZTE3M2MmdHM9dHJ1ZVwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL0FkZEFjdGl2aXR5QnV0dG9uLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10c1wiXG5leHBvcnQgKiBmcm9tIFwiLi9BZGRBY3Rpdml0eUJ1dHRvbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9dHNcIlxuXG5pbXBvcnQgZXhwb3J0Q29tcG9uZW50IGZyb20gXCIvVXNlcnMvdGl0dW5nZHVwL3Byb2plY3RzL2lhdGlwdWJsaXNoZXIvbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9leHBvcnRIZWxwZXIuanNcIlxuY29uc3QgX19leHBvcnRzX18gPSAvKiNfX1BVUkVfXyovZXhwb3J0Q29tcG9uZW50KHNjcmlwdCwgW1sncmVuZGVyJyxyZW5kZXJdLFsnX19maWxlJyxcInJlc291cmNlcy9hc3NldHMvanMvdmlld3MvYWN0aXZpdHkvcGFydGlhbHMvQWRkQWN0aXZpdHlCdXR0b24udnVlXCJdXSlcbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7XG4gIF9fZXhwb3J0c19fLl9faG1ySWQgPSBcIjA1MGUxNzNjXCJcbiAgY29uc3QgYXBpID0gX19WVUVfSE1SX1JVTlRJTUVfX1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghYXBpLmNyZWF0ZVJlY29yZCgnMDUwZTE3M2MnLCBfX2V4cG9ydHNfXykpIHtcbiAgICBhcGkucmVsb2FkKCcwNTBlMTczYycsIF9fZXhwb3J0c19fKVxuICB9XG4gIFxuICBtb2R1bGUuaG90LmFjY2VwdChcIi4vQWRkQWN0aXZpdHlCdXR0b24udnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTA1MGUxNzNjJnRzPXRydWVcIiwgKCkgPT4ge1xuICAgIGFwaS5yZXJlbmRlcignMDUwZTE3M2MnLCByZW5kZXIpXG4gIH0pXG5cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBfX2V4cG9ydHNfXyIsImltcG9ydCB7IHJlbmRlciB9IGZyb20gXCIuL0VtcHR5QWN0aXZpdHkudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTlhZWY5Njg4JnRzPXRydWVcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9FbXB0eUFjdGl2aXR5LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10c1wiXG5leHBvcnQgKiBmcm9tIFwiLi9FbXB0eUFjdGl2aXR5LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10c1wiXG5cbmltcG9ydCBleHBvcnRDb21wb25lbnQgZnJvbSBcIi9Vc2Vycy90aXR1bmdkdXAvcHJvamVjdHMvaWF0aXB1Ymxpc2hlci9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2V4cG9ydEhlbHBlci5qc1wiXG5jb25zdCBfX2V4cG9ydHNfXyA9IC8qI19fUFVSRV9fKi9leHBvcnRDb21wb25lbnQoc2NyaXB0LCBbWydyZW5kZXInLHJlbmRlcl0sWydfX2ZpbGUnLFwicmVzb3VyY2VzL2Fzc2V0cy9qcy92aWV3cy9hY3Rpdml0eS9wYXJ0aWFscy9FbXB0eUFjdGl2aXR5LnZ1ZVwiXV0pXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkge1xuICBfX2V4cG9ydHNfXy5fX2htcklkID0gXCI5YWVmOTY4OFwiXG4gIGNvbnN0IGFwaSA9IF9fVlVFX0hNUl9SVU5USU1FX19cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIWFwaS5jcmVhdGVSZWNvcmQoJzlhZWY5Njg4JywgX19leHBvcnRzX18pKSB7XG4gICAgYXBpLnJlbG9hZCgnOWFlZjk2ODgnLCBfX2V4cG9ydHNfXylcbiAgfVxuICBcbiAgbW9kdWxlLmhvdC5hY2NlcHQoXCIuL0VtcHR5QWN0aXZpdHkudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTlhZWY5Njg4JnRzPXRydWVcIiwgKCkgPT4ge1xuICAgIGFwaS5yZXJlbmRlcignOWFlZjk2ODgnLCByZW5kZXIpXG4gIH0pXG5cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBfX2V4cG9ydHNfXyIsImltcG9ydCB7IHJlbmRlciB9IGZyb20gXCIuL1BhZ2VUaXRsZS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NzU4OWU4NmUmdHM9dHJ1ZVwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL1BhZ2VUaXRsZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9dHNcIlxuZXhwb3J0ICogZnJvbSBcIi4vUGFnZVRpdGxlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10c1wiXG5cbmltcG9ydCBleHBvcnRDb21wb25lbnQgZnJvbSBcIi9Vc2Vycy90aXR1bmdkdXAvcHJvamVjdHMvaWF0aXB1Ymxpc2hlci9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2V4cG9ydEhlbHBlci5qc1wiXG5jb25zdCBfX2V4cG9ydHNfXyA9IC8qI19fUFVSRV9fKi9leHBvcnRDb21wb25lbnQoc2NyaXB0LCBbWydyZW5kZXInLHJlbmRlcl0sWydfX2ZpbGUnLFwicmVzb3VyY2VzL2Fzc2V0cy9qcy92aWV3cy9hY3Rpdml0eS9wYXJ0aWFscy9QYWdlVGl0bGUudnVlXCJdXSlcbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7XG4gIF9fZXhwb3J0c19fLl9faG1ySWQgPSBcIjc1ODllODZlXCJcbiAgY29uc3QgYXBpID0gX19WVUVfSE1SX1JVTlRJTUVfX1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghYXBpLmNyZWF0ZVJlY29yZCgnNzU4OWU4NmUnLCBfX2V4cG9ydHNfXykpIHtcbiAgICBhcGkucmVsb2FkKCc3NTg5ZTg2ZScsIF9fZXhwb3J0c19fKVxuICB9XG4gIFxuICBtb2R1bGUuaG90LmFjY2VwdChcIi4vUGFnZVRpdGxlLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD03NTg5ZTg2ZSZ0cz10cnVlXCIsICgpID0+IHtcbiAgICBhcGkucmVyZW5kZXIoJzc1ODllODZlJywgcmVuZGVyKVxuICB9KVxuXG59XG5cblxuZXhwb3J0IGRlZmF1bHQgX19leHBvcnRzX18iLCJpbXBvcnQgeyByZW5kZXIgfSBmcm9tIFwiLi9UYWJsZUxheW91dC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NWQ4NGExZDgmdHM9dHJ1ZVwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL1RhYmxlTGF5b3V0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10c1wiXG5leHBvcnQgKiBmcm9tIFwiLi9UYWJsZUxheW91dC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9dHNcIlxuXG5pbXBvcnQgZXhwb3J0Q29tcG9uZW50IGZyb20gXCIvVXNlcnMvdGl0dW5nZHVwL3Byb2plY3RzL2lhdGlwdWJsaXNoZXIvbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9leHBvcnRIZWxwZXIuanNcIlxuY29uc3QgX19leHBvcnRzX18gPSAvKiNfX1BVUkVfXyovZXhwb3J0Q29tcG9uZW50KHNjcmlwdCwgW1sncmVuZGVyJyxyZW5kZXJdLFsnX19maWxlJyxcInJlc291cmNlcy9hc3NldHMvanMvdmlld3MvYWN0aXZpdHkvcGFydGlhbHMvVGFibGVMYXlvdXQudnVlXCJdXSlcbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7XG4gIF9fZXhwb3J0c19fLl9faG1ySWQgPSBcIjVkODRhMWQ4XCJcbiAgY29uc3QgYXBpID0gX19WVUVfSE1SX1JVTlRJTUVfX1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghYXBpLmNyZWF0ZVJlY29yZCgnNWQ4NGExZDgnLCBfX2V4cG9ydHNfXykpIHtcbiAgICBhcGkucmVsb2FkKCc1ZDg0YTFkOCcsIF9fZXhwb3J0c19fKVxuICB9XG4gIFxuICBtb2R1bGUuaG90LmFjY2VwdChcIi4vVGFibGVMYXlvdXQudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTVkODRhMWQ4JnRzPXRydWVcIiwgKCkgPT4ge1xuICAgIGFwaS5yZXJlbmRlcignNWQ4NGExZDgnLCByZW5kZXIpXG4gIH0pXG5cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBfX2V4cG9ydHNfXyIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01LnVzZVswXSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC02LnVzZVswXSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdHMtbG9hZGVyL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTchLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFswXS51c2VbMF0hLi9BZG1pbkhlYWRlci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9dHNcIjsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNS51c2VbMF0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNi51c2VbMF0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RzLWxvYWRlci9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC03IS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMF0udXNlWzBdIS4vQWRtaW5IZWFkZXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPXRzXCIiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNS51c2VbMF0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNi51c2VbMF0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RzLWxvYWRlci9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC03IS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMF0udXNlWzBdIS4vQWxlcnRNZXNzYWdlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10c1wiOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01LnVzZVswXSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC02LnVzZVswXSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdHMtbG9hZGVyL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTchLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFswXS51c2VbMF0hLi9BbGVydE1lc3NhZ2UudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPXRzXCIiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNS51c2VbMF0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNi51c2VbMF0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RzLWxvYWRlci9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC03IS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMF0udXNlWzBdIS4vUGFnaW5hdGlvbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9dHNcIjsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNS51c2VbMF0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNi51c2VbMF0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RzLWxvYWRlci9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC03IS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMF0udXNlWzBdIS4vUGFnaW5hdGlvbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9dHNcIiIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01LnVzZVswXSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC02LnVzZVswXSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdHMtbG9hZGVyL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTchLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFswXS51c2VbMF0hLi9Qb3B1cE1vZGFsLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10c1wiOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01LnVzZVswXSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC02LnVzZVswXSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdHMtbG9hZGVyL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTchLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFswXS51c2VbMF0hLi9Qb3B1cE1vZGFsLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10c1wiIiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTUudXNlWzBdIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTYudXNlWzBdIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy90cy1sb2FkZXIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzBdLnVzZVswXSEuL1RvYXN0TWVzc2FnZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9dHNcIjsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNS51c2VbMF0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNi51c2VbMF0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RzLWxvYWRlci9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC03IS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMF0udXNlWzBdIS4vVG9hc3RNZXNzYWdlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10c1wiIiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gXCItIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTUudXNlWzBdIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTYudXNlWzBdIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy90cy1sb2FkZXIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNyEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzBdLnVzZVswXSEuL0FjdGl2aXR5TGlzdC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9dHNcIjsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNS51c2VbMF0hLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNi51c2VbMF0hLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RzLWxvYWRlci9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC03IS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMF0udXNlWzBdIS4vQWN0aXZpdHlMaXN0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10c1wiIiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gXCItIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTUudXNlWzBdIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTYudXNlWzBdIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy90cy1sb2FkZXIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNyEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzBdLnVzZVswXSEuL0FkZEFjdGl2aXR5QnV0dG9uLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10c1wiOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01LnVzZVswXSEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC02LnVzZVswXSEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdHMtbG9hZGVyL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTchLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFswXS51c2VbMF0hLi9BZGRBY3Rpdml0eUJ1dHRvbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9dHNcIiIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tIFwiLSEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01LnVzZVswXSEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC02LnVzZVswXSEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdHMtbG9hZGVyL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTchLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFswXS51c2VbMF0hLi9FbXB0eUFjdGl2aXR5LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10c1wiOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01LnVzZVswXSEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC02LnVzZVswXSEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdHMtbG9hZGVyL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTchLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFswXS51c2VbMF0hLi9FbXB0eUFjdGl2aXR5LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10c1wiIiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gXCItIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTUudXNlWzBdIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTYudXNlWzBdIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy90cy1sb2FkZXIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNyEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzBdLnVzZVswXSEuL1BhZ2VUaXRsZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9dHNcIjsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNS51c2VbMF0hLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNi51c2VbMF0hLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RzLWxvYWRlci9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC03IS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMF0udXNlWzBdIS4vUGFnZVRpdGxlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10c1wiIiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gXCItIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTUudXNlWzBdIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTYudXNlWzBdIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy90cy1sb2FkZXIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNyEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzBdLnVzZVswXSEuL1RhYmxlTGF5b3V0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10c1wiOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01LnVzZVswXSEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC02LnVzZVswXSEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdHMtbG9hZGVyL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTchLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFswXS51c2VbMF0hLi9UYWJsZUxheW91dC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9dHNcIiIsImV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTUudXNlWzBdIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTYudXNlWzBdIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy90cy1sb2FkZXIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3RlbXBsYXRlTG9hZGVyLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzRdIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMF0udXNlWzBdIS4vQWRtaW5IZWFkZXIudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTZmZTU5MDU1JnRzPXRydWVcIiIsImV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTUudXNlWzBdIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTYudXNlWzBdIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy90cy1sb2FkZXIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3RlbXBsYXRlTG9hZGVyLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzRdIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMF0udXNlWzBdIS4vQWxlcnRNZXNzYWdlLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD02NTdmYTM0MiZzY29wZWQ9dHJ1ZSZ0cz10cnVlXCIiLCJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01LnVzZVswXSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC02LnVzZVswXSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdHMtbG9hZGVyL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTchLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC90ZW1wbGF0ZUxvYWRlci5qcz8/cnVsZVNldFsxXS5ydWxlc1s0XSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzBdLnVzZVswXSEuL1BhZ2luYXRpb24udnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTM4OTVhZmRlJnRzPXRydWVcIiIsImV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTUudXNlWzBdIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTYudXNlWzBdIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy90cy1sb2FkZXIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3RlbXBsYXRlTG9hZGVyLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzRdIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMF0udXNlWzBdIS4vUG9wdXBNb2RhbC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NWEyYmRhNTgmc2NvcGVkPXRydWUmdHM9dHJ1ZVwiIiwiZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNS51c2VbMF0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNi51c2VbMF0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RzLWxvYWRlci9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC03IS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvdGVtcGxhdGVMb2FkZXIuanM/P3J1bGVTZXRbMV0ucnVsZXNbNF0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFswXS51c2VbMF0hLi9Ub2FzdE1lc3NhZ2UudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPWQwMWQ4Y2QyJnRzPXRydWVcIiIsImV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTUudXNlWzBdIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTYudXNlWzBdIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy90cy1sb2FkZXIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNyEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3RlbXBsYXRlTG9hZGVyLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzRdIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMF0udXNlWzBdIS4vQWN0aXZpdHlMaXN0LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0yMjIyZWQ2YyZ0cz10cnVlXCIiLCJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01LnVzZVswXSEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC02LnVzZVswXSEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdHMtbG9hZGVyL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTchLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC90ZW1wbGF0ZUxvYWRlci5qcz8/cnVsZVNldFsxXS5ydWxlc1s0XSEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzBdLnVzZVswXSEuL0FkZEFjdGl2aXR5QnV0dG9uLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0wNTBlMTczYyZ0cz10cnVlXCIiLCJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01LnVzZVswXSEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC02LnVzZVswXSEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdHMtbG9hZGVyL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTchLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC90ZW1wbGF0ZUxvYWRlci5qcz8/cnVsZVNldFsxXS5ydWxlc1s0XSEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzBdLnVzZVswXSEuL0VtcHR5QWN0aXZpdHkudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTlhZWY5Njg4JnRzPXRydWVcIiIsImV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTUudXNlWzBdIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTYudXNlWzBdIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy90cy1sb2FkZXIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNyEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3RlbXBsYXRlTG9hZGVyLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzRdIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMF0udXNlWzBdIS4vUGFnZVRpdGxlLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD03NTg5ZTg2ZSZ0cz10cnVlXCIiLCJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01LnVzZVswXSEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC02LnVzZVswXSEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdHMtbG9hZGVyL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTchLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC90ZW1wbGF0ZUxvYWRlci5qcz8/cnVsZVNldFsxXS5ydWxlc1s0XSEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzBdLnVzZVswXSEuL1RhYmxlTGF5b3V0LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD01ZDg0YTFkOCZ0cz10cnVlXCIiLCJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTE0LnVzZVsxXSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtMTQudXNlWzJdIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC0xNC51c2VbM10hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFswXS51c2VbMF0hLi9BbGVydE1lc3NhZ2UudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9NjU3ZmEzNDImbGFuZz1zY3NzJnNjb3BlZD10cnVlXCIiLCJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTE0LnVzZVsxXSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtMTQudXNlWzJdIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC0xNC51c2VbM10hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFswXS51c2VbMF0hLi9Qb3B1cE1vZGFsLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTVhMmJkYTU4Jmxhbmc9c2NzcyZzY29wZWQ9dHJ1ZVwiIiwiaW1wb3J0ICogYXMgcnVudGltZURvbSBmcm9tICdAdnVlL3J1bnRpbWUtZG9tJztcbmltcG9ydCB7IGluaXRDdXN0b21Gb3JtYXR0ZXIsIHdhcm4sIHJlZ2lzdGVyUnVudGltZUNvbXBpbGVyIH0gZnJvbSAnQHZ1ZS9ydW50aW1lLWRvbSc7XG5leHBvcnQgKiBmcm9tICdAdnVlL3J1bnRpbWUtZG9tJztcbmltcG9ydCB7IGNvbXBpbGUgfSBmcm9tICdAdnVlL2NvbXBpbGVyLWRvbSc7XG5pbXBvcnQgeyBpc1N0cmluZywgTk9PUCwgZXh0ZW5kLCBnZW5lcmF0ZUNvZGVGcmFtZSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuZnVuY3Rpb24gaW5pdERldigpIHtcclxuICAgIHtcclxuICAgICAgICBpbml0Q3VzdG9tRm9ybWF0dGVyKCk7XHJcbiAgICB9XHJcbn1cblxuLy8gVGhpcyBlbnRyeSBpcyB0aGUgXCJmdWxsLWJ1aWxkXCIgdGhhdCBpbmNsdWRlcyBib3RoIHRoZSBydW50aW1lXHJcbmlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgIGluaXREZXYoKTtcclxufVxyXG5jb25zdCBjb21waWxlQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5mdW5jdGlvbiBjb21waWxlVG9GdW5jdGlvbih0ZW1wbGF0ZSwgb3B0aW9ucykge1xyXG4gICAgaWYgKCFpc1N0cmluZyh0ZW1wbGF0ZSkpIHtcclxuICAgICAgICBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcclxuICAgICAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5pbm5lckhUTUw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybihgaW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246IGAsIHRlbXBsYXRlKTtcclxuICAgICAgICAgICAgcmV0dXJuIE5PT1A7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3Qga2V5ID0gdGVtcGxhdGU7XHJcbiAgICBjb25zdCBjYWNoZWQgPSBjb21waWxlQ2FjaGVba2V5XTtcclxuICAgIGlmIChjYWNoZWQpIHtcclxuICAgICAgICByZXR1cm4gY2FjaGVkO1xyXG4gICAgfVxyXG4gICAgaWYgKHRlbXBsYXRlWzBdID09PSAnIycpIHtcclxuICAgICAgICBjb25zdCBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGVtcGxhdGUpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWVsKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYFRlbXBsYXRlIGVsZW1lbnQgbm90IGZvdW5kIG9yIGlzIGVtcHR5OiAke3RlbXBsYXRlfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBfX1VOU0FGRV9fXHJcbiAgICAgICAgLy8gUmVhc29uOiBwb3RlbnRpYWwgZXhlY3V0aW9uIG9mIEpTIGV4cHJlc3Npb25zIGluIGluLURPTSB0ZW1wbGF0ZS5cclxuICAgICAgICAvLyBUaGUgdXNlciBtdXN0IG1ha2Ugc3VyZSB0aGUgaW4tRE9NIHRlbXBsYXRlIGlzIHRydXN0ZWQuIElmIGl0J3MgcmVuZGVyZWRcclxuICAgICAgICAvLyBieSB0aGUgc2VydmVyLCB0aGUgdGVtcGxhdGUgc2hvdWxkIG5vdCBjb250YWluIGFueSB1c2VyIGRhdGEuXHJcbiAgICAgICAgdGVtcGxhdGUgPSBlbCA/IGVsLmlubmVySFRNTCA6IGBgO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBjb2RlIH0gPSBjb21waWxlKHRlbXBsYXRlLCBleHRlbmQoe1xyXG4gICAgICAgIGhvaXN0U3RhdGljOiB0cnVlLFxyXG4gICAgICAgIG9uRXJyb3I6IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IG9uRXJyb3IgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgb25XYXJuOiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBlID0+IG9uRXJyb3IoZSwgdHJ1ZSkgOiBOT09QXHJcbiAgICB9LCBvcHRpb25zKSk7XHJcbiAgICBmdW5jdGlvbiBvbkVycm9yKGVyciwgYXNXYXJuaW5nID0gZmFsc2UpIHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gYXNXYXJuaW5nXHJcbiAgICAgICAgICAgID8gZXJyLm1lc3NhZ2VcclxuICAgICAgICAgICAgOiBgVGVtcGxhdGUgY29tcGlsYXRpb24gZXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YDtcclxuICAgICAgICBjb25zdCBjb2RlRnJhbWUgPSBlcnIubG9jICYmXHJcbiAgICAgICAgICAgIGdlbmVyYXRlQ29kZUZyYW1lKHRlbXBsYXRlLCBlcnIubG9jLnN0YXJ0Lm9mZnNldCwgZXJyLmxvYy5lbmQub2Zmc2V0KTtcclxuICAgICAgICB3YXJuKGNvZGVGcmFtZSA/IGAke21lc3NhZ2V9XFxuJHtjb2RlRnJhbWV9YCA6IG1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gICAgLy8gVGhlIHdpbGRjYXJkIGltcG9ydCByZXN1bHRzIGluIGEgaHVnZSBvYmplY3Qgd2l0aCBldmVyeSBleHBvcnRcclxuICAgIC8vIHdpdGgga2V5cyB0aGF0IGNhbm5vdCBiZSBtYW5nbGVkLCBhbmQgY2FuIGJlIHF1aXRlIGhlYXZ5IHNpemUtd2lzZS5cclxuICAgIC8vIEluIHRoZSBnbG9iYWwgYnVpbGQgd2Uga25vdyBgVnVlYCBpcyBhdmFpbGFibGUgZ2xvYmFsbHkgc28gd2UgY2FuIGF2b2lkXHJcbiAgICAvLyB0aGUgd2lsZGNhcmQgb2JqZWN0LlxyXG4gICAgY29uc3QgcmVuZGVyID0gKG5ldyBGdW5jdGlvbignVnVlJywgY29kZSkocnVudGltZURvbSkpO1xyXG4gICAgcmVuZGVyLl9yYyA9IHRydWU7XHJcbiAgICByZXR1cm4gKGNvbXBpbGVDYWNoZVtrZXldID0gcmVuZGVyKTtcclxufVxyXG5yZWdpc3RlclJ1bnRpbWVDb21waWxlcihjb21waWxlVG9GdW5jdGlvbik7XG5cbmV4cG9ydCB7IGNvbXBpbGVUb0Z1bmN0aW9uIGFzIGNvbXBpbGUgfTtcbiIsInZhciBtYXAgPSB7XG5cdFwiLi9hbGVydC5zdmdcIjogXCIuL3Jlc291cmNlcy9hc3NldHMvaW1hZ2VzL3N2Zy9hbGVydC5zdmdcIixcblx0XCIuL2FwcHJvdmVkLWNsb3VkLnN2Z1wiOiBcIi4vcmVzb3VyY2VzL2Fzc2V0cy9pbWFnZXMvc3ZnL2FwcHJvdmVkLWNsb3VkLnN2Z1wiLFxuXHRcIi4vYXJyb3ctbGVmdC5zdmdcIjogXCIuL3Jlc291cmNlcy9hc3NldHMvaW1hZ2VzL3N2Zy9hcnJvdy1sZWZ0LnN2Z1wiLFxuXHRcIi4vYXJyb3ctcmlnaHQuc3ZnXCI6IFwiLi9yZXNvdXJjZXMvYXNzZXRzL2ltYWdlcy9zdmcvYXJyb3ctcmlnaHQuc3ZnXCIsXG5cdFwiLi9hc2NlbmRpbmctYXJyb3cuc3ZnXCI6IFwiLi9yZXNvdXJjZXMvYXNzZXRzL2ltYWdlcy9zdmcvYXNjZW5kaW5nLWFycm93LnN2Z1wiLFxuXHRcIi4vY2hlY2tib3guc3ZnXCI6IFwiLi9yZXNvdXJjZXMvYXNzZXRzL2ltYWdlcy9zdmcvY2hlY2tib3guc3ZnXCIsXG5cdFwiLi9jbG9zZS5zdmdcIjogXCIuL3Jlc291cmNlcy9hc3NldHMvaW1hZ2VzL3N2Zy9jbG9zZS5zdmdcIixcblx0XCIuL2RlbGV0ZS5zdmdcIjogXCIuL3Jlc291cmNlcy9hc3NldHMvaW1hZ2VzL3N2Zy9kZWxldGUuc3ZnXCIsXG5cdFwiLi9kZXNjZW5kaW5nLWFycm93LnN2Z1wiOiBcIi4vcmVzb3VyY2VzL2Fzc2V0cy9pbWFnZXMvc3ZnL2Rlc2NlbmRpbmctYXJyb3cuc3ZnXCIsXG5cdFwiLi9kb2N1bWVudC13cml0ZS5zdmdcIjogXCIuL3Jlc291cmNlcy9hc3NldHMvaW1hZ2VzL3N2Zy9kb2N1bWVudC13cml0ZS5zdmdcIixcblx0XCIuL2Rvd25sb2FkLWZpbGUuc3ZnXCI6IFwiLi9yZXNvdXJjZXMvYXNzZXRzL2ltYWdlcy9zdmcvZG93bmxvYWQtZmlsZS5zdmdcIixcblx0XCIuL2ZvbGRlci5zdmdcIjogXCIuL3Jlc291cmNlcy9hc3NldHMvaW1hZ2VzL3N2Zy9mb2xkZXIuc3ZnXCIsXG5cdFwiLi9oaXN0b3J5LnN2Z1wiOiBcIi4vcmVzb3VyY2VzL2Fzc2V0cy9pbWFnZXMvc3ZnL2hpc3Rvcnkuc3ZnXCIsXG5cdFwiLi9sb2dvLnN2Z1wiOiBcIi4vcmVzb3VyY2VzL2Fzc2V0cy9pbWFnZXMvc3ZnL2xvZ28uc3ZnXCIsXG5cdFwiLi9wbHVzLnN2Z1wiOiBcIi4vcmVzb3VyY2VzL2Fzc2V0cy9pbWFnZXMvc3ZnL3BsdXMuc3ZnXCIsXG5cdFwiLi9wdWJsaXNoLnN2Z1wiOiBcIi4vcmVzb3VyY2VzL2Fzc2V0cy9pbWFnZXMvc3ZnL3B1Ymxpc2guc3ZnXCIsXG5cdFwiLi9xdWVzdGlvbi1tYXJrLnN2Z1wiOiBcIi4vcmVzb3VyY2VzL2Fzc2V0cy9pbWFnZXMvc3ZnL3F1ZXN0aW9uLW1hcmsuc3ZnXCIsXG5cdFwiLi90aWNrLnN2Z1wiOiBcIi4vcmVzb3VyY2VzL2Fzc2V0cy9pbWFnZXMvc3ZnL3RpY2suc3ZnXCIsXG5cdFwiLi91c2VyLXByb2ZpbGUuc3ZnXCI6IFwiLi9yZXNvdXJjZXMvYXNzZXRzL2ltYWdlcy9zdmcvdXNlci1wcm9maWxlLnN2Z1wiXG59O1xuXG5cbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0KHJlcSkge1xuXHR2YXIgaWQgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKTtcblx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oaWQpO1xufVxuZnVuY3Rpb24gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkge1xuXHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKG1hcCwgcmVxKSkge1xuXHRcdHZhciBlID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJ1wiKTtcblx0XHRlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7XG5cdFx0dGhyb3cgZTtcblx0fVxuXHRyZXR1cm4gbWFwW3JlcV07XG59XG53ZWJwYWNrQ29udGV4dC5rZXlzID0gZnVuY3Rpb24gd2VicGFja0NvbnRleHRLZXlzKCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXMobWFwKTtcbn07XG53ZWJwYWNrQ29udGV4dC5yZXNvbHZlID0gd2VicGFja0NvbnRleHRSZXNvbHZlO1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrQ29udGV4dDtcbndlYnBhY2tDb250ZXh0LmlkID0gXCIuL3Jlc291cmNlcy9hc3NldHMvaW1hZ2VzL3N2ZyBzeW5jIHJlY3Vyc2l2ZSBeXFxcXC5cXFxcLy4qJFwiOyIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0aWQ6IG1vZHVsZUlkLFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIiIsIi8vIHN0YXJ0dXBcbi8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLy8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9hcHAudHNcIik7XG4iLCIiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ2dWVfMSIsInJlcXVpcmUiLCJkZWZpbmVDb21wb25lbnQiLCJuYW1lIiwiY29tcG9uZW50cyIsInNldHVwIiwiZGF0YSIsImxhbmd1YWdlTmF2TGlDbGFzc2VzIiwibGFuZ3VhZ2VOYXZBbmNob3JDbGFzc2VzIiwibWVudU5hdkxpQ2xhc3NlcyIsIm1lbnVOYXZBbmNob3JDbGFzc2VzIiwibGFuZ3VhZ2VzIiwibGFuZ3VhZ2UiLCJwZXJtYWxpbmsiLCJhY3RpdmUiLCJtZW51cyIsInByb3BzIiwidHlwZSIsIlN0cmluZyIsImljb24iLCJlbWl0cyIsIl9hIiwiZW1pdCIsImNsb3NlIiwiX19pbXBvcnREZWZhdWx0IiwibW9kIiwiX19lc01vZHVsZSIsIkVtcHR5QWN0aXZpdHlfdnVlXzEiLCJUYWJsZUxheW91dF92dWVfMSIsIlBhZ2luYXRpb25fdnVlXzEiLCJQYWdlVGl0bGVfdnVlXzEiLCJUb2FzdE1lc3NhZ2VfdnVlXzEiLCJFbXB0eUFjdGl2aXR5IiwiUGFnZVRpdGxlIiwiUGFnaW5hdGlvbiIsIlRvYXN0TWVzc2FnZSIsIlRhYmxlTGF5b3V0Iiwic3RhdGUiLCJyZWFjdGl2ZSIsInNob3dCdXR0b25zIiwic2hvd09ySGlkZSIsIkFycmF5IiwibGVuZ3RoIiwiaXNWaXNpYmxlIiwibGlDbGFzcyIsInRvZ2dsZSIsIkFkZEFjdGl2aXR5QnV0dG9uX3Z1ZV8xIiwiQWN0aXZpdHlCdXR0b24iLCJkaXNtaXNzIiwiUG9wdXBNb2RhbF92dWVfMSIsIkFsZXJ0TWVzc2FnZV92dWVfMSIsIkFkZEFjdGl2aXR5QnV0dG9uIiwiTW9kYWwiLCJBbGVydCIsIkJvb2xlYW4iLCJtb2RhbEFjdGl2ZSIsImFjdGl2aXR5TGlzdCIsInRpdGxlIiwiY2FuQmVQdWJsaXNoZWQiLCJsaXN0IiwicHVibGlzaGFibGUiLCJub25QdWJsaXNoYWJsZSIsInRvZ2dsZU1vZGFsIiwic2VsZWN0ZWQiLCJlbWl0U2hvd09ySGlkZSIsInJlbmRlciIsIl9ob2lzdGVkXzEiLCJfaG9pc3RlZF8yIiwiX2hvaXN0ZWRfMyIsImhyZWYiLCJfaG9pc3RlZF80IiwiX2hvaXN0ZWRfNSIsIl9ob2lzdGVkXzYiLCJfaG9pc3RlZF83IiwiX2hvaXN0ZWRfOCIsIl9ob2lzdGVkXzkiLCJfaG9pc3RlZF8xMCIsIl9ob2lzdGVkXzExIiwiX2hvaXN0ZWRfMTIiLCJfaG9pc3RlZF8xMyIsIl9ob2lzdGVkXzE0IiwiX2hvaXN0ZWRfMTUiLCJfY3R4IiwiX2NhY2hlIiwiJHByb3BzIiwiJHNldHVwIiwiJGRhdGEiLCIkb3B0aW9ucyIsIl9jb21wb25lbnRfc3ZnX3Z1ZSIsInJlc29sdmVDb21wb25lbnQiLCJvcGVuQmxvY2siLCJjcmVhdGVFbGVtZW50QmxvY2siLCJjcmVhdGVFbGVtZW50Vk5vZGUiLCJjcmVhdGVWTm9kZSIsIkZyYWdtZW50IiwicmVuZGVyTGlzdCIsImluZGV4Iiwibm9ybWFsaXplQ2xhc3MiLCJrZXkiLCJuYXZfX3BvaW50ZXIiLCJ0b0Rpc3BsYXlTdHJpbmciLCJtZW51IiwiY3JlYXRlQ29tbWVudFZOb2RlIiwicmVuZGVyU2xvdCIsIiRzbG90cyIsInVuZGVmaW5lZCIsImNyZWF0ZVN0YXRpY1ZOb2RlIiwiX3dpdGhTY29wZUlkIiwibiIsInB1c2hTY29wZUlkIiwicG9wU2NvcGVJZCIsImNyZWF0ZUJsb2NrIiwiVGVsZXBvcnQiLCJ0byIsIlRyYW5zaXRpb24iLCJ3aXRoQ3R4Iiwid2l0aERpcmVjdGl2ZXMiLCJvbkNsaWNrIiwiYXJncyIsIl9pIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJ2U2hvdyIsIl8iLCJpZCIsIl9jb21wb25lbnRfUGFnZVRpdGxlIiwiX2NvbXBvbmVudF9UYWJsZUxheW91dCIsIl9jb21wb25lbnRfUGFnaW5hdGlvbiIsIl9jb21wb25lbnRfVG9hc3RNZXNzYWdlIiwib25TaG93T3JIaWRlIiwiY3JlYXRlVGV4dFZOb2RlIiwic3R5bGUiLCJfY29tcG9uZW50X0FjdGl2aXR5QnV0dG9uIiwiJGV2ZW50IiwiX2hvaXN0ZWRfMTYiLCJfaG9pc3RlZF8xNyIsIl9ob2lzdGVkXzE4IiwiX2hvaXN0ZWRfMTkiLCJfaG9pc3RlZF8yMCIsIl9ob2lzdGVkXzIxIiwiX2hvaXN0ZWRfMjIiLCJfaG9pc3RlZF8yMyIsIl9ob2lzdGVkXzI0IiwiX2hvaXN0ZWRfMjUiLCJfY29tcG9uZW50X2FsZXJ0IiwiX2NvbXBvbmVudF9Nb2RhbCIsIl9jb21wb25lbnRfQWRkQWN0aXZpdHlCdXR0b24iLCJvbkNsb3NlIiwic2NvcGUiLCJfaG9pc3RlZF8yNiIsIl9ob2lzdGVkXzI3IiwiX2hvaXN0ZWRfMjgiLCJfaG9pc3RlZF8yOSIsIl9ob2lzdGVkXzMwIiwiX2hvaXN0ZWRfMzEiLCJfaG9pc3RlZF8zMiIsIl9ob2lzdGVkXzMzIiwiX2hvaXN0ZWRfMzQiLCJfaG9pc3RlZF8zNSIsIl9ob2lzdGVkXzM2IiwiX2hvaXN0ZWRfMzciLCJfaG9pc3RlZF8zOCIsIl9ob2lzdGVkXzM5IiwiX2hvaXN0ZWRfNDAiLCJfaG9pc3RlZF80MSIsIl9ob2lzdGVkXzQyIiwiX2hvaXN0ZWRfNDMiLCJfaG9pc3RlZF80NCIsIl9ob2lzdGVkXzQ1IiwiX2hvaXN0ZWRfNDYiLCJfaG9pc3RlZF80NyIsIl9ob2lzdGVkXzQ4IiwiX2hvaXN0ZWRfNDkiLCJfaG9pc3RlZF81MCIsIl9ob2lzdGVkXzUxIiwiX2hvaXN0ZWRfNTIiLCJfaG9pc3RlZF81MyIsIl9ob2lzdGVkXzU0IiwiX2hvaXN0ZWRfNTUiLCJfaG9pc3RlZF81NiIsIl9ob2lzdGVkXzU3IiwiX2hvaXN0ZWRfNTgiLCJfaG9pc3RlZF81OSIsIl9ob2lzdGVkXzYwIiwiX2hvaXN0ZWRfNjEiLCJfaG9pc3RlZF82MiIsIl9ob2lzdGVkXzYzIiwib25DaGFuZ2UiLCJ2TW9kZWxDaGVja2JveCIsInN2Z192dWUzXzEiLCJBY3Rpdml0eUxpc3RfdnVlXzEiLCJBZG1pbkhlYWRlcl92dWVfMSIsImFwcCIsImNyZWF0ZUFwcCIsImNvbXBvbmVudCIsInVzZSIsIm1vdW50Il0sInNvdXJjZVJvb3QiOiIifQ==
